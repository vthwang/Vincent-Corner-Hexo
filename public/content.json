{"meta":{"title":"Vincent's Corner","subtitle":"I see, I come, I conquer.","description":"Who knows what fantastic things around Vincent's corner?","author":"Vincent Ting Hsuan Wang","url":"https://vincent.fishboneapps.com","root":"/"},"pages":[{"title":"Quotable Quotes","date":"2020-05-08T05:34:18.000Z","updated":"2020-05-23T12:20:06.641Z","comments":true,"path":"quotes/index.html","permalink":"https://vincent.fishboneapps.com/quotes/index.html","excerpt":"","text":"Nothing is so common as the wish to be remarkable. (William Shakespeare) 沒有什麼比想要不平凡更平凡的了。 The belief in a supernatural source of evil is not necessary. Men alone are quite capable of every wickedness. (Joseph Conrad) 沒有必要將邪惡歸結於超自然，人類本身就有能力犯下任何惡行。 Imagination is more important than knowledge. Knowledge is limited. Imagination encircles the world. (Albert Einstein) 想像力比知識更重要。知識有界，想像無邊。 Don’t bother just to be better than your contemporaries or predecessors. Try to be better than yourself. (Faulkner) 不要想著超越你的同僚或是前輩，試試超越你自己。 Almost all absurdity of conduct arises from the imitation of those whom we cannot resemble. (Samuel Johnson) 幾乎所有行為的荒謬都來自東施效顰。 Don’t forget that I cannot see myself – that my role is limited to being the one who looks in the mirror. (Jacques Rigaut) 別忘了我看不到自己，我的角色僅限於看像鏡子的那人。 Birds sing after a storm; why shouldn’t people feel as free to delight in whatever sunlight remains to them? (Rose Kennedy) 鳥在暴風之後唱歌，為什麼人們在仍是陽光普照時，還不盡情感受快樂呢？ When a good man is hurt, all who would be called good must suffer with him. (Euripides) 當一個好人受到傷害，所有的好人定將與其同歷磨難。 When love is in excess, it brings a man no honor, no worthiness. (Euripides) 當愛過多時，它就不會給男人帶來榮譽和價值。 The irrationality of a thing is no argument against its existence, rather a condition of it. (Friedrich Nietzsche) 一件事情的不合理性，不適駁斥其存在的依據，還不如以一種特定情況來證明。 There is no hunting like the hunting of man, and those who have hunted armed men long enough and liked it, never care for anything else thereafter. (Ernest Hemingway) 沒有任何追捕可以和人的追捕相比，那些長期且喜歡追捕武裝份子的人，從來不會真的在乎其他任何東西。 The healthy man does not torture others - generally it is the tortured who turn into torturers. (Carl Jung) 健康的人不會折磨別人，一般是被折磨的變成折磨人的。 Unfortunately, a superabundance of dreams is paid for by a growing potential for nightmares. (Peter Ustinov) 不幸的是，多夢的代價就是噩夢也將隨之增多。 Ideologies separate us. Dreams and anguish bring us together. (Eugene Ionesco) 意識形態分離了我們，而夢想和痛苦使我們走到一起。 The bitterest tears shed over graves are for words left unsaid and deeds left undone. (Harriet Beecher Stowe) 最痛苦的眼淚從墳墓裡流出，為了還沒說過的話和還沒做過的事。 Evil is unspectacular and always human, and shares our bed and eats at our own table. (W. H. Auden) 惡魔通常只是凡人並且毫不起眼，他們用我們的床，與我們同桌共餐。 Measure not the work until the day’s out and the labor done. (Elizabeth Barrett Browning) 在沒努力完之前，不評價工作。 What is food to one man is bitter poison to others. (Lucretius) 一些人的美食，卻是其他人的毒藥。 Before you embark on a journey of revenge, dig two graves. (Confucious) 在你決定報復之前，先挖好兩個墳墓。 Whoever sheds the blood of man, by man his blood will be shed. (Genesis 9:6) 讓別人流血的人，他的血必被別人所流， What we do for ourselves dies with us. What we do for others and the world remains and is immortal. (Albert Pine) 對自己所做的會隨著死亡而消逝，對其他人和世界所做的才會永存而且不朽。 It is those we live with and love and should know who elude us. (Norman Maclean) 總是那些我們相處、相愛、本該相知的人在蒙蔽我們。 In the end, it’s not the years in your life that count. It’s the life in your years. (Abraham Lincoln) 到頭來，你活了多少歲不算數，重要的是你怎麼過的這些年歲。 The individual has always had to struggle to keep from being overwhelmed by the tribe. (Friedrich Nietzsche) 個體必須奮鬥以防被部落征服。 Murder is unique in that it abolishes the party it injures, so that society must take the place of the victim, and on his behalf demand atonement or grant forgiveness. (W. H. Auden) 謀殺是獨特的，因為它完全破壞了受害人，所以社會必須為死者說話，而且以死者的名義來要求補償或行使赦免。 An American has no sense of privacy. He does not know what it means. (George Bernard Shaw) 美國人沒有對隱私的認識，他不知道那是什麼意思。 Other things may change us, but we start and end with the family. (Anthony Brandt) 其他的事情可能會改變我們，但我們開始並終結於家庭。 The house does not rest upon the ground, but upon a woman. (Mexican Proverb) 家不是建立在土地上，而是建立在女性上。 There are some that only employ words for the purpose of disguising their thoughts. (Voltaire) 有些人只會用文字掩飾他們的思想。 We are so accustomed to disguise ourselves to others that in the end we become disguised to ourselves. (Francois de la) 在人前我們總是習慣於偽裝自己，但最終也蒙騙了自己。 Whoever undertakes to set himself up as a judge of truth and knowledge is shipwrecked by the laughter of the gods. (Albert Einstein) 當一個人把自己當成真理和知識的法官時，他將被上帝的嘲笑毀滅。 In a time of universal deceit, telling the truth is a revolutionary act. (George Orwell) 在大欺騙的時代，說出真相才是革命性的舉動。 No man needs a vacation so much as the man who has just had one. (Elbert Hubbard) 沒有人比剛剛度過假的人更需要假期了。"},{"title":"ABOUT ME","date":"2016-08-30T11:17:58.000Z","updated":"2022-03-30T04:48:38.105Z","comments":true,"path":"about/index.html","permalink":"https://vincent.fishboneapps.com/about/index.html","excerpt":"","text":"Hi, My name is Vincent Ting-Hsuan Wang (Chinese: 王霆瑄). Vincent is a professional backend programmer with the experience managing small tech teams. His background in foreign literature helps him solve many issues with cross-cultural communication with different teams. Moreover, he has lived in many cities and been familiar with the different programming tools between mainland China and outside China. He is also fueled by his passion for understanding algorithm. He considers himself a 'forever student', eager to both build on his academic foundations in computer science and stay in tune with the latest programming tools through using these tools on daily works. EDUCATION Syracuse University (August 2021 - NOW) Department of Computer Science, M.S. China Medical University (September 2016 - June 2017) Department of Traditional Chinese Medicine, M.S. Asia University, Taiwan (September 2012 - June 2016) Department of Foreign Languages and Literature, B.A. Cumulative GPA: 3.92/4.00 EXPERIENCE Senior Software Engineer at IC3 Network Co., Ltd. Jan 2022 - Present Location: Paris, France (Remote) Use Golang as the main development language. Running the apps on the Kubernetes. Senior Software Engineer at Dotech Technology Co., Ltd. Sep 2020 - Oct 2021 (1 year 2 months) Location: Taichung, Taiwan Help enterprise renew the official website and re-define old corporation identify with modern design. In the meantime, I aborted old language and framework, and rebuilt the whole company’s ecosystem. Also, I built PTS (Project Tracking System) and use OKR as the main architecture to improve teams working efficiency. Overall, company’s project progress increase 50% than before compared without this system. Senior Software Engineer at Muki Corporation Co., Ltd. June 2020 - Aug 2020 (3 months) Location: Taichung, Taiwan Help enterprise transform from old-fashion development tools to modern development mode. Migrate projects from CodeIgniter to Laravel and introduce the git flow to improve the efficiency between team members. SOHO at Fishbone Creative Co., Ltd. Location: Taichung, Taiwan April 2020 - May 2020 (2 months) Working on E-commerce and brand image websites. Project Manager at ShangHai Pu-Yu Software Development Co., Ltd. Location: Shanghai, China November 2018 - March 2020 (1 year 5 months) Responsible for understanding clients’ demands, arrange working schedule and coordinate team members to develop API for mimi-program (WeChat App) and mobile Apps. Junior Software Developer at ShangHai Pu-Yu Software Development Co., Ltd. Location: Shanghai, China August 2017 - October 2018 (1 year 3 months) Help clients build official website by using WordPress and PHP + Mysql. In 2018, I imported Laravel framework and Gitlab Services to our company and applied this development mode to many client’s services. HONORS &amp; AWARDS 103 Semester - Outstanding Achievement Award (Technology R&amp;D Project) Date: 2015/03/21 Excellent Work Award of the 8th Dunhuang National College Cup , Advanced University Group Date: 2014/05/23 PARTICIPATIONS LaravelConf Taiwan 2018 Date: 2018/07/08 Location: Chang Yung-Fa Foundation DevOpsDays Taipei 2017 Date: 2017/09/04~2017/09/06 Location: National Taiwan University MOPCON 2016 Date: 2016/10/29~2016/10/30 Location: International Convention Center Kaohsiung CGCM Meeting 2016 Date: 2016/08/22~2016/08/26 Location: Academia Sinica CTJS 2016 Date: 2016/06/25 Location: National Taichung University of Science and Technology International Congress of Oriental Medicine-ICOM18 Date: 2016/04/15~2016/04/17 Location: Okinawa, Japan CONTACT ME Please feel free to get in touch and share your thoughts, ask questions, or just say hi! You can email me directly at vincent@fishboneapps.com I look forward to hear from you."}],"posts":[{"title":"Golang 快速學習自我挑戰 Day14","slug":"Golang-快速學習自我挑戰-Day14","date":"2021-12-10T13:20:08.000Z","updated":"2021-12-26T04:39:55.947Z","comments":true,"path":"2021/12/10/Golang-快速學習自我挑戰-Day14/","link":"","permalink":"https://vincent.fishboneapps.com/2021/12/10/Golang-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day14/","excerpt":"","text":"Section14: Methods: OOP with Go Methods：Enhance types with additional behavior Methods Value Receivers Pointer Receivers Non-Struct Methods Interface Type Assertion Type Switch Empty Interface Promoted Methods Famous Interfaces Stringer Marshaler Unmarshaler Reflection io.Reader The book has data but it doesn’t have any behavior. Suppose we have printbook() and discount(book, ratio) two methods. Both of methods take book values and their primary purpose is to work with books. Here we can combine the data and behavior together. Go will pass the value of a book automatically to these methods. (b book) is called “receiver”. 12345678type book struct &#123; title string price float64&#125;func (b book) print book() &#123; fmt.Printf(&quot;...&quot;, b.title, b.price)&#125; You cannot create a function with the same name in the same package. However, each type can have its own namespace. The same method name does not cause a conflict with another type. Here is a convention. We use b for a book, g for a game and gt for a gameType. The dot operator selects a name(func, method, field, …) from a namespace(from a package or type). Example book.go 123456789101112package mainimport &quot;fmt&quot;type book struct &#123; title string price float64&#125;func (b book) print() &#123; fmt.Printf(&quot;%-15s: $%.2f\\n&quot;, b.title, b.price)&#125; game.go 123456789101112package mainimport &quot;fmt&quot;type game struct &#123; title string price float64&#125;func (g game) print() &#123; fmt.Printf(&quot;%-15s: $%.2f\\n&quot;, g.title, g.price)&#125; main.go 12345678910111213141516171819202122package mainfunc main() &#123; mobydick := book&#123; title: &quot;moby dick&quot;, price: 10, &#125; minecraft := game&#123; title: &quot;minecraft&quot;, price: 20, &#125; tetris := game&#123; title: &quot;tetris&quot;, price: 5, &#125; mobydick.print() minecraft.print() tetris.print()&#125; Pointer Receiver: Change the received value Behind the scenes, a method is a function with a receiver as the first parameter. Both book.print(mobydick) and mobydick.print() pass the mobidick to print(), former one manually pass it and latter one automatically pass it. Methods v.s. Funcs: A method is a function that takes a receiver as teh first argument. There is only one difference between a method and a function. A method belongs to a type; A function belongs to a package. Using pointer to change the struct original value. game.go 123func (g *game) discount(ratio float64) &#123; g.price *= 1 - ratio&#125; main.go 12// When a method has a pointer receiver, Go can take its address automatically.minecraft.discount(.5) If one of the method use pointer receiver, it’s better to use pointer in all other methods. Using pointer is faster in some situations. You can use time to check the execution time between using pointer and not using pointer. huge.go 1234567891011package mainimport &quot;fmt&quot;type huge struct &#123; games [1000000]game&#125;func (h *huge) addr() &#123; fmt.Printf(&quot;%p\\n&quot;, &amp;h)&#125; main.go 12345678910111213141516171819202122package mainfunc main() &#123; var h huge for i := 0; i &lt; 10; i++ &#123; h.addr() &#125;&#125;====EXECUTE====time go run .====OUTPUT====0xc0017f20000xc0017f20100xc0017f20180xc0017f20200xc0017f20280xc0017f20300xc0017f20380xc0017f20400xc0017f20480xc0017f2050go run . 0.20s user 0.25s system 133% cpu 0.336 total Non-Structs: Attach methods to almost any type Unlike other OOP language, go doesn’t have classes. The methods can be attached to almost any type. It doesn’t have to be a struct type. Don’t use pointer in the last two items, because they already carry a pointer with themselves. int, string, float64… (primitive types) array, struct slice, map, chan func A slice of game pointers without methods []*game &amp;minecraft&#123;...&#125; &amp;tetris&#123;...&#125; Example: list.go 12345678910111213141516package mainimport &quot;fmt&quot;type list []*gamefunc (l list) print() &#123; if len(l) == 0 &#123; fmt.Println(&quot;Sorry. We&#x27;re waiting for delivery 🚚.&quot;) return &#125; for _, it := range l &#123; it.print() &#125;&#125; main.go 1234567891011121314151617package mainfunc main() &#123; var ( minecraft = game&#123;title: &quot;minecraft&quot;, price: 20&#125; tetris = game&#123;title: &quot;tetris&quot;, price: 5&#125; ) var items []*game items = append(items, &amp;minecraft, &amp;tetris) my := list(items) my = nil my.print()&#125; Section15: Interfaces: Implicit OOP Way Interfaces: Be dynamic All the non-interface types are concrete types. convention: “-er” suffix. “printer” is an interface type. In the interface, it only describes the expected behavior(methods). In this case, printer only needs a printing behavior and it doesn’t care where the behavior comes from. 123type printer interface &#123; print()&#125; Example. main.go 12345678910111213package mainfunc main() &#123; var ( mobydick = book&#123;title: &quot;moby dick&quot;, price: 10&#125; minecraft = game&#123;title: &quot;minecraft&quot;, price: 20&#125; tetris = game&#123;title: &quot;tetris&quot;, price: 5&#125; ) var store list store = append(store, &amp;mobydick, &amp;minecraft, &amp;tetris) store.print()&#125; list.go 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;// an abstract type, a protocol, a contract.// no implementationtype printer interface &#123; print()&#125;type list []printerfunc (l list) print() &#123; if len(l) == 0 &#123; fmt.Println(&quot;Sorry. We&#x27;re waiting for delivery 🚚.&quot;) return &#125; for _, it := range l &#123; fmt.Printf(&quot;(%-10T) --&gt; &quot;, it) it.print() &#125;&#125; Type Assertion: Extract the dynamic value! The wrapped value inside that interface value is called a dynamic value, because this value can change in the runtime. The type inside the interface is called a dynamic type, because the type can also change in the runtime. Example. main.go 1234567891011121314151617package mainfunc main() &#123; var ( mobydick = book&#123;title: &quot;moby dick&quot;, price: 10&#125; minecraft = game&#123;title: &quot;minecraft&quot;, price: 20&#125; tetris = game&#123;title: &quot;tetris&quot;, price: 5&#125; yoda = toy&#123;title: &quot;yoda&quot;, price: 150&#125; ) var store list store = append(store, &amp;mobydick, &amp;minecraft, &amp;tetris, &amp;yoda) store.discount(.5) store.print()&#125; toy.go (copy from game.go) 12345678910111213141516package mainimport &quot;fmt&quot;type toy struct &#123; title string price money&#125;func (t *toy) print() &#123; fmt.Printf(&quot;%-15s: %s\\n&quot;, t.title, t.price.string())&#125;func (t *toy) discount(ratio float64) &#123; t.price *= money(1 - ratio)&#125; list.go 1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport &quot;fmt&quot;// an abstract type, a protocol, a contract.// no implementationtype printer interface &#123; print()&#125;type list []printerfunc (l list) print() &#123; if len(l) == 0 &#123; fmt.Println(&quot;Sorry. We&#x27;re waiting for delivery 🚚.&quot;) return &#125; for _, it := range l &#123; fmt.Printf(&quot;(%-10T) --&gt; &quot;, it) it.print() &#125;&#125;func (l list) discount(ratio float64) &#123; type discounter interface &#123; discount(float64) &#125; for _, it := range l &#123; //g, ok := it.(discounter) //fmt.Printf(&quot;%T game? %v\\n&quot;, it, ok) //if !ok &#123; // continue //&#125; //g.discount(ratio) if it, ok := it.(discounter); ok &#123; it.discount(ratio) &#125; &#125;&#125; Empty Interface: Represent any type of value interface&#123;&#125; says nothing. It wraps other types in a hidden place. When you have the slice of empty interface, unlike the single interface, you need to use loop to save it. Here is an example. 12345678910111213141516171819package mainimport &quot;fmt&quot;func main() &#123; nums := []int&#123;1, 2, 3&#125; var any interface&#123;&#125; any = nums _ = len(any.([]int)) var many []interface&#123;&#125; for _, n := range nums &#123; many = append(many, n) &#125; fmt.Println(many)&#125; Using empty interface may let your programs become brittle and hard to maintain, so do not use it unless really necessary. Example. book.go 123456789101112131415161718192021222324252627282930313233343536package mainimport ( &quot;fmt&quot; &quot;strconv&quot; &quot;time&quot;)type book struct &#123; title string price money published interface&#123;&#125;&#125;func (b book) print() &#123; p := format(b.published) fmt.Printf(&quot;%-15s: %s - (%v)\\n&quot;, b.title, b.price.string(), p)&#125;func format(v interface&#123;&#125;) string &#123; if v == nil &#123; return &quot;unknown&quot; &#125; var t int if v, ok := v.(int); ok &#123; t = v &#125; if v, ok := v.(string); ok &#123; t, _ = strconv.Atoi(v) &#125; u := time.Unix(int64(t), 0) return u.String()&#125; main.go 123456789101112131415package mainfunc main() &#123; store := list&#123; book&#123;title: &quot;moby dick&quot;, price: 10, published: 118281600&#125;, book&#123;title: &quot;odyssey&quot;, price: 10, published: &quot;733622400&quot;&#125;, book&#123;title: &quot;hobbit&quot;, price: 10&#125;, &amp;game&#123;title: &quot;minecraft&quot;, price: 20&#125;, &amp;game&#123;title: &quot;tetris&quot;, price: 5&#125;, puzzle&#123;title: &quot;rubik&#x27;s cube&quot;, price: 5&#125;, &amp;toy&#123;title: &quot;yoda&quot;, price: 150&#125;, &#125; store.print()&#125; Type Switch: Detect and extract multiple values Type switch detects and extracts the dynamic value from an interface value. Example. Rewrite book.go 1234567891011121314151617func format(v interface&#123;&#125;) string &#123; var t int switch v := v.(type) &#123; case int: t = v case string: t, _ = strconv.Atoi(v) default: return &quot;unknown&quot; &#125; const layout = &quot;2006/01&quot; u := time.Unix(int64(t), 0) return u.Format(layout)&#125; Promoted Methods: Let’s make a little bit of refactoring Example. product.go 12345678910111213141516package mainimport &quot;fmt&quot;type product struct &#123; title string price money&#125;func (p *product) print() &#123; fmt.Printf(&quot;%-15s: %s\\n&quot;, p.title, p.price.string())&#125;func (p *product) discount(ratio float64) &#123; p.price *= money(1 - ratio)&#125; book.go 123456789101112131415161718192021222324252627282930313233343536package mainimport ( &quot;fmt&quot; &quot;strconv&quot; &quot;time&quot;)type book struct &#123; product published interface&#123;&#125;&#125;func (b *book) print() &#123; b.product.print() p := format(b.published) fmt.Printf(&quot;\\t - (%v)\\n&quot;, p)&#125;func format(v interface&#123;&#125;) string &#123; var t int switch v := v.(type) &#123; case int: t = v case string: t, _ = strconv.Atoi(v) default: return &quot;unknown&quot; &#125; const layout = &quot;2006/01&quot; u := time.Unix(int64(t), 0) return u.Format(layout)&#125; game.go 12345package maintype game struct &#123; product&#125; puzzle.go 12345package maintype puzzle struct &#123; product&#125; toy.go 12345package maintype toy struct &#123; product&#125; list.go 12345678910111213141516171819202122232425262728293031323334package mainimport &quot;fmt&quot;// an abstract type, a protocol, a contract.// no implementationtype item interface &#123; print() discount(ratio float64)&#125;type list []itemfunc (l list) print() &#123; if len(l) == 0 &#123; fmt.Println(&quot;Sorry. We&#x27;re waiting for delivery 🚚.&quot;) return &#125; for _, it := range l &#123; fmt.Printf(&quot;(%-10T) --&gt; &quot;, it) it.print() &#125;&#125;func (l list) discount(ratio float64) &#123; type discounter interface &#123; discount(float64) &#125; for _, it := range l &#123; it.discount(ratio) &#125;&#125; Section16: Interfaces; Marshaler, Sorter, and so on Don’t interface everything! Prefer to work directly with concrete types. Leads to a simple and easy to understand code. Abstractions (interfaces) can unnecessarily complicate your code. Separating responsibilities is critical. Timestamp type can represent, store, and print a UNIX timestamp. When a type anonymously embeds a type, it can use the methods of the embedded type as its own. Timestamp embeds a time.Time. So you can call the methods of the time.Time through a timestamp value. Example main.go 123456789101112package mainfunc main() &#123; l := list&#123; &#123;title: &quot;moby dick&quot;, price: 10, released: toTimestamp(118281600)&#125;, &#123;title: &quot;odyssey&quot;, price: 15, released: toTimestamp(&quot;733622400&quot;)&#125;, &#123;title: &quot;hobbit&quot;, price: 25&#125;, &#125; l.discount(.5) l.print()&#125; timestamp.go 123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;strconv&quot; &quot;time&quot;)type timestamp struct &#123; time.Time&#125;func (ts timestamp) string() string &#123; if ts.IsZero() &#123; return &quot;unknown&quot; &#125; const layout = &quot;2006/01&quot; return ts.Format(layout)&#125;func toTimestamp(v interface&#123;&#125;) (ts timestamp) &#123; var t int switch v := v.(type) &#123; case int: t = v case string: t, _ = strconv.Atoi(v) &#125; ts.Time = time.Unix(int64(t), 0) return ts&#125; product.go 12345678910111213141516171819package mainimport ( &quot;fmt&quot;)type product struct &#123; title string price money released timestamp&#125;func (p *product) print() &#123; fmt.Printf(&quot;%s: %s (%s)\\n&quot;, p.title, p.price.string(), p.released.string())&#125;func (p *product) discount(ratio float64) &#123; p.price *= money(1 - ratio)&#125; list.go 123456789101112131415161718192021222324252627282930313233package mainimport &quot;fmt&quot;// an abstract type, a protocol, a contract.// no implementationtype item interface &#123; print() discount(ratio float64)&#125;type list []*productfunc (l list) print() &#123; if len(l) == 0 &#123; fmt.Println(&quot;Sorry. We&#x27;re waiting for delivery 🚚.&quot;) return &#125; for _, p := range l &#123; p.print() &#125;&#125;func (l list) discount(ratio float64) &#123; type discounter interface &#123; discount(float64) &#125; for _, p := range l &#123; p.discount(ratio) &#125;&#125; Stringer: Grant a type the ability to represent itself as a string fmt.Stringer has one method: String(). That returns a string. It is better to be an fmt.Stringer instead of printing directly. Implement the String() on a type and the type can represent itself as a string. Bonus: The functions in the fmt package can print your type. They use type assertion to detect if a type implements a String() method. strings.Builder can efficiently combine multiple string values. Example. money.go 123456789package mainimport &quot;fmt&quot;type money float64func (m money) String() string &#123; return fmt.Sprintf(&quot;$%.2f&quot;, m)&#125; timestamp.go 123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;strconv&quot; &quot;time&quot;)type timestamp struct &#123; time.Time&#125;func (ts timestamp) String() string &#123; if ts.IsZero() &#123; return &quot;unknown&quot; &#125; const layout = &quot;2006/01&quot; return ts.Format(layout)&#125;func toTimestamp(v interface&#123;&#125;) (ts timestamp) &#123; var t int switch v := v.(type) &#123; case int: t = v case string: t, _ = strconv.Atoi(v) &#125; ts.Time = time.Unix(int64(t), 0) return ts&#125; product.go 12345678910111213141516171819package mainimport ( &quot;fmt&quot;)type product struct &#123; title string price money released timestamp&#125;func (p *product) String() string &#123; return fmt.Sprintf(&quot;%s: %s (%s)&quot;, p.title, p.price, p.released)&#125;func (p *product) discount(ratio float64) &#123; p.price *= money(1 - ratio)&#125; list.go 123456789101112131415161718192021222324252627282930313233343536package mainimport ( &quot;strings&quot;)type item interface &#123; print() discount(ratio float64)&#125;type list []*productfunc (l list) String() string &#123; if len(l) == 0 &#123; return &quot;Sorry. We&#x27;re waiting for delivery 🚚.\\n&quot; &#125; var str strings.Builder for _, p := range l &#123; str.WriteString(&quot;* &quot;) str.WriteString(p.String()) str.WriteRune(&#x27;\\n&#x27;) &#125; return str.String()&#125;func (l list) discount(ratio float64) &#123; type discounter interface &#123; discount(float64) &#125; for _, p := range l &#123; p.discount(ratio) &#125;&#125; main.go 1234567891011121314package mainimport &quot;fmt&quot;func main() &#123; l := list&#123; &#123;title: &quot;moby dick&quot;, price: 10, released: toTimestamp(118281600)&#125;, &#123;title: &quot;odyssey&quot;, price: 15, released: toTimestamp(&quot;733622400&quot;)&#125;, &#123;title: &quot;hobbit&quot;, price: 25&#125;, &#125; l.discount(.5) fmt.Print(l)&#125; Sorter: let a type know how to sort itself sort.Sort() can sort any type that implements the sort.Interface. sort.Interface has three methods: Len(), Less(), Swap() Len() returns the length of a collection. Less(i, j) should return true when an element comes before another one. Swap(i, j)s the elements when the Less() return true. sort.Reverse() can reverse sort a type that satisfies the sort.Interface. You can customize the sorting: Either by implementing the sort.Interface methods or by anonymously embedding a type that already satisfies the sort.Interface and adding a Less() method. Anonymous embedding means auto-forwarding method calls to an embedded type. Check out the source-code for detail. Example. list.go, add the following three lines to the bottom of list.go. It implements the sort interface methods. 123func (l list) Len() int &#123; return len(l) &#125;func (l list) Less(i, j int) bool &#123; return l[i].title &lt; l[j].title &#125;func (l list) Swap(i, j int) &#123; l[i], l[j] = l[j], l[i] &#125; main.go 12345678910111213141516171819package mainimport ( &quot;fmt&quot; &quot;sort&quot;)func main() &#123; l := list&#123; &#123;title: &quot;moby dick&quot;, price: 10, released: toTimestamp(118281600)&#125;, &#123;title: &quot;odyssey&quot;, price: 15, released: toTimestamp(&quot;733622400&quot;)&#125;, &#123;title: &quot;hobbit&quot;, price: 25&#125;, &#125; sort.Sort(l) l.discount(.5) fmt.Print(l)&#125; Custom sort example. list.go 1234567891011type byRelease struct &#123; list&#125;func (br byRelease) Less(i, j int) bool &#123; return br.list[i].released.Before(br.list[j].released.Time)&#125;func byReleaseDate(l list) sort.Interface &#123; return &amp;byRelease&#123;l&#125;&#125; Marshalers: Customize JSON encoding and decoding of a type json.Marsahl() and json.MarsahllIndent() can only encode primitive types. Custom types can tell the encoder how to encode. To do that satisfy the json.Marshaler interface. json.Unmarshal() can only decode primitive types. Custom types can tell the decoder how to decode. To do that satisfy the json.Unmarshal interface. strconv.AppendInt() can append an int value to a []byte. There are several other functions in the strconv package for other primitive types as well. Do not make unnecessary string &lt;-&gt; []byte conversions. log.Fatal(0 can print the given error message and terminate the program. Use it only from the main(). Do not use it in other functions. main() is should be the main driver of a program. Marshal Example. main.go 123456789101112131415161718192021package mainimport ( &quot;encoding/json&quot; &quot;fmt&quot; &quot;log&quot;)func main() &#123; l := list&#123; &#123;Title: &quot;moby dick&quot;, Price: 10, Released: toTimestamp(118281600)&#125;, &#123;Title: &quot;odyssey&quot;, Price: 15, Released: toTimestamp(&quot;733622400&quot;)&#125;, &#123;Title: &quot;hobbit&quot;, Price: 25&#125;, &#125; data, err := json.MarshalIndent(l, &quot;&quot;, &quot; &quot;) if err != nil &#123; log.Fatal(err) &#125; fmt.Println(string(data))&#125; timestamp.go 12345func (ts timestamp) MarshalJSON() (data []byte, _ error) &#123; // ts -&gt; integer -&gt; ts.Unix() -&gt; integer // data &lt;- integer -&gt; strconv.AppendInt(data, integer, 10) return strconv.AppendInt(data, ts.Unix(), 10), nil&#125; Unmarshal Example. main.go 12345678910111213141516171819202122232425262728293031323334package mainimport ( &quot;encoding/json&quot; &quot;fmt&quot; &quot;log&quot;)const data = `[&#123;&quot;Title&quot;: &quot;moby dick&quot;,&quot;Price&quot;: 10,&quot;Released&quot;: 118281600&#125;,&#123;&quot;Title&quot;: &quot;odyssey&quot;,&quot;Price&quot;: 15,&quot;Released&quot;: 733622400&#125;,&#123;&quot;Title&quot;: &quot;hobbit&quot;,&quot;Price&quot;: 25,&quot;Released&quot;: -62135596800&#125;]`func main() &#123; var l list err := json.Unmarshal([]byte(data), &amp;l) if err != nil &#123; log.Fatal(err) &#125; fmt.Print(l)&#125; timestamp.go 1234func (ts *timestamp) UnmarshalJSON(data []byte) error &#123; *ts = toTimestamp(string(data)) return nil&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://vincent.fishboneapps.com/tags/Golang/"}]},{"title":"C++ Learning Journey Day12","slug":"C-Learning-Journey-Day12","date":"2021-12-04T07:43:26.000Z","updated":"2021-12-04T22:38:46.821Z","comments":true,"path":"2021/12/04/C-Learning-Journey-Day12/","link":"","permalink":"https://vincent.fishboneapps.com/2021/12/04/C-Learning-Journey-Day12/","excerpt":"","text":"Section 24: C++ 11 Auto auto can detect the data type, so you don’t need to declare the data type by yourself. decltype can capture the data type and use it on the other variables. 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;float fun()&#123; return 2.34f;&#125;int main()&#123; double d = 12.3; int i = 9; auto x = 2 * d + i; cout &lt;&lt; x &lt;&lt; endl; auto y = fun(); cout &lt;&lt; y &lt;&lt; endl; float a = 90.5; decltype(a) b = 12.3; cout &lt;&lt; typeid(b).name() &lt;&lt; endl; return 0;&#125;====OUTPUT====33.62.34f Final Keyword If you use final keyword, it will restrict inheritance. Moreover, final function can’t be inherited by the derived class. Lambda Expressions Lambda is useful for defining unnamed function, so we can define the function wherever we like. The format of lambda expression: [capture_list](parameter_list)-&gt;returnType&#123; body &#125;; Example. 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;template&lt;typename T&gt;void fun(T p)&#123; p();&#125;int main()&#123; []()&#123; cout &lt;&lt; &quot;Hello&quot; &lt;&lt; endl; &#125;(); [](int x, int y)&#123; cout &lt;&lt; &quot;Sum is &quot; &lt;&lt; x + y &lt;&lt; endl; &#125;(10, 5); cout &lt;&lt; ([](int x, int y)&#123; return x + y; &#125;(10, 5)) &lt;&lt; endl; int a = [](int x, int y)-&gt;int&#123; return x + y; &#125;(10, 5); cout &lt;&lt; a &lt;&lt; endl; auto f = []()&#123; cout &lt;&lt; &quot;Hello&quot; &lt;&lt; endl; &#125;; f(); int x = 10; auto g = [&amp;x]()&#123; cout &lt;&lt; x++ &lt;&lt; endl; &#125;; g(); x++; g(); fun(g); fun(g); return 0;&#125;====OUTPUT====HelloSum is 151515Hello10121314 Smart Pointers unique_ptr: Upon an object at a time only one pointer will be pointing. shared_ptr: It can be used by more than one pointer can point on the same object. It has Ref_counter to record how many pointers point to an object and you can use use_count() to check it. If the Ref_counter becomes to zero, the object will be deleted. weak_ptr: It doesn’t have the Ref_counter. Suppose the pointers are holding the objects and requesting for other objects, then they may form a deadlock between the pointers. So to avoid a deadlock, weak pointers are useful. This is between unique and share, but it’s not strict. unique_prt example. 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;class Rectangle&#123; int length; int breadth;public: Rectangle(int l, int b) &#123; length = l; breadth = b; &#125; int area() &#123; return length * breadth; &#125;&#125;;int main()&#123; unique_ptr&lt;Rectangle&gt; ptr(new Rectangle(10, 5)); cout &lt;&lt; ptr-&gt;area() &lt;&lt; endl; // It&#x27;s deleted, so you can&#x27;t initialize another pointer to ptr. // unique_ptr&lt;Rectangle&gt; ptr2 = ptr; unique_ptr&lt;Rectangle&gt; ptr2; ptr2 = move(ptr); cout &lt;&lt; ptr2-&gt;area() &lt;&lt; endl; // shows nothing, because ptr is removed at this point. cout &lt;&lt; ptr-&gt;area() &lt;&lt; endl; return 0;&#125;====OUTPUT====5050 share_ptr example. 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;class Rectangle&#123; int length; int breadth;public: Rectangle(int l, int b) &#123; length = l; breadth = b; &#125; int area() &#123; return length * breadth; &#125;&#125;;int main()&#123; shared_ptr&lt;Rectangle&gt; ptr(new Rectangle(10, 5)); cout &lt;&lt; ptr-&gt;area() &lt;&lt; endl; shared_ptr&lt;Rectangle&gt; ptr2; ptr2 = ptr; cout &lt;&lt; ptr2-&gt;area() &lt;&lt; endl; cout &lt;&lt; ptr-&gt;area() &lt;&lt; endl; cout &lt;&lt; ptr.use_count() &lt;&lt; endl; return 0;&#125;====OUTPUT====5050502 InClass Initializer and Delegation of Constructor One constructor can call another constructor in the same class. Here is an example. 123456789101112class Test&#123; int x = 10; int y = 13;public: Test(int a, int b) &#123; x = a; y = b; &#125; Test():Test(1, 1) &#123;&#125;&#125;; Ellipsis Ellipsis is used for taking variable number of arguments in a function. Here is an example. 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;int sum(int n, ...)&#123; va_list list; va_start(list, n); int x; int s = 0; for (int i = 0; i &lt; n; i++) &#123; x = va_arg(list, int); s += x; &#125; va_end(list); return s;&#125;int main()&#123; cout &lt;&lt; sum(3, 10, 20, 30) &lt;&lt; endl; cout &lt;&lt; sum(5, 1, 2, 3, 4, 5) &lt;&lt; endl; return 0;&#125;====OUTPUT====6015 Disclaimer I took this course from Udemy, which is Learn C++ Programming -Beginner to Advance- Deep Dive in C++. I only took some notes of this amazing course for my personal future uses and share my thoughts with my peers. If you like it, you should take the course from Udemy too.","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://vincent.fishboneapps.com/tags/C/"}]},{"title":"C++ Learning Journey Day11","slug":"C-Learning-Journey-Day11","date":"2021-12-03T12:46:32.000Z","updated":"2021-12-04T20:43:16.982Z","comments":true,"path":"2021/12/03/C-Learning-Journey-Day11/","link":"","permalink":"https://vincent.fishboneapps.com/2021/12/03/C-Learning-Journey-Day11/","excerpt":"","text":"Section 22: I/O Streams Streams Stream is a flow of data or flow of characters. Streams are used for accessing the data from outside program. Here are the types of stream. istream: cin &gt;&gt; ostream: cout &lt;&lt; ifstream ofstream Writing in a File Example. 123456789101112131415#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;int main()&#123; ofstream ofs(&quot;My.txt&quot;, ios::trunc); ofs &lt;&lt; &quot;John&quot; &lt;&lt; endl; ofs &lt;&lt; 25 &lt;&lt; endl; ofs &lt;&lt; &quot;cs&quot; &lt;&lt; endl; ofs.close(); return 0;&#125; Reading From a File Example. 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;int main()&#123; ofstream ofs(&quot;My.txt&quot;, ios::trunc); ofs &lt;&lt; &quot;John&quot; &lt;&lt; endl; ofs &lt;&lt; 25; ofs.close(); ifstream ifs; ifs.open(&quot;My.txt&quot;); if (!ifs.is_open()) cout &lt;&lt; &quot;File can&#x27;t be open&quot; &lt;&lt; endl; string str; int x; ifs &gt;&gt; str; ifs &gt;&gt; x; cout &lt;&lt; str &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; endl; if (ifs.eof()) cout &lt;&lt; &quot;end of file reached&quot;; ifs.close(); return 0;&#125;====OUTPUT====John 25end of file reached Serialization Example. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;class Student&#123;public: string name; int roll; string branch; friend ofstream &amp; operator&lt;&lt;(ofstream &amp;ofs, Student &amp;s); friend ifstream &amp; operator&gt;&gt;(ifstream &amp;ifs, Student &amp;s);&#125;;ofstream &amp; operator&lt;&lt;(ofstream &amp;ofs, Student &amp;s)&#123; ofs &lt;&lt; s.name &lt;&lt; endl; ofs &lt;&lt; s.roll &lt;&lt; endl; ofs &lt;&lt; s.branch &lt;&lt; endl; return ofs;&#125;ifstream &amp; operator&gt;&gt;(ifstream &amp;ifs, Student &amp;s)&#123; ifs &gt;&gt; s.name &gt;&gt; s.roll &gt;&gt; s.branch; return ifs;&#125;int main()&#123; Student s1; s1.name = &quot;Khan&quot;; s1.roll = 10; s1.branch = &quot;CS&quot;; ofstream ofs(&quot;Student.txt&quot;, ios::trunc); ofs &lt;&lt; s1; ofs.close(); Student s2; ifstream ifs(&quot;Student.txt&quot;); ifs &gt;&gt; s2; cout &lt;&lt; &quot;Name &quot; &lt;&lt; s2.name &lt;&lt; endl; cout &lt;&lt; &quot;Roll &quot; &lt;&lt; s2.roll &lt;&lt; endl; cout &lt;&lt; &quot;Branch &quot; &lt;&lt; s2.branch &lt;&lt; endl; return 0;&#125;====OUTPUT====Name KhanRoll 10Branch CS Text and Binary Files Text files are human readable and binary files are a machine readable. Binary file is faster and take less space. Manipulators Manipulators are used for enhancing streams or formatting streams. Manipulators for integer: hex, oct, dec, fixed, scientific. Example. 12345678910111213cout &lt;&lt; endl;cout &lt;&lt; &quot;\\n&quot;;cout &lt;&lt; hex &lt;&lt; 163 &lt;&lt; endl;cout &lt;&lt; fixed &lt;&lt; 125.731 &lt;&lt; endl;cout &lt;&lt; scientific &lt;&lt; 125.731 &lt;&lt; endl;====OUTPUT====a3125.7310001.257310e+02 Other Manipulators: set(), left, right, ws. Section 23: STL Why STL STL = Standard Template Library. Storing the collection of values, you need data structure. You want to save data in efficient time and space, you need STL. Types of Data Structures Data Structures. Array Singly LinkedList Doubly LinkedList Stack Queue Deque Priority Queue map set STL Classes STL has the following classes. Algorithms: search(), sort(), binary-search(), reverse(), concat(), copy(), union(), intersection(), merge(), Heap(). Containers(Contain collection of data) vector(self-managed array, it can resize the length of array automatically): push_back(), pop_back(), insert(), remove(), size(), empty(). list(doubly linkedList): push_front(), pop_front(), push_back(), pop_back(), insert(), remove(), size(), empty(), front(), back(). forward_list(singly linkedList): push_front(), pop_front(), push_back(), pop_back(), insert(), remove(), size(), empty(), front(), back(). deque: push_front(), pop_front(), push_back(), pop_back(), insert(), remove(), size(), empty(), front(), back(). priority_queue(max heap): push(), pop(), empty(), size(). stack(LIFO) set(unique element) multiset(allow duplicate) map(Hashtable): It can store &lt;key, value&gt; pair. It has to contain unique keys. muttimap: keys can be duplicated, but same key value map can’t be here. Iterators You can focus on add and remove data, here is an example. 1234567891011121314151617181920212223#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; v = &#123; 10, 20, 40, 90 &#125;; // default size is 16 v.push_back(25); v.push_back(70); v.pop_back(); for (int x : v) cout &lt;&lt; x &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; vector&lt;int&gt;::iterator itr; for (itr = v.begin(); itr != v.end(); itr++) cout &lt;&lt; *itr &lt;&lt; &quot; &quot;; return 0;&#125; If you change the iterator’s data, you will change the data directly. 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; v = &#123; 2, 4, 6, 8, 10 &#125;; // default size is 16 v.push_back(20); v.push_back(30); cout &lt;&lt; &quot;using Iterator&quot; &lt;&lt; endl; vector&lt;int&gt;::iterator itr; for (itr = v.begin(); itr != v.end(); itr++) cout &lt;&lt; ++*itr &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; for (int x : v) cout &lt;&lt; x &lt;&lt; &quot; &quot;; return 0;&#125;====OUTPUT====using Iterator3 5 7 9 11 21 31 3 5 7 9 11 21 31 You can change vector to list or forward_list. 1234567891011121314151617181920212223#include &lt;iostream&gt;#include&lt;forward_list&gt;using namespace std;int main()&#123; forward_list&lt;int&gt; v = &#123; 2, 4, 6, 8, 10 &#125;; // default size is 16 v.push_front(20); v.push_front(30); cout &lt;&lt; &quot;using Iterator&quot; &lt;&lt; endl; forward_list&lt;int&gt;::iterator itr; for (itr = v.begin(); itr != v.end(); itr++) cout &lt;&lt; ++*itr &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; for (int x : v) cout &lt;&lt; x &lt;&lt; &quot; &quot;; return 0;&#125; You can not change set value and it use insert to add data. 1234567891011121314151617181920212223#include &lt;iostream&gt;#include&lt;set&gt;using namespace std;int main()&#123; set&lt;int&gt; v = &#123; 2, 4, 6, 8, 10 &#125;; // default size is 16 v.insert(20); v.insert(30); cout &lt;&lt; &quot;using Iterator&quot; &lt;&lt; endl; set&lt;int&gt;::iterator itr; for (itr = v.begin(); itr != v.end(); itr++) cout &lt;&lt; *itr &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; for (int x : v) cout &lt;&lt; x &lt;&lt; &quot; &quot;; return 0;&#125; Map Classes Example. 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;int, string&gt; m; m.insert(pair&lt;int, string&gt;(1, &quot;john&quot;)); m.insert(pair&lt;int, string&gt;(2, &quot;Ravi&quot;)); m.insert(pair&lt;int, string&gt;(3, &quot;Khan&quot;)); map&lt;int, string&gt;::iterator itr; for (itr = m.begin(); itr != m.end(); itr++) &#123; cout &lt;&lt; itr-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; itr-&gt;second &lt;&lt; endl; &#125; map&lt;int, string&gt;::iterator itr1; itr1 = m.find(2); cout &lt;&lt; &quot;Value found is &quot;; cout &lt;&lt; itr1-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; itr1-&gt;second &lt;&lt; endl; return 0;&#125;====OUTPUT====1 john2 Ravi3 KhanValue found is 2 Ravi Disclaimer I took this course from Udemy, which is Learn C++ Programming -Beginner to Advance- Deep Dive in C++. I only took some notes of this amazing course for my personal future uses and share my thoughts with my peers. If you like it, you should take the course from Udemy too.","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://vincent.fishboneapps.com/tags/C/"}]},{"title":"C++ Learning Journey Day10","slug":"C-Learning-Journey-Day10","date":"2021-12-01T16:21:07.000Z","updated":"2021-12-04T02:25:23.772Z","comments":true,"path":"2021/12/01/C-Learning-Journey-Day10/","link":"","permalink":"https://vincent.fishboneapps.com/2021/12/01/C-Learning-Journey-Day10/","excerpt":"","text":"Section 19: Template Functions and Classes Template Functions and Classes Template is used for multiple data types. Here is an example. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;using namespace std;template&lt;class T&gt;class Stack&#123;private: T *stk; int top; int size;public: Stack(int sz) &#123; size = sz; top = -1; stk = new T[size]; &#125; void push(T x); T pop();&#125;;template&lt;class T&gt;void Stack&lt;T&gt;::push(T x)&#123; if (top == size - 1) cout &lt;&lt; &quot;Stack is Full&quot; &lt;&lt; endl; else &#123; top++; stk[top] = x; &#125;&#125;template&lt;class T&gt;T Stack&lt;T&gt;::pop()&#123; T x = 0; if (top == -1) cout &lt;&lt; &quot;Stack is Empty&quot; &lt;&lt; endl; else &#123; x = stk[top]; size--; &#125; return x;&#125;int main()&#123; Stack&lt;float&gt; s(10); s.push(10); s.push(23); s.push(33); return 0;&#125; Section 20: Constants, Preprocessor Directives and Namespaces Constant Qualifier Constant qualifier can’t be modified in the program. If you tried to modify it, you will get the error. Here is an example. 123cont int x = 10;// get the error// x++; Pointer to constant integer, can’t modify the x. 1234int x = 10;const int *ptr = &amp;x;// get the error// ++*ptr; Also pointer to constant integer(same as 2), you can’t modify the data, but you can point to any data. 1234int x = 10;int const *ptr = &amp;x;int y = 20;ptr = &amp;y; Constant pointer to integer, pointer can’t be modified to point to other data. 123456int x = 10;int *const ptr = &amp;x;int y = 20;// get the error// ptr = &amp;y;++(*ptr) Constant pointer to constant integer, both pointer and data can’t be modified. 1234567int x = 10;const int *const ptr = &amp;x;int y = 20;// get the error// ptr = &amp;y;// get the error// ++(*ptr) Constant in functions. You can add const after functions and you can’t modify the data in the function. 123456789101112class Demo&#123;public: int x = 10; int y = 20; void Display() const &#123; // get the error // x++; cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl; &#125;&#125;; Call by reference will modify the data. You can use const to prevent someone modify data in the function. 123456789101112131415161718#include &lt;iostream&gt;using namespace std;void fun(const int &amp;x, int &amp;y)&#123; // get the error // x++; cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y;&#125;int main()&#123; int a = 10, b = 20; fun(a, b); return 0;&#125; Preprocessor Preprocessor Directives / Macros, here is an example. 123456789101112#include &lt;iostream&gt;using namespace std;#define PI 3.1425#define c coutint main()&#123; cout &lt;&lt; PI; c &lt;&lt; 10;&#125; Preprocessor can replace contents before the compilation process start. # can convert the variable into string. Here is an example. 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;#define max(x ,y) (x &gt; y ? x : y)#define SQR(x) ( x * x )#define MSG(x) #xint main()&#123; cout &lt;&lt; max(10, 12) &lt;&lt; endl; cout &lt;&lt; SQR(5) &lt;&lt; endl; cout &lt;&lt; MSG(Hello) &lt;&lt; endl; return 0;&#125;====OUTPUT====1225Hello ifndef means if not defined. 1234#define PI 3.1425#ifndef PI #define PI 3#endif Namespaces You can use namespace to define the same function name without error. Also, you can use using namespace First to declare the default namespace. The best practice is using namespace in front of function all the time. 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;namespace First&#123; void fun() &#123; cout &lt;&lt; &quot;First&quot; &lt;&lt; endl; &#125;&#125;namespace Second&#123; void fun() &#123; cout &lt;&lt; &quot;Second&quot; &lt;&lt; endl; &#125;&#125;using namespace First;int main()&#123; fun(); Second::fun(); return 0;&#125;====OUTPUT====FirstSecond Section 21: Destructor and Virtual Destructors Destructor Constructor is used for initialization purpose. The other usage of constructor is allocating the resources. Destructor is used for allocating resources and releasing the resources. You can have multiple constructor, but you can only have one destructor. Example. 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;class Demo&#123; int *p;public: Demo() &#123; p = new int[10]; cout &lt;&lt; &quot;Constructor of Demo&quot; &lt;&lt; endl; &#125; ~Demo() &#123; delete []p; cout &lt;&lt; &quot;Destructor of Demo&quot; &lt;&lt; endl; &#125;&#125;;void fun()&#123; Demo *p = new Demo(); delete p;&#125;int main()&#123; fun(); return 0;&#125; Virtual Destructor Using inheritance, the derived class destructor is called first and then the base destructor is called. Here is an example. 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;class Base&#123;public: Base() &#123; cout &lt;&lt; &quot;Constructor of Base&quot; &lt;&lt; endl; &#125; ~Base() &#123; cout &lt;&lt; &quot;Destructor of Base&quot; &lt;&lt; endl; &#125;&#125;;class Derived : public Base&#123;public: Derived() &#123; cout &lt;&lt; &quot;Constructor of Derived&quot; &lt;&lt; endl; &#125; ~Derived() &#123; cout &lt;&lt; &quot;Destructor of Derived&quot; &lt;&lt; endl; &#125;&#125;;void fun()&#123; Derived d;&#125;int main()&#123; fun(); return 0;&#125;====OUTPUT====Constructor of BaseConstructor of DerivedDestructor of DerivedDestructor of Base If you use Base *p = new Derived; to initialize the class, you will call the destructor of the Base class when you delete the object. Therefore, you need to use virtual ~Base() in the Base class to call the Derived class destructor. 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;class Base&#123;public: virtual ~Base() &#123; cout &lt;&lt; &quot;Destructor of Base&quot; &lt;&lt; endl; &#125;&#125;;class Derived : public Base&#123;public: ~Derived() &#123; cout &lt;&lt; &quot;Destructor of Derived&quot; &lt;&lt; endl; &#125;&#125;;void fun()&#123; Base *p = new Derived(); delete p;&#125;int main()&#123; fun(); return 0;&#125;====OUTPUT====Destructor of DerivedDestructor of Base Disclaimer I took this course from Udemy, which is Learn C++ Programming -Beginner to Advance- Deep Dive in C++. I only took some notes of this amazing course for my personal future uses and share my thoughts with my peers. If you like it, you should take the course from Udemy too.","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://vincent.fishboneapps.com/tags/C/"}]},{"title":"C++ Learning Journey Day9","slug":"C-Learning-Journey-Day9","date":"2021-11-27T11:51:58.000Z","updated":"2021-12-03T05:20:41.033Z","comments":true,"path":"2021/11/27/C-Learning-Journey-Day9/","link":"","permalink":"https://vincent.fishboneapps.com/2021/11/27/C-Learning-Journey-Day9/","excerpt":"","text":"Section 16: Polymorphism Function Overriding Function overriding is you can redefined the parent function in the child class. You use the same function name of the parent class in child class. Example. 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;class Base&#123;public: void display() &#123; cout &lt;&lt; &quot;Display of Base&quot; &lt;&lt; endl; &#125;&#125;;class Derived : public Base&#123;public: void display() &#123; cout &lt;&lt; &quot;Display of Derived&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Derived d; d.display(); return 0;&#125;====OUTPUT====Display of Derived Virtual Functions If you don’t use virtual in the base function. Pointer object will call the base class. 123456789101112131415161718192021222324252627282930313233 ```#include &lt;iostream&gt;using namespace std;class Base&#123;public: void fun() &#123; cout &lt;&lt; &quot;fun of Base&quot; &lt;&lt; endl; &#125;&#125;;class Derived : public Base&#123;public: void fun() &#123; cout &lt;&lt; &quot;fun of Derived&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Derived d; Base *ptr = &amp;d; ptr-&gt;fun(); return 0;&#125;====OUTPUT====fun of Base If you use virtual in the base function. Pointer object will call the derived class. 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;class Base&#123;public: virtual void fun() &#123; cout &lt;&lt; &quot;fun of Base&quot; &lt;&lt; endl; &#125;&#125;;class Derived : public Base&#123;public: void fun() &#123; cout &lt;&lt; &quot;fun of Derived&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Derived d; Base *ptr = &amp;d; ptr-&gt;fun(); return 0;&#125;====OUTPUT====fun of Derived Runtime Polymorphism We can defined functions in the base class equals to zero, and the sub-classes must implement those functions, this is called pure virtual functions. Example. 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;class Car&#123;public: virtual void start() &#123; cout &lt;&lt; &quot;Car Started&quot; &lt;&lt; endl; &#125;&#125;;class Innova : public Car&#123;public: void start() &#123; cout &lt;&lt; &quot;Innova Started&quot; &lt;&lt; endl; &#125;&#125;;class Swift : public Car&#123;public: void start() &#123; cout &lt;&lt; &quot;Swift Started&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Car *p = new Innova(); p-&gt;start(); p = new Swift(); p-&gt;start(); return 0;&#125;====OUTPUT====Innova StartedSwift Started Abstract Classes If a base class has all concrete functions, it means this class’s purpose is to achieve reusability. And if a base class has some concrete functions and some pure virtual functions, it means this class’s purpose is to achieve reusability and polymorphism. If a base class has all pure virtual functions, it means this class’s purpose is to achieve polymorphism. This is also called interface. When you use pure virtual functions in the base class, they are the abstract class. If you make a class as abstract class, you can’t initialize it. For example, Car c; is not allowed. If the sub-class didn’t overwrite the virtual functions from the base class, the sbu-class will also become abstract class. Section 17: Friend and Static Members / Inner Classes Friend Function and Classes Friend function is a global function outside function which can access all the members of a class. When you declare the friend function, you need to add the class name before calling the class as friend. Example. 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class Your;class My&#123;private: int a;protected: int b;public: int c; friend Your;&#125;;class Your&#123;public: My m; void fun() &#123; m.a = 10; m.b = 10; m.c = 10; &#125;&#125;; Static Members Static variables are static data members of a class belongs to a class that doesn’t belong to an object, and all the objects can share it. When you declare a static members inside the class, that data member must also be declared outside the class using scope resolution. You can access the static members by object or class. Static member functions can access only static data members of a class. Example: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;class Test&#123;public: int a; static int count; Test() &#123; a = 10; count ++; &#125; static int getCount() &#123; // a++; // invalid return count; &#125;&#125;;int Test::count = 0;int main()&#123; Test t1, t2; cout &lt;&lt; t1.count &lt;&lt; endl; cout &lt;&lt; t2.count &lt;&lt; endl; t1.count = 25; cout &lt;&lt; t2.count &lt;&lt; endl; cout &lt;&lt; Test::count &lt;&lt; endl; cout &lt;&lt; Test::getCount() &lt;&lt; endl; cout &lt;&lt; t1.getCount() &lt;&lt; endl; return 0;&#125;====OUTPUT====2225252525 Inner / Nested Class Inner Class can access the members of the outer class if they are static. Outer Class can access all the members of the inner class and create a object of the inner class. Example. 123456789101112131415161718class Outer&#123;public: void fun() &#123; i.display(); &#125; class Inner &#123; public: void display() &#123; cout &lt;&lt; &quot;Display of Inner&quot; &lt;&lt; endl; &#125; &#125;; Inner i;&#125;; Section 18: Exception Handling Exception Handling Error types and solutions. Syntax Error - Compiler Logical Error - Debugger Runtime Error - Caused by (1) bad input (2) problem with resources, using Exception to solve. Exception Handling Construct Example. 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 10, b = 0, c; try &#123; if (b == 0) throw 20; c = a / b; cout &lt;&lt; c; &#125; catch (int e) &#123; cout &lt;&lt; &quot;Divided by zero &quot; &lt;&lt; &quot;error code &quot; &lt;&lt; e &lt;&lt; endl; &#125; cout &lt;&lt; &quot;Bye&quot; &lt;&lt; endl; return 0;&#125;====OUTPUT====Divided by zero error code 20Bye Throw and Catch Between Functions Error can also be implemented by if else, but the most powerful thing in try catch function is that you can throw the error from other functions. Example. 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;int division(int x, int y)&#123; if (y == 0) throw 1; else return x / y;&#125;int main()&#123; int a = 10, b = 0, c; try &#123; c = division(a, b); cout &lt;&lt; c &lt;&lt; endl; &#125; catch (int e) &#123; cout &lt;&lt; &quot;Divided by zero &quot; &lt;&lt; &quot;error code &quot; &lt;&lt; e &lt;&lt; endl; &#125; cout &lt;&lt; &quot;Bye&quot; &lt;&lt; endl; return 0;&#125;====OUTPUT====Divided by zero error code 20Bye All About Throw You can throw anything, such as int, float, string, etc. You can define your own Exception class. Example. 123class MyException : exception&#123;&#125;; Using throw after the function to declare the throw type. 123456int division(int x, int y) throw (int)&#123; if (y == 0) throw 10; return x / y;&#125; All About Catch You can have multiple catch blocks. ... means catch all, but it can only use in the last block. If you use ... in the first catch block, it will catch all of errors in the first block. 123456789101112131415161718try&#123; ... int ... float ... myException&#125;catch(int e)&#123;&#125;catch(myException e)&#123;&#125;catch(...)&#123;&#125; Try catch can do nesting. 123456789101112131415try&#123; try &#123; &#125; catch (int e) &#123; &#125;&#125;catch (int e)&#123; &#125; If you write your own Exception class, the child class must put before the base class. Here is an example. 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;class MyException1&#123; &#125;;class MyException2 : public MyException1&#123; &#125;;int main()&#123; try &#123; &#125; catch (MyException2 e) &#123; &#125; catch (MyException1 e) &#123; &#125; return 0;&#125; Disclaimer I took this course from Udemy, which is Learn C++ Programming -Beginner to Advance- Deep Dive in C++. I only took some notes of this amazing course for my personal future uses and share my thoughts with my peers. If you like it, you should take the course from Udemy too.","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://vincent.fishboneapps.com/tags/C/"}]},{"title":"C++ Learning Journey Day8","slug":"C-Learning-Journey-Day8","date":"2021-11-25T12:09:23.000Z","updated":"2021-11-28T00:51:21.038Z","comments":true,"path":"2021/11/25/C-Learning-Journey-Day8/","link":"","permalink":"https://vincent.fishboneapps.com/2021/11/25/C-Learning-Journey-Day8/","excerpt":"","text":"Section 13: Operator Overloading Operator Overloading Operators: +, *, -, (), ++, new, delete… These operators can be used for primary data types, such as int, float… If we want to perform these operators to custom data types, we need to use operator overloading. Example of complex number. 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;class Complex&#123;private: int real; int img;public: Complex(int r = 0, int i = 0) &#123; real = r; img = i; &#125; Complex operator+(Complex x) &#123; Complex temp; temp.real = real + x.real; temp.img = img + x.img; return temp; &#125;;&#125;;int main()&#123; Complex C1(3, 7); Complex C2(5, 4); Complex C3; C3 = C1 + C2; return 0;&#125; Friend Operator Overloading Friend function can be used to Operator Overloading, when you need to use friend to access the private variable outside the class. Here is an example. 12345678910111213141516171819202122class Complex&#123;private: int real; int img;public: Complex(int r = 0, int i = 0) &#123; real = r; img = i; &#125; friend Complex operator+(Complex c1, Complex c2);&#125;;Complex operator+(Complex c1, Complex c2)&#123; Complex t; t.real = c1.real + c2.real; t.img = c1.real + c2.img; return t;&#125; Insertion Operator Overloading Example 1234567891011121314151617class Complex&#123;private: int real; int img;public: . . . friend ostream &amp; operator&lt;&lt;(ostream &amp;o, Complex &amp;c1);&#125;;ostream &amp; operator&lt;&lt;(ostream &amp;o, Complex &amp;c1)&#123; o &lt;&lt; c1.real &lt;&lt; &quot;+i&quot; &lt;&lt; c1.img; return o;&#125; Section 14: Inheritance Introduction The derived class can use everything in the base class. Here is an example. 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;class Base&#123;public: int x; void show() &#123; cout &lt;&lt; x &lt;&lt; endl; &#125;&#125;;class Derived : public Base&#123;public: int y; void display() &#123; cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl; &#125;&#125;;int main()&#123; Base b; b.x = 25; b.show(); // 25 Derived d; d.x = 10; d.y = 15; d.show(); // 10 d.display(); // 10 15 return 0;&#125;====OUTPUT====251010 15 Inheritance Examples Using Rectangle as the base class and extend the new class Cuboid. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;using namespace std;class Rectangle&#123;private: int length; int breadth;public: Rectangle(int r = 0, int b = 0) &#123; length = r; breadth = b; &#125; void setLength(int l) &#123; if (l &gt;= 0) length = l; else length = 0; &#125; void setBreadth(int b) &#123; if (b &gt;= 0) breadth = b; else breadth = 0; &#125; int getLength() &#123; return length; &#125; int getBreadth() &#123; return breadth; &#125; int area() &#123; return length * breadth; &#125; int perimeter() &#123; return 2 * (length + breadth); &#125;&#125;;class Cuboid : public Rectangle&#123;private: int height;public: Cuboid(int l = 0, int b = 0, int h = 0) &#123; height = h; setLength(l); setBreadth(b); &#125; int getHeight() &#123; return height; &#125; void setHeight(int h) &#123; height = h; &#125; int volume() &#123; return getLength() * getBreadth() * height; &#125;&#125;;int main()&#123; Cuboid c(10, 5, 3); cout &lt;&lt; c.getLength() &lt;&lt; endl; cout &lt;&lt; c.volume() &lt;&lt; endl; cout &lt;&lt; c.area() &lt;&lt; endl; return 0;&#125;====OUTPUT====1015050 Constructors in Inheritance When you call a derived class, it will call the default constructor of the base class first and then call the constructor of the derived class. Example. 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;class Base&#123;public: Base() &#123; cout &lt;&lt; &quot;Non-param Base&quot; &lt;&lt; endl; &#125; Base(int x) &#123; cout &lt;&lt; &quot;Param of Base &quot; &lt;&lt; x &lt;&lt; endl; &#125;&#125;;class Derived : public Base&#123;public: Derived() &#123; cout &lt;&lt; &quot;Non-param Derived&quot; &lt;&lt; endl; &#125; Derived(int y) &#123; cout &lt;&lt; &quot;Param of Derived &quot; &lt;&lt; y &lt;&lt; endl; &#125; Derived(int x, int y) : Base(x) &#123; cout &lt;&lt; &quot;Param of Derived &quot; &lt;&lt; y &lt;&lt; endl; &#125;&#125;;int main()&#123; Derived d; Derived d2(10); Derived d3(5, 10); return 0;&#125;====OUTPUT====Non-param BaseNon-param DerivedNon-param BaseParam of Derived 10Param of Base 5Param of Derived 10 isA and hasA There are two ways for a class: A class can be derived(isA). Object of a class can be used(hasA). Access Specifiers When you create an object of a class, you cannot access all members except public members. When you want to call the variables of the base class in the derived class, you can only access the protected and public members. Types of Inheritance Simple/Single: Cuboid inheritance from Rectangle. Hierarchical: Rectangle, Circle and Quadrilateral inheritance from Shape. Multilevel: Cylinder inheritance from Circle, Circle inheritance from Point. Multiple: Smart Phone inheritance from Phone and Camera. Hybrid: mix hierarchical and multilevel or multiple. D inheritance from B and C, B and C inheritance from A. 12345678910111213141516class A&#123; ...&#125;;class B : virtual public A&#123; ...&#125;;class C : virtual public A&#123; ...&#125;;class D : public B, public C&#123; ...&#125;; Ways of Inheritance If you inheritance publicly, you can access all the members except the private member. If you inheritance protected class, the public and protected members become protected in child class. If you inheritance privately, the public and protected members become private in child class. Thus, you can access those members in the child class, but you can’t access them in the grandchild members since they are private in the child class. Generalization and Specialization Something is existing, then you are deriving something from that one and defining a new class. It’s specialization. The child classes are existing, then you are defining a base class for them. It’s Generalization. Section 15: Base Class Pointer Derived Class Object Base Class Pointer Derived Class Object You can only call the base class functions when you initiate the pointer with base class. 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;class Base&#123;public: void fun1(); void fun2(); void fun3();&#125;;class Derived : public Base&#123;public: void fun4(); void fun5();&#125;;int main()&#123; Base *p; p = new Derived(); p-&gt;fun1(); p-&gt;fun2(); p-&gt;fun3(); // p-&gt;fun4(); // Can&#x27;t Work // p-&gt;fun5(); // Can&#x27;t Work return 0;&#125; Example: you can only create a pointer of a base class to point to the child class. If we define the base class is Rectangle and derived class is cuboid, you want to initialize Cuboid *ptr = &amp;r; which would get the error message. Because you can’t say Rectangle is Cuboid which fits the real world rule. 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;class Base&#123;public: void fun1() &#123; cout &lt;&lt; &quot;fun1 of Base&quot; &lt;&lt; endl; &#125;&#125;;class Derived : public Base&#123;public: void fun2() &#123; cout &lt;&lt; &quot;fun2 of Derived&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Derived d; Base *ptr = &amp; d; ptr-&gt;fun1(); // Can&#x27;t work // Base b; // Derived *ptr = &amp;b; return 0;&#125; Disclaimer I took this course from Udemy, which is Learn C++ Programming -Beginner to Advance- Deep Dive in C++. I only took some notes of this amazing course for my personal future uses and share my thoughts with my peers. If you like it, you should take the course from Udemy too.","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://vincent.fishboneapps.com/tags/C/"}]},{"title":"C++ Learning Journey Day7","slug":"C-Learning-Journey-Day7","date":"2021-10-26T14:12:21.000Z","updated":"2021-11-27T03:23:20.584Z","comments":true,"path":"2021/10/26/C-Learning-Journey-Day7/","link":"","permalink":"https://vincent.fishboneapps.com/2021/10/26/C-Learning-Journey-Day7/","excerpt":"","text":"Section 12: Introduction to OOPS Principles of Object-Oriented Programming Abstraction: We use class to abstract the object, and put data and function inside the class. We don’t need to see content inside the class. Encapsulation: We hide the data to prevent misbehaving. Data Hiding Inheritance Polymorphism Class vs Objects We initiate the class Human, you and my are the objects of this class. Also, we initiate the class Car, BMW and Camry are the objects of this class. We can treat Class as the blueprint of Object. Example 123456789101112131415class Rectangle&#123; float length; float breath; float area() float perimeter() float diagonal()&#125;;// r1, r2, r3 are the objectsint main()&#123; Rectangle r1, r2, r3;&#125; Writing a Class in C++ Example. 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;class Rectangle&#123;public: int length; int breadth; int area() &#123; return length * breadth; &#125; int perimeter() &#123; return 2 * (length + breadth); &#125;&#125;;int main()&#123; Rectangle r1, r2; r1.length = 10; r1.breadth = 5; cout &lt;&lt; &quot;r1 Area is &quot; &lt;&lt; r1.area() &lt;&lt; endl; cout &lt;&lt; &quot;r1 Perimeter is &quot; &lt;&lt; r1.perimeter() &lt;&lt; endl; r2.length = 15; r2.breadth = 10; cout &lt;&lt; &quot;r2 Area is &quot; &lt;&lt; r2.area() &lt;&lt; endl; cout &lt;&lt; &quot;r2 Perimeter is &quot; &lt;&lt; r2.perimeter() &lt;&lt; endl; return 0;&#125; Pointer to an Object in Heap The first example create an object by stack, and the second example create an object by heap. 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;class Rectangle&#123;public: int length; int breadth; int area() &#123; return length * breadth; &#125; int perimeter() &#123; return 2 * (length + breadth); &#125;&#125;;int main()&#123; // created by stack Rectangle r; Rectangle *p; p = &amp;r; r.length = 10; p-&gt;length = 10; p-&gt;breadth = 5; cout &lt;&lt; p-&gt;area() &lt;&lt; endl; // created by heap Rectangle *q; q = new Rectangle; q-&gt;length = 15; q-&gt;breadth = 10; cout &lt;&lt; q-&gt;area() &lt;&lt; endl; return 0;&#125; Philosophy Behind Data Hiding Inside the class, we should not let variables as public. If the data is wrong, we should handle it inside the class. Data Hiding in C++ (Accessors and Mutator) Getter(Accessor) and Setter(Mutator) in class. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;using namespace std;class Rectangle&#123;private: int length; int breadth;public: void setLength(int l) &#123; if (l &gt;= 0) length = l; else length = 0; &#125; void setBreadth(int b) &#123; if (b &gt;= 0) breadth = b; else breadth = 0; &#125; int getLength() &#123; return length; &#125; int getBreadth() &#123; return breadth; &#125; int area() &#123; return length * breadth; &#125; int perimeter() &#123; return 2 * (length + breadth); &#125;&#125;;int main()&#123; Rectangle r; r.setLength(10); r.setBreadth(-5); cout &lt;&lt; r.area() &lt;&lt; endl; cout &lt;&lt; &quot;Length is &quot; &lt;&lt; r.getLength() &lt;&lt; endl; cout &lt;&lt; &quot;Breadth is &quot; &lt;&lt; r.getBreadth() &lt;&lt; endl; return 0;&#125;====OUTPUT====0Length is 10Breadth is 0 Philosophy Behind Constructors Constructors are used for initializing the variables inside class. If we want to create an object with default variables, we should use constructors. Constructors Default Constructor Non-parameterized Constructor Parameterized Constructor Copy Constructor Example 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;using namespace std;class Rectangle&#123;private: int length; int breadth;public: Rectangle() &#123; length = 0; breadth = 0; &#125; Rectangle(int l, int b) &#123; setLength(l); setBreadth(b); &#125; Rectangle(Rectangle &amp;r) &#123; length = r.length; breadth = r.breadth; &#125; void setLength(int l) &#123; if (l &gt;= 0) length = l; else length = 0; &#125; void setBreadth(int b) &#123; if (b &gt;= 0) breadth = b; else breadth = 0; &#125; int getLength() &#123; return length; &#125; int getBreadth() &#123; return breadth; &#125; int area() &#123; return length * breadth; &#125; int perimeter() &#123; return 2 * (length + breadth); &#125;&#125;;int main()&#123; // Default Constructor // Non-parameterized Constructor Rectangle r; // Parameterized Constructor Rectangle r2(10, 5); // Copy Constructor Rectangle r3(r); return 0;&#125; We can set default value to Parameterized Constructor Rectangle(int l, int b). And we can call Rectangle(l, b), Rectangle(l) and Rectangle() just use one constructor. 12345Rectangle(int l = 0, int b = 0)&#123; setLength(l); setBreadth(b);&#125; Deep Copy Constructor When we deal with the pointer in copy constructor, we need to assign the values carefully. 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;class Test&#123; int a; int *p;public: Test(int x) &#123; a = x; p = new int[a]; &#125; Test(Test &amp;t) &#123; a = t.a; // many people use p = t.p, it will point to same address location which is wrong. p = new int[a]; &#125;&#125;;int main()&#123; Test t(5); Test t2(t); return 0;&#125; All Types of Functions in a Class A complete Class example. 1234567891011121314151617181920212223class Rectangle&#123;private: int length; int breadth;public: // Constructor Rectangle(); Rectangle(int l, int b); Rectangle(Rectangle &amp;r); // Mutator void setLength(int l); void setBreadth(int b); // Accessor int getLength(); int getBreadth(); // Facilitators int area(); int perimeter(); bool isSquare(); // Destructor ~Rectangle();&#125;; Scope Resolution Operator The best practice in C++ should use function outside the class, inline function should only have simple logic. Complete Example 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;using namespace std;class Rectangle&#123;private: int length; int breadth;public: // Constructor Rectangle(); Rectangle(int l, int b); Rectangle(Rectangle &amp;r); // Mutator void setLength(int l); void setBreadth(int b); // Accessor int getLength() &#123; return length; &#125;; int getBreadth() &#123; return breadth; &#125;; // Facilitators int area(); int perimeter(); bool isSquare(); // Destructor ~Rectangle();&#125;;int main()&#123; Rectangle r1(10, 10); cout &lt;&lt; &quot;Area &quot; &lt;&lt; r1.area() &lt;&lt; endl; if (r1.isSquare()) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; return 0;&#125;Rectangle::Rectangle()&#123; length = 1; breadth = 1;&#125;Rectangle::Rectangle(int l, int b)&#123; length = l; breadth = b;&#125;Rectangle::Rectangle(Rectangle &amp;r)&#123; length = r.length; breadth = r.breadth;&#125;void Rectangle::setLength(int l)&#123; length = l;&#125;void Rectangle::setBreadth(int b)&#123; breadth = b;&#125;int Rectangle::area()&#123; return length * breadth;&#125;int Rectangle::perimeter()&#123; return 2 * (length + breadth);&#125;bool Rectangle::isSquare()&#123; return length == breadth;&#125;Rectangle::~Rectangle()&#123; cout &lt;&lt; &quot;Rectangle Destroyed&quot;;&#125;====OUTPUT====Area 100YesRectangle Destroyed Inline Functions If you put your code inline in the class, machine will generate your code inside the main. If your code isn’t inline, the code will be generated outside the main. Moreover, you can add inline keyword in front of the function, machine will generate your code inside the main even if you put your function outside the class. This pointer If the class private variables’ name are as same as the class input of a function, we can use this-&gt;variable_name to point to the class private variables. 12345Rectangle::Rectangle(int length, int breadth)&#123; this-&gt;length = length; this-&gt;breadth = breadth;&#125; Struct v.s. Class The only difference between Struct and Class is everything in the Struct are public by default. And, everything in the Class are private by default. Disclaimer I took this course from Udemy, which is Learn C++ Programming -Beginner to Advance- Deep Dive in C++. I only took some notes of this amazing course for my personal future uses and share my thoughts with my peers. If you like it, you should take the course from Udemy too.","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://vincent.fishboneapps.com/tags/C/"}]},{"title":"C++ Learning Journey Day6","slug":"C-Learning-Journey-Day6","date":"2021-10-23T08:40:55.000Z","updated":"2021-10-26T03:00:47.582Z","comments":true,"path":"2021/10/23/C-Learning-Journey-Day6/","link":"","permalink":"https://vincent.fishboneapps.com/2021/10/23/C-Learning-Journey-Day6/","excerpt":"","text":"Section11: Functions Introduction return-Type Function-name(Parameter List). Should not use cin and cout inside function. Add function example. 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int add (int x, int y) &#123; int z; z = x + y; return z;&#125;int main()&#123; int a = 10, b= 15, c; c = add(a, b); cout &lt;&lt; &quot;sum is &quot; &lt;&lt; c &lt;&lt; endl; return 0;&#125;====OUTPUT====sum is 25 Function Overloading Functions can be overloaded. If the functions with same name have different number of parameters and different types of parameters, they are the different functions. int max(int, int) float max(float, float) int max(int, int, int) float max(int, int) (X, this is the same function with the first one.) Overloading example. 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;int add(int x, int y)&#123; return x + y;&#125;int add(int x, int y, int z)&#123; return x + y + z;&#125;float add(float x, float y)&#123; return x + y;&#125;int main()&#123; int a = 10, b = 5, c, d; c = add(a, b); d = add(a, b, c); cout &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; d &lt;&lt; endl; float i = 2.5f, j = 3.5f, k; k = add(i, j); cout &lt;&lt; k &lt;&lt; endl; return 0;&#125;====OUTPUT====15306 Function Template Template is used for generic function. For example, we have two max functions with two types and the whole logic is identical. I can use template to combine them together. 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;template&lt;class T&gt;T Max(T x, T y)&#123; return x &gt; y ? x : y;&#125;int main()&#123; int c = Max(10, 5); float d = Max(10.5f, 6.9f); cout &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; d &lt;&lt; endl; return 0;&#125;====OUTPUT====1010.5 Default Arguments You can assign a default value for function arguments. For example. 12345678910111213141516#include &lt;iostream&gt;using namespace std;int sum(int a, int b, int c = 0)&#123; return a + b + c;&#125;int main()&#123; cout &lt;&lt; sum(10 ,5) &lt;&lt; endl; cout &lt;&lt; sum(12, 13, 14) &lt;&lt; endl; return 0;&#125; The best practice is write the default argument from right to left parameters. Make sure you’ll check every arguments. 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;int max(int a = 0, int b = 0, int c = 0)&#123; return a &gt; b &amp;&amp; a &gt; c ? a : (b &gt; c ? b : c);&#125;int main()&#123; cout &lt;&lt; max() &lt;&lt; endl; cout &lt;&lt; max(10) &lt;&lt; endl; cout &lt;&lt; max(10 ,13) &lt;&lt; endl; cout &lt;&lt; max(10 ,13, 15) &lt;&lt; endl; return 0;&#125;====OUTPUT====0101315 Parameter Passing - Pass by Value Parameter Passing Method. Pass by value. Pass by address. Pass by reference. Example. x and y won’t be changed, because it just pass value into swap() function, and a and b would eliminate after the function is executed. 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;void swap(int a, int b)&#123; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; int temp; temp = a; a = b; b = temp; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;&#125;int main()&#123; int x = 10, y = 20; swap(x, y); cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl; return 0;&#125;====OUTPUT====10 2020 1010 20 Parameter Passing - Pass by Address Example. 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;void swap(int *a, int *b)&#123; int temp; temp = *a; *a = *b; *b = temp;&#125;int main()&#123; int x = 10, y = 20; swap(&amp;x, &amp;y); cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl; return 0;&#125;====OUTPUT====20 10 Parameter Passing - Pass by Reference Example. 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;void swap(int &amp;a, int &amp;b)&#123; int temp; temp = a; a = b; b = temp;&#125;int main()&#123; int x = 10, y = 20; swap(x, y); cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl; return 0;&#125;====OUTPUT====20 10 Return by Address Return by address example. 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;int * fun()&#123; int *p = new int[5]; for (int i = 0; i &lt; 5; i++) &#123; p[i] = 5 * i; &#125; cout &lt;&lt; p &lt;&lt; endl; return p;&#125;int main()&#123; int *q = fun(); cout &lt;&lt; q &lt;&lt; endl; for (int i = 0; i &lt; 5; i++) &#123; cout &lt;&lt; q[i] &lt;&lt; endl; &#125; return 0;&#125;====OUTPUT====0x7ff6a04059d00x7ff6a04059d005101520 Return by Reference Return by reference example. Because the fun() return the reference type a, we can assign value to it. fun(a) = 25; is as same as a = 25;. 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int &amp; fun(int &amp;x)&#123; return x;&#125;int main()&#123; int a = 10; fun(a) = 25; cout &lt;&lt; a &lt;&lt; endl; return 0;&#125;====OUTPUT====25 Local and Global Variables Example. The outside g is the global variable. The other variables are local variables, they would be vanished after the variables’ block code is executed. Declare variable g repeatedly would shadow the global variable g, the related code block only treat the g as a local variable. 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int g = 5;void fun()&#123; int g = 10; &#123; int g = 0; g++; cout &lt;&lt; g &lt;&lt; endl; &#125; cout &lt;&lt; g &lt;&lt; endl;&#125;int main()&#123; cout &lt;&lt; g &lt;&lt; endl; fun(); cout &lt;&lt; g &lt;&lt; endl; return 0;&#125;====OUTPUT====51105 Scope Rule Example. If we want to access the global variable, we can use ::x to access it. 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;int x = 10;int main()&#123; int x = 20; &#123; int x = 30; cout &lt;&lt; x &lt;&lt; endl; &#125; cout &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; ::x &lt;&lt; endl; return 0;&#125;====OUTPUT====302010 Static Variables If we want to create a global variable and limited it use in a function, we will use static. Here is an example. 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;void fun()&#123; static int s = 10; s++; cout &lt;&lt; s &lt;&lt; endl;&#125;int main()&#123; fun(); fun(); fun(); return 0;&#125;====OUTPUT====111213 Recursive Functions Example. 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;void fun(int n)&#123; if (n &gt; 0) &#123; fun(n - 1); cout &lt;&lt; n &lt;&lt; endl; &#125;&#125;int main()&#123; fun(5); return 0;&#125;====OUTPUT====12345 Function Pointer Function pointer can point to different functions when they have same signature. 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int max(int x, int y)&#123; return x &gt; y ? x : y;&#125;int min(int x, int y)&#123; return x &lt; y ? x : y;&#125;int main()&#123; int (*fp) (int, int); fp = max; int a = (*fp)(10, 5); cout &lt;&lt; a &lt;&lt; endl; fp = min; int b = (*fp)(10, 5); cout &lt;&lt; b &lt;&lt; endl; return 0;&#125;====OUTPUT====105 Disclaimer I took this course from Udemy, which is Learn C++ Programming -Beginner to Advance- Deep Dive in C++. I only took some notes of this amazing course for my personal future uses and share my thoughts with my peers. If you like it, you should take the course from Udemy too.","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://vincent.fishboneapps.com/tags/C/"}]},{"title":"C++ Learning Journey Day5","slug":"C-Learning-Journey-Day5","date":"2021-10-19T10:41:00.000Z","updated":"2021-10-23T20:35:07.316Z","comments":true,"path":"2021/10/19/C-Learning-Journey-Day5/","link":"","permalink":"https://vincent.fishboneapps.com/2021/10/19/C-Learning-Journey-Day5/","excerpt":"","text":"Section 10: String Class String You need to include string library to use string. Also, you can use getline to get the string from the user input. 12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string str = &quot;Hello&quot;; cout &lt;&lt; &quot;Enter a string &quot;; getline(cin, str); cout &lt;&lt; str &lt;&lt; endl; return 0;&#125; You can use cin to get the string directly and it won’t get the line break. For example, output1 typed “Hi” and then enter to type “World”, it will show two separate strings respectively. Also, output 2 types “Hello World”, it will print Hello World separately. Not like char, you need to use cin.ignore() to ignore the line break. 12345678910111213141516string str;cout &lt;&lt; &quot;Enter a string &quot;;cin &gt;&gt; str;cout &lt;&lt; str &lt;&lt; endl;cin &gt;&gt; str;cout &lt;&lt; str &lt;&lt; endl;====OUTPUT====Enter a string `Hi`Hi`World`World====OUTPUT====Enter a string `Hello World`HelloWorld Basic Functions of Class String Basic functions of class string. s.length() s.size() s.capacity() s.resize(30) s.max_size() s.clear() s.empty() Example 123456789101112131415161718192021222324string str = &quot;Hello&quot;;cout &lt;&lt; str.length() &lt;&lt; endl;cout &lt;&lt; str.size() &lt;&lt; endl;cout &lt;&lt; str.capacity() &lt;&lt; endl;str.resize(50);cout &lt;&lt; str.capacity() &lt;&lt; endl;cout &lt;&lt; str.max_size() &lt;&lt; endl;str.clear();if (str.empty()) cout &lt;&lt; &quot;String is empty&quot; &lt;&lt; endl;else cout &lt;&lt; &quot;String is &quot; &lt;&lt; str &lt;&lt; endl;====OUTPUT====55226318446744073709551599String is empty Class String - Append and Insert Functions Append and insert functions s.append(“Bye”) s.insert(3, “kk”) s.replace(3, 5, “aa”) s.erase() s.push_back(‘z’) s.pop_back() s1.swap(s2) append() example. 1234567891011string str = &quot;Hello&quot;;cout &lt;&lt; str.capacity() &lt;&lt; endl;str.append(&quot; How are you all? Hope all are fine&quot;);cout &lt;&lt; str.capacity() &lt;&lt; &quot; &quot; &lt;&lt; str.length() &lt;&lt; endl;cout &lt;&lt; str &lt;&lt; endl;====OUTPUT====2247 40Hello How are you all? Hope all are fine insert() example, the third parameters is word number you like to insert. 1234567string str = &quot;How you&quot;;str.insert(3, &quot; area&quot;, 4);cout &lt;&lt; str &lt;&lt; endl;====OUTPUT====How are you replace() example, the first parameter is the position start to replace and the second parameters is how many characters you want to replace with. 1234567string str = &quot;programming&quot;;str.replace(3, 6, &quot;H&quot;);cout &lt;&lt; str &lt;&lt; endl;====OUTPUT====proHng push_back() example, the parameter can only be char type. 1234567string str = &quot;programming&quot;;str.push_back(&#x27;H&#x27;);cout &lt;&lt; str &lt;&lt; endl;====OUTPUT====programmingH pop_back() example, it removes the last character. 1234567string str = &quot;programming&quot;;str.pop_back();cout &lt;&lt; str &lt;&lt; endl;====OUTPUT====programmin swap() example. 12345678910string str1 = &quot;programming&quot;;string str2 = &quot;Language&quot;;str1.swap(str2);cout &lt;&lt; str1 &lt;&lt; endl;cout &lt;&lt; str2 &lt;&lt; endl;====OUTPUT====Languageprogramming String Class - Copy and Find Functions Copy and Find Functions. s.copy(char desp[]) s.find(str) or char s.rfind(str) s.find_first_of() s.find_last_of() s.substr(start, number) s.compare(str) copy() example. 12345678910string s = &quot;Welcome&quot;;char str[10];s.copy(str, 3);str[3] = &#x27;\\0&#x27;;cout &lt;&lt; str &lt;&lt; endl;====OUTPUT====Wel In default, find() finds the words from the left. rfind() finds the words from the right. If the words can’t be found, it will return large number. 1234567891011string str = &quot;How are you&quot;;cout &lt;&lt; str.find(&quot;are&quot;) &lt;&lt; endl;cout &lt;&lt; str.find(&quot;yo&quot;) &lt;&lt; endl;cout &lt;&lt; str.find(&quot;is&quot;) &lt;&lt; endl;cout &lt;&lt; str.rfind(&#x27;o&#x27;) &lt;&lt; endl;====OUTPUT====48184467440737095516159 find_first_of() and find_last_of() examples. The second parameter is the position that you want to start your search. You can also put more than one letter as the first parameter, it will find one of the letter and return the position. find_last_of() will find from the back and return the last position of your parameter. 12345678910111213string str = &quot;Hello World&quot;;cout &lt;&lt; str.find_first_of(&#x27;l&#x27;) &lt;&lt; endl;cout &lt;&lt; str.find_first_of(&#x27;l&#x27;, 3) &lt;&lt; endl;cout &lt;&lt; str.find_first_of(&#x27;l&#x27;, 4) &lt;&lt; endl;cout &lt;&lt; str.find_first_of(&quot;le&quot;) &lt;&lt; endl;cout &lt;&lt; str.find_last_of(&#x27;l&#x27;) &lt;&lt; endl;====OUTPUT====23919 substr() example. The second parameter is the length of return string. 1234567string str = &quot;Programming&quot;;cout &lt;&lt; str.substr(3) &lt;&lt; endl;cout &lt;&lt; str.substr(3, 4) &lt;&lt; endl;====OUTPUT====gramminggram compare() example. 1234567891011121314string str1 = &quot;Hello&quot;;string str2 = &quot;Hello&quot;;string str3 = &quot;World&quot;;string str4 = &quot;hello&quot;;cout &lt;&lt; str1.compare(str2) &lt;&lt; endl;cout &lt;&lt; str1.compare(str3) &lt;&lt; endl;cout &lt;&lt; str1.compare(str4) &lt;&lt; endl;cout &lt;&lt; str4.compare(str1) &lt;&lt; endl;====OUTPUT====0-15-3232 Example of string operator. 12345678910111213141516171819202122string str = &quot;Holiday&quot;;string str2 = &quot;World&quot;;cout &lt;&lt; str.at(4) &lt;&lt; endl;str[4] = &#x27;M&#x27;;cout &lt;&lt; str &lt;&lt; endl;str = str + str2;cout &lt;&lt; str &lt;&lt; endl;str = str + &quot; How are you?&quot;;cout &lt;&lt; str &lt;&lt; endl;str = str2;cout &lt;&lt; str &lt;&lt; endl;====OUTPUT====dHoliMayHoliMayWorldHoliMayWorld How are you?World String Class - Iterator Iterator string::iterator begin() end() reverse_iterator rbegin() rend() String iterator example. 1234567891011121314151617181920212223242526272829string str = &quot;today&quot;;string::iterator it;for (it = str.begin(); it != str.end(); it++) &#123; *it = *it -32;&#125;cout &lt;&lt; str &lt;&lt; endl;string str1 = &quot;today&quot;;string::reverse_iterator rit;for (rit = str.rbegin(); rit != str.rend(); rit++) &#123; cout &lt;&lt; *rit;&#125;cout &lt;&lt; endl;string str2 = &quot;today&quot;;for (int i = 0; str2[i] != &#x27;\\0&#x27;; i++) &#123; str2[i] = str2[i] - 32;&#125;cout &lt;&lt; str2 &lt;&lt; endl;====OUTPUT====TODAYYADOTTODAY Find Length of a String There are two ways to find the length of a string, use str[i] != '\\0' or iterator. 123456789101112131415161718192021string str = &quot;test&quot;;int count = 0;for (int i = 0; str[i] != &#x27;\\0&#x27;; i++) &#123; count++;&#125;cout &lt;&lt; count &lt;&lt; endl;int iteratorCount = 0;string::iterator it;for (it = str.begin(); it != str.end(); it++) &#123; iteratorCount++;&#125;cout &lt;&lt; iteratorCount &lt;&lt; endl;====OUTPUT====44 Practice Problem: Change Cases of Letters Change to lowercase example. 1234567891011string str = &quot;WELCOmE&quot;;for (int i = 0; str[i] != &#x27;\\0&#x27;; i++) &#123; if (str[i] &gt;= 65 &amp;&amp; str[i] &lt;= 90) &#123; str[i] += 32; &#125;&#125;cout &lt;&lt; str &lt;&lt; endl;====OUTPUT====welcome Change to uppercase example. 123456789string str = &quot;welcome5&quot;;for (int i = 0; str[i] != &#x27;\\0&#x27;; i++) &#123; if (str[i] &gt;= 97 &amp;&amp; str[i] &lt;= 122) &#123; str[i] -= 32; &#125;&#125;cout &lt;&lt; str &lt;&lt; endl; Practice Problem: Count Vowels and Words in a String Example. 12345678910111213141516171819string str = &quot;how Many wOrds&quot;;int vowels = 0, consonant = 0, space = 0;for (int i = 0; str[i] != &#x27;\\0&#x27;; i++) &#123; if (str[i] == &#x27;A&#x27; || str[i] == &#x27;E&#x27; || str[i] == &#x27;I&#x27; || str[i] == &#x27;O&#x27; || str[i] == &#x27;U&#x27; || str[i] == &#x27;a&#x27; || str[i] == &#x27;e&#x27; || str[i] == &#x27;i&#x27; || str[i] == &#x27;o&#x27; || str[i] == &#x27;u&#x27;) vowels++; else if (str[i] == &#x27; &#x27;) space++; else consonant++;&#125;cout &lt;&lt; &quot;Vowels &quot; &lt;&lt; vowels &lt;&lt; endl;cout &lt;&lt; &quot;Consonants &quot; &lt;&lt; consonant &lt;&lt; endl;cout &lt;&lt; &quot;Words &quot; &lt;&lt; space + 1 &lt;&lt; endl;====OUTPUT====Vowels 3Consonants 9Words 3 Practice Problem: Checking Palindrome Example. 123456789101112131415161718192021string str = &quot;MADAM&quot;;string rev = &quot;&quot;;int len = (int) str.length();rev.resize(len);for (int i = 0, j = len - 1; i &lt; len; i++, j--) &#123; rev[i] = str[j];&#125;rev[len] = &#x27;\\0&#x27;;cout &lt;&lt; rev &lt;&lt; endl;if (str.compare(rev) == 0) cout &lt;&lt; &quot;Palindrome&quot; &lt;&lt; endl;else cout &lt;&lt; &quot;Not a Palindrome&quot; &lt;&lt; endl;====OUTPUT====MADAMPalindrome Practice Problem: Find username from email address Example. 123456789string email = &quot;john123@gmail.com&quot;;int i = (int) email.find(&#x27;@&#x27;);string uname = email.substr(0, i);cout &lt;&lt; &quot;User Name is &quot; &lt;&lt; uname &lt;&lt; endl;====OUTPUT====User Name is john123 Disclaimer I took this course from Udemy, which is Learn C++ Programming -Beginner to Advance- Deep Dive in C++. I only took some notes of this amazing course for my personal future uses and share my thoughts with my peers. If you like it, you should take the course from Udemy too.","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://vincent.fishboneapps.com/tags/C/"}]},{"title":"C++ Learning Journey Day4","slug":"C-Learning-Journey-Day4","date":"2021-10-10T11:22:24.000Z","updated":"2021-10-19T22:41:16.922Z","comments":true,"path":"2021/10/10/C-Learning-Journey-Day4/","link":"","permalink":"https://vincent.fishboneapps.com/2021/10/10/C-Learning-Journey-Day4/","excerpt":"","text":"Section 9: Pointers Introduction Two types of variables. data variable. For example, int x = 10;. address variable. For example, int *p; p = &amp;x; Example 1234567// x, value 10, address 200/201// p, value 10, address 300/301cout &lt;&lt; x; // 10cout &lt;&lt; &amp;x; // 200cout &lt;&lt; p; // 200cout &amp;p; // 300cout &lt;&lt; *p. // 10 Three things about pointer. declaration int *p;. initialization p = &amp;x;. dereferencing cout &lt;&lt; *p;. Why pointers? You can only access a file by pointer. Also, access network connection can only be done by pointer. The keyboard, monitor and printer are all needed it. Java and most of programming languages without pointer can’t access the hardware directly. For example, Java need to use JVM to access hardwares using C runtime. Heap Memory Allocation When you initiate int *p, p will created in the stack of memory. Then, if you new array, the array will created in the heap of memory and p will point to the array in the heap. 123int A[5] = &#123;1, 2, 3, 4, 5&#125;;int *p;p = new int[5]; When you want to delete a pointer variable p, you should not use p = NULL;. The p won’t be deleted, p just point to null. You should use delete []p;. If you really want to make p point to nothing, you should use p = nullptr;. You can access general array by using A[2], you can also access pointer array by using p[2]. It’s the benefit. Pointer Arithmetic p++;, ++ means move to next location instead of add one. For example, if the pointer is float, it will move 4 bytes. p--;, – means move backward. p = p + 2;, it will move forward by two elements. p = p - 2;, it can move backward. d = q - p, it can know the distance between two elements. For example, p = 200, q = 206, and the type of p and q is int. The d will be 3, because it will divide 6 by 2 bytes and you know the distance between the q and p is 3 elements. On the contrary, if you do p - q, it will get the -3. You can know q is farther than p. Print values by many ways. 1234567891011121314int A[5]&#123;2, 4, 6, 8, 10&#125;;int *p = A;for (int i = 0; i &lt; 5; i++) &#123; // cout &lt;&lt; A[i] &lt;&lt; endl; // cout &lt;&lt; i[A] &lt;&lt; endl; // cout &lt;&lt; *(A + i) &lt;&lt; endl; // cout &lt;&lt; A + i &lt;&lt; endl; // print the address // cout &lt;&lt; p + i &lt;&lt; endl; // print the address // cout &lt;&lt; *(p + i) &lt;&lt; endl; // cout &lt;&lt; p[i] &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; p++;&#125; Print distance example. 123456int A[5]&#123;2, 4, 6, 8, 10&#125;;int *p = A, *q = &amp;A[4];cout &lt;&lt; p - q;====OUTPUT====-4 Problems using Pointers Uninitialized pointer. There are three ways to initialize the pointer. 1234567int x = 10;int *p;1) p = &amp;x;2) p = (int *) 0x5638;3) p = new int[5];// Runtime error - Using uninitialized pointercout &lt;&lt; *p; Memory leak. If you don’t want to use p anymore, and you don’t delete the p by using delete []p. It will cause memory leak. 12345int *p = new int[5];...p = NULL; Dangling pointer 12345678910111213141516void main() &#123; int *p = new int[5]; . . . fun(P); // cause the error, since p is deleted in the function. cout &lt;&lt; *p;&#125;void func(int *q) &#123; . . . delete []q;&#125; Reference Reference doesn’t consume any memory at all. 1234567891011121314151617main() &#123; int x = 10; int &amp;y = x; // reference, x is l-value of x // Error: cannot initialize without value. // int &amp;y; x++; y++; cout &lt;&lt; x; // 12 cout &lt;&lt; y; // 12 int a; a = x; // x is r-value and the data of x. x = 25; // x is l-value and the address of x. // Error: y can&#x27;t be referencing any other variable at all. // &amp;y = a;&#125; Reference Example. 123456789101112int x = 10;int &amp;y = x;cout &lt;&lt; x &lt;&lt; endl;y++;x++;cout &lt;&lt; x &lt;&lt; endl;cout &lt;&lt; &amp;x &lt;&lt; &quot; &quot; &lt;&lt; &amp;y &lt;&lt; endl;====OUTPUT====10120x7ffee33ae828 0x7ffee33ae828 Section 10: String Introduction There are two ways to represent the String. Using char Array class string Declaring and Initializing String char x = 'A'; char S[10] = &quot;Hello&quot;; char S[] = &#123;'H', 'e', 'l', 'l', 'o', '\\0'&#125;; char S[] = &#123;65, 66, 67, 68, '\\n'&#125;; char * S = &quot;Hello&quot;; If you put the letters after \\0, those letters won’t show. 1234567char H[] = &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;\\0&#x27;, &#x27;p&#x27;, &#x27;p&#x27;, &#x27;p&#x27;&#125;;cout &lt;&lt; H &lt;&lt; endl;char S[] = &#123;65, 66, 67, 68, 69, 0, 70, 71&#125;;cout &lt;&lt; S &lt;&lt; endl;====OUTPUT====HelloABCDE Reading and Writing String You can use cin.get() and cin.getline() to write a string. If you try to get two string using cin.getline(), remember to use cin.ignore() to avoid the second cin get extra content from the first cin. 1234567891011121314char s[100];char s2[100];cout &lt;&lt; &quot;Enter your Name &quot;;cin.get(s, 100);cout &lt;&lt; &quot;Welcome &quot; &lt;&lt; s &lt;&lt; endl;cin.ignore();cout &lt;&lt; &quot;Enter your Name Again &quot;;cin.get(s2, 100);cout &lt;&lt; &quot;Welcome &quot; &lt;&lt; s2 &lt;&lt; endl; String Functions - Length, Concatenate and Copy strlen(str1); to get the length of string. 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; char *s; cout &lt;&lt; &quot;Enter a String &quot;; cin.getline(s, 100); cout &lt;&lt; &quot;Length &quot; &lt;&lt; strlen(s) &lt;&lt; endl; return 0;&#125;====OUTPUT====Enter a String Hello WorldLength 11 strcat(destination, source); concatenates two words. 12345678char S1[20] = &quot;Good&quot;;char S2[10] = &quot;Mourning&quot;;strcat(S1, S2);cout &lt;&lt; S1 &lt;&lt; endl;====OUTPUT====GoodMourning strncat(destination, source, length); concatenates two words with certain length. 12345678char S1[20] = &quot;Good&quot;;char S2[10] = &quot;Mourning&quot;;strncat(S1, S2, 3);cout &lt;&lt; S1 &lt;&lt; endl;====OUTPUT====GoodMou strcpy(destination, source); copies source string to destination string. 12345678char S1[20] = &quot;Good&quot;;char S2[10] = &quot;&quot;;strcpy(S2, S1);cout &lt;&lt; S2 &lt;&lt; endl;====OUTPUT====Good strncpy(destination, source, length); copies source string to destination string with certain length. 12345678char S1[20] = &quot;Good&quot;;char S2[10] = &quot;&quot;;strncpy(S2, S1, 2);cout &lt;&lt; S2 &lt;&lt; endl;====OUTPUT====Go String Function - Substring and Compare strstr(main, sub); can substring with certain string, it returns the string from sub to the rest of main string. 123456char S1[20] = &quot;Programming&quot;;char S2[10] = &quot;gram&quot;;cout &lt;&lt; strstr(S1, S2) &lt;&lt; endl;====OUTPUT====gramming If you use strstr in the sub string which is not in the main string, it returns null. 123456789char S1[20] = &quot;Programming&quot;;char S2[10] = &quot;k&quot;;if (strstr(S1, S2) != NULL) cout &lt;&lt; strstr(S1, S2) &lt;&lt; endl;else cout &lt;&lt; &quot;Not Found&quot; &lt;&lt; endl;====OUTPUT====Not Found The function of strchr(main, char); is as same as strstr, the only difference is the second parameter is char type. strrchr(main, char); can return the string count from the right hand side. 1234567char S1[20] = &quot;Programming&quot;;cout &lt;&lt; strchr(S1, &#x27;g&#x27;) &lt;&lt; endl;cout &lt;&lt; strrchr(S1, &#x27;g&#x27;) &lt;&lt; endl;====OUTPUT====grammingg strcmp(str1, str2) will return 0 when the two strings are the same. It will return positive number if str1 is greater than str2, and vice versa. 123456char s1[20] = &quot;minor&quot;;char s2[20] = &quot;elder&quot;;cout &lt;&lt; strcmp(s1, s2) &lt;&lt; endl;====OUTPUT====8 String Functions - Tokenizer and To Integer strtol(str1, NULL, base) means string to long. strtof(str1, NULL) means string to float. 12345678910char s1[10] = &quot;235&quot;;char s2[10] = &quot;54.78&quot;;long int x = strtol(s1, NULL, 10);float y= strtof(s2, NULL);cout &lt;&lt; x + 10 &lt;&lt; endl &lt;&lt; y - 5 &lt;&lt; endl;====OUTPUT====24549.78 strtok(str1, &quot;=;&quot;) tokenize a string base on the symbols. 12345678910111213141516char s1[20] = &quot;x=10;y=20;z=35&quot;;char *token = strtok(s1, &quot;=;&quot;);while (token != NULL)&#123; cout &lt;&lt; token &lt;&lt; endl; token = strtok(NULL, &quot;=;&quot;);&#125;====OUTPUT====x10y20z35 Disclaimer I took this course from Udemy, which is Learn C++ Programming -Beginner to Advance- Deep Dive in C++. I only took some notes of this amazing course for my personal future uses and share my thoughts with my peers. If you like it, you should take the course from Udemy too.","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://vincent.fishboneapps.com/tags/C/"}]},{"title":"C++ Learning Journey Day3","slug":"C-Learning-Journey-Day3","date":"2021-10-03T10:14:05.000Z","updated":"2021-10-06T00:35:16.156Z","comments":true,"path":"2021/10/03/C-Learning-Journey-Day3/","link":"","permalink":"https://vincent.fishboneapps.com/2021/10/03/C-Learning-Journey-Day3/","excerpt":"","text":"Section 7: Loops Loops - Iterative Statement while 123while (&lt;condition&gt;) &#123; process;&#125; do while 123do &#123; process;&#125; while (&lt;condition&gt;) Print the numbers example. while 1234567int n, i = 1;cout &lt;&lt; &quot;Enter n&quot;;cin &gt;&gt; n;while (i &lt;= n) &#123; cout &lt;&lt; i &lt;&lt; endl; i++;&#125; do while 1234567int n, i = 1;cout &lt;&lt; &quot;Enter n&quot;;cin &gt;&gt; n;do &#123; cout &lt;&lt; i &lt;&lt; endl; i++;&#125; while (i &lt;= n); for loop for 123for (initialization; condition; updation) &#123; process;&#125; Print the numbers example 123456int n, i;cout &lt;&lt; &quot;Enter n&quot;;cin &gt;&gt; n;for (i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; i &lt;&lt; endl;&#125; for each Infinite loop You can skip condition in the for and define the initialization and condition somewhere else. 12345678int i = 0;for (;;)&#123; cout &lt;&lt; i &lt;&lt; &quot; Hello\\n&quot;; i++; if (i &gt; 10) break;&#125; Multiplication Table Example. 123456int n, i;cout &lt;&lt; &quot;Enter n&quot;;cin &gt;&gt; n;for (i = 1; i &lt;= 10; i++) &#123; cout &lt;&lt; n &lt;&lt; &quot; x &quot; &lt;&lt; i &lt;&lt; &quot; = &quot; &lt;&lt; n * i &lt;&lt; endl;&#125; Find GDC of 2 numbers Example. 12345678910int m, n;cout &lt;&lt; &quot;Enter 2 numbers&quot;;cin &gt;&gt; m &gt;&gt; n;while (m != n) &#123; if (m &gt; n) m -= n; else n -= m;&#125;cout &lt;&lt; &quot;GCD is &quot; &lt;&lt; m &lt;&lt; endl; Section 8: Array Introduction Array can be any type, such as int, float, char. Declaration: 123int A[5] = &#123;2, 4, 6, 8, 10&#125;;float B[5] = &#123;1.1, 2.4, 3.7, 6.2, 9.5&#125;;char C[5] = &#123;&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;&#125;; You can initialize without assigning data, it will be 0. And you can initialize without length, it will give it a size automatically. 12int A[5] = &#123;2, 4&#125;; // A = &#123;2, 4, 0, 0, 0&#125;;int B[] = &#123;1, 2, 4, 6&#125; // B = &#123;1, 2, 4, 6&#125;; Array Declarations Declare the array without initialization. 123456789int A[5];for (int i = 0; i &lt; 5; i++) cout &lt;&lt; A[i] &lt;&lt; endl;====OUTPUT====0000-487864256 If you assign more data than array length, it will have the compile error. For example, int A[5] = &#123;2, 4, 6, 8, 10, 12&#125;;. For each loop. 123int A[6] = &#123;2, 4, 6, 8, 10, 12&#125;;for (int x : A) cout &lt;&lt; x &lt;&lt; endl; You can use auto to specify the type automatically. 123float A[] = &#123;2.5f, 5.6f, 9, 8, 7&#125;;for (auto x : A) cout &lt;&lt; x &lt;&lt; endl; If you don’t want to specify automatically, you can specify the type by yourself. For example, you can specify int to read char, it will show the ASCII code of char. 12345678char A[] = &#123;&#x27;A&#x27;, 66, &#x27;C&#x27;, 68&#125;;for (auto x : A) cout &lt;&lt; x &lt;&lt; endl;====OUTPUT====ABCD 12345678char A[] = &#123;&#x27;A&#x27;, 66, &#x27;C&#x27;, 68&#125;;for (int x : A) cout &lt;&lt; x &lt;&lt; endl;====OUTPUT====65666768 For Each loop You can use pointer to change the original value in the array by for each loop. 123int A[] = &#123;8, 6, 3, 9, 7, 4&#125;;for (auto &amp;x : A) cout &lt;&lt; ++x &lt;&lt; endl; Nested Loops If you want to working on matrixes, it will use nested loops. For example. 12345for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; cout &lt;&lt; i &lt;&lt; j &lt;&lt; endl; &#125;&#125; Multidimensional Array Multidimensional array can initialize may ways. If you don’t specify the value, it will be zero. 123int A[2][3] = &#123; &#123;2, 5, 9&#125;, &#123;6, 9, 15&#125; &#125;;int A[2][3] = &#123;2, 5, 9, 6, 9, 15&#125;;int A[2][3] = &#123;2, 5&#125; print all value in the multidimensional array. 12345678int A[3][4] = &#123; &#123;2, 5, 9&#125;, &#123;6, 9, 15&#125; &#125;;for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; cout &lt;&lt; A[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; Use for each to print out the multidimensional array. 12345678int A[2][3] = &#123;2, 4, 6, 3, 5, 7&#125;;for (auto&amp; x : A) &#123; for (auto&amp; y : x) &#123; cout &lt;&lt; y &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; Add two matrixes. 123456789101112131415int A[2][3] = &#123; &#123;2, 5, 9&#125;, &#123;7, 3, 6&#125; &#125;;int B[2][3] = &#123; &#123;6, 3, 4&#125;, &#123;9, 5, 2&#125; &#125;;int C[2][3];for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; C[i][j] = A[i][j] + B[i][j]; &#125;&#125;for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; cout &lt;&lt; C[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125; Disclaimer I took this course from Udemy, which is Learn C++ Programming -Beginner to Advance- Deep Dive in C++. I only took some notes of this amazing course for my personal future uses and share my thoughts with my peers. If you like it, you should take the course from Udemy too.","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://vincent.fishboneapps.com/tags/C/"}]},{"title":"C++ Learning Journey Day2","slug":"C-Learning-Journey-Day2","date":"2021-10-01T07:25:53.000Z","updated":"2021-10-03T22:15:10.214Z","comments":true,"path":"2021/10/01/C-Learning-Journey-Day2/","link":"","permalink":"https://vincent.fishboneapps.com/2021/10/01/C-Learning-Journey-Day2/","excerpt":"","text":"Section 5: C++ Basics Compound Assignment +=, -=, *=, /=, %=. &amp;=, |=, &lt;&lt;=, &gt;&gt;=. example 12345678910int a = 10, b = 5, c = 15;int sum;sum = sum + a + b + c;// simplifysum += a + b + c;int prod = 1;prod = prod * a * b * c;// simplifyprod *= a * b * c; Increment and Decrement Operators pre increment ++x; post increment x++; pre decrement --x; post decrement x–; Pre increment add value to variable first, then execute the others. Post increment execute the assignment, then add value to variable. pre increment. 1234567int x = 5, y;y = ++x;// x = 6cout &lt;&lt; x;// y = 6cout &lt;&lt; y; post increment 1234567int x = 5, y;y = x++;// x = 6cout &lt;&lt; x;// y = 5cout &lt;&lt; y; Complicated example. 1234567int x = 5, y = 10, z;// x = 5, y = 10, z = 50z = x++ * y;// x = 6, y = 10, z = 60z = ++x * y; Overflow Overflow is if a value is more than the capacity, it will take the values from the beginning. For example, char x = 127;, x++;, then the x will become -128. Bitwise Operators &amp; and. | or. ^ X-OR. ~ not. &lt;&lt; shift left. &gt;&gt; shift right. Example. 123456789101112int x = 11, y = 7, z;// 00001011 &amp; 00000111 = 00000011 (3)z = x &amp; y;cout &lt;&lt; z &lt;&lt; endl;// 00001011 | 00000111 = 00001111 (15)z = x | y;// 00001011 ^ 00000111 = 00001100 (12)z = x | y;cout &lt;&lt; z &lt;&lt; endl; Shift example. If x shift i left x &lt;&lt; i, the result is $x*2^i$. On the contrary, if x shift i right x &gt;&gt; i, the result is $\\frac{x}{2^i}$. 123456789char x = 20, y;// 00010100 -&gt; 00101000 (40)y = x &lt;&lt; 1;cout &lt;&lt; int(y) &lt;&lt; endl;// 00010100 -&gt; 00001010 (10)y = x &gt;&gt; 1;cout &lt;&lt; int(y) &lt;&lt; endl; Enum and Typedef If you have a set of words, you want to use them efficiently. You can use enum to make these words as the constant numbers. You can even assign the number to the constant. If you don’t assign the number, enum will add one from the previous one to the current word. Here is the example. 12345678910111213141516171819202122232425262728enum day &#123;mon = 1, tue = 7, wed, thu = 10, fri, sat, sun&#125;;enum dept &#123;cs = 1, it, ec, mech&#125;;int main()&#123; dept dep = cs; cout &lt;&lt; dep &lt;&lt; endl; cout &lt;&lt; mon &lt;&lt; endl; cout &lt;&lt; tue &lt;&lt; endl; cout &lt;&lt; wed &lt;&lt; endl; cout &lt;&lt; thu &lt;&lt; endl; cout &lt;&lt; fri &lt;&lt; endl; cout &lt;&lt; sat &lt;&lt; endl; cout &lt;&lt; sun &lt;&lt; endl; return 0;&#125;====OUTPUT====117810111213 typedef is used for making variable readable. You can define the variables by yourself. For example, you can know m1 means marks and it is int type. 1234567891011typedef int marks;int main()&#123; marks m1, m2; m1 = 50; m2 = 90; return 0;&#125; Section 6 Conditional Statement - if Relational Operators &lt; &lt;= &gt; &gt;= == != Practice Problem: Finding Maximum of 2 Numbers Example. 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main()&#123; int x, y; cout &lt;&lt; &quot;Enter 2 numbers&quot; &lt;&lt; endl; cin &gt;&gt; x &gt;&gt; y; if (x &gt; y) &#123; cout &lt;&lt; &quot;Max is &quot; &lt;&lt; x &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;Max is &quot; &lt;&lt; y &lt;&lt; endl; &#125; return 0;&#125; Logical Operators &amp;&amp; AND || OR ! NOT Nested if Example: Find the max of 3 numbers. 1234567891011int a,b, c;cout &lt;&lt; &quot;Enter 3 numbers&quot;;cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;if (a &gt; b &amp;&amp; a &gt; c) &#123; cout &lt;&lt; a;&#125; else if (b &gt; c) &#123; cout &lt;&lt; b;&#125; else &#123; cout &lt;&lt; c;&#125; else if ladder Example 1234567891011121314151617181920int day;cout &lt;&lt; &quot;Enter day number&quot;;cin &gt;&gt; day;if (day == 1) &#123; cout &lt;&lt; &quot;sun&quot;;&#125; else if (day == 2) &#123; cout &lt;&lt; &quot;mon&quot;;&#125; else if (day == 3) &#123; cout &lt;&lt; &quot;tue&quot;;&#125; else if (day == 4) &#123; cout &lt;&lt; &quot;wed&quot;;&#125; else if (day == 5) &#123; cout &lt;&lt; &quot;thu&quot;;&#125; else if (day == 6) &#123; cout &lt;&lt; &quot;fri&quot;;&#125; else if (day == 7) &#123; cout &lt;&lt; &quot;sat&quot;;&#125; else &#123; cout &lt;&lt; &quot;Invalid Day Input&quot;;&#125; short circuit If the logical operator is AND in the statement and the first one is false, the second condition will not be executed since the result will always be false. If the logical operator is OR in the statement and the first one is true, the second condition will not be executed since the result will always be true. 1234567int a = 15, b = 7, i = 6;if (a &lt; b &amp;&amp; ++i &lt;= b) &#123;&#125;cout &lt;&lt; i &lt;&lt; endl;====OUTPUT====6 Dynamic Declaration The variables inside the if block will be removed from the memory after the statement is executed. After the C++ 17, you can declare the variable in the IF statement if you don’t want to use it after you ran the if code block. 1234int a;if (int k = exp; k &lt; a) &#123; expression;&#125; For loop is as same as the IF statement. 12345for (int i = 0; i &lt; 10; i ++) &#123; expression;&#125;// The following line can&#x27;t be executed.// cout &lt;&lt; i; You can put the variable inside another code block, then the variable can’t be read outside the code block. 12345678910int a = 10, b = 5;&#123; int c = a + b; if (c &gt; 10) &#123; &#125;&#125;// The following line can&#x27;t be executed.cout &lt;&lt; c &lt;&lt; endl; Switch Case - Branch and Control Example. Using Switch is faster than if else ladder, it jumps to the case directly. 123456789101112131415161718192021222324252627int day;cout &lt;&lt; &quot;Enter day number&quot;;cin &gt;&gt; day;switch (day) &#123; case 1: cout &lt;&lt; &quot;sun&quot;; break; case 2: cout &lt;&lt; &quot;mon&quot;; break; case 3: cout &lt;&lt; &quot;tue&quot;; break; case 4: cout &lt;&lt; &quot;wed&quot;; break; case 5: cout &lt;&lt; &quot;thu&quot;; break; case 6: cout &lt;&lt; &quot;fri&quot;; break; case 7: cout &lt;&lt; &quot;sat&quot;; break;&#125; Disclaimer I took this course from Udemy, which is Learn C++ Programming -Beginner to Advance- Deep Dive in C++. I only took some notes of this amazing course for my personal future uses and share my thoughts with my peers. If you like it, you should take the course from Udemy too.","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://vincent.fishboneapps.com/tags/C/"}]},{"title":"C++ Learning Journey Day1","slug":"C-Learning-Journey-Day1","date":"2021-09-20T13:13:42.000Z","updated":"2021-10-03T22:13:46.672Z","comments":true,"path":"2021/09/20/C-Learning-Journey-Day1/","link":"","permalink":"https://vincent.fishboneapps.com/2021/09/20/C-Learning-Journey-Day1/","excerpt":"","text":"Section 2: Essential Fundamentals How computer works? CPU have two parts, ALU(Arithmetic Logic Unit) and CU(Control Unit). A computer can perform arithmetic operations like +, -, *, / and logical operations like &gt;, &lt;, =, AND, OR, NOT. Hard Drive has program files and data files. If you type data into computer, it will put into buffer, not directly use in the program; also the output has buffer, the data will put into output buffer before showing on the screen. So it’s the communication point for the device and a programming running inside the memory. What is a program? Natural Language -&gt; Programming Language -&gt; Machine Language. When you transform Programming Language to Machine Language, you need Compiler or Interpreter. Low-Level v.s. High-Level Language Low-Level Language is the Machine Language, it’s the binary system. We can’t understand it. Assembly Language is easier than Machine Language, it can be learned, practiced and used for writing the program. However, it’s still the Low-Level Language and it’s very difficult for learning. High-Level Language: C, C++, Java, Python, C#, VB, VC++… Compiler v.s. Interpreter Both do these things. Check Errors - syntax error Convert into Machine Code The third step: Execution. Compiler don’t have the responsibility for execution, but Interpreter involved. If we create the first.cpp file, you will get the first.exe file after you compile it. Then, you don’t need Compiler anymore, you can execute first.exe as many time as you want. The first difference between them is Interpreter won’t create exe file. The second difference between them is Compiler just translate it and it won’t execute. However, Interpreter will translate as well as execute. The third difference between them is after Compile compile the file, you can execute whenever you want. However, Interpreter need to translate every time they run. So if n times you are executing then n times translation will be done. Compiling Programs are faster because they’re independent as a separate program, but Interpreter Language is easy to write. Section 3: Program Development Programming paradigms/Methodologies Programming Paradigm Monolithic Programming: Write everything in only one file. Modular / Procedural Programming: Remove the duplicated code and make function to reuse these code. One benefit is you can share the functions with other projects and other programmers. Second, team work can work, functions can be developed individually. Modular programming has data. In C language, you can group data using structure and process data in functions. Object-oriented Programming: Put the data and functions related to these data together and defined as a class. Aspect-oriented/Component Assembly Programming: Talk in the OOP section. What is an Algorithm Algorithm: You can write the Pseudo-code to perform the algorithm. Program: You need to follow the syntax to write the program. Example: find average of list of elements. Algorithm 12345678910Algorithm Average(List, n)&#123; sum &lt;- o; for each element x in List Begin sum &lt;- sum + x; End; avg &lt;- sum / n; return avg;&#125; Program 12345678910float Average(int L&#123;&#125;, int n)&#123; float sum = 0.0; for (i = 0; i &lt; n; i++) &#123; sum = sum + L&#123;i&#125;; &#125; float avg = sum / n; return avg;&#125; What is a FlowChart FlowChart is used for showing the flow of control of a program. Steps for Program Development and Execution Editing Compiling LKinking Library Loading Execution: Stack of memory is used for variable creation and code section of memory is used for program itself. Heap of memory is used for dynamic memory allocation. Section 4: Compiler and IDE Setup Practice C++ online Compiler Online compiler link. You can use the following code to test. 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; int x, y, z; cout &lt;&lt; &quot;Enter 2 numbers&quot;; cin &gt;&gt; x &gt;&gt; y; z = x + y; cout &lt;&lt; &quot;Sum is &quot; &lt;&lt; z; return 0;&#125; Setup Xcode Install Xcode in the App Store. New Project -&gt; set name and start working. Left sidebar has a start button to run the code. Section 5: C++ Basics Skeleton of C++ Program iostream is a library. int is the main function return type. cout can print value on the screen. If you don’t want to use using namespace std;, you need to add std in front of cout as std::cout. 12345678910#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; &quot;Hello World&quot;; return 0;&#125; Writing My First Program Every program has three elements: Input, Process, Output. Add two number’s program. 12345678910111213#include &lt;iostream&gt;using namespace std;int main()&#123; int a, b, c; cout &lt;&lt; &quot;Enter 2 numbers&quot;; cin &gt;&gt; a &gt;&gt; b; c = a + b; cout &lt;&lt; &quot;Sum is &quot; &lt;&lt; c; return 0;&#125; Get the name and give welcome message. Use getline to get the whole line stead of a word. 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; string name; cout &lt;&lt; &quot;May I know your name&quot;; getline(cin, name); cout &lt;&lt; &quot;Hello &quot; &lt;&lt; name; return 0;&#125; Why Data Types Data Numeric Integer Floating Character/Alphabetic String Primitive Data Types Data Types Primitive Integral int char Bool Floating Point float double UserDefined enum structure union class Derived Array Pointer Reference Data Type Size Data Type Size Range int 2 or 4 -32768 to 32676 float 4 $-3.4\\times10^{-38}$ to $3.4\\times10^{38}$ double 8 $-1.7\\times10^{-308}$ to $1.7\\times10^{308}$ char 1 -128 to 127 bool undefined true/false Modifier unsigned unsigned integer, range is 0-65535 unsigned char, range is 0-255 long long int, 4 bytes / 8 bytes long double, 10 bytes Variables You must declare variable before you use it. If you want to declare float, better to add f after the decimal number. Allowed and not-allowed variables. √ int x1; x int 1x; √ int rollno; x int roll no; √ int roll_no; √ int rollNo; √ int RollNo; Arithmetic Operators and Expressions Arithmetic - +, -, *, /, % % gets the remainder of two numbers. We can’t perform % on the float number. We can perform % to char, using ASCII code do the calculation. Relational - &lt;, &lt;=, &gt;, &gt;=, == Logical - &amp;&amp;, ||, ! Bitwise - &amp;, |, ~, ^ Increment/Decrement - ++, – Assignment - = Operator Precedence &amp; Expressions Highest precedence will calculate first. Operator Assumed Precedence ( ) 3 *, /, % 2 +, - 1 Program using Expression Calculate Triangle Area. 12345678910111213#include &lt;iostream&gt;using namespace std;int main()&#123; float b, h, a; cout &lt;&lt; &quot;Enter base &amp; height&quot;; cin &gt;&gt; b &gt;&gt; h; a = (b * h) / 2; cout &lt;&lt; &quot;Area is &quot; &lt;&lt; a;&#125; Practice Problem: Sum of First N Natural Numbers Formula: n * (n + 1) / 2 12345678910111213#include &lt;iostream&gt;using namespace std;int main()&#123; int n, sum; cout &lt;&lt; &quot;Enter n&quot;; cin &gt;&gt; n; sum = n * (n + 1) / 2; cout &lt;&lt; &quot;Sum is &quot; &lt;&lt; sum; return 0;&#125; Practice Problem: Roots of Quadratic Equations Formula: $ax^2 + bx + c = 0$ $r = \\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}$ Program 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; float a, b, c, r1, r2; cout &lt;&lt; &quot;Enter a, b, c&quot;; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; r1 = (-b + sqrt( b * b - 4 * a * c)) / (2 * a); r2 = (-b - sqrt( b * b - 4 * a * c)) / (2 * a); cout &lt;&lt; &quot;Roots are &quot; &lt;&lt; r1 &lt;&lt; &quot; &quot; &lt;&lt; r2; return 0;&#125;====EXECUTE====4 8 4====OUTPUT====Roots are -1 -1 Demo - Expression Find the circle area. 123456789101112131415#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; float r, area; cout &lt;&lt; &quot;Enter Radius&quot;; cin &gt;&gt; r; area = 3.1425f * r * r; cout &lt;&lt; &quot;Area is &quot; &lt;&lt; area &lt;&lt; endl; return 0;&#125; Find the speed. 12345678910111213141516#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int u, v, a; float speed; cout &lt;&lt; &quot;Enter 3 numbers&quot;; cin &gt;&gt; u &gt;&gt; v &gt;&gt; a; speed = (v * v - u * u) / (2 * a); cout &lt;&lt; &quot;Speed is &quot; &lt;&lt; speed &lt;&lt; endl; return 0;&#125; Disclaimer I took this course from Udemy, which is Learn C++ Programming -Beginner to Advance- Deep Dive in C++. I only took some notes of this amazing course for my personal future uses and share my thoughts with my peers. If you like it, you should take the course from Udemy too.","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://vincent.fishboneapps.com/tags/C/"}]},{"title":"Golang 快速學習自我挑戰 Day13","slug":"Golang-快速學習自我挑戰-Day13","date":"2021-09-13T12:59:37.000Z","updated":"2021-09-19T23:10:44.288Z","comments":true,"path":"2021/09/13/Golang-快速學習自我挑戰-Day13/","link":"","permalink":"https://vincent.fishboneapps.com/2021/09/13/Golang-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day13/","excerpt":"","text":"第十三章：Functions, Pointers 和 Addressability 學習 Function 的基礎 Function 用 func 這個 keyword，init 和 main 是特殊名字，不用在 Function 的名字使用它們。 一個 Function 可以有零到多個輸入參數，func sum(a int, b int) &#123;&#125; 和 func sum(a, b int) &#123;&#125; 是一樣的。 如果你不需要回傳任何內容，最後一行直接加上 return 就可以了，return 可以立刻讓 Function 停止和終止。 回傳參數的設置 func name(inputParams) (resultParams) &#123;&#125;，resultParams 就是回傳的結果。在實際場景中，最佳的實踐是，回傳的最後一個參數設置為 error。 如果回傳參數只有一個，就不要放到括號裡面 func name(inputParams) singleParam &#123;&#125;。 使用 Function 只會複製本來的變數，而不會覆蓋本來的變數，比方說輸入變數有 a，在 Function 內經過改變之後，再回傳 a，也不會改變到外部調用 Function 之前的 a，回傳出來的結果會複製到新的變數上。 呼叫不同檔案裡的 Function，如果執行 go run main.go 會出現錯誤，要使用 go run . 執行目錄下所有的 go 檔案，並須要使用 go mod init 來新增 go.mod 檔案才能正常執行。而在全局的地方使用 N 變數是最差的實踐，因為所有的 package main 都可以使用這個變數，被誰改變了都不知道。 main.go 1234567891011package main// N is a package level variable// It belongs to the main packagevar N intfunc main() &#123; incrN() incrN() showN()&#125; bad.go 1234567891011121314package mainimport &quot;fmt&quot;func showN() &#123; if N == 0 &#123; return &#125; fmt.Printf(&quot;showN : N is %d\\n&quot;, N)&#125;func incrN() &#123; N++&#125; 對 Function 限制變數 在上個段落，在全局使用 N 變數會很難除錯。解決方案就是盡可能新增更多的變數在局部的 Function。 使用局部變數的範例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package mainimport ( &quot;fmt&quot; &quot;strconv&quot;)func main() &#123; local := 10 show(local) incrWrong(local) fmt.Printf(&quot;main -&gt; local = %d\\n&quot;, local) local = incr(local) fmt.Printf(&quot;local = %d\\n&quot;, local) local = incrBy(local, 5) show(local) _, err := incrByStr(local, &quot;TWO&quot;) if err != nil &#123; fmt.Printf(&quot;err -&gt; %s\\n&quot;, err) &#125; local, _ = incrByStr(local, &quot;2&quot;) show(local) show(incrBy(local, 2)) show(local) // show(incrByStr(local, &quot;2&quot;)) local = sanitize(incrByStr(local, &quot;2&quot;)) show(local) local = limit(incrBy(local, 5), 500) show(local)&#125;func show(n int) &#123; fmt.Printf(&quot;show -&gt; n = %d\\n&quot;, n)&#125;func incrWrong(n int) &#123; // n := main&#x27;s local variable&#x27;s value n++&#125;func incr(n int) int &#123; // n := main&#x27;s local variable&#x27;s value n++ return n&#125;func incrBy(n, factor int) int &#123; return n * factor&#125;func incrByStr(n int, factor string) (int, error) &#123; m, err := strconv.Atoi(factor) n = incrBy(n, m) return n, err&#125;func sanitize(n int, err error) int &#123; if err != nil &#123; return 0 &#125; return n&#125;func limit(n, lim int) (m int) &#123; // var m int m = n if m &gt;= lim &#123; m = lim &#125; return // equals to: return m&#125; 使用 Function 重構 Log 解析器 使用動詞來找到獨特的責任：Functions。 Log Parser 範例。 main.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package mainimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;os&quot; &quot;sort&quot; &quot;strings&quot;)func main() &#123; p := newParser() // Scan the standard-in line by line in := bufio.NewScanner(os.Stdin) for in.Scan() &#123; p.lines++ parsed, err := parse(p, in.Text()) if err != nil &#123; fmt.Println(err) return &#125; domain, visits := parsed.domain, parsed.visits // Collect the unique domains if _, ok := p.sum[domain]; !ok &#123; p.domains = append(p.domains, domain) &#125; // Keep track of total and per domain visits p.total += visits // create and assign a new copy of `visit` p.sum[domain] = result&#123; domain: domain, visits: visits + p.sum[domain].visits, &#125; &#125; // Print the visits per domain sort.Strings(p.domains) fmt.Printf(&quot;%-30s %10s\\n&quot;, &quot;DOMAIN&quot;, &quot;VISITS&quot;) fmt.Println(strings.Repeat(&quot;-&quot;, 45)) for _, domain := range p.domains &#123; parsed := p.sum[domain] fmt.Printf(&quot;%-30s %10d\\n&quot;, domain, parsed.visits) &#125; // Print the total visits for all domains fmt.Printf(&quot;\\n%-30s %10d\\n&quot;, &quot;TOTAL&quot;, p.total) // Let&#x27;s handle the error if err := in.Err(); err != nil &#123; fmt.Println(&quot;&gt; Err:&quot;, err) &#125;&#125; parser.go 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( &quot;fmt&quot; &quot;strconv&quot; &quot;strings&quot;)// result stores the parsed result for a domaintype result struct &#123; domain string visits int // add more metrics if needed&#125;// parser keep tracks of the parsingtype parser struct &#123; sum map[string]result // metrics per domain domains []string // unique domain names total int // total visits for all domains lines int // number of parsed lines (for the error messages)&#125;// newParser constructs, initializes and returns a new parserfunc newParser() parser &#123; return parser&#123;sum: make(map[string]result)&#125;&#125;// parse() parses a log line and returns the parsed result with an errorfunc parse(p parser, line string) (parsed result, err error) &#123; fields := strings.Fields(line) if len(fields) != 2 &#123; err = fmt.Errorf(&quot;wrong input: %v (line #%d)&quot;, fields, p.lines) return &#125; parsed.domain = fields[0] parsed.visits, err = strconv.Atoi(fields[1]) if parsed.visits &lt; 0 || err != nil &#123; err = fmt.Errorf(&quot;wrong input: %q (line #%d)&quot;, fields[1], p.lines) return &#125; return&#125; 學習 Pass By Value Go 使用 Pass By Value 的方式，只要有經過 Function 就會複製一個新的變數，但是 Map 是指向記憶體位置的，所以如果 Map 變更，其它指向同一個地方的 Map 也會跟著變更資料。 所以只要有傳送到 Function 的變數一定要 return 回來，才能取得變數。 Log Parser 優化。 main.go 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;os&quot; &quot;sort&quot; &quot;strings&quot;)func main() &#123; p := newParser() // Scan the standard-in line by line in := bufio.NewScanner(os.Stdin) for in.Scan() &#123; p.lines++ parsed, err := parse(p, in.Text()) if err != nil &#123; fmt.Println(err) return &#125; p = update(p, parsed) &#125; // Print the visits per domain sort.Strings(p.domains) fmt.Printf(&quot;%-30s %10s\\n&quot;, &quot;DOMAIN&quot;, &quot;VISITS&quot;) fmt.Println(strings.Repeat(&quot;-&quot;, 45)) for _, domain := range p.domains &#123; parsed := p.sum[domain] fmt.Printf(&quot;%-30s %10d\\n&quot;, domain, parsed.visits) &#125; // Print the total visits for all domains fmt.Printf(&quot;\\n%-30s %10d\\n&quot;, &quot;TOTAL&quot;, p.total) // Let&#x27;s handle the error if err := in.Err(); err != nil &#123; fmt.Println(&quot;&gt; Err:&quot;, err) &#125;&#125; parser.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package mainimport ( &quot;fmt&quot; &quot;strconv&quot; &quot;strings&quot;)// result stores the parsed result for a domaintype result struct &#123; domain string visits int // add more metrics if needed&#125;// parser keep tracks of the parsingtype parser struct &#123; sum map[string]result // metrics per domain domains []string // unique domain names total int // total visits for all domains lines int // number of parsed lines (for the error messages)&#125;// newParser constructs, initializes and returns a new parserfunc newParser() parser &#123; return parser&#123;sum: make(map[string]result)&#125;&#125;// parse() parses a log line and returns the parsed result with an errorfunc parse(p parser, line string) (parsed result, err error) &#123; fields := strings.Fields(line) if len(fields) != 2 &#123; err = fmt.Errorf(&quot;wrong input: %v (line #%d)&quot;, fields, p.lines) return &#125; parsed.domain = fields[0] parsed.visits, err = strconv.Atoi(fields[1]) if parsed.visits &lt; 0 || err != nil &#123; err = fmt.Errorf(&quot;wrong input: %q (line #%d)&quot;, fields[1], p.lines) return &#125; return&#125;func update(p parser, parsed result) parser &#123; domain, visits := parsed.domain, parsed.visits // Collect the unique domains if _, ok := p.sum[domain]; !ok &#123; p.domains = append(p.domains, domain) &#125; // Keep track of total and per domain visits p.total += visits // create and assign a new copy of `visit` p.sum[domain] = result&#123; domain: domain, visits: visits + p.sum[domain].visits, &#125; return p&#125; 什麼是 Pointer？ Pointer 會儲存值的記憶體位置。 &amp; 可以找到地址，* 可以找到值， *Type 表示 Pointer 的類型。 var counter byte = 100，P := &amp;counter，這邊可以知道 P 的型別是 *byte，V := *P，V 的型別會是 byte。 如果寫 V = 200，V 會直接變成 200。 如果 counter 等於 100，寫 P := &amp;counter、counter++，取得 *P 的值，會是 101。 如果 counter 等於 100，寫 P := &amp;counter、*P = 25，取得 counter 的值，就會是 25。 總結 var P *byte：*Type 表示 Pointer 的類型。 &amp;counter：&amp; 可以找到地址。 *P：* 可以找到值。 P 的型別就是 *byte，counter 的型別就是 byte。 每一種型別都有對應的 Pointer 型別。 byte -&gt; *byte int -&gt; *int struct { n bool } -&gt; *struct { n bool } 學習 Pointer 的機制 Function 會新增新的 Pointer 變數來指向同樣的位置。這個新增的 Pointer 在 runtime 不會被刪除，只有執行完畢之後，確認不會再使用才會被永久刪除。 範例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package mainimport &quot;fmt&quot;func main() &#123; var ( counter int V int P *int ) counter = 100 P = &amp;counter V = *P fmt.Printf(&quot;counter: %-13d addr: %-13p\\n&quot;, counter, &amp;counter) fmt.Printf(&quot;P : %-13p addr: %-13p *P: %-13d\\n&quot;, P, &amp;P, *P) fmt.Printf(&quot;V : %-13d addr: %-13p\\n&quot;, V, &amp;V) fmt.Println(&quot;\\n.... change counter&quot;) counter = 10 fmt.Printf(&quot;counter: %-13d addr: %-13p\\n&quot;, counter, &amp;counter) fmt.Println(&quot;\\n.... change counter in passVal()&quot;) counter = passVal(counter) fmt.Printf(&quot;counter: %-13d addr: %-13p\\n&quot;, counter, &amp;counter) fmt.Println(&quot;\\n.... change counter in passPtrVal()&quot;) passPtrVal(&amp;counter) passPtrVal(&amp;counter) passPtrVal(&amp;counter) fmt.Printf(&quot;counter: %-13d addr: %-13p\\n&quot;, counter, &amp;counter)&#125;func passVal(n int) int &#123; n = 50 fmt.Printf(&quot;n : %-13d addr: %-13p\\n&quot;, n, &amp;n) return n&#125;func passPtrVal(pn *int) &#123; fmt.Printf(&quot;pn : %-13p addr: %-13p *pn: %-13d\\n&quot;, pn, &amp;pn, *pn) *pn++ fmt.Printf(&quot;pn : %-13p addr: %-13p *pn: %-13d\\n&quot;, pn, &amp;pn, *pn) // It doesn&#x27;t affect the counter. // pn = nil&#125;====OUTPUT====counter: 100 addr: 0xc0000b2008 P : 0xc0000b2008 addr: 0xc0000ac018 *P: 100 V : 100 addr: 0xc0000b2010 .... change countercounter: 10 addr: 0xc0000b2008 .... change counter in passVal()n : 50 addr: 0xc0000b2018 counter: 50 addr: 0xc0000b2008 .... change counter in passPtrVal()pn : 0xc0000b2008 addr: 0xc0000ac028 *pn: 50 pn : 0xc0000b2008 addr: 0xc0000ac028 *pn: 51 pn : 0xc0000b2008 addr: 0xc0000ac030 *pn: 51 pn : 0xc0000b2008 addr: 0xc0000ac030 *pn: 52 pn : 0xc0000b2008 addr: 0xc0000ac038 *pn: 52 pn : 0xc0000b2008 addr: 0xc0000ac038 *pn: 53 counter: 53 addr: 0xc0000b2008 學習如何在 Composite Types 使用 Pointer Slice Header 已經有指向 backing Array 的 Pointer，所以不需要對 Slice 使用 Pointer 來改變 element。 在實務上，不要使用 Pointer 來指向 Slice。 跟 Slice 一樣，Map 的值已經是一個 Pointer 了，所以不要對 Map 使用 Pointer。 範例可以看到 Map 也不能取得 element 的地址，因為 Go runtime 是不能更改 Map element 的地址的。另外，在儲存的時候地址會是連續的，這樣存取的效率會很好。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() &#123; fmt.Println(&quot;... ARRAYS&quot;) arrays() fmt.Println(&quot;... SLICES&quot;) slices() fmt.Println(&quot;... MAPS&quot;) maps() fmt.Println(&quot;... STRUCTS&quot;) structs()&#125;type house struct &#123; name string rooms int&#125;func structs() &#123; myHouse := house&#123;name: &quot;My house&quot;, rooms: 5&#125; addRoom(myHouse) //fmt.Printf(&quot;%+v\\n&quot;, myHouse) fmt.Printf(&quot;structs() : %p %+v\\n&quot;, &amp;myHouse, myHouse) addRoomPtr(&amp;myHouse) fmt.Printf(&quot;structs() : %p %+v\\n&quot;, &amp;myHouse, myHouse)&#125;func addRoom(h house) &#123; h.rooms++ fmt.Printf(&quot;structs() : %p %+v\\n&quot;, &amp;h, h)&#125;func addRoomPtr(h *house) &#123; h.rooms++ // same: (*h).rooms++ fmt.Printf(&quot;addRoomPtr() : %p %+v\\n&quot;, h, h) fmt.Printf(&quot;&amp;myHouse.name() : %p\\n&quot;, &amp;h.name) fmt.Printf(&quot;&amp;myHouse.rooms(): %p\\n&quot;, &amp;h.rooms)&#125;func maps() &#123; confused := map[string]int&#123;&quot;one&quot;: 2, &quot;two&quot;: 1&#125; fix(confused) fmt.Println(confused) // &amp;confused[&quot;one&quot;]&#125;func fix(m map[string]int) &#123; m[&quot;one&quot;] = 1 m[&quot;two&quot;] = 2 m[&quot;three&quot;] = 3&#125;func slices() &#123; dirs := []string&#123;&quot;up&quot;, &quot;down&quot;, &quot;left&quot;, &quot;right&quot;&#125; up(dirs) fmt.Printf(&quot;slices list : %p %q\\n&quot;, &amp;dirs, dirs) upPtr(&amp;dirs) fmt.Printf(&quot;slices list : %p %q\\n&quot;, &amp;dirs, dirs)&#125;func up(list []string) &#123; for i := range list &#123; list[i] = strings.ToUpper(list[i]) fmt.Printf(&quot;up.list[%d] : %p\\n&quot;, i, &amp;list[i]) &#125; list = append(list, &quot;HEISEN BUG&quot;) fmt.Printf(&quot;up list : %p %q\\n&quot;, &amp;list, list)&#125;func upPtr(list *[]string) &#123; lv := *list for i := range lv &#123; lv[i] = strings.ToUpper(lv[i]) &#125; *list = append(*list, &quot;HEISEN BUG&quot;) fmt.Printf(&quot;up list : %p %q\\n&quot;, list, list)&#125;func arrays() &#123; nums := [...]int&#123;1, 2, 3&#125; incr(nums) fmt.Printf(&quot;array nums : %p\\n&quot;, &amp;nums) fmt.Println(nums) incrByPtr(&amp;nums) fmt.Println(nums)&#125;func incr(nums [3]int) &#123; fmt.Printf(&quot;incr nums : %p\\n&quot;, &amp;nums) for i := range nums &#123; nums[i]++ fmt.Printf(&quot;up.list[%d] : %p\\n&quot;, i, &amp;nums[i]) &#125;&#125;func incrByPtr(nums *[3]int) &#123; fmt.Printf(&quot;incrByPtr nums : %p\\n&quot;, &amp;nums) for i := range nums &#123; nums[i]++ &#125;&#125;====OUTPUT====... ARRAYSincr nums : 0xc0000b6018up.list[0] : 0xc0000b6018up.list[1] : 0xc0000b6020up.list[2] : 0xc0000b6028array nums : 0xc0000b6000[1 2 3]incrByPtr nums : 0xc0000ac020[2 3 4]... SLICESup.list[0] : 0xc0000b0040up.list[1] : 0xc0000b0050up.list[2] : 0xc0000b0060up.list[3] : 0xc0000b0070up list : 0xc0000a4030 [&quot;UP&quot; &quot;DOWN&quot; &quot;LEFT&quot; &quot;RIGHT&quot; &quot;HEISEN BUG&quot;]slices list : 0xc0000a4018 [&quot;UP&quot; &quot;DOWN&quot; &quot;LEFT&quot; &quot;RIGHT&quot;]up list : 0xc0000a4018 &amp;[&quot;UP&quot; &quot;DOWN&quot; &quot;LEFT&quot; &quot;RIGHT&quot; &quot;HEISEN BUG&quot;]slices list : 0xc0000a4018 [&quot;UP&quot; &quot;DOWN&quot; &quot;LEFT&quot; &quot;RIGHT&quot; &quot;HEISEN BUG&quot;]... MAPSmap[one:1 three:3 two:2]... STRUCTSstructs() : 0xc0000a40c0 &#123;name:My house rooms:6&#125;structs() : 0xc0000a40a8 &#123;name:My house rooms:5&#125;addRoomPtr() : 0xc0000a40a8 &amp;&#123;name:My house rooms:6&#125;&amp;myHouse.name() : 0xc0000a40a8&amp;myHouse.rooms(): 0xc0000a40b8structs() : 0xc0000a40a8 &#123;name:My house rooms:6&#125; 使用 Pointer 重構 Log 解析器 如果不需要修改值的 func 就不需要使用 Pointer。 修改後的內容。 main.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;os&quot; &quot;sort&quot; &quot;strings&quot;)func main() &#123; p := newParser() // Scan the standard-in line by line in := bufio.NewScanner(os.Stdin) for in.Scan() &#123; parsed, err := parse(&amp;p, in.Text()) if err != nil &#123; fmt.Println(err) return &#125; update(&amp;p, parsed) &#125; summarize(p) // Let&#x27;s handle the error if err := in.Err(); err != nil &#123; fmt.Println(&quot;&gt; Err:&quot;, err) &#125;&#125;func summarize(p parser) &#123; // Print the visits per domain sort.Strings(p.domains) fmt.Printf(&quot;%-30s %10s\\n&quot;, &quot;DOMAIN&quot;, &quot;VISITS&quot;) fmt.Println(strings.Repeat(&quot;-&quot;, 45)) for _, domain := range p.domains &#123; parsed := p.sum[domain] fmt.Printf(&quot;%-30s %10d\\n&quot;, domain, parsed.visits) &#125; // Print the total visits for all domains fmt.Printf(&quot;\\n%-30s %10d\\n&quot;, &quot;TOTAL&quot;, p.total)&#125; parser.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package mainimport ( &quot;fmt&quot; &quot;strconv&quot; &quot;strings&quot;)// result stores the parsed result for a domaintype result struct &#123; domain string visits int // add more metrics if needed&#125;// parser keep tracks of the parsingtype parser struct &#123; sum map[string]result // metrics per domain domains []string // unique domain names total int // total visits for all domains lines int // number of parsed lines (for the error messages)&#125;// newParser constructs, initializes and returns a new parserfunc newParser() parser &#123; return parser&#123;sum: make(map[string]result)&#125;&#125;// parse() parses a log line and returns the parsed result with an errorfunc parse(p *parser, line string) (parsed result, err error) &#123; p.lines++ fields := strings.Fields(line) if len(fields) != 2 &#123; err = fmt.Errorf(&quot;wrong input: %v (line #%d)&quot;, fields, p.lines) return &#125; parsed.domain = fields[0] parsed.visits, err = strconv.Atoi(fields[1]) if parsed.visits &lt; 0 || err != nil &#123; err = fmt.Errorf(&quot;wrong input: %q (line #%d)&quot;, fields[1], p.lines) return &#125; return&#125;func update(p *parser, parsed result) &#123; domain, visits := parsed.domain, parsed.visits // Collect the unique domains if _, ok := p.sum[domain]; !ok &#123; p.domains = append(p.domains, domain) &#125; // Keep track of total and per domain visits p.total += visits // create and assign a new copy of `visit` p.sum[domain] = result&#123; domain: domain, visits: visits + p.sum[domain].visits, &#125;&#125; 這邊有一個問題，比方說要修改 visits 的值，使用 p.sum[domain].visits += visits 是不能使用的，因為 &amp;p.sum[domain] 是Map element，是不能取得地址的。但是如果我使用 clone := p.sum[domain]，然後使用 &amp;clone 是可以取得地址的，因為 clone 是複製 Map element 裡面的內容所產生的新東西，它是 addressable value（你可以找到他的地址）。 要使用 Pointer 還是 Value？要一致。 範例裡面，parser 的 struct 都使用 Pointer，就要全部改用 Pointer，result 的 struct 都不使用 Pointer 就全部不使用 Pointer。 main.go 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( &quot;bufio&quot; &quot;fmt&quot; &quot;os&quot; &quot;sort&quot; &quot;strings&quot;)func main() &#123; p := newParser() // Scan the standard-in line by line in := bufio.NewScanner(os.Stdin) for in.Scan() &#123; parsed := parse(p, in.Text()) update(p, parsed) &#125; summarize(p) dumpErr([]error&#123;in.Err(), err(p)&#125;)&#125;func dumpErr(errs []error) &#123; for _, err := range errs &#123; if err != nil &#123; fmt.Println(&quot;&gt; Err:&quot;, err) &#125; &#125;&#125;func summarize(p *parser) &#123; // Print the visits per domain sort.Strings(p.domains) fmt.Printf(&quot;%-30s %10s\\n&quot;, &quot;DOMAIN&quot;, &quot;VISITS&quot;) fmt.Println(strings.Repeat(&quot;-&quot;, 45)) for _, domain := range p.domains &#123; fmt.Printf(&quot;%-30s %10d\\n&quot;, domain, p.sum[domain].visits) &#125; // Print the total visits for all domains fmt.Printf(&quot;\\n%-30s %10d\\n&quot;, &quot;TOTAL&quot;, p.total)&#125; parser.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package mainimport ( &quot;fmt&quot; &quot;strconv&quot; &quot;strings&quot;)// result stores the parsed result for a domaintype result struct &#123; domain string visits int // add more metrics if needed&#125;// parser keep tracks of the parsingtype parser struct &#123; sum map[string]result // metrics per domain domains []string // unique domain names total int // total visits for all domains lines int // number of parsed lines (for the error messages) lerr error&#125;// newParser constructs, initializes and returns a new parserfunc newParser() *parser &#123; return &amp;parser&#123;sum: make(map[string]result)&#125;&#125;// parse() parses a log line and returns the parsed result with an errorfunc parse(p *parser, line string) (r result) &#123; if p.lerr != nil &#123; return &#125; p.lines++ fields := strings.Fields(line) if len(fields) != 2 &#123; p.lerr = fmt.Errorf(&quot;wrong input: %v (line #%d)&quot;, fields, p.lines) return &#125; var err error r.domain = fields[0] r.visits, err = strconv.Atoi(fields[1]) if r.visits &lt; 0 || err != nil &#123; p.lerr = fmt.Errorf(&quot;wrong input: %q (line #%d)&quot;, fields[1], p.lines) return &#125; return&#125;func update(p *parser, r result) &#123; if p.lerr != nil &#123; return &#125; // Collect the unique domains if _, ok := p.sum[r.domain]; !ok &#123; p.domains = append(p.domains, r.domain) &#125; // Keep track of total and per domain visits p.total += r.visits // create and assign a new copy of `visit` p.sum[r.domain] = result&#123; domain: r.domain, visits: r.visits + p.sum[r.domain].visits, &#125;&#125;func err(p *parser) error &#123; return p.lerr&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://vincent.fishboneapps.com/tags/Golang/"}]},{"title":"Golang 快速學習自我挑戰 Day12","slug":"Golang-快速學習自我挑戰-Day12","date":"2021-08-21T15:44:32.000Z","updated":"2021-08-31T05:57:37.712Z","comments":true,"path":"2021/08/21/Golang-快速學習自我挑戰-Day12/","link":"","permalink":"https://vincent.fishboneapps.com/2021/08/21/Golang-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day12/","excerpt":"","text":"第十二章：Structs：Encode 和 Decode JSON 什麼是 Struct？ Struct 就像 blueprint。 Struct 就像 OOP 語言裡面的 class。 Struct 可以將相關的資料組裝成一個單一型別。 Struct 在 compile-time 是固定的，所以在 runtime 的時候不能新增 field。 Struct 可儲存不同型別的資料。 Struct fields 在 compile-time 被宣告，而 Struct 值在 runtime 的時候填入。Field 的名字和型別在 compile-time 就被宣告，所以他們在 runtime 的時候是固定而不能改變的。然而，Field 值是屬於 runtime 的，你可以在 runtime 的時候改變它。 總結 Slice &amp; Map Struct Element 只有單一型別 Fields 有不同型別 動態的 Elements 數量 固定的 Fields 數量 Struct 範例 1234567891011type VideoGame struct &#123; Title string Genre string Published bool&#125;pacman := VideoGame&#123; Title: &quot;Pac-Man&quot;, Genre: &quot;Arcade Game&quot;, Published: true,&#125; 建立一個 Struct 建立 Struct 可以有很多方式，可以直接使用 short declaration 或是用 var 定義 Struct。使用 short declaration 最好加上 field name 以避免新增 Struct 的時候，程式碼有問題，如果不加上 field name，會按照默認順序去讀取。 1234567891011121314151617181920212223242526package mainimport &quot;fmt&quot;func main() &#123; type person struct &#123; name, lastname string age int &#125; picasso := person&#123; name: &quot;Pablo&quot;, lastname: &quot;Picasso&quot;, age: 91, &#125; var freud person freud.name = &quot;sigmund&quot; freud.lastname = &quot;Freud&quot; freud.age = 83 fmt.Printf(&quot;\\nPicasso: %#v\\n&quot;, picasso) fmt.Printf(&quot;Freud : %#v\\n&quot;, freud)&#125; 什麼時候可以比較 Struct 的值？ Struct 是 bare value 的型別，就跟 Array 一樣。Struct 不像 Slice 有 backing Array，所以當你複製 Struct 的時候，它會一個一個的複製它的 field。在比較的時候，Go 會一個一個比較 field，如果 field 都一樣，那比較結果就會是一樣的，這邊要注意，type 必須相同才能做比較。 Struct 可以直接進行比較。 12345678910111213141516package mainimport &quot;fmt&quot;func main() &#123; song1 := song&#123;title: &quot;wonderwall&quot;, artist: &quot;oasis&quot;&#125; song2 := song&#123;title: &quot;super sonic&quot;, artist: &quot;oasis&quot;&#125; fmt.Printf(&quot;song1: %+v\\nsong2: %+v\\n&quot;, song1, song2) if song1 == song2 &#123; fmt.Println(&quot;songs are equal.&quot;) &#125; else &#123; fmt.Println(&quot;songs are not equal.&quot;) &#125;&#125; Struct 最好定義在 package 這一層，這樣就可以隨時使用。Struct 裡面如果有不能比較的型別，比方說 Slice、Map 或是 function value，那這個 Struct 就不能進行比較。看到下面的結果就知道在 for 迴圈裡面，s 是複製出來的，並不會變更到本來的 struct 的內容。 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport &quot;fmt&quot;type song struct &#123; title, artist string&#125;type playlist struct &#123; genre string songs []song&#125;func main() &#123; songs := []song&#123; &#123;title: &quot;wonderwall&quot;, artist: &quot;oasis&quot;&#125;, &#123;title: &quot;super sonic&quot;, artist: &quot;oasis&quot;&#125;, &#125; rock := playlist&#123;genre: &quot;indie rock&quot;, songs: songs&#125; rock.songs[0].title = &quot;live forever&quot; fmt.Printf(&quot;%-20s %20s\\n&quot;, &quot;TITLE&quot;, &quot;ARTIST&quot;) for _, s := range rock.songs &#123; s.title = &quot;destroy&quot; fmt.Printf(&quot;%-20s %20s\\n&quot;, s.title, s.artist) &#125; fmt.Printf(&quot;%-20s %20s\\n&quot;, &quot;TITLE&quot;, &quot;ARTIST&quot;) for _, s := range rock.songs &#123; fmt.Printf(&quot;%-20s %20s\\n&quot;, s.title, s.artist) &#125;&#125;====OUTPUT====TITLE ARTISTdestroy oasisdestroy oasisTITLE ARTISTlive forever oasissuper sonic oasis Go OOP：Struct Embedding Go 不使用繼承(Inheritance)，Go 使用 Embedding。 這邊有兩個魔術方法，第一、如果欄位是匿名的，它會從它的 type 取得它的名字。第二，可以直接用 moby.words 取得下層的同名的值，等同於 ``moby.text.words`，但是如果剛好名稱有衝突的，會優先取得 parent type 的值。 1234567891011121314151617181920212223242526272829303132package mainimport &quot;fmt&quot;func main() &#123; type text struct &#123; title string words int &#125; type book struct &#123; text isbn string title string &#125; moby := book&#123; text: text&#123;title: &quot;moby dick&quot;, words: 206052&#125;, isbn: &quot;102030&quot;, &#125; moby.text.words = 1000 moby.words++ fmt.Printf(&quot;%s has %d words (isbn: %s)\\n&quot;, moby.text.title, moby.words, moby.isbn) fmt.Printf(&quot;%#v\\n&quot;, moby)&#125;====OUTPUT==== has 1001 words (isbn: 102030)main.book&#123;text:main.text&#123;title:&quot;moby dick&quot;, words:1001&#125;, isbn:&quot;102030&quot;, title:&quot;&quot;&#125; 將值編碼為 JSON 使用 Marshal 語法可以直接編寫成 JSON 格式，語法的第一個參數是 empty interface，代表你可以傳送任何型態的值給它。而 json 套件只編碼輸出的欄位，輸出的欄位的首字母必須要是大寫才能輸出。可以直接使用 go run main.go &gt; users.json 將回傳的 JSON 直接存到檔案。field 標籤是 Struct 型別的一部份，它們是 compile-time 的常數，用來關聯 field 固定的 string metadata，大部分是用來控制編碼和解碼的行為，傳統來說，它有 key 和 value，json 就是 key 的名字，用來表示套件的名稱，這邊只有 json 的套件會讀取這個標籤，而 perms,omitempty 是 json 的 value，用逗點來區隔，第一個用來改變欄位編碼的名稱，第二個是如果 field 為 zero-value 的時候省略這個 field。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( &quot;encoding/json&quot; &quot;fmt&quot;)type permissions map[string]booltype user struct &#123; Name string `json:&quot;username&quot;` Password string `json:&quot;-&quot;` Permissions permissions `json:&quot;perms,omitempty&quot;`&#125;func main() &#123; users := []user&#123; &#123;&quot;inanc&quot;, &quot;1234&quot;, nil&#125;, &#123;&quot;god&quot;, &quot;42&quot;, permissions&#123;&quot;admin&quot;: true&#125;&#125;, &#123;&quot;devil&quot;, &quot;666&quot;, permissions&#123;&quot;admin&quot;: true&#125;&#125;, &#125; out, err := json.MarshalIndent(users, &quot;&quot;, &quot;\\t&quot;) if err != nil &#123; fmt.Println(err) return &#125; fmt.Println(string(out))&#125;====OUTPUT====[ &#123; &quot;username&quot;: &quot;inanc&quot; &#125;, &#123; &quot;username&quot;: &quot;god&quot;, &quot;perms&quot;: &#123; &quot;admin&quot;: true &#125; &#125;, &#123; &quot;username&quot;: &quot;devil&quot;, &quot;perms&quot;: &#123; &quot;admin&quot;: true &#125; &#125;] 從 JSON 解碼值 &amp; 會找到值的記憶體位置，後面會說更多關於 pointer 的話題。使用 Unmarshal 就可以解碼 JSON 的內容。 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( &quot;bufio&quot; &quot;encoding/json&quot; &quot;fmt&quot; &quot;os&quot;)type user struct &#123; Name string `json:&quot;username&quot;` Permissions map[string]bool `json:&quot;perms&quot;`&#125;func main() &#123; var input []byte for in := bufio.NewScanner(os.Stdin); in.Scan(); &#123; input = append(input, in.Bytes()...) &#125; var users []user err := json.Unmarshal(input, &amp;users) if err != nil &#123; fmt.Println(err) return &#125; fmt.Println(users) for _, user := range users &#123; fmt.Print(&quot;+ &quot;, user.Name) switch p := user.Permissions; &#123; case p == nil: fmt.Print(&quot; has no power.&quot;) case p[&quot;admin&quot;]: fmt.Print(&quot; is an admin.&quot;) case p[&quot;write&quot;]: fmt.Print(&quot; can write.&quot;) &#125; fmt.Println() &#125;&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://vincent.fishboneapps.com/tags/Golang/"}]},{"title":"Golang 快速學習自我挑戰 Day11","slug":"Golang-快速學習自我挑戰-Day11","date":"2021-08-18T09:57:38.000Z","updated":"2021-08-22T04:35:50.039Z","comments":true,"path":"2021/08/18/Golang-快速學習自我挑戰-Day11/","link":"","permalink":"https://vincent.fishboneapps.com/2021/08/18/Golang-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day11/","excerpt":"","text":"第五章：Slices 和 Internal 完整的 Slice 表達式：限制 Slice 的 capacity newSlice := sliceable[START:STOP:CAP]，CAP 可以限制回傳的 Slice capacity。 stop position &lt;= capacity position，停止的位置必定小於等於 capacity 的位置。 123456789sliceable := []byte&#123;&#x27;f&#x27;, &#x27;u&#x27;, &#x27;l&#x27;, &#x27;l&#x27;&#125;sliceable[0:3] - len: 3, cap: 4sliceable[0:3:3] - len: 3, cap: 3sliceable[0:2:2] - len: 2, cap: 2sliceable[0:1:1] - len: 1, cap: 1sliceable[1:3:3] - len: 2, cap: 2sliceable[2:3:3] - len: 1, cap: 1sliceable[2:3:4] - len: 1, cap: 2sliceable[4:4:4] - len: 0, cap: 0 如果在 odds 設定 nums[:2] 然後 append 數字上去之後，本來的 Array 會被取代，因為共享同一個 backing Array，這時候限制 capacity 之後，它就會生成新的 Array。而 evens 因為 capacity slice 之後就只有 2 了，所以不需要定義 capacity 就一樣會生成新的 Array。 123456789101112131415161718192021222324252627282930313233package mainimport ( s &quot;github.com/inancgumus/prettyslice&quot;)func main() &#123; s.PrintBacking = true nums := []int&#123;1, 3, 2, 4&#125; odds := append(nums[:2:2], 5, 7) evens := append(nums[2:4], 6, 8) s.Show(&quot;nums&quot;, nums) s.Show(&quot;odds&quot;, odds) s.Show(&quot;evens&quot;, evens)&#125;====OUTPUT====nums (len:4 cap:4 ptr:3840)╔═══╗╔═══╗╔═══╗╔═══╗║ 1 ║║ 3 ║║ 2 ║║ 4 ║╚═══╝╚═══╝╚═══╝╚═══╝ 0 1 2 3 odds (len:4 cap:4 ptr:3872)╔═══╗╔═══╗╔═══╗╔═══╗║ 1 ║║ 3 ║║ 5 ║║ 7 ║╚═══╝╚═══╝╚═══╝╚═══╝ 0 1 2 3 evens (len:4 cap:4 ptr:3904)╔═══╗╔═══╗╔═══╗╔═══╗║ 2 ║║ 4 ║║ 6 ║║ 8 ║╚═══╝╚═══╝╚═══╝╚═══╝ 0 1 2 3 make()：預分配位置給 backing Array make 初始化並回傳一個指定長度和 capacity 的 Slice。如果使用一直使用 append 會非常耗能，所以如果提前知道大小，先指定好，會更有效率。 make(type, length, capacity)，最常使用的方式就是 s := make([]int, 0, 5)，直接指定一個變數給它，後面只需要直接 append()，s = append(s, 42)。 這是沒有效率的方式，因為指定了好幾次不同的記憶體位置。 123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( s &quot;github.com/inancgumus/prettyslice&quot; &quot;strings&quot;)func main() &#123; s.PrintBacking = true s.MaxPerLine = 10 tasks := []string&#123;&quot;jump&quot;, &quot;run&quot;, &quot;read&quot;&#125; var upTasks []string s.Show(&quot;upTasks&quot;, upTasks) for _, task := range tasks &#123; upTasks = append(upTasks, strings.ToUpper(task)) s.Show(&quot;upTasks&quot;, upTasks) &#125;&#125;====OUTPUT====upTasks (len:0 cap:0 ptr:0 )&lt;nil slice&gt;upTasks (len:1 cap:1 ptr:5872)╔══════╗║ JUMP ║╚══════╝ 0 upTasks (len:2 cap:2 ptr:7424)╔══════╗╔═════╗║ JUMP ║║ RUN ║╚══════╝╚═════╝ 0 1 upTasks (len:3 cap:4 ptr:9136)╔══════╗╔═════╗╔══════╗+--+║ JUMP ║║ RUN ║║ READ ║| |╚══════╝╚═════╝╚══════╝+--+ 0 1 2 3 使用 make() 改寫，就會指向同一個 backing Array 了。 123456789101112131415161718192021package mainimport ( s &quot;github.com/inancgumus/prettyslice&quot; &quot;strings&quot;)func main() &#123; s.PrintBacking = true s.MaxPerLine = 10 tasks := []string&#123;&quot;jump&quot;, &quot;run&quot;, &quot;read&quot;&#125; upTasks := make([]string, 0, len(tasks)) s.Show(&quot;upTasks&quot;, upTasks) for _, task := range tasks &#123; upTasks = append(upTasks, strings.ToUpper(task)) s.Show(&quot;upTasks&quot;, upTasks) &#125;&#125; copy()：在 Slices 之間複製 elements copy(destination Slice, source Slice)，來源 Slice 和目標 Slice 的型別必須相同，而複製 elements 是基於長度最小的 Slice 來複製，而最後 copy() 回傳的是幾個 element 被複製了。 如果你用比較少的 element copy 到目標 Slice，它就只會複製少的那一個，比方說，把 99 和 100 複製到本來的 data，只有前面兩個有改變，如果來源 element 比較多，那就只會複製目標有的 element 數量，比方說，把 10, 5, 15, 0, 20 複製到只有 4 個 element 的 data，就只有四個會改變，而不會增加長度。如果需要增加長度要用 append 的方式，也可以用 make() 之後再 copy() 來新增 Slice，但是用 append() 更好一些，因為看起來比較精簡。 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( &quot;fmt&quot; s &quot;github.com/inancgumus/prettyslice&quot;)func main() &#123; data := []float64&#123;10, 25, 30, 50&#125; copy(data, []float64&#123;99, 100&#125;) //saved := make([]float64, len(data)) //copy(saved, data) saved := append([]float64(nil), data...) n := copy(data, []float64&#123;10, 5, 15, 0, 20&#125;) fmt.Printf(&quot;%d probabilities copied.\\n&quot;, n) s.Show(&quot;Probabilities (saved)&quot;, saved) s.Show(&quot;Probabilities (data)&quot;, data) fmt.Printf(&quot;Is it gonna rain? %.f%% chance.\\n&quot;, (data[0]+data[1]+data[2]+data[3])/float64(len(data)))&#125;====OUTPUT====4 probabilities copied.Probabilities (saved) (len:4 cap:4 ptr:912 )╔════╗╔═════╗╔════╗╔════╗║ 99 ║║ 100 ║║ 30 ║║ 50 ║╚════╝╚═════╝╚════╝╚════╝ 0 1 2 3 Probabilities (data) (len:4 cap:4 ptr:880 )╔════╗╔═══╗╔════╗╔═══╗║ 10 ║║ 5 ║║ 15 ║║ 0 ║╚════╝╚═══╝╚════╝╚═══╝ 0 1 2 3 Is it gonna rain? 8% chance. 如何使用 multi-dimensional Slice？ 基本上就跟 multi-dimensional Array 一樣，這邊實現計算每天的花費總和。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( &quot;fmt&quot; &quot;strconv&quot; &quot;strings&quot;)func main() &#123; spendings := fetch() for i, daily := range spendings &#123; var total int for _, spending := range daily &#123; total += spending &#125; fmt.Printf(&quot;Day %d: %d\\n&quot;, i+1, total) &#125;&#125;func fetch() [][]int &#123; content := `200 10025 10 45 605 15 3595 1050 25` lines := strings.Split(content, &quot;\\n&quot;) spendings := make([][]int, len(lines)) for i, line := range lines &#123; fields := strings.Fields(line) spendings[i] = make([]int, len(fields)) for j, field := range fields &#123; spending, _ := strconv.Atoi(field) spendings[i][j] = spending &#125; &#125; return spendings&#125; 第十章：Maps 和 Internal 創建一個英文和土耳其語的 dictionary Maps 允許我們更快使用 unique key 去存取資料。 先使用一般的方式來做查詢，裡面就會有 O(n) 的演算法，在資料越來越多的情況下，速度就會大幅下降。 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; args := os.Args[1:] if len(args) != 1 &#123; fmt.Println(&quot;[english word] -&gt; [turkish word]&quot;) return &#125; query := args[0] english := []string&#123;&quot;good&quot;, &quot;great&quot;, &quot;perfect&quot;&#125; turkish := []string&#123;&quot;iyi&quot;, &quot;harika&quot;, &quot;mükemmel&quot;&#125; for i, w := range english &#123; if query == w &#123; fmt.Printf(&quot;%q means %q\\n&quot;, w, turkish[i]) return &#125; &#125; fmt.Printf(&quot;%q not found\\n&quot;, query)&#125; Key 和 Value 的型別不需要相同，他們可以不同。一個 Map key 必須要是可以比較的型別，比方說：map[int]bool int 就是可以比較的型別，而如果 map[[]float64]bool []float64 就是不能比較的型別，Slice、Map 和 function values 都是不能比較的型別。另外不要使用 float 型別當作 Map key，因為結果會不準確。如果新增 Map 的話，Map 裡面有重複的 key 就會覆蓋，如果沒有重複的 key 就會新增。在取得 Map 的時候，可以增加第二個參數，來確定 Map 裡面是否有資料，如果有資料就會回傳 true。另外 Map 是用來快速查找的，不要用 loop 來取得資料，如果想要用 loop，Slice 會是更好的選項。從 Go 1.12 版本之後，Map 會自動排序，所以 Map 可以進行比較。 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; args := os.Args[1:] if len(args) != 1 &#123; fmt.Println(&quot;[english word] -&gt; [turkish word]&quot;) return &#125; query := args[0] dict := map[string]string&#123; &quot;good&quot;: &quot;kötü&quot;, &quot;great&quot;: &quot;harika&quot;, &quot;perfect&quot;: &quot;mükemmel&quot;, &#125; dict[&quot;good&quot;] = &quot;iyi&quot; dict[&quot;up&quot;] = &quot;yukarı&quot; dict[&quot;down&quot;] = &quot;aşağı&quot; dict[&quot;mistake&quot;] = &quot;&quot; copied := map[string]string&#123;&quot;down&quot;:&quot;aşağı&quot;, &quot;good&quot;:&quot;iyi&quot;, &quot;great&quot;:&quot;harika&quot;, &quot;mistake&quot;:&quot;&quot;, &quot;perfect&quot;:&quot;mükemmel&quot;, &quot;up&quot;:&quot;yukarı&quot;&#125; first := fmt.Sprintf(&quot;%s&quot;, dict) second := fmt.Sprintf(&quot;%s&quot;, copied) if first == second &#123; fmt.Println(&quot;Maps are equal.&quot;) &#125; if value, ok := dict[query]; ok &#123; fmt.Printf(&quot;%q means %#v\\n&quot;, query, value) return &#125; fmt.Printf(&quot;%q not found\\n&quot;, query) fmt.Printf(&quot;# of keys: %d\\n&quot;, len(dict))&#125; Map Internal：Map 實際在後面是如何運作的？ Map Header 跟 Slice 一樣，你新增之後，它會一樣指向同一個記憶體位置，所以如果改了其中一個的 value，兩個都會改。跟 Slice 不同的地方是，Map 只有包含記憶體的位址，然後會指向一個 Map Header，這個 Header 裡面包含了很多複雜且可以移動部分的資料類型。 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; args := os.Args[1:] if len(args) != 1 &#123; fmt.Println(&quot;[english word] -&gt; [turkish word]&quot;) return &#125; query := args[0] dict := map[string]string&#123; &quot;good&quot;: &quot;iyi&quot;, &quot;great&quot;: &quot;harika&quot;, &quot;perfect&quot;: &quot;mükemmel&quot;, &#125; turkish := dict turkish[&quot;good&quot;] = &quot;güzel&quot; dict[&quot;great&quot;] = &quot;kusursuz&quot; fmt.Printf(&quot;english: %q\\nturkish: %q\\n&quot;, dict, turkish) if value, ok := dict[query]; ok &#123; fmt.Printf(&quot;%q means %#v\\n&quot;, query, value) return &#125; fmt.Printf(&quot;%q not found\\n&quot;, query) fmt.Printf(&quot;# of keys: %d\\n&quot;, len(dict))&#125;====OUTPUT====english: map[&quot;good&quot;:&quot;güzel&quot; &quot;great&quot;:&quot;kusursuz&quot; &quot;perfect&quot;:&quot;mükemmel&quot;]turkish: map[&quot;good&quot;:&quot;güzel&quot; &quot;great&quot;:&quot;kusursuz&quot; &quot;perfect&quot;:&quot;mükemmel&quot;]&quot;perfect&quot; means &quot;mükemmel&quot; 使用 make() 複製 Map，第二個參數指定的 length 就是個指示，讓 Go 知道什麼時候去增加 Map 更合適，但是實際的 Map 長度會是 0。delete(mapValue, key) 可以刪除指定 Map 的 key，而且你可以重複一直使用 delete() 不管 key 存在與否。如果使用 dict = nil 來刪除 Map 裡面所有的 key，看起來是刪除了，事實上他只是指向別的位置，Map 並沒有真正消失，要用 for loop 來刪除才能真正刪除。下面的範例，將土耳其語再翻譯回去英文，用 make() 來實現。 123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; args := os.Args[1:] if len(args) != 1 &#123; fmt.Println(&quot;[english word] -&gt; [turkish word]&quot;) return &#125; query := args[0] dict := map[string]string&#123; &quot;good&quot;: &quot;iyi&quot;, &quot;great&quot;: &quot;harika&quot;, &quot;perfect&quot;: &quot;mükemmel&quot;, &quot;awesome&quot;: &quot;mükemmel&quot;, &#125; // delete all // for k := range dict &#123; // delete(dict, k) // &#125; turkish := make(map[string]string, len(dict)) for k, v := range dict &#123; turkish[v] = k &#125; if value, ok := turkish[query]; ok &#123; fmt.Printf(&quot;%q means %#v\\n&quot;, query, value) return &#125; if value, ok := dict[query]; ok &#123; fmt.Printf(&quot;%q means %#v\\n&quot;, query, value) return &#125; fmt.Printf(&quot;%q not found\\n&quot;, query) fmt.Printf(&quot;# of keys: %d\\n&quot;, len(dict))&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://vincent.fishboneapps.com/tags/Golang/"}]},{"title":"Golang 快速學習自我挑戰 Day10","slug":"Golang-快速學習自我挑戰-Day10","date":"2021-08-15T06:16:49.000Z","updated":"2021-08-21T05:21:19.770Z","comments":true,"path":"2021/08/15/Golang-快速學習自我挑戰-Day10/","link":"","permalink":"https://vincent.fishboneapps.com/2021/08/15/Golang-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day10/","excerpt":"","text":"第五章：Slices 和 Internal 什麼是 Slice header？ 如果一個 Slice 沒有儲存任何 elements，那它裡面包含什麼？Slice 裡面包含記憶體位置用來指向 backing Array。 Slice header 裡面包含三個內容，Pointer(記憶體位置)、Length(長度) 和 Capacity(空間大小，儲存記憶體實際佔用的大小，你可以使用 cap() 來取得 Capacity 的值)。 Slice 就等同於 Slice Header，它是小型的資料結構，裡面包含它的 backing Array。 ages := []int&#123;35, 15, 25&#125; 它的 Slice Header 就包含 Pointer = 48、Length = 3 和 Capacity = 3。 如果使用 ages[0:1] 減少 Slice 之後，它的 Pointer 還是 48，Length 會變成 1，而 Capacity 還是 3 。 如果使用 ages[1:3] 減少 Slice 之後，它的 Pointer 會是 56，Length 會變成 2，而 Capacity 會變成 2，因為 Slice 不能往回看，所以 Pointer 和 Capacity 都會改變 。 nil Slice 沒有 backing Array，但是它還是有 Slice Header，它的 Slice Header 會是 Pointer = 0、Length = 0 和 Capacity = 0，如果你不知道 Slice 有沒有任何 elements，先 declare 它為一個 nil Slice。 Slice Header 在 Go 的 runtime 程式碼看起來是怎麼樣的？ 你會發現本來的 data 沒有被改變，因為使用 func 會把變數複製過去，看到 output 的位址是兩個不同的位置，所以它們兩個是不同的 Array。 123456789101112131415161718192021222324252627282930313233package mainimport ( s &quot;github.com/inancgumus/prettyslice&quot;)type collection [4]stringfunc main() &#123; s.PrintElementAddr = true data := collection&#123;&quot;slices&quot;, &quot;are&quot;, &quot;awesome&quot;, &quot;period&quot;&#125; change(data) s.Show(&quot;main&#x27;s data&quot;, data)&#125;func change(data collection) &#123; data[2] = &quot;brilliant!&quot; s.Show(&quot;change&#x27;s data&quot;, data)&#125;====OUTPUT====change&#x27;s data ╔════════════════════════════════╗║ [slices are brilliant! period] ║╚════════════════════════════════╝ 0 8192 main&#x27;s data ╔═════════════════════════════╗║ [slices are awesome period] ║╚═════════════════════════════╝ 0 8960 如果將 Array 改成 Slice 就會發現 data 的結果是一樣的，因為 Slice 被複製之後，backing Array 的資料仍然是一樣的，可以使用 &amp;data 取得 Slice 的位置，會發現 Slice 位置不一樣，因為這邊有兩個 Slice 但是都是同一個 backing Array。 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( &quot;fmt&quot; s &quot;github.com/inancgumus/prettyslice&quot;)type collection []stringfunc main() &#123; s.PrintElementAddr = true data := collection&#123;&quot;slices&quot;, &quot;are&quot;, &quot;awesome&quot;, &quot;period&quot;&#125; change(data) s.Show(&quot;main&#x27;s data&quot;, data) fmt.Printf(&quot;main&#x27;s data slice address: %p\\n&quot;, &amp;data)&#125;func change(data collection) &#123; data[2] = &quot;brilliant!&quot; s.Show(&quot;change&#x27;s data&quot;, data) fmt.Printf(&quot;changes&#x27;s data slice address: %p\\n&quot;, &amp;data)&#125;====OUTPUT==== change&#x27;s data (len:4 cap:4 ptr:1392)╔════════╗╔═════╗╔════════════╗╔════════╗║ slices ║║ are ║║ brilliant! ║║ period ║╚════════╝╚═════╝╚════════════╝╚════════╝ 0 1 2 3 1392 1408 1424 1440 changes&#x27;s data slice address: 0xc00011e018main&#x27;s data (len:4 cap:4 ptr:1392)╔════════╗╔═════╗╔════════════╗╔════════╗║ slices ║║ are ║║ brilliant! ║║ period ║╚════════╝╚═════╝╚════════════╝╚════════╝ 0 1 2 3 1392 1408 1424 1440 main&#x27;s data slice address: 0xc00011e000 這邊你會看到 Slice 的長度都是固定的，因為它裡面只有 Slice Header，而 Array 則直接儲存資料，大小和 element 的多寡相關。 12345678910111213141516171819202122232425package mainimport ( &quot;fmt&quot; &quot;unsafe&quot;)type collection []stringfunc main() &#123; data := collection&#123;&quot;slices&quot;, &quot;are&quot;, &quot;awesome&quot;, &quot;period&quot;&#125; array := [...]string&#123;&quot;slices&quot;, &quot;are&quot;, &quot;awesome&quot;, &quot;period&quot;&#125; fmt.Printf(&quot;array&#x27;s size: %d bytes\\n&quot;, unsafe.Sizeof(array)) fmt.Printf(&quot;slice&#x27;s size: %d bytes\\n&quot;, unsafe.Sizeof(data)) data2 := collection&#123;&quot;slices&quot;, &quot;are&quot;, &quot;awesome&quot;, &quot;period&quot;, &quot;!&quot;&#125; array2 := [...]string&#123;&quot;slices&quot;, &quot;are&quot;, &quot;awesome&quot;, &quot;period&quot;, &quot;!&quot;&#125; fmt.Printf(&quot;array&#x27;s size: %d bytes\\n&quot;, unsafe.Sizeof(array2)) fmt.Printf(&quot;slice&#x27;s size: %d bytes\\n&quot;, unsafe.Sizeof(data2))&#125;====OUTPUT====array&#x27;s size: 64 bytesslice&#x27;s size: 24 bytesarray&#x27;s size: 80 bytesslice&#x27;s size: 24 bytes Slice 總結： Slice 非常高效且便宜。 Slicing：會新增一個新的 Slice Header。 Assign 一個 Slice 到另一個 Slice，或是將 Slice 傳到一個 function：只會複製 Slice Header。 Slice Header 有固定 Size，就算你有上百萬個 elements，它也不會改變。 所以 Array 非常昂貴，assign 或是 pass Array 到 function 會複製所有的 elements。 什麼是 Slice 的 capacity？ nil Slice 沒有任何 backing Array，所以它的 capacity 是 0。 ages := []int&#123;35, 15, 25&#125;，這個 Slice Literal 有 3 個 elements，所以它會創建有 3 個 elements 的 Array。 capacity 就是關於 backing Array 的長度和 Slice 從哪裡開始。 由 Slice Literal 創建的 Slice 會有相同的 len 和 cap。 ages[0:0]，空的 Slice 的長度是 0，但是它的 backing Array 有 3 個 elements，所以它的 capacity 是 3。如果 capacity 不是 0 的情況下，可以再使用 ages[0:3] 來 extend 並取得本來的 Slice，也可以使用 ages[0, cap(ages)]，會得到一樣的東西。在這邊要注意的是，不能使用 ages[0:cap(ages) + 1]，因為你不能 extend 一個超過它自己 capacity 的 Slice。 Capacity 就是 backing Array slice 之後的第一個 item 的長度。例如：ages[1:3] 的 capacity 就是 2。 ages[3:3] 是空的 Slice 但是它有 backing Array，長度為 0。這邊有意思的地方是，它的 Pointer 的位置是完整 Slice 的第一個位置，就算它知道 Slice 的位置，Go 也不能夠透過 ages[0:3] 來取得完整的 Slice，因為 capacity 等於 0。 如果你失去了原本的 Slice Header，你就不能 extend 回來了。 使用 capacity 來 Extend Slice 如果定義一個 nil 的 Slice，那麼它的地址就是 0。如果你定義空的 Slice，不管你定義了幾個，在同一個 runtime 都會指向同一個地址，而且使用相同的 Array。part[:0] 會得空的 Slice，使用 part[:cap(part)] 就可以完整還原 Slice 了。覆寫 part 會和原來的 part 共享相同的 backing Array，for 迴圈這一段就是一直縮減到沒有為止，就可以觀察到他們是相同的 backing Array。如果不修改 games 的話，後面 games 還是會有值，因為更改 part 不會更改到 games，這就是 Slice 強大的地方，使用 games = games[len(games):] 就會讓 games 和 part 一樣是空的 Slice，如此一來，games 和 part 再也不能夠 extend 回來本來的 Slice，這也是為什麼在前面同時定義了 games 和 part 了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package mainimport ( s &quot;github.com/inancgumus/prettyslice&quot;)type collection []stringfunc main() &#123; s.PrintBacking = true var games []string s.Show(&quot;games&quot;, games) games = []string&#123;&#125; s.Show(&quot;games&quot;, games) s.Show(&quot;another empty&quot;, []int&#123;&#125;) games = []string&#123;&quot;pacman&quot;, &quot;mario&quot;, &quot;tetris&quot;, &quot;doom&quot;&#125; s.Show(&quot;games&quot;, games) part := games s.Show(&quot;part&quot;, part) part = games[:0] s.Show(&quot;part[:0]&quot;, part) s.Show(&quot;part[:cap]&quot;, part[:cap(part)]) for cap(part) != 0 &#123; part = part[1:cap(part)] s.Show(&quot;part&quot;, part) &#125; games = games[len(games):] s.Show(&quot;games&quot;, games) s.Show(&quot;part&quot;, part)&#125;====OUTPUT====games (len:0 cap:0 ptr:0 )&lt;nil slice&gt;games (len:0 cap:0 ptr:4976)&lt;empty slice&gt;another empty (len:0 cap:0 ptr:4976)&lt;empty slice&gt;games (len:4 cap:4 ptr:9136)╔════════╗╔═══════╗╔════════╗╔══════╗║ pacman ║║ mario ║║ tetris ║║ doom ║╚════════╝╚═══════╝╚════════╝╚══════╝ 0 1 2 3 part (len:4 cap:4 ptr:9136)╔════════╗╔═══════╗╔════════╗╔══════╗║ pacman ║║ mario ║║ tetris ║║ doom ║╚════════╝╚═══════╝╚════════╝╚══════╝ 0 1 2 3 part[:0] (len:0 cap:4 ptr:9136)&lt;empty slice&gt;+--------++-------++--------++------+| pacman || mario || tetris || doom |+--------++-------++--------++------+ 0 1 2 3 part[:cap] (len:4 cap:4 ptr:9136)╔════════╗╔═══════╗╔════════╗╔══════╗║ pacman ║║ mario ║║ tetris ║║ doom ║╚════════╝╚═══════╝╚════════╝╚══════╝ 0 1 2 3 part (len:3 cap:3 ptr:9152)╔═══════╗╔════════╗╔══════╗║ mario ║║ tetris ║║ doom ║╚═══════╝╚════════╝╚══════╝ 0 1 2 part (len:2 cap:2 ptr:9168)╔════════╗╔══════╗║ tetris ║║ doom ║╚════════╝╚══════╝ 0 1 part (len:1 cap:1 ptr:9184)╔══════╗║ doom ║╚══════╝ 0 part (len:0 cap:0 ptr:9184)&lt;empty slice&gt;games (len:0 cap:0 ptr:9136)&lt;empty slice&gt;part (len:0 cap:0 ptr:9184)&lt;empty slice&gt; append function 什麼時候會新增一個新的 backing Array？ 當 Slice 的 capacity 滿了，append() 就會分配一個新的而且更大的 Array，會回傳新的 Slice Header 而且指向更新的 Array。為什麼 Array 會新增一個更大的 Array，就是為了麼節省未來新分配的數量，複製之前的 Array 到新的 Array 會消耗 CPU 和記憶體的資源，所以當新增更大的 Array 會分配 0 的值到 backing Array 未初始化的 element。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package mainimport ( s &quot;github.com/inancgumus/prettyslice&quot;)type collection []stringfunc main() &#123; s.PrintBacking = true var nums []int s.Show(&quot;no backing array&quot;, nums) nums = append(nums, 1, 3) s.Show(&quot;allocates&quot;, nums) nums = append(nums, 2) s.Show(&quot;free capacity&quot;, nums) nums = append(nums, 4) s.Show(&quot;no allocation&quot;, nums) nums = append(nums, nums[2:]...) s.Show(&quot;nums &lt;- nums[2:]&quot;, nums) nums = append(nums[:2], 7, 9) s.Show(&quot;nums[:2] &lt;- 7, 9&quot;, nums) nums = nums[:6] s.Show(&quot;nums: extend&quot;, nums)&#125;====OUTPUT====no backing array (len:0 cap:0 ptr:0 )&lt;nil slice&gt;allocates (len:2 cap:2 ptr:5760)╔═══╗╔═══╗║ 1 ║║ 3 ║╚═══╝╚═══╝ 0 1 free capacity (len:3 cap:4 ptr:3936)╔═══╗╔═══╗╔═══╗+---+║ 1 ║║ 3 ║║ 2 ║| 0 |╚═══╝╚═══╝╚═══╝+---+ 0 1 2 3 no allocation (len:4 cap:4 ptr:3936)╔═══╗╔═══╗╔═══╗╔═══╗║ 1 ║║ 3 ║║ 2 ║║ 4 ║╚═══╝╚═══╝╚═══╝╚═══╝ 0 1 2 3 nums &lt;- nums[2:] (len:6 cap:8 ptr:2800)╔═══╗╔═══╗╔═══╗╔═══╗╔═══╗║ 1 ║║ 3 ║║ 2 ║║ 4 ║║ 2 ║╚═══╝╚═══╝╚═══╝╚═══╝╚═══╝ 0 1 2 3 4 ╔═══╗+---++---+║ 4 ║| 0 || 0 |╚═══╝+---++---+ 5 6 7 nums[:2] &lt;- 7, 9 (len:4 cap:8 ptr:2800)╔═══╗╔═══╗╔═══╗╔═══╗+---+║ 1 ║║ 3 ║║ 7 ║║ 9 ║| 2 |╚═══╝╚═══╝╚═══╝╚═══╝+---+ 0 1 2 3 4 +---++---++---+| 4 || 0 || 0 |+---++---++---+ 5 6 7 nums: extend (len:6 cap:8 ptr:2800)╔═══╗╔═══╗╔═══╗╔═══╗╔═══╗║ 1 ║║ 3 ║║ 7 ║║ 9 ║║ 2 ║╚═══╝╚═══╝╚═══╝╚═══╝╚═══╝ 0 1 2 3 4 ╔═══╗+---++---+║ 4 ║| 0 || 0 |╚═══╝+---++---+ 5 6 7 什麼時候 Slice 的 backing Array 會增加？ 每當 Array 不夠的時候，Slice 就會新增更大的 Array 讓你在未來可以直接使用，不需要額外複製 Array。 12345678910111213141516171819202122232425262728package mainimport ( s &quot;github.com/inancgumus/prettyslice&quot; &quot;github.com/inancgumus/screen&quot; &quot;math/rand&quot; &quot;time&quot;)type collection []stringfunc main() &#123; s.PrintBacking = true s. MaxPerLine = 20 s.Width = 150 var nums []int screen.Clear() for cap(nums) &lt;= 128 &#123; screen.MoveTopLeft() s.Show(&quot;nums&quot;, nums) nums = append(nums, rand.Intn(9) + 1) time.Sleep(time.Second / 4) &#125;&#125; 5e5 代表 500000，而 5e4 代表 50000，以此類推。當新增 Array 到一個量級的時候，它的增長速度就會變慢，因為你可能後面不需要那麼多 elements 了，而且大量的 elements 是非常耗資源的，所以 Go 已經把 Slice 優化好了，不需要做額外的優化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package mainimport ( &quot;fmt&quot;)type collection []stringfunc main() &#123; ages, oldCap := []int&#123;1&#125;, 1. for len(ages) &lt; 5e5 &#123; ages = append(ages, 1) c := float64(cap(ages)) if c != oldCap &#123; fmt.Printf(&quot;len:%-10d cap:%-10g growth:%.2f\\n&quot;, len(ages), c, c/oldCap) &#125; oldCap = c &#125;&#125;====OUTPUT====len:2 cap:2 growth:2.00len:3 cap:4 growth:2.00len:5 cap:8 growth:2.00len:9 cap:16 growth:2.00len:17 cap:32 growth:2.00len:33 cap:64 growth:2.00len:65 cap:128 growth:2.00len:129 cap:256 growth:2.00len:257 cap:512 growth:2.00len:513 cap:1024 growth:2.00len:1025 cap:1280 growth:1.25len:1281 cap:1696 growth:1.32len:1697 cap:2304 growth:1.36len:2305 cap:3072 growth:1.33len:3073 cap:4096 growth:1.33len:4097 cap:5120 growth:1.25len:5121 cap:7168 growth:1.40len:7169 cap:9216 growth:1.29len:9217 cap:12288 growth:1.33len:12289 cap:15360 growth:1.25len:15361 cap:19456 growth:1.27len:19457 cap:24576 growth:1.26len:24577 cap:30720 growth:1.25len:30721 cap:38912 growth:1.27len:38913 cap:49152 growth:1.26len:49153 cap:61440 growth:1.25len:61441 cap:76800 growth:1.25len:76801 cap:96256 growth:1.25len:96257 cap:120832 growth:1.26len:120833 cap:151552 growth:1.25len:151553 cap:189440 growth:1.25len:189441 cap:237568 growth:1.25len:237569 cap:296960 growth:1.25len:296961 cap:371712 growth:1.25len:371713 cap:464896 growth:1.25len:464897 cap:581632 growth:1.25","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://vincent.fishboneapps.com/tags/Golang/"}]},{"title":"Golang 快速學習自我挑戰 Day9","slug":"Golang-快速學習自我挑戰-Day9","date":"2021-08-13T04:28:43.000Z","updated":"2021-08-21T05:21:22.421Z","comments":true,"path":"2021/08/13/Golang-快速學習自我挑戰-Day9/","link":"","permalink":"https://vincent.fishboneapps.com/2021/08/13/Golang-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day9/","excerpt":"","text":"第五章：Slices 和 Internal 章節介紹 Slice 是動態的 Array。 這個章節會學習到的內容。 Array 和 Slice 的差異。 使用 append() 來增加 Slice。 Slicing - Slice 表達式 [low:high]。 Internals。 Backing Array。 Slice Header。 Capacity of Slice - cap()。 完整的 Slice 表達式 [low:high:cap]。 Preallocation - make()。 不使用 loop 來複製 Slices - copy()。 Multi-Dimensional Slices。 學習 Array 和 Slice 的差異 Array 不能增加或減少 elements，Slice 可以在 Runtime 的時候增加和減少 elements。 Array 不能在 在 Runtime 的時候增加或減少 elements，因為長度是 type 的一部分，比方說 var nums [3]int 的 type 就是 [3]int，它的長度屬於 compile-time，所以它的長度在 Runtime 的時候不能修改，也就是這樣，Array 不能增加或減少 elements。 Slice 可以在 Runtime 的時候增加和減少 elements，比方說 var nums []int 它在 compile-time 的時候並沒有固定長度，所以它的長度在 Runtime 的時候可以修改，它的長度屬於 Runtime。 跟 Array 不同，未初始化的 Slice 的值是 nil，比方說 var nums []int，nums 就等於 nil。nil 不是裡面沒有值，而是值還沒有被初始化，雖然它的值是 nil，但是他還是有型別，它的型別是 int。它可以使用 len(nums)，這邊的長度值會等於 0。 Array 和 Slice 的差別。 Slice Array var nums []int var nums [3]int 它的長度不屬於它型別的一部分。 它的長度屬於它型別的一部分。 它可以增加或減少。 它不可以增加或減少。 它的空值是 nil。 它的空值是 0 elements。 Array 和 Slice 的相同之處。 Slice &amp; Array 它們可以只能包含相同類型的 elements。 你可以使用 index 表達式去取得值，例如：nums[0]、nums[1]。 可以使用 len(nums)，因為它們的有相同的 index。 Slice 跟另外一個 Slice 比較嗎？ Slice 只能跟 nil value 進行比較。 如果 Slice 是 nil 的情況下，Go 不會執行 for loop。 可以直接將一個 Slice assign 到另外一個 Slice，例如：games = newGames，也可以直接 assign nil，例如：games = nil 千萬不要檢查 Slice 是否等於 nil，而要檢查 Slice 的長度，因為當你使用 games = []string&#123;&#125; 的時候，你會發現這個 Slice 不等於 nil。 用 for loop 的方式進行比較。 1234567891011121314151617181920212223242526272829303132333435363738package mainimport &quot;fmt&quot;func main() &#123; games := []string&#123;&quot;Pokemon&quot;, &quot;sims&quot;&#125; newGames := []string&#123;&quot;pacman&quot;, &quot;doom&quot;, &quot;pong&quot;&#125; games = []string&#123;&#125; var ok string for i, game := range games &#123; if game != newGames[i] &#123; ok = &quot;not &quot; break &#125; &#125; if len(games) == 0 &#123; ok = &quot;not &quot; &#125; fmt.Printf(&quot;games and newGames are %sequal\\n\\n&quot;, ok) fmt.Printf(&quot;games : %#v\\n&quot;, games) fmt.Printf(&quot;newGames : %#v\\n&quot;, newGames) fmt.Printf(&quot;games : %T\\n&quot;, games) fmt.Printf(&quot;games&#x27; len : %d\\n&quot;, len(games)) fmt.Printf(&quot;nil? : %t\\n&quot;, games == nil)&#125;====OUTPUT====games and newGames are not equalgames : []string&#123;&#125;newGames : []string&#123;&quot;pacman&quot;, &quot;doom&quot;, &quot;pong&quot;&#125;games : []stringgames&#x27; len : 0nil? : false 新增唯一編號產生器 使用 append() 新增 Slice 的 element。使用 nums[:] 可以將 Array 換成 Slice。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport ( &quot;fmt&quot; &quot;math/rand&quot; &quot;os&quot; &quot;sort&quot; &quot;strconv&quot; &quot;time&quot;)func main() &#123; rand.Seed(time.Now().UnixNano()) max, _ := strconv.Atoi(os.Args[1]) var uniques []intloop: for len(uniques) &lt; max &#123; n := rand.Intn(max) + 1 fmt.Print(n, &quot; &quot;) for _, u := range uniques &#123; if u == n &#123; continue loop &#125; &#125; uniques = append(uniques, n) &#125; fmt.Println(&quot;\\n\\nuniques:&quot;, uniques) sort.Ints(uniques) fmt.Println(&quot;\\nsorted:&quot;, uniques) nums := [5]int&#123;5, 4, 3, 2, 1&#125; sort.Ints(nums[:]) fmt.Println(&quot;\\nnums:&quot;, nums)&#125;====EXECUTE====go run main.go 10====OUTPUT====5 3 4 1 5 7 6 4 3 8 4 10 3 10 6 9 6 10 7 9 10 5 4 5 7 1 5 10 2 uniques: [5 3 4 1 7 6 8 10 9 2]sorted: [1 2 3 4 5 6 7 8 9 10]nums: [1 2 3 4 5] Append：新增到 Slice 用法：append(slice, newElement)，append() 可以到處使用，不需要引入任何 package。 這邊下面的 nums 還是 []int{1, 2, 3}，因為 append() 不會改變傳入的 Slice，需要把 append 過後的結果傳到一個新的 Slice。 12nums := []int&#123;1, 2, 3&#125;append(nums, 4) nums = append(nums, 4) 把 append() 過後的結果存回去本來的 Slice。 可以 append 多個 elements，因為 append 是 variadic function，nums = append(nums, 4, 9)。 可以使用 ellipsis 來 append 一個 Slice 到另外一個 Slice。 123nums := []int&#123;1, 2, 3&#125;tens := []int&#123;12, 13&#125;nums = append(nums, tens...) 取得課程的 prettyslice go get -u github.com/inancgumus/prettyslice。 使用 append() 的範例。 123456789101112131415package mainimport s &quot;github.com/inancgumus/prettyslice&quot;func main() &#123; var todo []string todo = append(todo, &quot;sing&quot;) todo = append(todo, &quot;run&quot;, &quot;code&quot;, &quot;play&quot;) tomorrow := []string&#123;&quot;see mom&quot;, &quot;learn go&quot;&#125; todo = append(todo, tomorrow...) s.Show(&quot;todo&quot;, todo)&#125; Slicing：來減少 Slice 吧！ Sliceable：可以被 Slice 的任意值，比方說：Array, Slice 和 String 都是 Sliceable。 newSlice := sliceable[START:STOP]，START 就是從哪個 index 開始 slice，STOP 就是 slice 到哪個位置（範圍是 index + 1），最後回傳的會是一個新的 Slice。 msg := []string&#123;&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;&#125;，msg[0:1] 就是 []string&#123;&quot;h&quot;&#125;，msg[4:5] 就是 []string&#123;&quot;o&quot;&#125;。如果第一個是最前面的數字，最後面跟長度一樣，就可以省略，比方說 msg[:] 回傳 []string&#123;&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;&#125;。如果用 msg[:6] 因為沒有這麼長，會出現 RUNTIME ERROR: Slice bounds out of range。 可以在 slice 過後再 append element 上去，append(msg[:4], &quot;!&quot;)，結果會是 []string&#123;&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;!&quot;&#125;，但是這邊原本的 Slice 也會變成 []string&#123;&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;!&quot;&#125;，後面會解釋為什麼有這樣奇怪的現象。 slicing 的範例。可以使用取得長度的方式來取得位置，更加容易閱讀。被 slice 過的 Slice 也可以再次 slice，這稱為 re-slicing。slice 之後會回傳 Slice，如果用 index 的方式則會取得 element 的內容，在下面的範例是 string。 1234567891011121314151617181920212223242526272829package mainimport ( &quot;fmt&quot; s &quot;github.com/inancgumus/prettyslice&quot;)func main() &#123; items := []string&#123; &quot;pacman&quot;, &quot;mario&quot;, &quot;tetris&quot;, &quot;doom&quot;, &quot;galaga&quot;, &quot;frogger&quot;, &quot;asteroids&quot;, &quot;simcity&quot;, &quot;metroid&quot;, &quot;defender&quot;, &quot;rayman&quot;, &quot;tempest&quot;, &quot;ultima&quot;, &#125; s.MaxPerLine = 4 s.Show(&quot;items&quot;, items) top3 := items[:3] s.Show(&quot;top 3 items&quot;, top3) l := len(items) last4 := items[l-4:] s.Show(&quot;last 4 items&quot;, last4) mid := last4[1:3] s.Show(&quot;mid items&quot;, mid) fmt.Printf(&quot;slicing: %T %[1]q\\n&quot;, items[2:3]) fmt.Printf(&quot;indexing: %T %[1]q\\n&quot;, items[2])&#125; 如果使用 Slice 來新增分頁(Pagination)？ 分頁的範例。如果遇到錯誤，可以使用 printf 來進行除錯。Sprintf 和 printf 其實很像，差別在於 Sprintf 回傳格式化的 String 而不是列印出來。 123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot; s &quot;github.com/inancgumus/prettyslice&quot;)func main() &#123; items := []string&#123; &quot;pacman&quot;, &quot;mario&quot;, &quot;tetris&quot;, &quot;doom&quot;, &quot;galaga&quot;, &quot;frogger&quot;, &quot;asteroids&quot;, &quot;simcity&quot;, &quot;metroid&quot;, &quot;defender&quot;, &quot;rayman&quot;, &quot;tempest&quot;, &quot;ultima&quot;, &#125; const pageSize = 4 l := len(items) for from := 0; from &lt; l; from+=pageSize &#123; to := from + pageSize if to &gt; l &#123; to = l &#125; currentPage := items[from:to] head := fmt.Sprintf(&quot;Page #%d&quot;, (from/pageSize) + 1) s.Show(head, currentPage) &#125;&#125; 什麼是 backing Array？ Slice 背後有一個隱藏的 Array，也就是 backing Array 儲存在記憶體中，最後回傳的 Slice 會指向那個 Array，Slice 就是指向 backing Array 的一個窗戶。 使用 Slice 表達式產生的 Slice 會跟原本的 Slice 共享相同的 Array。 indexing Slice 是非常快的，因為 Slice 的 backing Array 是連續的。 非空值的 Slice 會總是新增新的 Backing Array。例如新增兩個 Slice ages := []int&#123;35, 15, 25&#125; 和 grades := []int&#123;70, 99&#125;，它們兩個的 backing Array 就是分開的，總結來說，新增不一樣的 Slice，backing Array 是分開的。 後面修改 ages 也會影響到本來的 agesArray。 1234agesArray := [3]int&#123;35, 15, 25&#125;ages := agesArray[0:3]ages[0] = 100ages[2] = 50 這邊你會發現 grades 也被改變了，而且後面的 ptr 指向的是同一個 backing Array。 123456789101112131415161718192021222324252627282930package mainimport ( s &quot;github.com/inancgumus/prettyslice&quot; &quot;sort&quot;)func main() &#123; grades := []float64&#123;40, 10, 20, 50, 60, 70&#125; front := grades[:3] sort.Float64s(front) s.PrintBacking = true s.MaxPerLine = 7 s.Show(&quot;grades&quot;, grades[:]) s.Show(&quot;front&quot;, front)&#125;====OUTPUT====grades (len:6 cap:6 ptr:4544)╔════╗╔════╗╔════╗╔════╗╔════╗╔════╗║ 10 ║║ 20 ║║ 40 ║║ 50 ║║ 60 ║║ 70 ║╚════╝╚════╝╚════╝╚════╝╚════╝╚════╝ 0 1 2 3 4 5 front (len:3 cap:6 ptr:4544)╔════╗╔════╗╔════╗+----++----++----+║ 10 ║║ 20 ║║ 40 ║| 50 || 60 || 70 |╚════╝╚════╝╚════╝+----++----++----+ 0 1 2 3 4 5 這邊新增一個 newGrades 就會發現 ptr 和本來的 grades 不一樣，而 front 則跟 newGrades 共享同一個 backing Array。 123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( s &quot;github.com/inancgumus/prettyslice&quot; &quot;sort&quot;)func main() &#123; grades := []float64&#123;40, 10, 20, 50, 60, 70&#125; var newGrades []float64 newGrades = append(newGrades, grades...) front := newGrades[:3] sort.Float64s(front) s.PrintBacking = true s.MaxPerLine = 7 s.Show(&quot;grades&quot;, grades[:]) s.Show(&quot;newGrades&quot;, newGrades) s.Show(&quot;front&quot;, front)&#125;====OUTPUT====grades (len:6 cap:6 ptr:2896)╔════╗╔════╗╔════╗╔════╗╔════╗╔════╗║ 40 ║║ 10 ║║ 20 ║║ 50 ║║ 60 ║║ 70 ║╚════╝╚════╝╚════╝╚════╝╚════╝╚════╝ 0 1 2 3 4 5 newGrades (len:6 cap:6 ptr:2944)╔════╗╔════╗╔════╗╔════╗╔════╗╔════╗║ 10 ║║ 20 ║║ 40 ║║ 50 ║║ 60 ║║ 70 ║╚════╝╚════╝╚════╝╚════╝╚════╝╚════╝ 0 1 2 3 4 5 front (len:3 cap:6 ptr:2944)╔════╗╔════╗╔════╗+----++----++----+║ 10 ║║ 20 ║║ 40 ║| 50 || 60 || 70 |╚════╝╚════╝╚════╝+----++----++----+ 0 1 2 3 4 5 可以在 append 的地方直接放入 nil 的 Slice，但是那邊一定要是 Slice，所以使用 []float64(nil)。同時我們新增 front2, front3，看結果你會發現一樣都被排序了，因為它們共享相同的 backing Array。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package mainimport ( s &quot;github.com/inancgumus/prettyslice&quot; &quot;sort&quot;)func main() &#123; grades := []float64&#123;40, 10, 20, 50, 60, 70&#125; newGrades := append([]float64(nil), grades...) front := newGrades[:3] front2 := front[:3] front3 := front2 sort.Float64s(front) s.PrintBacking = true s.MaxPerLine = 7 s.Show(&quot;grades&quot;, grades[:]) s.Show(&quot;newGrades&quot;, newGrades) s.Show(&quot;front&quot;, front) s.Show(&quot;front2&quot;, front2) s.Show(&quot;front3&quot;, front3)&#125;====OUTPUT==== grades (len:6 cap:6 ptr:4544)╔════╗╔════╗╔════╗╔════╗╔════╗╔════╗║ 40 ║║ 10 ║║ 20 ║║ 50 ║║ 60 ║║ 70 ║╚════╝╚════╝╚════╝╚════╝╚════╝╚════╝ 0 1 2 3 4 5 newGrades (len:6 cap:6 ptr:4592)╔════╗╔════╗╔════╗╔════╗╔════╗╔════╗║ 10 ║║ 20 ║║ 40 ║║ 50 ║║ 60 ║║ 70 ║╚════╝╚════╝╚════╝╚════╝╚════╝╚════╝ 0 1 2 3 4 5 front (len:3 cap:6 ptr:4592)╔════╗╔════╗╔════╗+----++----++----+║ 10 ║║ 20 ║║ 40 ║| 50 || 60 || 70 |╚════╝╚════╝╚════╝+----++----++----+ 0 1 2 3 4 5 front2 (len:3 cap:6 ptr:4592)╔════╗╔════╗╔════╗+----++----++----+║ 10 ║║ 20 ║║ 40 ║| 50 || 60 || 70 |╚════╝╚════╝╚════╝+----++----++----+ 0 1 2 3 4 5 front3 (len:3 cap:6 ptr:4592)╔════╗╔════╗╔════╗+----++----++----+║ 10 ║║ 20 ║║ 40 ║| 50 || 60 || 70 |╚════╝╚════╝╚════╝+----++----++----+ 0 1 2 3 4 5","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://vincent.fishboneapps.com/tags/Golang/"}]},{"title":"Golang 快速學習自我挑戰 Day8","slug":"Golang-快速學習自我挑戰-Day8","date":"2021-08-11T14:09:35.000Z","updated":"2021-08-15T02:55:25.666Z","comments":true,"path":"2021/08/11/Golang-快速學習自我挑戰-Day8/","link":"","permalink":"https://vincent.fishboneapps.com/2021/08/11/Golang-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day8/","excerpt":"","text":"第三章 如何使用 Multi-dimensional Array？ 新增一個 Multi-dimensional Array，會是這樣的形式，最外層的 [2] 宣告裡面有 2 個 Array，而 [3]int 是裡面 Array 的長度和型別。 1234[2][3]int&#123; [3]int&#123;5, 6, 1&#125;, [3]int&#123;9, 8, 4&#125;,&#125; 要取得學生的平均分數，程式碼如下： 123456789student1 := [3]float64&#123;5, 6, 1&#125;student2 := [3]float64&#123;9, 8, 4&#125;var sum float64sum += student1[0] + student1[1] + student1[2]sum += student2[0] + student2[1] + student2[2]const N = float64(len(student1) * 2)fmt.Printf(&quot;Avg Grade: %g\\n&quot;, sum/N) 使用 Multi-dimensional Array。 1234567891011students := [2][3]float64&#123; [3]float64&#123;5, 6, 1&#125;, [3]float64&#123;9, 8, 4&#125;,&#125;var sum float64sum += students[0][0] + students[0][1] + students[0][2]sum += students[1][0] + students[1][1] + students[1][2]const N = float64(len(students) * len(students[0]))fmt.Printf(&quot;Avg Grade: %g\\n&quot;, sum/N) 優化程式碼，型別已經在外層宣告，所以不用再宣告一遍，長度也可以用 ellipse ([…]) 的方式處理，最後再用 for range 取得分數。 1234567891011121314students := [...][3]float64&#123; &#123;5, 6, 1&#125;, &#123;9, 8, 4&#125;,&#125;var sum float64for _, grades := range students &#123; for _, grade := range grades &#123; sum += grade &#125;&#125;const N = float64(len(students) * len(students[0]))fmt.Printf(&quot;Avg Grade: %g\\n&quot;, sum/N) 小挑戰 2：Moodly 使用 Multi-dimensional Array 改良 Moodly 12345678910111213141516171819202122232425262728293031323334package mainimport ( &quot;fmt&quot; &quot;math/rand&quot; &quot;os&quot; &quot;time&quot;)func main() &#123; args := os.Args[1:] if len(args) != 2 &#123; fmt.Println(&quot;[your name] [positive|negative]&quot;) return &#125; name, mood := args[0], args[1] moods := [...][3]string&#123; &#123;&quot;happy 😀&quot;, &quot;good 👍&quot;, &quot;awesome 😎&quot;&#125;, &#123;&quot;sad 😔&quot;, &quot;bad 👎&quot;, &quot;terrible 😩&quot;&#125;, &#125; rand.Seed(time.Now().UnixNano()) n := rand.Intn(len(moods[0])) var mi int if mood != &quot;positive&quot; &#123; mi = 1 &#125; fmt.Printf(&quot;%s feels %s\\n&quot;, name, moods[mi][n])&#125; 學習 Go 很少被人知道的功能：The Keyed Elements 可以直接在 element 前面加上 index 的數字，指定 element 的 key。 12345rates := [3]float64&#123; 1: 2.5, 0: 0.5, 2: 1.5,&#125; 如果直接指定 key，就會指定 element 的位置，因為另外兩個 Element 沒有值，所以初始化為 0，下面這個 Array 的值等於 [3]float64&#123;0, 0, 1.5&#125;。 123rates := [3]float64&#123; 2: 1.5,&#125; 如果使用 ellipsis，因為指定 key 為 5，它就會知道有 6 個 elements，所以下面這個 Array 的值等於 [6]float64&#123;0, 0, 0, 0, 0, 1.5&#125;。 123rates := [...]float64&#123; 5: 1.5,&#125; 如果有 element 是沒有 key 的，Go 會先把有 key 的 element 放到對應位置，最後再把沒有 key 的 element 加到最後面，所以下面這個 Array 的值等於 [7]float64&#123;0.5, 0, 0, 0, 0, 1.5, 2.5&#125;。 12345rates := [...]float64&#123; 5: 1.5, 2.5, 0: 0.5,&#125; 在 Array 使用 const，這樣的程式碼更好閱讀。 123456789101112131415161718192021222324package mainimport ( &quot;fmt&quot;)func main() &#123; const( ETH = 9 - iota WAN ICX ) rates := [...]float64&#123; ETH: 25.5, WAN: 120.5, ICX: 20, &#125; fmt.Printf(&quot;1 BTC is %g ETH\\n&quot;, rates[ETH]) fmt.Printf(&quot;1 BTC is %g WAN\\n&quot;, rates[WAN]) fmt.Printf(&quot;1 BTC is %g ICX\\n&quot;, rates[ICX]) fmt.Printf(&quot;%#v\\n&quot;, rates)&#125; 學習 composite 和 unnamed types 的關係 Composite types 都是 unnamed types。 [3]int&#123;6, 9, 3&#125; 就是一個 unnamed type，這個的底層型別(underlying type)是它自己，也就是 [3]int，這個不只是 Array 是這樣，所有的 composite types 都是這樣。 type bookcase [3]int 就是一個 named type，這個的底層型別(underlying type)也是 [3]int。 這時候新增一個 bookcase&#123;6, 9, 3&#125;，它可以和 [3]int&#123;6, 9, 3&#125; 進行比較，在 unnamed type 和 named type 的情況下，它們的底層型別是一樣的，所以是可以比較的。 新增一個 type cabinet [3]int 並定義 cabinet&#123;6, 9, 3&#125;，它和 bookcase&#123;6, 9, 3&#125; 就不能比較，因為在兩個都是 named type 的情況下，就算底層型別一樣，也是不能比較的。 但是如果再轉換過後，bookcase(cabinet&#123;6, 9, 3&#125;)，它們就可以進行比較了，因為它們有一樣的 type，這邊需要特別注意的地方是，轉換過後，底層型別一定要一樣，否則還是不能比較的。 如果 type 不一樣，可以透過轉換的方式，就可以進行比較了。 12345678910111213141516171819202122232425262728package mainimport &quot;fmt&quot;func main() &#123; type ( bookcase [5]int cabinet [5]int ) blue := bookcase&#123;6, 9, 3, 2, 1&#125; red := cabinet&#123;6, 9, 3, 2, 1&#125; fmt.Printf(&quot;Are they equal?&quot;) if cabinet(blue) == red &#123; fmt.Println(&quot;✅&quot;) &#125; else &#123; fmt.Println(&quot;❌&quot;) &#125; fmt.Printf(&quot;blue: %#v\\n&quot;, blue) fmt.Printf(&quot;red : %#v\\n&quot;, red)&#125;====OUTPUT====Are they equal?✅blue: main.bookcase&#123;6, 9, 3, 2, 1&#125;red : main.cabinet&#123;6, 9, 3, 2, 1&#125; 如果再新增一個 type 叫做 integer，[5]integer&#123;&#125; == [5]int&#123;&#125; 不成立，因為它們有不一樣的底層型別。而 [5]integer&#123;&#125; == cabinet&#123;&#125; 是可以比較的，因為 unnamed type 可以和 named type 進行比較。 1234567891011type ( integer int bookcase [5]int cabinet [5]integer)// cannot compare//_ = [5]integer&#123;&#125; == [5]int&#123;&#125;// comparable_ = [5]integer&#123;&#125; == cabinet&#123;&#125; 回顧：Array Array 就是一個 elements 的集合，它儲存同樣的型別、同樣的數量在相連的記憶體位置，所以非常高效。但是 Array 的長度和型別是固定的，你不能新增多的 element 或是修改 type。 Array 的 element 是 unnamed variables，所以你只能用 index expression 來讀取 Array 裡面的 element。 定義 Array 的方式 var name[length]elementType，長度也是型別的一部分，你也可以用常數(constant)來定義長度。 Array Literal 會根據不同的型別，初始化沒有被定義的 element 為 0 或是空。 可以使用 ellipsis，Go 會自動根據 element 來設定 Array 的長度。 可以使用 keyed element 來指定 Array element 的位置。 可以使用 Multi-Dimensional Array，將 Array 儲存在一個 Array 裡面。 如果新增一個 Array，Go 會自動複製一份新的 Array 到新的記憶體位置。 不同長度和型別的 Array 是不能比較的也不能夠互相 assign 給對方。 一個 unnamed composite type 的底層型別就是它自己，Array 就是一個 composite type。 如果底層型別相同，named 和 unnamed type 是可以比較的。","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://vincent.fishboneapps.com/tags/Golang/"}]},{"title":"Golang 快速學習自我挑戰 Day7","slug":"Golang-快速學習自我挑戰-Day7","date":"2021-07-27T15:57:30.000Z","updated":"2021-08-12T02:03:41.360Z","comments":true,"path":"2021/07/27/Golang-快速學習自我挑戰-Day7/","link":"","permalink":"https://vincent.fishboneapps.com/2021/07/27/Golang-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day7/","excerpt":"","text":"第三章 複合型別(Composite Type) 複合型別的類型 Arrays：有 index、固定長度。 Slices：有 index、動態長度。 Sting Internals：ByteSlices, ASCII &amp; Unicode, Encoding &amp; Decoding。 Maps：有 index，key-value pair。 Structs：一組不同型別的變數。 這邊會學習到什麼？ 什麼是 Array? Getting and Setting Array Elements Array Literals - 建立 Array 最簡單的方式 Comparing Array Assigning Array Multi-Dimensional Arrays Keyed Elements Named vs Unnamed Types 為什麼需要 Array？因為很多時候我們要一起使用多個變數，這只是其中一個原因，後面會講到用 Array 的更多好處。 12345678910111213// No Arraya := 54b := 143.. := ..oneThousand := 1000sum := a + b + .. + oneThousand// Using Arraynums := [...]int&#123;54, 143, .., 1000&#125;var sum intfor _, num := range nums &#123; sum += num&#125; 在 Go 裡面，Array 是什麼？ Go 會將 Array 的資料儲存在相鄰的位置，這可以讓效率提升很多，因為資料儲存在旁邊。CPU 就可以部分快取，速度也會變快。 Array 的 size 就等於 Array 的 Element size 的總和。 var age [2]byte，這邊的 2 就是 Array 的長度，也就是說，Array 最多只能儲存這個長度的內容。 var age [1 + 1]byte，在長度的地方，可以使用 constant values 或是 constant expressions。 當你設置了 Array 的長度，它就是固定的，之後你就不能更改他的長度了，但是如果你需要更大的 Array，你可以重新 declare 一個新的。 你不能設置 Array 長度為 -1，因為這樣做是沒有意義的。 var age [2]byte，這邊的 byte 就是 element type，意思是這個 Array 只能儲存這個型別的值。如果你一開始沒有定義值的話，Array 會自動給予初始值，如果是 byte 的話，初始值為 0。 你可以使用任何類型的 type，比方說：var tags [2]string，初始值為 &quot;&quot; 在定義好型別的 Array，不能在 Array 放其它種型別的值。 每一個 Array 的值都是未命名的變數(Unnamed Variables)，所以你不能像變數一樣地使用它。默認的情況下，Go 不允許你直接存取任意記憶體的位置，所以 Go 使用 index expression 來存取 Array 的內容。 var age [2]byte，要取得 Array 的內容，直接用 age[0] 就可以取得了，但是 age[2] 是不允許的，因為不可以超過 Array 的長度，age[-1] 也是不允許的，因為 Go index 從 0 開始。 你可以使用 assignment operators 來設定 element。123456var ages [2]intages[0] = 6ages[1] -= 3// resultages[0] = 6ages[1] = -3 開始創建一個 Array 我們可以用 constant variable 來設置長度，可以用 %#v 完整地把 Array 印出來。 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;const ( winter = 1 summer = 3 yearly = winter + summer)func main() &#123; var books [yearly]string fmt.Printf(&quot;books: %T\\n&quot;, books) fmt.Println(&quot;books&quot;, books) fmt.Printf(&quot;books: %q\\n&quot;, books) fmt.Printf(&quot;books: %#v\\n&quot;, books)&#125;====OUTPUT====books: [4]stringbooks [ ]books: [&quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot;]books: [4]string&#123;&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;&#125; Array 可以組合 Element 的內容形成一個新的 Element，因為 Array 的 Element 就像變數。 12345678910111213141516171819202122package mainimport &quot;fmt&quot;const ( winter = 1 summer = 3 yearly = winter + summer)func main() &#123; var books [yearly]string books[0] = &quot;Kafka&#x27;s Revenge&quot; books[1] = &quot;Stay Golden&quot; books[2] = &quot;Everythingship&quot; books[3] = books[0] + &quot; 2nd Edition&quot; fmt.Printf(&quot;books: %#v\\n&quot;, books)&#125;====OUTPUT====books: [4]string&#123;&quot;Kafka&#x27;s Revenge&quot;, &quot;Stay Golden&quot;, &quot;Everythingship&quot;, &quot;Kafka&#x27;s Revenge 2nd Edition&quot;&#125; 對 Array 使用 for range 在 Array 長度的地方可以使用 len 是因為 len 會回傳 constant。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package mainimport &quot;fmt&quot;const ( winter = 1 summer = 3 yearly = winter + summer)func main() &#123; var books [yearly]string books[0] = &quot;Kafka&#x27;s Revenge&quot; books[1] = &quot;Stay Golden&quot; books[2] = &quot;Everythingship&quot; books[3] = books[0] + &quot; 2nd Edition&quot; fmt.Printf(&quot;books: %#v\\n&quot;, books) var ( wBooks [winter]string sBooks [summer]string ) wBooks[0] = books[0] //sBooks[0] = books[1] //sBooks[1] = books[2] //sBooks[2] = books[3] for i := range sBooks &#123; sBooks[i] = books[i+1] &#125; fmt.Printf(&quot;\\nwinter: %#v\\n&quot;, wBooks) fmt.Printf(&quot;\\nsummber: %#v\\n&quot;, sBooks) var published [len(books)]bool published[0] = true published[len(books) - 1] = true fmt.Println(&quot;\\nPublished Books:&quot;) for i, ok := range published &#123; if ok &#123; fmt.Printf(&quot;+ %s\\n&quot;, books[i]) &#125; &#125;&#125;====OUTPUT====books: [4]string&#123;&quot;Kafka&#x27;s Revenge&quot;, &quot;Stay Golden&quot;, &quot;Everythingship&quot;, &quot;Kafka&#x27;s Revenge 2nd Edition&quot;&#125;winter: [1]string&#123;&quot;Kafka&#x27;s Revenge&quot;&#125;summber: [3]string&#123;&quot;Stay Golden&quot;, &quot;Everythingship&quot;, &quot;Kafka&#x27;s Revenge 2nd Edition&quot;&#125;Published Books:+ Kafka&#x27;s Revenge+ Kafka&#x27;s Revenge 2nd Edition 什麼是 Composite Literal？ 可以同時初始化 Array 並給每個 elements 賦值。 123456var books [4]string&#123; &quot;Kafka&#x27;s Revenge&quot;, &quot;Stay Golden&quot;, &quot;Everythingship&quot;, &quot;Kafka&#x27;s Revenge 2nd Edition&quot;,&#125; 也可以使用 short declaration。 123456books := [4]string&#123; &quot;Kafka&#x27;s Revenge&quot;, &quot;Stay Golden&quot;, &quot;Everythingship&quot;, &quot;Kafka&#x27;s Revenge 2nd Edition&quot;,&#125; Array Literal 是 Composite Literal 的一種，Composite Literal 新增 Composite values，一個 Composite Value 是其它值的容器(container)。 123456789// Array&#x27;s Type[4]string// element list&#123; &quot;Kafka&#x27;s Revenge&quot;, &quot;Stay Golden&quot;, &quot;Everythingship&quot;, &quot;Kafka&#x27;s Revenge 2nd Edition&quot;,&#125; Elements 之間一定要用逗號隔開，最後一個 element 的逗號不是必須的。 使用 ellipsis([…]) 來自動取得 Array 的元素有幾個，以下面的例子來說，會新增 2 個 elements。 1[...]string&#123;&quot;Kafka&#x27;s Revenge&quot;, &quot;Stay Golden&quot;&#125; 修改 Hipster’s Love Bookstores 為 Array Literal 修改內容如下。 12345678910111213141516package mainimport &quot;fmt&quot;func main() &#123; books := [...]string&#123; &quot;Kafka&#x27;s Revenge&quot;, &quot;Stay Golden&quot;, &quot;Everythingship&quot;, &quot;Kafka&#x27;s Revenge 2nd Edition&quot;, &#125; fmt.Printf(&quot;books: %#v\\n&quot;, books)&#125;====OUTPUT====books: [4]string&#123;&quot;Kafka&#x27;s Revenge&quot;, &quot;Stay Golden&quot;, &quot;Everythingship&quot;, &quot;Kafka&#x27;s Revenge 2nd Edition&quot;&#125; 小挑戰：Moodly 題目：輸入名字之後，每次都給不同的心情，要將心情存在 Array 裡面。 答案： 1234567891011121314151617181920212223242526272829303132package mainimport ( &quot;fmt&quot; &quot;math/rand&quot; &quot;os&quot; &quot;time&quot;)func main() &#123; args := os.Args[1:] if len(args) != 1 &#123; fmt.Println(&quot;[your name]&quot;) return &#125; name := args[0] moods := [...]string&#123; &quot;happy 😀&quot;, &quot;good 👍&quot;, &quot;awesome 😎&quot;, &quot;sad 😔&quot;, &quot;bad 👎&quot;, &quot;terrible 😩&quot;, &#125; rand.Seed(time.Now().UnixNano()) n := rand.Intn(len(moods)) fmt.Printf(&quot;%s feels %s\\n&quot;, name, moods[n])&#125; 如何比較 Array Values？ 型別一定要一樣才能做比較，而有一些是不能比較的，例如：function values, slices, maps 是不能夠做比較的。 Go 會一個一個 Element 來做比較，如果第一個是 true，才會進行下一個比較，直到最後一個 element 都一樣，就是相同的 Array。 如果 Array 的 Element 一樣，但是順序不一樣，就是不同的 Array。 [3]int&#123;6, 9, 3&#125; 和 [2]int&#123;6, 9&#125;，雖然看起來前兩個 element 一樣，但是它們是不能比較的，因為型別不同，一個是 [3]int，另外一個是 [2]int。 你可以把 Array 指派到另外一個 Array 嗎？ 你可以把 Array 指派到另外一個 Array，Go 會新增一個新的 Array 放在記憶體的不同位置，所以你可以想像成是完成不同的 Array，如果把其中的一個 Array 的 element 換掉，也不會影響另外一個 Array。在這邊你會發現這樣很沒效率，但是在小 Array 的情況下這個就不是問題了。 和比較 Array 一樣，如果型別不同，也不能指派 Array。blue := [3]int&#123;6, 9, 3&#125; 和 red := [2]int&#123;6, 9&#125;，如果執行 blue = red，會直接出錯。 如果型別不同，可以使用 range 的方式來將 Array 的 elements 複製到新的 Array。 12345678910111213141516171819202122232425262728package mainimport &quot;fmt&quot;func main() &#123; prev := [3]string&#123; &quot;Kafka&#x27;s Revenge&quot;, &quot;Stay Golden&quot;, &quot;Everythingship&quot;, &#125; var books [4]string for i, b := range prev &#123; books[i] = b + &quot; 2nd Ed.&quot; &#125; books[3] = &quot;Awesomeness&quot; fmt.Printf(&quot;last year:\\n%#v\\n&quot;, prev) fmt.Printf(&quot;\\nthis year:\\n%#v\\n&quot;, books)&#125;====OUTPUT====last year:[3]string&#123;&quot;Kafka&#x27;s Revenge&quot;, &quot;Stay Golden&quot;, &quot;Everythingship&quot;&#125;this year:[4]string&#123;&quot;Kafka&#x27;s Revenge 2nd Ed.&quot;, &quot;Stay Golden 2nd Ed.&quot;, &quot;Everythingship 2nd Ed.&quot;, &quot;Awesomeness&quot;&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://vincent.fishboneapps.com/tags/Golang/"}]},{"title":"Golang 快速學習自我挑戰 Day6","slug":"Golang-快速學習自我挑戰-Day6","date":"2021-07-26T00:46:56.000Z","updated":"2021-07-31T01:49:42.090Z","comments":true,"path":"2021/07/25/Golang-快速學習自我挑戰-Day6/","link":"","permalink":"https://vincent.fishboneapps.com/2021/07/25/Golang-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day6/","excerpt":"","text":"章節二 Go 和 Randomization 這邊會實作一個 Lucky number 的專案，使用者會輸入數字，然後系統會隨機產生一個數字，當使用者猜到跟系統隨機產生的數字相同，使用者勝利。 這邊會用到 rand 的套件包，Go 的隨機是使用假隨機(pseudo-random)，在每次執行的時候，Go 會產生一連串的已定好的數列(deterministic sequence)。 func Intn(n) 會產生 [0, n) 之間的亂數，但是不包含 n。所以如果要取得 0-10 的變數，要使用 Intn(11)。 Lucky Number 的範例，你會發現你每次的結果都一樣，因為 Go 使用了假隨機。 123456789101112131415161718package mainimport ( &quot;fmt&quot; &quot;math/rand&quot;)func main() &#123; guess := 10 for n := 0; n != guess; &#123; n = rand.Intn(guess + 1) fmt.Printf(&quot;%d &quot;, n) &#125; fmt.Println()&#125;====OUTPUT====6 8 1 0 2 4 6 0 10 為了要讓每次產生的數字都不一樣，要使用 func Seed(int64)，在裡面放不同的數字，它就會產生不同的隨機值，也就是說如果 Seed 放 10，每次產生的隨機值就會都一樣，所以我們要在 Seed 裡面放不同的數字來讓每次產生不同的數字。 1234567891011121314151617package mainimport ( &quot;fmt&quot; &quot;math/rand&quot;)func main() &#123; rand.Seed(100) guess := 10 for n := 0; n != guess; &#123; n = rand.Intn(guess + 1) fmt.Printf(&quot;%d &quot;, n) &#125; fmt.Println()&#125; 用時間 Seed 隨機數字 查看現在的 Unix Time。 Time 套件的 func Unix 回傳的是 int，可以拿來 Seed，這邊還有一個 func UnixNano 可以產生 Nanoseconds，更精準所以更適合拿來 Seed。 用時間 Seed 隨機數字，這樣就可以每次產生不同的數字了。 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;math/rand&quot; &quot;time&quot;)func main() &#123; rand.Seed(time.Now().UnixNano()) guess := 10 for n := 0; n != guess; &#123; n = rand.Intn(guess + 1) fmt.Printf(&quot;%d &quot;, n) &#125; fmt.Println()&#125;====OUTPUT====7 8 0 7 0 8 10 5 3 4 4 6 0 2 10 寫一個 Game Logic 範例。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport ( &quot;fmt&quot; &quot;math/rand&quot; &quot;os&quot; &quot;strconv&quot; &quot;time&quot;)const ( maxTurns = 5 usage = `Welcome to the Luck Number Game! 🍀The program will pick %d random numbers.Your mission is to guess one those numbers.The greater your numbers is, the harder it gets.Wanna play?`)func main() &#123; rand.Seed(time.Now().UnixNano()) args := os.Args[1:] if len(args) != 1 &#123; fmt.Printf(usage, maxTurns) return &#125; guess, err := strconv.Atoi(args[0]) if err != nil &#123; fmt.Println(&quot;Not a number.&quot;) return &#125; if guess &lt;= 0 &#123; fmt.Println(&quot;Please pick a positive number.&quot;) return &#125; for turn := 1; turn &lt; maxTurns; turn++ &#123; n := rand.Intn(guess + 1) if n == guess &#123; fmt.Println(&quot;🎉 YOU WIN!&quot;) return &#125; &#125; fmt.Println(&quot;☠️ YOU LOST...Try again?&quot;)&#125; 建立文字查找器 建立一個簡單的文字查找器。 1234567891011121314151617181920212223package mainimport ( &quot;fmt&quot; &quot;os&quot; &quot;strings&quot;)const corpus = &quot;lazy cat jumps again and again and again&quot;func main() &#123; words := strings.Fields(corpus) query := os.Args[1:] for _, q := range query &#123; for i, w := range words &#123; if q == w &#123; fmt.Printf(&quot;#%-2d: %q\\n&quot;, i + 1, w) break &#125; &#125; &#125;&#125; Label Statement 使用 labeled statement，可以讓 nested loop 的 parent loop 直接被 break。 123456789101112131415161718192021222324package mainimport ( &quot;fmt&quot; &quot;os&quot; &quot;strings&quot;)const corpus = &quot;lazy cat jumps again and again and again&quot;func main() &#123; words := strings.Fields(corpus) query := os.Args[1:]queries: for _, q := range query &#123; for i, w := range words &#123; if q == w &#123; fmt.Printf(&quot;#%-2d: %q\\n&quot;, i + 1, w) break queries &#125; &#125; &#125;&#125; 在 label 上面新增一樣名字的變數，也不會出錯，因為變數和 label 是不一樣的東西。正常來說，在同一個 block 不能宣告同樣的名字，所以 label 和變數還有常數並沒有共享同一個 block。 123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot; &quot;os&quot; &quot;strings&quot;)const corpus = &quot;lazy cat jumps again and again and again&quot;func main() &#123; words := strings.Fields(corpus) query := os.Args[1:] var queries string _ = queriesqueries: for _, q := range query &#123; for i, w := range words &#123; if q == w &#123; fmt.Printf(&quot;#%-2d: %q\\n&quot;, i + 1, w) break queries &#125; &#125; &#125;&#125; 同樣地，也可以從 parent loop 直接 continue。 123456789101112131415161718192021222324package mainimport ( &quot;fmt&quot; &quot;os&quot; &quot;strings&quot;)const corpus = &quot;lazy cat jumps again and again and again&quot;func main() &#123; words := strings.Fields(corpus) query := os.Args[1:]queries: for _, q := range query &#123; for i, w := range words &#123; if q == w &#123; fmt.Printf(&quot;#%-2d: %q\\n&quot;, i + 1, w) continue queries &#125; &#125; &#125;&#125; 使用 label 來中斷 switch 如果直接在 switch 裡面 break，就只會 break switch statement，下面還會繼續執行，用 label 的方式就可以讓 parent loop 直接中斷。 1234567891011121314151617181920212223242526272829package mainimport ( &quot;fmt&quot; &quot;os&quot; &quot;strings&quot;)const corpus = &quot;lazy cat jumps again and again and again&quot;func main() &#123; words := strings.Fields(corpus) query := os.Args[1:]queries: for _, q := range query &#123; search: for i, w := range words &#123; switch q &#123; case &quot;and&quot;, &quot;or&quot;, &quot;the&quot;: break search &#125; if q == w &#123; fmt.Printf(&quot;#%-2d: %q\\n&quot;, i + 1, w) break queries &#125; &#125; &#125;&#125; Go 的 goto statement goto 語法很少使用，正常來說使用 for，break 和 continue 更好，所以只有在 goto 能讓程式碼變簡單才選用它。 123456789101112131415package mainimport &quot;fmt&quot;func main() &#123; var i intloop: if i &lt; 3 &#123; fmt.Println(&quot;looping&quot;) i++ goto loop &#125; fmt.Println(&quot;done&quot;)&#125; 不能在 label 裡面有定義的變數之前使用 goto。 123// Can&#x27;t Workgoto loopvar i int","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://vincent.fishboneapps.com/tags/Golang/"}]},{"title":"Golang 快速學習自我挑戰 Day5","slug":"Golang-快速學習自我挑戰-Day5","date":"2021-07-24T14:44:22.000Z","updated":"2021-07-31T01:50:13.188Z","comments":true,"path":"2021/07/24/Golang-快速學習自我挑戰-Day5/","link":"","permalink":"https://vincent.fishboneapps.com/2021/07/24/Golang-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day5/","excerpt":"","text":"章節一 在 Go 只有一種迴圈 在 Go 只有 for 迴圈，沒有 while 和 until 迴圈。 for 迴圈就是重複一段程式碼當條件是 true。 i := 1 是 init statement。i &lt;= 5 是 condition statement，它是 bool expression，當它等於 false 的時候，迴圈結束。i++ 是 post statement。 123for i := 1; i &lt;= 5; i++ &#123; sum += i&#125; 如何 break 一個 for 迴圈？ 使用 break 就可以 break for 迴圈，for 的 init statement 可以在前面定義，post statement 可以放到 for 回圈的最後面，condition statement 也可以放到 for 裡面，如果不使用 break，那麼這個 for 迴圈就會變成無限迴圈，只能用戶手動停止。 123456789101112131415161718192021package mainimport &quot;fmt&quot;func main() &#123; var ( sum int i = 1 ) for &#123; if i &gt; 5 &#123; break &#125; sum += i fmt.Println(i, &quot;--&gt;&quot;, sum) i++ &#125; fmt.Println(sum)&#125; 如何 continue 一個 for 迴圈？ continue 可以離開當前的步驟，並繼續下一次的迴圈。 123456789101112131415161718192021222324252627282930313233package mainimport &quot;fmt&quot;func main() &#123; var ( sum int i = 1 ) for &#123; if i &gt; 10 &#123; break &#125; if i % 2 != 0 &#123; i++ continue &#125; sum += i fmt.Println(i, &quot;--&gt;&quot;, sum) i++ &#125; fmt.Println(sum)&#125;====OUTPUT====2 --&gt; 24 --&gt; 66 --&gt; 128 --&gt; 2010 --&gt; 3030 如何建立一個乘法表？ 這裡會使用巢狀迴圈(nested loop)，把迴圈放在迴圈裡。乘法表範例如下。 12345678910111213141516171819202122232425262728293031package mainimport &quot;fmt&quot;const max = 5func main() &#123; fmt.Printf(&quot;%5s&quot;, &quot;X&quot;) for i := 0; i &lt;= max; i++ &#123; fmt.Printf(&quot;%5d&quot;, i) &#125; fmt.Println() for i := 0; i &lt;= max; i++ &#123; fmt.Printf(&quot;%5d&quot;, i) for j := 0; j &lt;= max; j++ &#123; fmt.Printf(&quot;%5d&quot;, i*j) &#125; fmt.Println() &#125;&#125;====OUTPUT==== X 0 1 2 3 4 5 0 0 0 0 0 0 0 1 0 1 2 3 4 5 2 0 2 4 6 8 10 3 0 3 6 9 12 15 4 0 4 8 12 16 20 5 0 5 10 15 20 25 如何用迴圈把 slice 跑一遍？ 把 slice 用 for 迴圈跑一遍。 123456789101112131415161718package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; for i := 1; i &lt; len(os.Args); i++ &#123; fmt.Printf(&quot;%q\\n&quot;, os.Args[i]) &#125;&#125;====EXECUTE====go run main.go hi hello hey====OUTPUT====&quot;hi&quot;&quot;hello&quot;&quot;hey&quot; strings.Fields 可以把 string 用空格區隔並輸出成 slice，變成 slice 之後就沒有名字，你只能透過 words[index] 來取得值。%-2d 可以用來調整位置，%-2d 就是靠左排列，會顯示 d ，如果是 %2d 就會靠右排列，會顯示 d。 1234567891011121314package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() &#123; words := strings.Fields(&quot;lazy cat jumps again and again and again&quot;) for j := 0; j &lt; len(words); j++ &#123; fmt.Printf(&quot;#%-2d: %q\\n&quot;, j+1, words[j]) &#125;&#125; For Range For Range 用來對 slice 跑迴圈是最簡單的方式，但是它不只能用在 slice，還可以用在 array, string, map 和 channel，後面會說到。這邊有用到一個進階的方法，os.Args[1:]，這個方法會建立一個新的 slice，然後省略掉第一個值。 123456789101112package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; for _, v := range os.Args[1:] &#123; fmt.Printf(&quot;%q\\n&quot;, v) &#125;&#125; 用 for range 跟 for 相比，更方便把變數提到外面，即使在迴圈之外，也可以使用這些變數。 123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() &#123; words := strings.Fields(&quot;lazy cat jumps again and again and again&quot;) var ( i int v string ) for i, v = range words &#123; fmt.Printf(&quot;#%-2d: %q\\n&quot;, i+1, v) &#125; fmt.Printf(&quot;Last value of i is %d q = %q\\n&quot;, i, v)&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://vincent.fishboneapps.com/tags/Golang/"}]},{"title":"Golang 快速學習自我挑戰 Day4","slug":"Golang-快速學習自我挑戰-Day4","date":"2021-07-23T14:59:50.000Z","updated":"2021-07-31T01:50:23.541Z","comments":true,"path":"2021/07/23/Golang-快速學習自我挑戰-Day4/","link":"","permalink":"https://vincent.fishboneapps.com/2021/07/23/Golang-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day4/","excerpt":"","text":"章節一 Switch Statement switch statement 和 if statement 很像，但是有不同的語法。 city 是 condition expression，它非常重要因為它控制了 case 語法的 condition。如果 city 等於 case 裡面的內容（等同於 if city == “Paris”），就會執行 case 裡面的 block。 1234switch city &#123; case &quot;Paris&quot;: fmt.Println(&quot;France&quot;)&#125; 在 Go 裡面，Switch 背後的機制其實就是 if else。 1234567891011121314151617181920212223package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; city := os.Args[1] switch city &#123; case &quot;Paris&quot;: fmt.Println(&quot;France&quot;) case &quot;Tokyo&quot;: fmt.Println(&quot;Japan&quot;) &#125; if city == &quot;Paris&quot; &#123; fmt.Println(&quot;France&quot;) &#125; else if city == &quot;Tokyo&quot; &#123; fmt.Println(&quot;Japan&quot;) &#125;&#125; 使用 switch statement 有兩個原則。 case 不能重複。 switch 的變數和 case 裡面的值必須要是可以比較的，也就是說型別要相同。 如果你先學了其它的語言，你會發現為什麼不用 break，事實上，Go 有 break 這個語法，但是不是必要的。 如果在 case block 裡面新增的變數，在外面是不能使用的。 123456789101112131415161718192021222324package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; city := os.Args[1] switch city &#123; case &quot;Paris&quot;: fmt.Println(&quot;France&quot;) vip := true // It&#x27;s working fmt.Println(&quot;VIP trip?&quot;, vip) case &quot;Tokyo&quot;: fmt.Println(&quot;Japan&quot;) // can&#x27;t work fmt.Println(&quot;VIP trip?&quot;, vip) &#125; // can&#x27;t work, either fmt.Println(&quot;VIP trip?&quot;, vip)&#125; 什麼是 default clause 如果 switch statement 找不到相符資料的時候，就會跑 default 的地方，跟 case clause 一樣，default 也只能有一個。 12345678910111213141516171819package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; city := os.Args[1] switch city &#123; case &quot;Paris&quot;: fmt.Println(&quot;France&quot;) case &quot;Tokyo&quot;: fmt.Println(&quot;Japan&quot;) default: fmt.Println(&quot;Where?&quot;) &#125;&#125; default 的位置可以隨便擺放，結果會是一樣的。 1234567891011121314151617181920212223package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; city := os.Args[1] switch city &#123; default: fmt.Println(&quot;Where?&quot;) case &quot;Paris&quot;: fmt.Println(&quot;France&quot;) case &quot;Tokyo&quot;: fmt.Println(&quot;Japan&quot;) &#125;&#125;====EXECUTE====go run main.go Paris====OUTPUT====France 使用很多值在一個 case condition 如果要在一個 case condition 添加很多值，只要加上 , 和想要的值就可以了，這個背後使用的概念就是 if city == &quot;Paris || city == &quot;Lyon&quot;。 12345678910111213141516171819package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; city := os.Args[1] switch city &#123; case &quot;Paris&quot;, &quot;Lyon&quot;: fmt.Println(&quot;France&quot;) case &quot;Tokyo&quot;: fmt.Println(&quot;Japan&quot;) default: fmt.Println(&quot;Where?&quot;) &#125;&#125; 在 case condition 使用 bool expression 這邊的 i &gt; 0 的結果是 bool，所以可以跟 switch 的 true 放在一起。 12345678switch true &#123;case i &gt; 0: fmt.Println(&quot;positive&quot;)case i &lt; 0: fmt.Println(&quot;negative&quot;)default: fmt.Println(&quot;zero&quot;)&#125; switch 後面默認就是 true，所以可以簡化成以下內容，結果會是一樣的。 12345678switch &#123;case i &gt; 0: fmt.Println(&quot;positive&quot;)case i &lt; 0: fmt.Println(&quot;negative&quot;)default: fmt.Println(&quot;zero&quot;)&#125; fallthrough statement 是如何運作的？ fallthrough statement 就是直接跳過 condition 檢查，直接進去下一個 case block 裡面。事實上，真實情境很少使用到 fallthrough，但是有些情況下他卻很好用。 1234567891011121314151617181920package mainimport &quot;fmt&quot;func main() &#123; i := 142 switch &#123; case i &gt; 100: fmt.Print(&quot;big &quot;) fallthrough case i &gt; 0: fmt.Print(&quot;positive &quot;) fallthrough default: fmt.Print(&quot;number\\n&quot;) &#125;&#125;====OUTPUT====big positive number 什麼是 short switch? short switch 和 short if 很像。把剛剛上面的程式碼，縮減成下面的程式碼。i := 10 稱為 simple statement，裡面可以放置各種 simple statement，例如：i = 10, i++, i--，甚至可以放 func func call() 等等。 12345678switch i := 10; true &#123;case i &gt; 0: fmt.Println(&quot;positive&quot;)case i &lt; 0: fmt.Println(&quot;negative&quot;)default: fmt.Println(&quot;zero&quot;)&#125; 在 simple statement，true 一樣可以省略掉。 12345678switch i := 10; &#123;case i &gt; 0: fmt.Println(&quot;positive&quot;)case i &lt; 0: fmt.Println(&quot;negative&quot;)default: fmt.Println(&quot;zero&quot;)&#125; 小挑戰：Parts of a Day 題目 12345如果系統時間是早上，要顯示『Good morning』。如果系統時間是下午，要顯示『Good afternoon』。如果系統時間是傍晚，要顯示『Good evening』。如果系統時間是晚上，要顯示『Good night』。要使用 time package。 答案 12345678910111213141516171819package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; switch h := time.Now().Hour(); &#123; case h &gt;= 18: fmt.Println(&quot;Good evening&quot;) case h &gt;= 12: fmt.Println(&quot;Good afternoon&quot;) case h &gt;= 6: fmt.Println(&quot;Good morning&quot;) default: fmt.Println(&quot;Good night&quot;) &#125;&#125; if vs switch，要用哪一個？ 如果你有像範例一樣很難閱讀的 if statement，就要改用 switch statement。 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; if len(os.Args) != 2 &#123; fmt.Println(&quot;Gimme a month name&quot;) &#125; m := os.Args[1] if m == &quot;Dec&quot; || m == &quot;Jan&quot; || m == &quot;Feb&quot; &#123; fmt.Println(&quot;Winter&quot;) &#125; else if m == &quot;Mar&quot; || m == &quot;Apr&quot; || m == &quot;May&quot; &#123; fmt.Println(&quot;Spring&quot;) &#125; else if m == &quot;Jun&quot; || m == &quot;Jul&quot; || m == &quot;Aug&quot; &#123; fmt.Println(&quot;Summer&quot;) &#125; else if m == &quot;Sep&quot; || m == &quot;Oct&quot; || m == &quot;Nov&quot; &#123; fmt.Println(&quot;Fall&quot;) &#125; else &#123; fmt.Printf(&quot;%q is not the month.\\n&quot;, m) &#125;&#125; 改用 switch statement。 123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; if len(os.Args) != 2 &#123; fmt.Println(&quot;Gimme a month name&quot;) &#125; m := os.Args[1] switch m &#123; case &quot;Dec&quot;, &quot;Jan&quot;, &quot;Feb&quot;: fmt.Println(&quot;Winter&quot;) case &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;: fmt.Println(&quot;Spring&quot;) case &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;: fmt.Println(&quot;Summer&quot;) case &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;: fmt.Println(&quot;Fall&quot;) default: fmt.Printf(&quot;%q is not the month.\\n&quot;, m) &#125;&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://vincent.fishboneapps.com/tags/Golang/"}]},{"title":"Golang 快速學習自我挑戰 Day3","slug":"Golang-快速學習自我挑戰-Day3","date":"2021-07-22T15:07:43.000Z","updated":"2021-07-31T01:50:29.939Z","comments":true,"path":"2021/07/22/Golang-快速學習自我挑戰-Day3/","link":"","permalink":"https://vincent.fishboneapps.com/2021/07/22/Golang-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day3/","excerpt":"","text":"章節一 IF statement Go 裡面的 if statement 不需要括號，直接在 if 後面輸入你的條件就可以了。 1234567891011package mainimport &quot;fmt&quot;func main() &#123; score, valid := 5, true if score &gt; 3 &amp;&amp; valid &#123; fmt.Println(&quot;good&quot;) &#125;&#125; Else 和 Else if else if 是可以無限新增的，不一定要有，else 只能用一遍，但是也不一定要有。 1234567891011121314151617package mainimport &quot;fmt&quot;func main() &#123; score := 2 if score &gt; 3 &#123; fmt.Println(&quot;good&quot;) &#125; else if score == 3 &#123; fmt.Println(&quot;on the edge&quot;) &#125; else if score == 2 &#123; fmt.Println(&quot;meh...&quot;) &#125; else &#123; fmt.Println(&quot;low&quot;) &#125;&#125; 小挑戰：驗證一個單一用戶 題目 12345678910111213141516171819202122CHALLENGE #1Create a user/password protected program.EXAMPLE USERusername: jackpassword: 1888EXPECTED OUTPUTgo run main.goUsage: [username] [password]go run main.go albertUsage: [username] [password]go run main.go hacker 42Access denied for &quot;hacker&quot;.go run main.go jack 6475Invalid password for &quot;jack&quot;.go run main.go jack 1888Access granted to &quot;jack&quot;. 答案 12345678910111213141516171819202122232425262728293031323334package mainimport ( &quot;fmt&quot; &quot;os&quot;)const ( usage = &quot;Usage: [username] [password]&quot; errUser = &quot;Access denied for %q.\\n&quot; errPwd = &quot;Invalid password for %q.\\n&quot; accessOK = &quot;Access granted to %q.\\n&quot; user = &quot;jack&quot; pass = &quot;1888&quot;)func main() &#123; args := os.Args if len(args) != 3 &#123; fmt.Println(usage) return &#125; u, p := args[1], args[2] if u != user &#123; fmt.Printf(errUser, u) &#125; else if p != pass &#123; fmt.Printf(errPwd, u) &#125; else &#123; fmt.Printf(accessOK, u) &#125;&#125; 小挑戰：驗證多用戶 題目 12345678910111213141516171819202122232425262728CHALLENGE #2Add one more user to the PassMe program below.EXAMPLE USERSusername: jackpassword: 1888username: inancpassword: 1879EXPECTED OUTPUTgo run main.goUsage: [username] [password]go run main.go hacker 42Access denied for &quot;hacker&quot;.go run main.go jack 1888Access granted to &quot;jack&quot;.go run main.go inanc 1879Access granted to &quot;inanc&quot;.go run main.go jack 1879Invalid password for &quot;jack&quot;.go run main.go inanc 1888Invalid password for &quot;inanc&quot;. 答案 123456789101112131415161718192021222324252627282930313233343536package mainimport ( &quot;fmt&quot; &quot;os&quot;)const ( usage = &quot;Usage: [username] [password]&quot; errUser = &quot;Access denied for %q.\\n&quot; errPwd = &quot;Invalid password for %q.\\n&quot; accessOK = &quot;Access granted to %q.\\n&quot; user, user2 = &quot;jack&quot;, &quot;inanc&quot; pass, pass2 = &quot;1888&quot;, &quot;1879&quot;)func main() &#123; args := os.Args if len(args) != 3 &#123; fmt.Println(usage) return &#125; u, p := args[1], args[2] if u != user &amp;&amp; u !=user2 &#123; fmt.Printf(errUser, u) &#125; else if u == user &amp;&amp; p == pass &#123; fmt.Printf(accessOK, u) &#125; else if u == user2 &amp;&amp; p == pass2 &#123; fmt.Printf(accessOK, u) &#125; else &#123; fmt.Printf(errPwd, u) &#125;&#125; 什麼是 nil 值？ nil 值表示的是值尚未初始化。 nil 很常被用在錯誤處理，範例展示 nil 用在錯誤處理。 12345678910err := do()if err != nil &#123; // error // handle it! // terminate!&#125;// success// continue... 什麼是錯誤值？ 如果 error value 是 nil，表示成功，如果有錯誤，就千萬不要用回傳的值，因為是錯誤的。所以當 function 回傳 error value，一定要處理它。 123456789101112131415161718192021222324package mainimport ( &quot;fmt&quot; &quot;os&quot; &quot;strconv&quot;)func main() &#123; n, err := strconv.Atoi(os.Args[1]) fmt.Println(&quot;Converted number:&quot;, n) fmt.Println(&quot;Returned error value:&quot;, err)&#125;====EXECUTE====go run main.go 42====OUTPUT====Converted number: 42Returned error value: &lt;nil&gt;====EXECUTE====go run main.go hahaha====OUTPUT====Converted number: 0Returned error value: strconv.Atoi: parsing &quot;hahaha&quot;: invalid syntax 錯誤處理範例 用 if, else 就可以簡單地做錯誤處理。 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot; &quot;os&quot; &quot;strconv&quot;)func main() &#123; age := os.Args[1] n, err := strconv.Atoi(age) if err != nil &#123; fmt.Println(&quot;Error:&quot;, err) return &#125; fmt.Printf(&quot;SUCCESS: Converted %q to %d.\\n&quot;, age, n)&#125;====EXECUTE====go run main.go 42====OUTPUT====SUCCESS: Converted &quot;42&quot; to 42.====EXECUTE====go run main.go hello====OUTPUT====Error: strconv.Atoi: parsing &quot;hello&quot;: invalid syntax 挑戰：轉換 Feet 為 Meter 題目 12345678====EXECUTE====go run main.go hello====OUTPUT====error: &quot;hello&quot; is not the number.====EXECUTE====go run main.go 100====OUTPUT====100 feet is 30.48 meters. 答案。另外測試小數點和科學數字都是可以轉換的。 12345678910111213141516171819202122232425262728package mainimport ( &quot;fmt&quot; &quot;os&quot; &quot;strconv&quot;)func main() &#123; arg := os.Args[1] feet, err := strconv.ParseFloat(arg, 64) if err != nil &#123; fmt.Printf(&quot;err: %q is not the number.\\n&quot;, arg) return &#125; meters := feet * 0.3048 fmt.Printf(&quot;%g feet is %g meters.\\n&quot;, feet, meters)&#125;====EXECUTE====go run main.go .5====OUTPUT====0.5 feet is 0.1524 meters.====EXECUTE====go run main.go 1e3====OUTPUT====1000 feet is 304.8 meters. 什麼是 Simple Statement(Short Statement)? Short if：轉換成 short if 之後，裡面的 n 和 err 只能在這邊的 if 和接下來的 branches 使用。 123456789n, err := strconv.Atoi(&quot;42&quot;)if err == nil &#123; fmt.Println(&quot;There was no error, n is&quot;, n)&#125;====轉換成 short if====if n, err := strconv.Atoi(&quot;42&quot;); err == nil &#123; fmt.Println(&quot;There was no error, n is&quot;, n)&#125; Simple Statement 的 Scope 前面有 declare 的變數，後面才能使用，也不能在 if statement 之外的地方使用。 1234567891011121314151617181920package mainimport ( &quot;fmt&quot; &quot;os&quot; &quot;strconv&quot;)func main() &#123; if a := os.Args; len(a) != 2 &#123; // only a variable fmt.Println(&quot;Give me a number.&quot;) &#125; else if n, err := strconv.Atoi(a[1]); err != nil &#123; // only: a, n and err variables fmt.Printf(&quot;Cannot convert %q\\n&quot;, a[1]) &#125; else &#123; // all the variables in the if statement fmt.Printf(&quot;%s * 2 is %d\\n&quot;, a[1], n*2) &#125;&#125; 有名的 Shadowing 陷阱 Shadowing 是 Gopher 非常常陷入的陷阱。 如果在 if function 外面新增一個 n 和 err 的變數，在 if 裡面的變數，不會讓外面的變數改變，因為外面這個 n 被 if statement 的 n shadowed，所以如果要讓 if statement 裡面的值給外面讀到，要把 := 改成 = 就可以避免 shadowed 的問題，在 vs code 上面也可以安裝插件解決這個問題。 123456789101112131415161718192021222324package mainimport ( &quot;fmt&quot; &quot;os&quot; &quot;strconv&quot;)func main() &#123; var ( n int err error ) if a := os.Args; len(a) != 2 &#123; fmt.Println(&quot;Give me a number.&quot;) &#125; else if n, err := strconv.Atoi(a[1]); err != nil &#123; fmt.Printf(&quot;Cannot convert %q\\n&quot;, a[1]) &#125; else &#123; fmt.Printf(&quot;%s * 2 is %d\\n&quot;, a[1], n*2) &#125; fmt.Printf(&quot;n is %d. You&#x27;ve been shadowed\\n&quot;, n)&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://vincent.fishboneapps.com/tags/Golang/"}]},{"title":"Golang 快速學習自我挑戰 Day2","slug":"Golang-快速學習自我挑戰-Day2","date":"2021-07-21T11:52:07.000Z","updated":"2021-07-31T01:50:37.849Z","comments":true,"path":"2021/07/21/Golang-快速學習自我挑戰-Day2/","link":"","permalink":"https://vincent.fishboneapps.com/2021/07/21/Golang-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day2/","excerpt":"","text":"章節一 什麼是 Raw String Literal? 會分成三步驟學習：Raw String Literal, 字串的連結(Concatenation), 字串長度(String Length)。 String Literal，&quot;hi there, 星&quot;，使用雙引號只能有一行，而這邊會進行轉譯(interpreted)，如果有新的一行，Go 會轉換成一個新行字符。 Raw String Literal，使用抑音符(back quotes) 可以有多行，但是不會進行轉譯，你輸入什麼，它就顯示什麼。 12`hi there` 範例，整體來說，用 Raw String Literal，更好閱讀且方便。 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;func main() &#123; var s string s = &quot;how are you?&quot; fmt.Println(s) s = `how are you?` fmt.Println(s) s = &quot;&lt;html&gt;\\n\\t&lt;body&gt;\\&quot;Hello\\&quot;&lt;/body&gt;\\n&lt;/html&gt;&quot; fmt.Println(s) s = `&lt;html&gt; &lt;body&gt;&quot;Hello&quot;&quot;&lt;/body&gt;&lt;/html&gt;` fmt.Println(s) fmt.Println(&quot;c:\\\\my\\\\dir\\\\file&quot;) fmt.Println(`c:\\my\\dir\\file`)&#125; 如何取得 utf-8 的字串長度？ 你可以用 len 取得字串長度，不過只有英文字能取得字串長度，因為 len 真正的作用是取得字串有多少個 byte。 1234567891011package mainimport &quot;fmt&quot;func main() &#123; name := &quot;carl&quot; fmt.Println(len(name))&#125;====OUTPUT====4 Unicode 的字元每一個可以包含 1-4 個 byte。 1234567891011package mainimport &quot;fmt&quot;func main() &#123; name := &quot;王霆瑄&quot; fmt.Println(len(name))&#125;====OUTPUT====9 引入 utf8 套件的 RuneCountInString 可以計算字串長度，rune 可以計算英文字串和非英文字串。 1234567891011121314package mainimport ( &quot;fmt&quot; &quot;unicode/utf8&quot;)func main() &#123; name := &quot;王霆瑄&quot; fmt.Println(utf8.RuneCountInString(name))&#125;====OUTPUT====3 範例：BANGER 輸入一段字，返回這一段文字的大寫，並計算文字有幾個字之後，加上同樣數量的驚嘆號。 這邊會使用到 string package，提供操作 string 的實用函數。 範例答案 1234567891011121314151617package mainimport ( &quot;fmt&quot; &quot;os&quot; &quot;strings&quot;)func main() &#123; msg := os.Args[1] l := len(msg) s := msg + strings.Repeat(&quot;!&quot;, l) s = strings.ToUpper(s) fmt.Println(s)&#125; 實作題目：加上 “!” 到 argument 之前，如果輸入 hey，則返回 !!!HEY!!!，這邊只能使用一次 Repeat function。 123456789101112131415161718package mainimport ( &quot;fmt&quot; &quot;os&quot; &quot;strings&quot;)func main() &#123; msg := os.Args[1] l := len(msg) ex := strings.Repeat(&quot;!&quot;, l) s := ex + msg + ex s = strings.ToUpper(s) fmt.Println(s)&#125; 常數(Constant)和 iota iota 是 Go 裡面的常數產生器，可以自動加 1。 12345678910111213141516171819package mainimport &quot;fmt&quot;func main() &#123; const( monday = iota + 1 tuesday wednesday thursday friday saturday sunday ) fmt.Println(monday, tuesday, wednesday, thursday, friday, saturday, sunday)&#125;====OUTPUT====1 2 3 4 5 6 7 可以使用 _ 當作 blank identifier，來省略過你不需要用到的常數。 12345678910111213141516package mainimport &quot;fmt&quot;func main() &#123; const( EST = -(5 + iota) _ MST PST ) fmt.Println(EST, MST, PST)&#125;====OUTPUT====-5 -7 -8 Golang fmt 套件備忘單 Println vs Printf fmt.Printf(&quot;%q\\n&quot;, brand)，第一個 argument &quot;%q\\n&quot; 決定怎麼和如何 print，這邊的 %q 叫做 verb，而 Printf 會用第二個 argument 取代 verb，如果有更多的 verb，它就會傳送更多 value 給 verb 來去取代。這邊的 \\n 叫做 escape sequence，\\n 會產生新的行，像 Println 就會自動產生新的行，但是 Printf 不能產生新的行，所以要用 \\n 來產生新的行， 假設我要 print: total: 2350 success: 543 / 333。 Println 123fmt.Println( &quot;total&quot;, ops, &quot;success:&quot;, ok, &quot;/&quot;, fail,) Printf，%d 代表預期是 integer。 1234fmt.Printf( &quot;total: %d success: %d / %d\\n&quot;, ops, ok, fail,) 整體來說，Printf 更容易查看而且更容易使用。 什麼是 escape sequence? 用 \\n 可以換行，這邊的 \\n 是 escape sequence 而且是新增行的意思，如果取得 len，就會發現是 5，而不是 6，因為 \\n 是一個 character。 1234fmt.Printf(&quot;hi\\nhi&quot;)====OUTPUT====hihi 如果想要 print backslash，可以使用 \\\\。 如果想要 print 雙引號，可以使用 \\&quot;。 Escape sequence 有順序問題，比方說，&quot;hi\\\\n\\&quot;hi\\&quot;&quot;，結果會是 hi\\n&quot;hi&quot;，中間的 \\n 就會不會換行，因為前面有 \\\\。 如何使用 Printf? 你可以使用 Printf print 值的類型，%T 就是類型。 1234567891011121314151617181920package mainimport &quot;fmt&quot;func main() &#123; var speed int var heat float64 var off bool var brand string fmt.Printf(&quot;%T\\n&quot;, speed) fmt.Printf(&quot;%T\\n&quot;, heat) fmt.Printf(&quot;%T\\n&quot;, off) fmt.Printf(&quot;%T\\n&quot;, brand)&#125;====OUTPUT====intfloat64boolstring 可以使用 Argument index 來取得 Printf 的 argument，起始值是 1。 12345678910111213141516171819202122232425262728package mainimport &quot;fmt&quot;func main() &#123; var ( planet = &quot;venes&quot; distance = 261 orbital = 224.701 hasLife = false ) fmt.Printf(&quot;Planet: %v\\n&quot;, planet) fmt.Printf(&quot;Distance: %v millions kms\\n&quot;, distance) fmt.Printf(&quot;Orbital Period: %v days\\n&quot;, orbital) fmt.Printf(&quot;Does %v has life? %v\\n&quot;, planet, hasLife) fmt.Printf( &quot;%v is %v away. Think! %[2]v kms! %[1]v OMG!\\n&quot;, planet, distance, )&#125;====OUTPUT====Planet: venesDistance: 261 millions kmsOrbital Period: 224.701 daysDoes venes has life? falsevenes is 261 away. Think! 261 kms! venes OMG! Verb 可以做型別保護 %s 代表 string，%d 代表 integer，%f 代表 float，%t 代表 boolean，使用型別保護可以避免錯誤，建議使用對應的型別 verb，而不是 %v。 1234567891011121314151617package mainimport &quot;fmt&quot;func main() &#123; var ( planet = &quot;venes&quot; distance = 261 orbital = 224.701 hasLife = false ) fmt.Printf(&quot;Planet: %s\\n&quot;, planet) fmt.Printf(&quot;Distance: %d millions kms\\n&quot;, distance) fmt.Printf(&quot;Orbital Period: %f days\\n&quot;, orbital) fmt.Printf(&quot;Does %s has life? %t\\n&quot;, planet, hasLife)&#125; %.0f，這邊的 0 表示精度，如果精度越高顯示越多數字，如以下範例。 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;func main() &#123; var ( orbital = 224.701 ) fmt.Printf(&quot;Orbital Period: %.0f days\\n&quot;, orbital) fmt.Printf(&quot;Orbital Period: %.1f days\\n&quot;, orbital) fmt.Printf(&quot;Orbital Period: %.2f days\\n&quot;, orbital) fmt.Printf(&quot;Orbital Period: %.3f days\\n&quot;, orbital) fmt.Printf(&quot;Orbital Period: %.4f days\\n&quot;, orbital) fmt.Printf(&quot;Orbital Period: %.5f days\\n&quot;, orbital)&#125;====OUTPUT====Orbital Period: 225 daysOrbital Period: 224.7 daysOrbital Period: 224.70 daysOrbital Period: 224.701 daysOrbital Period: 224.7010 daysOrbital Period: 224.70100 days","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://vincent.fishboneapps.com/tags/Golang/"}]},{"title":"Golang 快速學習自我挑戰 Day1","slug":"Golang-快速學習自我挑戰-Day1","date":"2021-07-19T10:47:56.000Z","updated":"2021-07-31T01:50:43.091Z","comments":true,"path":"2021/07/19/Golang-快速學習自我挑戰-Day1/","link":"","permalink":"https://vincent.fishboneapps.com/2021/07/19/Golang-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day1/","excerpt":"","text":"章節一 安裝 Go 環境 安裝Go環境教學 變數介紹 你必須要先定義變數才能夠使用它，所以你不能直接給一個未定義的變數一個值，因為它不存在。 在 Dynamic Programming 裡面，你可以在還沒定義變數之前，直接給它值，這樣很好用，但是對後面的程式碼維護並不容易。 var speed int var 就是 variable 的簡稱，宣告變數一定要輸入這個 Keyword。 speed 就是變數的名字，又稱為「identifier」，這是一個獨一無二的名字，用來讓 Go 了解你在提到哪個變數。 在電腦科學裡面，兩件事情是最困難的，cache invalidation 和 naming，以下說的命名原則可以適用到 function name, package name…等等。 Go 可以這樣命名，下面是命名範例，真實情境不一定會這樣使用。 var speed int var SpeeD int var _speed int var 速度 int (unicode 是可以的) Go 不能這樣命名，這些原則是為了避免模稜兩可的命名 字首不能是數字 var 3speed int 字首不能是標點符號 var !speed int 變數不能包含標點符號，var spe!ed int，因為標點符號在 Go 裡面有特殊意義，它讓 Go 編譯器更容易辨識名字。 變數不能包含 Go Keywords var var int，Go 不允許你覆寫他的 keywords。 int 是變數的類型，int 是 integer 的簡稱，在 Go 裡面，所有的變數和值都有類型，因為 Go 是強型別語言(Strongly Typed Programming Language)。它比較像 C, C#, Java，它幫助你在編譯的時候就找到問題。 變數類型決定什麼樣的值可以儲存在這個變數，還有哪邊可以使用這個變數。 一旦你指定了變數的類型，你就不能改變它，它是固定的。 宣告變數的範例，在宣告變數的時候，如果是 integer 的話，初始值會是 0。 1234567891011package mainimport &quot;fmt&quot;func main() &#123; var speed int fmt.Println(speed)&#125;====OUTPUT====0 範例：Path Separator 你會學到三樣東西。 使用 Go 標準套件(stdlib) - path 學習如何賦值給表達式回傳的多個值 拋棄其中一個值(blank-identifier) path 套件提供實用的功能來處理 url string 路徑。 範例 123456789101112131415161718package mainimport ( &quot;fmt&quot; &quot;path&quot;)func main() &#123; var dir, file string dir, file = path.Split(&quot;css/main.css&quot;) fmt.Println(&quot;dir: &quot;, dir) fmt.Println(&quot;file: &quot;, file)&#125;====OUTPUT====dir: css/file: main.css 如果你想拋棄回傳回來的值，用 _ 來賦空值。 12345678910111213141516package mainimport ( &quot;fmt&quot; &quot;path&quot;)func main() &#123; var file string _, file = path.Split(&quot;css/main.css&quot;) fmt.Println(&quot;file: &quot;, file)&#125;====OUTPUT====file: main.css 你也可以使用 := (short declaration) 直接將表達式回傳的值直接變成一個變數。 1234567891011121314package mainimport ( &quot;fmt&quot; &quot;path&quot;)func main() &#123; _, file := path.Split(&quot;css/main.css&quot;) fmt.Println(&quot;file: &quot;, file)&#125;====OUTPUT====file: main.css 什麼時候使用 short declaration 什麼時候使用 normal declaration? 如果你不知道初始值，你就用 normal declaration，這是 Go 社群的傳統，建議你跟隨這個傳統，這樣大家就可以輕鬆地了解你的程式碼。 123456package mainfunc main() &#123; score := 0 // DON&#x27;T! var score int // already score = 0&#125; 當你需要 package scoped 變數。 1234package mainversion := 0 // DON&#x27;T!var version string // Good 當你想要將變數組合在一起增強可讀性。 123456789101112package mainfunc main() &#123; var ( // related: video string // closely related: duration int current int )&#125; 什麼時候使用 short declaration，我們最常使用 short declaration，因為 Go 喜歡精簡的語法。 如果你知道初始值，就用 short declaration。 123456package mainfunc main() &#123; var width, height = 100, 50 // DON&#x27;T width, height := 100, 50 // Good&#125; 讓程式碼保持精簡 為了 redeclaration，redeclaration 是禮物也是詛咒，會 shadowing 已經 declaration 的變數(後面會說到)。 123456789package mainfunc main() &#123; // DON&#x27;T width = 50 // assigns 50 to width color := &quot;red&quot; // new variable: color width, color := 50, &quot;red&quot; // Good, same as above&#125; 轉換值 型別轉換：用另外一個型態改變一個值的型態。 轉換型別可能形成破壞性的操作，2.5 轉換成 int 之後，會變成 2。 1234567891011121314package mainimport &quot;fmt&quot;func main() &#123; speed := 100 // speed is int force := 2.5 // force is float64 speed = speed * int(force) fmt.Println(speed)&#125;====OUTPUT====200 以下範例操作型別轉換之後就會是正確的，因為 speed 轉換成 100.0，然後乘以 2.5 會等於 250.0，最後 250.0 轉換成 int 之後，就會得到 250，而且它正是 int，所以可以正確輸出。 1234567891011121314package mainimport &quot;fmt&quot;func main() &#123; speed := 100 // speed is int force := 2.5 // force is float64 speed = int( float64(speed) * force ) fmt.Println(speed)&#125;====OUTPUT====250 取得命令列的輸入 要從命令列取得輸入，要用名為 os 的 Go 套件。 os 套件裡面的 Args，當你運行 go 的時候，Go 會自動將輸入的 Arguments 變成變數。 var Args []string，這邊要講到 slice 的概念，但是這邊的 slice 只是簡單的說，後面會有一個詳細的章節。 []string Args 的類型是『slice of strings』，意思是 Args 可以儲存一連串的 string 在裡面。變數只能儲存單一值，slice 可以儲存很多值，但是 slice 它自己本質上是單一值。 在 slice 的每一個值都是未命名的變數，所以要如何在 slice 取得沒有名字的變數呢？要用 index expression 來取得變數。 go main.go hi yo，用空格來區別 arguments，這邊的 hi 和 yo 是兩個 arguments。 Args[0]，儲存程式的路徑，它是一個暫時的路徑，ex: …/exe/main Args[1]，第一個 argument，所以就是 hi Args[2]，第二個 argument，所以就是 yo 學習 os.Args 的基礎 執行範例，了解 os.Args 和 len 的用法。 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; fmt.Printf(&quot;%#v\\n&quot;, os.Args) fmt.Println(&quot;Path&quot;, os.Args[0]) fmt.Println(&quot;1st Argument:&quot;, os.Args[1]) fmt.Println(&quot;2nd Argument:&quot;, os.Args[2]) fmt.Println(&quot;3rd Argument:&quot;, os.Args[3]) fmt.Println(&quot;Number of items inside os.Args&quot;, len(os.Args))&#125;====EXECUTE====go run go.main====OUTPUT====[]string&#123;&quot;/var/folders/3n/qn9m57sn0jq8h3pxfb11wq_m0000gn/T/go-build3944444413/b001/exe/main&quot;, &quot;hi&quot;, &quot;hello&quot;, &quot;hey&quot;&#125;Path: /var/folders/3n/qn9m57sn0jq8h3pxfb11wq_m0000gn/T/go-build3944444413/b001/exe/main1st Argument: hi2nd Argument: hello3rd Argument: heyNumber of items inside os.Args: 4 封裝上面的範例。 12345678910====EXECUTE====go build -o greeter./greeter hi hello hey====OUTPUT====[]string&#123;&quot;./greeter&quot;, &quot;hi&quot;, &quot;hello&quot;, &quot;hey&quot;&#125;Path: ./greeter1st Argument: hi2nd Argument: hello3rd Argument: heyNumber of items inside os.Args: 4 命名方式（推薦） 非慣用的命名方式。 123456789101112func Read(buffer *Buffer, inBuffer []byte) (size int, err error) &#123; if buffer.empty() &#123; buffer.Reset &#125;&#125;size = copy( inBuffer, buffer.buffer[buffer.offset:])buffer.offset += sizereturn size, nil 慣用的命名方式。 12345678910func Read(b *Buffer, p []byte) (n int, err error) &#123; if b.empty() &#123; b.Reset &#125;&#125;n = copy(p, b.buffer[b.off:])b.off += nreturn n, nil 很多人批評 Go 的命名神秘難解，那是因為讀太少 Go 的程式碼，多讀一點標準函式庫的 Go 程式碼，能夠幫助你理解這些命名傳統。以下是常用的簡寫。 123456789101112131415161718192021222324252627282930var s string // stringvar i int // indexvar num int // numbervar msg string // messagevar v string // valuevar val string // valuevar fv string // flag valuevar err error // error valuevar args []string // argumentsvar seen boolean // has seen?var parsed boolean // parsing ok?var buf [] byte // buffervar off int // offsetvar op int // operationvar opRead int // read operationvar l int // lengthvar n int // number or number ofvar m int // another numbervar c int // capacityvar c int // charactervar a int // arrayvar r rune // runevar sep string // separatorvar src int // sourcevar dst int // destinationvar b byte // bytevar b []byte // buffervar w io.Writer // writervar r io.Reader // readervar pos int // position 為什麼命名那麼重要？因為可讀性 = 可維護性。 使用單詞前面的第一個字母，ex: var fv string // flag value。 在小範圍裡面使用更少的字母。 12var bytesRead int // numbers of bytes read (NOT GOOD)var n int // numbers of bytes read (GOOD) 在大範圍的地方使用完整的文字表現意思。 12package filevar fileClosed bool 使用混合駝峰式（mixedCaps），使用 type PlayerScore struct 或是 type playerScore struct 都是可以的。 對縮寫詞（acronyms）使用全大寫。 12var localAPI string // GOODvar localApi string // NOT GOOD 不要結巴，也就是說不要重複的使用一個詞。12player.PlayerScore // NOT GOODplayer.Score // GOOD 不要在名字的地方使用底線。123const MAX_TIME int // NOT GOODconst MaxTime int // Goodconst N int // Still Good","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://vincent.fishboneapps.com/tags/Golang/"}]},{"title":"Java 快速學習自我挑戰 Day14","slug":"Java-快速學習自我挑戰-Day14","date":"2021-03-15T14:13:53.000Z","updated":"2021-03-16T09:33:09.056Z","comments":true,"path":"2021/03/15/Java-快速學習自我挑戰-Day14/","link":"","permalink":"https://vincent.fishboneapps.com/2021/03/15/Java-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day14/","excerpt":"","text":"Arrays、Java 內建 List、Autoboxing 和 Unboxing LinkedList LinkedList 是另外一種型態的 List。 Java 會為整數分配 4 位元的記憶體，基本上記憶體會連續排列，圖中可以看到 position 0 的位址是 100，position 1 的位址是 104，如果我想要找到 position 3 的位址，就 3*4=12，得知 position 3 的位址是 112。Double 則會分配 8 位元的記憶體。 String 跟原始型別不一樣，它的長度是可變的。圖中可以看到 String 的 Address 佔用的也是 8 位元的記憶體，但是他會指向 String 的位置。Java 最後可以追蹤到 String 所在的位置，並讀取它。最後圖中會讀取出來的 String 是 Tim Australia Java Hello World Done Array ArrayList。最後當程式停止之後，這些變數不需要了，會自動啟動一個 Java Garbage Collection 的程序，最後釋放記憶體。最後重要的一點是，String 的位址不一定要是連續的，就像 4000 跟其他數字差非常遠。 新增 Customer.java 12345678910111213141516171819202122232425public class Customer &#123; private String name; private double balance; public Customer(String name, double balance) &#123; this.name = name; this.balance = balance; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getBalance() &#123; return balance; &#125; public void setBalance(double balance) &#123; this.balance = balance; &#125;&#125; 修改 Main.java 1234567public static void main(String[] args) &#123; Customer customer = new Customer(&quot;Tim&quot;, 54.96); Customer anotherCustomer; anotherCustomer = customer; anotherCustomer.setBalance(12.18); System.out.println(&quot;Balance for customer &quot; + customer.getName() + &quot; is &quot; + customer.getBalance());&#125; 上面的輸出結果是 Balance for customer Tim is 12.18，為什麼修改 anotherCustomer 會影響到一開始的 customer 呢？因為指定 anotherCustomer = customer 的時候，他會指向同一個記憶體，最後修改 balance 的時候，其實是同一個地方，所以輸出的結果會是被修改後的 balance。 最下面的迴圈使用 add 之後，會出現 1, 2, 3, 4，原因是在 position 1 插入 2 之後，會將現有的值往後移動。 12345678910111213141516public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;(); intList.add(1); intList.add(3); intList.add(4); for (int i = 0; i &lt; intList.size(); i++) &#123; System.out.println(i + &quot;: &quot; + intList.get(i)); &#125; intList.add(1, 2); for (int i = 0; i &lt; intList.size(); i++) &#123; System.out.println(i + &quot;: &quot; + intList.get(i));&#125; LinkedList 在新增的時候，可以直接修改對應的位址，讓 LinkedList 直接插入在中間，移除也一樣，直接將對應的值改成下一個值，Java 就會自動把沒有背對應到的值放在 Java Garbage Collection。 新增 Demo.java，這邊可以測試出新增和刪除所出現的內容和排序，使用 Iterator 來進行迴圈功能。 12345678910111213141516171819202122232425262728public class Demo &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; placesToVisit = new LinkedList&lt;String&gt;(); placesToVisit.add(&quot;Sydney&quot;); placesToVisit.add(&quot;Melbourne&quot;); placesToVisit.add(&quot;Brisbane&quot;); placesToVisit.add(&quot;Perth&quot;); placesToVisit.add(&quot;Canberra&quot;); placesToVisit.add(&quot;Adelaide&quot;); placesToVisit.add(&quot;Darwin&quot;); printList(placesToVisit); placesToVisit.add(1, &quot;Alice Springs&quot;); printList(placesToVisit); placesToVisit.remove(4); printList(placesToVisit); &#125; private static void printList(LinkedList&lt;String&gt; linkedList) &#123; Iterator&lt;String&gt; i = linkedList.iterator(); while (i.hasNext()) &#123; System.out.println(&quot;Now visiting &quot; + i.next()); &#125; System.out.println(&quot;===========================&quot;); &#125;&#125; 將 cities 都列出，如果換方向的話，就會重複出現地名，所以我們這邊會使用 goingForward 來確定查詢的方向，避免方向不同而出現重複地名的問題。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public class Demo &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; placesToVisit = new LinkedList&lt;String&gt;(); addInOrder(placesToVisit, &quot;Sydney&quot;); addInOrder(placesToVisit, &quot;Melbourne&quot;); addInOrder(placesToVisit, &quot;Brisbane&quot;); addInOrder(placesToVisit, &quot;Perth&quot;); addInOrder(placesToVisit, &quot;Canberra&quot;); addInOrder(placesToVisit, &quot;Adelaide&quot;); addInOrder(placesToVisit, &quot;Darwin&quot;); printList(placesToVisit); addInOrder(placesToVisit, &quot;Alice Springs&quot;); addInOrder(placesToVisit, &quot;Darwin&quot;); printList(placesToVisit); visit(placesToVisit); &#125; private static void printList(LinkedList&lt;String&gt; linkedList) &#123; Iterator&lt;String&gt; i = linkedList.iterator(); while (i.hasNext()) &#123; System.out.println(&quot;Now visiting &quot; + i.next()); &#125; System.out.println(&quot;===========================&quot;); &#125; private static boolean addInOrder(LinkedList&lt;String&gt; linkedList, String newCity) &#123; ListIterator&lt;String&gt; stringListIterator = linkedList.listIterator(); while (stringListIterator.hasNext()) &#123; int comparison = stringListIterator.next().compareTo(newCity); if (comparison == 0) &#123; // equal, do not add System.out.println(newCity + &quot; is already included as a destination&quot;); return false; &#125; else if (comparison &gt; 0) &#123; // new City should appear before this one // Brisbane -&gt; Adelaide stringListIterator.previous(); stringListIterator.add(newCity); return true; &#125; else if (comparison &lt; 0) &#123; // move on next city &#125; &#125; stringListIterator.add(newCity); return true; &#125; private static void visit(LinkedList&lt;String&gt; cities) &#123; Scanner scanner = new Scanner(System.in); boolean quit = false; boolean goingForward = true; ListIterator&lt;String&gt; listIterator = cities.listIterator(); if (cities.isEmpty()) &#123; System.out.println(&quot;No cities in the itinerary&quot;); return; &#125; else &#123; System.out.println(&quot;Now visiting &quot; + listIterator.next()); printMenu(); &#125; while (!quit) &#123; int action = scanner.nextInt(); scanner.nextLine(); switch (action) &#123; case 0: System.out.println(&quot;Holiday (Vacation) over&quot;); quit = true; break; case 1: if (!goingForward) &#123; if (listIterator.hasNext()) &#123; listIterator.next(); &#125; goingForward = true; &#125; if (listIterator.hasNext()) &#123; System.out.println(&quot;Now visiting &quot; + listIterator.next()); &#125; else &#123; System.out.println(&quot;Reached the end of the list&quot;); goingForward = false; &#125; break; case 2: if (goingForward) &#123; if (listIterator.hasPrevious()) &#123; listIterator.previous(); &#125; goingForward = false; &#125; if (listIterator.hasPrevious()) &#123; System.out.println(&quot;Now visiting &quot; + listIterator.previous()); &#125; else &#123; System.out.println(&quot;We are at the start of the list&quot;); goingForward = true; &#125; break; case 3: printMenu(); break; &#125; &#125; &#125; private static void printMenu() &#123; System.out.println(&quot;Available actions:\\npress&quot;); System.out.println(&quot;0 - to quit\\n&quot; + &quot;1 - go to next city\\n&quot; + &quot;2 - go to previous city\\n&quot; + &quot;3 - print menu cities&quot;); &#125;&#125; LinkedList 挑戰 題目 Create a program that implements a playlist of songs. To start you off, implement the following classes: 1. Album - It has three fields, two Strings called name and artist, and an ArrayList that holds objects of type Song called songs. - A constructor that accepts two Strings (name of the album and artist). It initialises the fields and instantiates songs. - And three methods, they are: - addSong(), has two parameters of type String (title of song), double (duration of song) and returns a boolean. Returns true if the song was added successfully or false otherwise. - findSong(), has one parameter of type String (title of song) and returns a Song. Returns the Song if it exists, null if it doesn’t exists. - addToPlayList(), has two parameters of type int (track number of song in album) and LinkedList (the playlist) that holds objects of type Song, and returns a boolean. Returns true if it exists and it was added successfully using the track number, or false otherwise. - addToPlayList(), has two parameters of type String (title of song) and LinkedList (the playlist) that holds objects of type Song, and returns a boolean. Returns true if it exists and it was added successfully using the name of the song, or false otherwise. 2. Song - It has two fields, a String called title and a double called duration. - A constructor that accepts a String (title of the song) and a double (duration of the song). It initialises title and duration. - And two methods, they are: - getTitle(), getter for title. - toString(), Songs overriding toString method. Returns a String in the following format: “title: duration” -&gt; SAMPLE INPUT 12345678910111213141516171819202122232425262728293031323334ArrayList&lt;Album&gt; albums = new ArrayList&lt;&gt;();Album album = new Album(&quot;Stormbringer&quot;, &quot;Deep Purple&quot;);album.addSong(&quot;Stormbringer&quot;, 4.6);album.addSong(&quot;Love don&#x27;t mean a thing&quot;, 4.22);album.addSong(&quot;Holy man&quot;, 4.3);album.addSong(&quot;Hold on&quot;, 5.6);album.addSong(&quot;Lady double dealer&quot;, 3.21);album.addSong(&quot;You can&#x27;t do it right&quot;, 6.23);album.addSong(&quot;High ball shooter&quot;, 4.27);album.addSong(&quot;The gypsy&quot;, 4.2);album.addSong(&quot;Soldier of fortune&quot;, 3.13);albums.add(album);album = new Album(&quot;For those about to rock&quot;, &quot;AC/DC&quot;);album.addSong(&quot;For those about to rock&quot;, 5.44);album.addSong(&quot;I put the finger on you&quot;, 3.25);album.addSong(&quot;Lets go&quot;, 3.45);album.addSong(&quot;Inject the venom&quot;, 3.33);album.addSong(&quot;Snowballed&quot;, 4.51);album.addSong(&quot;Evil walks&quot;, 3.45);album.addSong(&quot;C.O.D.&quot;, 5.25);album.addSong(&quot;Breaking the rules&quot;, 5.32);album.addSong(&quot;Night of the long knives&quot;, 5.12);albums.add(album);LinkedList&lt;Song&gt; playList = new LinkedList&lt;Song&gt;();albums.get(0).addToPlayList(&quot;You can&#x27;t do it right&quot;, playList);albums.get(0).addToPlayList(&quot;Holy man&quot;, playList);albums.get(0).addToPlayList(&quot;Speed king&quot;, playList); // Does not existalbums.get(0).addToPlayList(9, playList);albums.get(1).addToPlayList(3, playList);albums.get(1).addToPlayList(2, playList);albums.get(1).addToPlayList(24, playList); // There is no track 24 TIP: In Album, use the findSong() method in addSong() and addToPlayList(String, LinkedList) to check if a song exists before proceeding. TIP: Be extremely careful with the spelling of the names of the fields, constructors and methods. TIP: Be extremely careful about spaces and spelling in the returned String from the toString() method. NOTE: All fields are private. NOTE: All constructors are public. NOTE: All methods are public (except for findSong() which is private). NOTE: There are no static members. NOTE: Do not add a main method to the solution code. NOTE: If you get an error from the Evaluate class, it’s most likely the constructor. Check if you’ve added a constructor or if the constructor has the right arguments. 答案 新增 Album.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.ArrayList;import java.util.LinkedList;public class Album &#123; private String name; private String artist; private ArrayList&lt;Song&gt; songs; public Album(String name, String artist) &#123; this.name = name; this.artist = artist; this.songs = new ArrayList&lt;Song&gt;(); &#125; public boolean addSong(String title, double duration) &#123; if (findSong(title) == null) &#123; this.songs.add(new Song(title, duration)); return true; &#125; return false; &#125; private Song findSong(String title) &#123; for (Song checkedSong: this.songs) &#123; if (checkedSong.getTitle().equals(title)) &#123; return checkedSong; &#125; &#125; return null; &#125; public boolean addToPlayList(int trackNumber, LinkedList&lt;Song&gt; playlist) &#123; int index = trackNumber - 1; if ((index &gt;= 0) &amp;&amp; (index &lt;= this.songs.size())) &#123; playlist.add(this.songs.get(index)); return true; &#125; return false; &#125; public boolean addToPlayList(String title, LinkedList&lt;Song&gt; playlist) &#123; Song checkedSong = findSong(title); if (checkedSong != null) &#123; playlist.add(checkedSong); return true; &#125; return false; &#125;&#125; 新增 Song.java 123456789101112131415161718public class Song &#123; private String title; private double duration; public Song(String title, double duration) &#123; this.title = title; this.duration = duration; &#125; public String getTitle() &#123; return title; &#125; @Override public String toString() &#123; return this.title + &quot;: &quot; + this.duration; &#125;&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://vincent.fishboneapps.com/tags/Java/"}]},{"title":"Java 快速學習自我挑戰 Day13","slug":"Java-快速學習自我挑戰-Day13","date":"2021-01-28T02:24:57.000Z","updated":"2021-02-03T09:38:48.808Z","comments":true,"path":"2021/01/27/Java-快速學習自我挑戰-Day13/","link":"","permalink":"https://vincent.fishboneapps.com/2021/01/27/Java-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day13/","excerpt":"","text":"Arrays、Java 內建 List、Autoboxing 和 Unboxing List 和 ArrayList Array 如果需要變更長度，會需要變更 Array 的長度，但是重複做變更長度會很冗贅，所以這邊要講 List 中的 ArrayList，ArrayList 就是可以變更長度的 Array，ArrayList 還可以保存 Objects。 這邊用購物清單的功能做一個例子，先新增一個 GroceryList.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.ArrayList;public class GroceryList &#123; private ArrayList&lt;String&gt; groceryList = new ArrayList&lt;String&gt;(); public void addGroceryItem(String item) &#123; groceryList.add(item); &#125; public ArrayList&lt;String&gt; getGroceryList() &#123; return groceryList; &#125; public void printGroceryList() &#123; System.out.println(&quot;You have &quot; + groceryList.size() + &quot; itmes in your grocery list&quot;); for (int i = 0; i &lt; groceryList.size(); i++) &#123; System.out.println((i+1) + &quot;. &quot; + groceryList.get(i)); &#125; &#125; public void modifyGroceryItem(String currentItem, String newItem) &#123; int position = findItem(currentItem); if (position &gt;= 0) &#123; modifyGroceryItem(position, newItem); &#125; &#125; private void modifyGroceryItem(int position, String newItem) &#123; groceryList.set(position, newItem); System.out.println(&quot;Grocery item &quot; + (position + 1) + &quot; has been modified.&quot;); &#125; public void removeGroceryItem(String item) &#123; int position = findItem(item); if (position &gt;= 0) &#123; removeGroceryItem(position); &#125; &#125; private void removeGroceryItem(int position) &#123; groceryList.remove(position); &#125; private int findItem(String searchItem) &#123; return groceryList.indexOf(searchItem); &#125; public boolean onFile(String searchItem) &#123; int position = findItem(searchItem); return position &gt;= 0; &#125;&#125; 修改 Main.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import java.util.ArrayList;import java.util.Scanner;public class Main &#123; private static Scanner scanner = new Scanner(System.in); private static GroceryList groceryList = new GroceryList(); public static void main(String[] args) &#123; boolean quit = false; int choice = 0; printInstructions(); while(!quit) &#123; System.out.println(&quot;Enter your choice: &quot;); choice = scanner.nextInt(); scanner.nextLine(); switch (choice) &#123; case 0: printInstructions(); break; case 1: groceryList.printGroceryList(); break; case 2: addItem(); break; case 3: modifyItem(); break; case 4: removeItem(); break; case 5: searchForItem(); break; case 6: processArrayList(); case 7: quit = true; break; &#125; &#125; &#125; public static void printInstructions() &#123; System.out.println(&quot;\\nPress &quot;); System.out.println(&quot;\\t 0 - To print choice options.&quot;); System.out.println(&quot;\\t 1 - To print the list of grocery items.&quot;); System.out.println(&quot;\\t 2 - To add an item to the list.&quot;); System.out.println(&quot;\\t 3 - To modify an item in the list.&quot;); System.out.println(&quot;\\t 4 - To remove an item from the list.&quot;); System.out.println(&quot;\\t 5 - To search for an item in the list.&quot;); System.out.println(&quot;\\t 6 - To quit the application.&quot;); &#125; public static void addItem() &#123; System.out.print(&quot;Please enter the grocery item: &quot;); groceryList.addGroceryItem(scanner.nextLine()); &#125; public static void modifyItem() &#123; System.out.print(&quot;Current item name: &quot;); String itemNo = scanner.nextLine(); System.out.print(&quot;Enter new item: &quot;); String newItem = scanner.nextLine(); groceryList.modifyGroceryItem(itemNo, newItem); &#125; public static void removeItem() &#123; System.out.print(&quot;Enter item name: &quot;); String itemNo = scanner.nextLine(); groceryList.removeGroceryItem(itemNo); &#125; public static void searchForItem() &#123; System.out.print(&quot;Item to search for: &quot;); String searchItem = scanner.nextLine(); if (groceryList.onFile(searchItem)) &#123; System.out.println(&quot;Found &quot; + searchItem + &quot; in our grocery list&quot;); &#125; else &#123; System.out.println(searchItem + &quot; is not in the shopping list&quot;); &#125; &#125; // 三種 複製 ArrayList 的方法 public static void processArrayList() &#123; ArrayList&lt;String&gt; newArray = new ArrayList&lt;String&gt;(); newArray.addAll(groceryList.getGroceryList()); ArrayList&lt;String&gt; nextArray = new ArrayList&lt;String&gt;(groceryList.getGroceryList()); // 把 ArrayList 轉換成 Array String[] myArray = new String[groceryList.getGroceryList().size()]; myArray = groceryList.getGroceryList().toArray(myArray); &#125;&#125; ArrayList 挑戰 題目 Create a program that implements a simple mobile phone with the following capabilities. Able to store, modify, remove and query contact names. You will want to create a separate class for Contacts (name and phone number). Create a master class (MobilePhone) that holds the ArrayList of Contacts The MobilePhone class has the functionality listed above. Add a menu of options that are available. Options: Quit, print list of contacts, add new contact, update existing contact, remove contact and search/find contact. When adding or updating be sure to check if the contact already exists (use name) Be sure not to expose the inner workings of the Arraylist to MobilePhone e.g. no ints, no .get(i) etc MobilePhone should do everything with Contact objects only. 答案 新增 Contact.java 123456789101112131415161718192021public class Contact &#123; private String name; private String phoneNumber; public Contact(String name, String phoneNumber) &#123; this.name = name; this.phoneNumber = phoneNumber; &#125; public String getName() &#123; return name; &#125; public String getPhoneNumber() &#123; return phoneNumber; &#125; public static Contact createContact(String name, String phoneNumber) &#123; return new Contact(name, phoneNumber); &#125;&#125; 新增 MobilePhone.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;public class MobilePhone &#123; private String myNumber; private ArrayList&lt;Contact&gt; myContacts; public MobilePhone(String myNumber) &#123; this.myNumber = myNumber; this.myContacts = new ArrayList&lt;Contact&gt;(); &#125; public boolean addNewContact(Contact contact) &#123; if (findContact(contact.getName()) &gt;= 0) &#123; System.out.println(&quot;Contact is already on file&quot;); return false; &#125; myContacts.add(contact); return true; &#125; public boolean updateContact(Contact oldContact, Contact newContact) &#123; int foundPosition = findContact(oldContact); if (foundPosition &lt; 0) &#123; System.out.println(oldContact.getName() + &quot;, was not found.&quot;); return false; &#125; else if (findContact(newContact.getName()) != -1) &#123; System.out.println(&quot;Contact with name &quot; + newContact.getName() + &quot; already exist. Update was not successful.&quot;); return false; &#125; this.myContacts.set(foundPosition, newContact); System.out.println(oldContact.getName() + &quot;, was replaced with &quot; + newContact.getName()); return true; &#125; public boolean removeContact(Contact contact) &#123; int foundPosition = findContact(contact); if (foundPosition &lt; 0) &#123; System.out.println(contact.getName() + &quot;, was not found.&quot;); return false; &#125; this.myContacts.remove(foundPosition); System.out.println(contact.getName() + &quot;, was deleted.&quot;); return true; &#125; private int findContact(Contact contact) &#123; return this.myContacts.indexOf(contact); &#125; private int findContact(String contactName) &#123; for (int i = 0; i &lt; this.myContacts.size(); i++) &#123; Contact contact = this.myContacts.get(i); if (contact.getName().equals(contactName)) &#123; return i; &#125; &#125; return -1; &#125; public Contact queryContact(String name) &#123; int position = findContact(name); if (position &gt;= 0) &#123; return this.myContacts.get(position); &#125; return null; &#125; public void printContacts() &#123; System.out.println(&quot;Contact List&quot;); for (int i = 0; i &lt; this.myContacts.size(); i++) &#123; System.out.println((i + 1) + &quot;.&quot; + this.myContacts.get(i).getName() + &quot; -&gt; &quot; + this.myContacts.get(i).getPhoneNumber()); &#125; &#125;&#125; 修改 Main.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import java.util.Scanner;public class Main &#123; private static Scanner scanner = new Scanner(System.in); private static MobilePhone mobilePhone = new MobilePhone(&quot;0039 330 4404&quot;); public static void main(String[] args) &#123; boolean quit = false; startPhone(); printActions(); while (!quit) &#123; System.out.println(&quot;\\nEnter action: (6 to show available actions)&quot;); int action = scanner.nextInt(); scanner.nextLine(); switch (action) &#123; case 0: System.out.println(&quot;\\nShutting down...&quot;); quit = true; break; case 1: mobilePhone.printContacts(); break; case 2: addNewContact(); break; case 3: updateContact(); break; case 4: removeContact(); break; case 5: queryContact(); break; case 6: printActions(); break; &#125; &#125; &#125; private static void updateContact() &#123; System.out.println(&quot;Enter existing contact name: &quot;); String name = scanner.nextLine(); Contact existingContactRecord = mobilePhone.queryContact(name); if (existingContactRecord == null) &#123; System.out.println(&quot;Contact not found&quot;); return; &#125; System.out.println(&quot;Enter new contact name: &quot;); String newName = scanner.nextLine(); System.out.println(&quot;Enter new contact phone number: &quot;); String newNumber = scanner.nextLine(); Contact newContact = Contact.createContact(newName, newNumber); if (mobilePhone.updateContact(existingContactRecord, newContact)) &#123; System.out.println(&quot;Successfully updated record&quot;); &#125; else &#123; System.out.println(&quot;Error updating record&quot;); &#125; &#125; private static void removeContact() &#123; System.out.println(&quot;Enter existing contact name: &quot;); String name = scanner.nextLine(); Contact existingContactRecord = mobilePhone.queryContact(name); if (existingContactRecord == null) &#123; System.out.println(&quot;Contact not found&quot;); return; &#125; if (mobilePhone.removeContact(existingContactRecord)) &#123; System.out.println(&quot;Successfully deleted&quot;); &#125; else &#123; System.out.println(&quot;Error deleting contact&quot;); &#125; &#125; private static void queryContact() &#123; System.out.println(&quot;Enter existing contact name: &quot;); String name = scanner.nextLine(); Contact existingContactRecord = mobilePhone.queryContact(name); if (existingContactRecord == null) &#123; System.out.println(&quot;Contact not found&quot;); return; &#125; System.out.println(&quot;Name: &quot; + existingContactRecord.getName() + &quot; phone number is &quot; + existingContactRecord.getPhoneNumber()); &#125; private static void addNewContact() &#123; System.out.println(&quot;Enter new contact name: &quot;); String name = scanner.nextLine(); System.out.println(&quot;Enter phone number: &quot;); String phone = scanner.nextLine(); Contact newContact = Contact.createContact(name, phone); if (mobilePhone.addNewContact(newContact)) &#123; System.out.println(&quot;New contact added: &quot; + name + &quot;, phone = &quot; + phone); &#125; else &#123; System.out.println(&quot;Cannot add, &quot; + name + &quot; already on file&quot;); &#125; &#125; private static void startPhone() &#123; System.out.println(&quot;Starting phone...&quot;); &#125; private static void printActions() &#123; System.out.println(&quot;\\nAvailable actions:\\npress&quot;); System.out.println(&quot;0 - to shut down\\n&quot; + &quot;1 - to print contact\\n&quot; + &quot;2 - to add a new contact\\n&quot; + &quot;3 - to update an existing contact\\n&quot; + &quot;4 - to remove an existing contact\\n&quot; + &quot;5 - query of an existing contact exists\\n&quot; + &quot;6 - to print a list of available actions.&quot;); System.out.println(&quot;Choose your action: &quot;); &#125;&#125; 注意幾個 ArrayList 常用的方法 .add() 新增 .set() 編輯 .remove() 刪除 .indexOf() 找到對應內容的 index .get() 找到 index 的對應內容 .size() 取得 ArrayList 的長度 Autoboxing 和 Unboxing String 可以給 ArrayList 使用，因為 String 是一種 Class，而 int 是 primitive type，所以無法使用在 ArrayList，這時候我們需要把 int 包裝成一個 Class 12345678String[] strArray = new String[10];int[] intArray = new int[10];ArrayList&lt;String&gt; strArrayList = new ArrayList&lt;String&gt;();strArrayList.add(&quot;Tim&quot;);// 以下會出錯ArrayList&lt;int&gt; intArrayList = new ArrayList&lt;int&gt;(); 直接新增一個 Class 來包裝 Int 1234567891011121314151617181920212223class IntClass &#123; private int myValue; public IntClass(int myValue) &#123; this.myValue = myValue; &#125; public int getMyValue() &#123; return myValue; &#125; public void setMyValue(int myValue) &#123; this.myValue = myValue; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; ArrayList&lt;IntClass&gt; intClassArrayList = new ArrayList&lt;IntClass&gt;(); intClassArrayList.add(new IntClass(54)); &#125;&#125; 新增 Class 太麻煩，可以用 Autoboxing 來達到一樣的目的，Autoboxing 就是一種 Wrapper 1234567891011Integer integer = new Integer(54);Double doubleValue = new Double(12.25);ArrayList&lt;Integer&gt; intArrayList = new ArrayList&lt;Integer&gt;();for (int i = 0;i &lt;= 10; i++) &#123; intArrayList.add(Integer.valueOf(i));&#125;for (int i = 0;i &lt;= 10; i++) &#123; System.out.println(i + &quot; --&gt; &quot; + intArrayList.get(i).intValue());&#125; Double 的 Autoboxing 和 Unboxing 如下 1234567891011121314// AutoboxingInteger myIntValue = 56; // 等同於 Integer.valueOf(56)// Unboxingint myInt = myIntValue.intValue();ArrayList&lt;Double&gt; myDoubleValues = new ArrayList&lt;Double&gt;();for (double dbl = 0.0; dbl &lt;= 10.0; dbl += 0.5) &#123; myDoubleValues.add(Double.valueOf(dbl));&#125;for (int i = 0; i &lt; myDoubleValues.size(); i++) &#123; double value = myDoubleValues.get(i).doubleValue(); System.out.println(i + &quot; --&gt; &quot; + value);&#125; Autoboxing 和 Unboxing 還可以簡化 123456789ArrayList&lt;Double&gt; myDoubleValues = new ArrayList&lt;Double&gt;();for (double dbl = 0.0; dbl &lt;= 10.0; dbl += 0.5) &#123; myDoubleValues.add(dbl);&#125;for (int i = 0; i &lt; myDoubleValues.size(); i++) &#123; double value = myDoubleValues.get(i); System.out.println(i + &quot; --&gt; &quot; + value);&#125; Autoboxing 和 Unboxing 挑戰 題目 Your job is to create a simple banking application. Implement the following classes: 1. Bank - It has two fields, A String called name and an ArrayList that holds objects of type Branch called branches. - A constructor that takes a String (name of the bank). It initialises name and instantiates branches. - And five methods, they are (their functions are in their names): - addBranch(), has one parameter of type String (name of the branch) and returns a boolean. It returns true if the branch was added successfully or false otherwise. - addCustomer(), has three parameters of type String (name of the branch), String (name of the customer), double (initial transaction) and returns a boolean. It returns true if the customer was added successfully or false otherwise. - addCustomerTransaction(), has three parameters of type String (name of the branch), String (name of the customer), double (transaction) and returns a boolean. It returns true if the customers transaction was added successfully or false otherwise. - findBranch(), has one parameter of type String (name of the Branch) and returns a Branch. Return the Branch if it exists or null otherwise. - listCustomers(), has two parameters of type String (name of the Branch), boolean (print transactions) and returns a boolean. Return true if the branch exists or false otherwise. This method prints out a list of customers. → TEST CODE 12345678910111213Bank bank = new Bank(&quot;National Australia Bank&quot;);bank.addBranch(&quot;Adelaide&quot;);bank.addCustomer(&quot;Adelaide&quot;, &quot;Tim&quot;, 50.05);bank.addCustomer(&quot;Adelaide&quot;, &quot;Mike&quot;, 175.34);bank.addCustomer(&quot;Adelaide&quot;, &quot;Percy&quot;, 220.12);bank.addCustomerTransaction(&quot;Adelaide&quot;, &quot;Tim&quot;, 44.22);bank.addCustomerTransaction(&quot;Adelaide&quot;, &quot;Tim&quot;, 12.44);bank.addCustomerTransaction(&quot;Adelaide&quot;, &quot;Mike&quot;, 1.65);bank.listCustomers(&quot;Adelaide&quot;, true); → OUTPUT The list of customers should be printed out in the following format if boolean parameter is true: 12345678910111213Customer details for branch AdelaideCustomer: Tim[1]Transactions[1] Amount 50.05[2] Amount 44.22[3] Amount 12.44Customer: Mike[2]Transactions[1] Amount 175.34[2] Amount 1.65Customer: Percy[3]Transactions[1] Amount 220.12 and if false, only the customers - no transactions: 123456bank.listCustomers(&quot;Adelaide&quot;, false);Customer details for branch AdelaideCustomer: Tim[1]Customer: Mike[2]Customer: Percy[3] 2. Branch - It has two fields, A String called name and an ArrayList that holds objects of type Customer called customers. - A constructor that takes a String (name of the branch). It initializes name and instantiates customers. - And five methods, they are (their functions are in their names): - getName(), getter for name. - getCustomers(), getter for customers. - newCustomer(), has two parameters of type String (name of customer), double (initial transaction) and returns a boolean. Returns true if the customer was added successfully or false otherwise. - addCustomerTransaction(), has two parameters of type String (name of customer), double (transaction) and returns a boolean. Returns true if the customers transaction was added successfully or false otherwise. - findCustomer(), has one parameter of type String (name of customer) and returns a Customer. Return the Customer if they exist, null otherwise. 3. Customer - It has two fields, A String called name and an ArrayList that holds objects of type Double called transactions. - A constructor that takes a String (name of customer) and a double (initial transaction). It initializes name and instantiates transactions. - And three methods, they are (their functions are in their names): - getName(), getter for name. - getTransactions(), getter for transactions. - addTransaction(), has one parameter of type double (transaction) and doesn’t return anything. TIP: In Bank, use the findBranch() method in each of the other four methods to validate a branch. Do the same thing in Branch with findCustomer() - except for the two getters. TIP: In Customer, think about what else you need to do in the constructor when you instantiate a Customer object. TIP: Think about what methods you need to call from another class when implementing a method. TIP: Be extremely careful with the spelling of the names of the fields, constructors and methods. TIP: Be extremely careful about spaces and spelling in the printed output. NOTE: All transactions are deposits (no withdraws/balances). NOTE: All fields are private. NOTE: All constructors are public. NOTE: All methods are public (except for findBranch() and findCustomer() which are private). NOTE: There are no static members. NOTE: Do not add a main method to the solution code. NOTE: If you get an error from the Evaluate class, it’s most likely the constructor. Check if you’ve added a constructor or if the constructor has the right arguments. 答案 新增 Customer.java 123456789101112131415161718192021222324import java.util.ArrayList;public class Customer &#123; private String name; private ArrayList&lt;Double&gt; transactions; public Customer(String name, double initialAmount) &#123; this.name = name; this.transactions = new ArrayList&lt;Double&gt;(); addTransaction(initialAmount); &#125; public String getName() &#123; return name; &#125; public ArrayList&lt;Double&gt; getTransactions() &#123; return transactions; &#125; public void addTransaction(double amount) &#123; this.transactions.add(amount); &#125;&#125; 新增 Branch.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.ArrayList;public class Branch &#123; private String name; private ArrayList&lt;Customer&gt; customers; public Branch(String name) &#123; this.name = name; this.customers = new ArrayList&lt;Customer&gt;(); &#125; public String getName() &#123; return name; &#125; public ArrayList&lt;Customer&gt; getCustomers() &#123; return customers; &#125; public boolean newCustomer(String customerName, double initialAmount) &#123; if (findCustomer(customerName) == null) &#123; this.customers.add(new Customer(customerName, initialAmount)); return true; &#125; return false; &#125; public boolean addCustomerTransaction(String customerName, double amount) &#123; Customer existingCustomer = findCustomer(customerName); if (existingCustomer != null) &#123; existingCustomer.addTransaction(amount); return true; &#125; return false; &#125; private Customer findCustomer(String customerName) &#123; for (int i = 0; i &lt; this.customers.size(); i++) &#123; Customer checkedCustomer = this.customers.get(i); if (checkedCustomer.getName().equals(customerName)) &#123; return checkedCustomer; &#125; &#125; return null; &#125;&#125; 新增 Bank.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.util.ArrayList;public class Bank &#123; private String name; private ArrayList&lt;Branch&gt; branches; public Bank(String name) &#123; this.name = name; this.branches = new ArrayList&lt;Branch&gt;(); &#125; public boolean addBranch(String branchName) &#123; if (findBranch(branchName) == null) &#123; this.branches.add(new Branch(branchName)); return true; &#125; return false; &#125; public boolean addCustomer(String branchName, String customerName, double initialAmount) &#123; Branch branch = findBranch(branchName); if (branch!= null) &#123; return branch.newCustomer(customerName, initialAmount); &#125; return false; &#125; public boolean addCustomerTransaction(String branchName, String customerName, double amount) &#123; Branch branch = findBranch(branchName); if (branch != null) &#123; return branch.addCustomerTransaction(customerName, amount); &#125; return false; &#125; private Branch findBranch(String branchName) &#123; for (int i = 0; i &lt; this.branches.size(); i++) &#123; Branch checkedBranch = this.branches.get(i); if (checkedBranch.getName().equals(branchName)) &#123; return checkedBranch; &#125; &#125; return null; &#125; public boolean listCustomers(String branchName, boolean showTransactions) &#123; Branch branch = findBranch(branchName); if (branch != null) &#123; System.out.println(&quot;Customer details for branch &quot; + branch.getName()); ArrayList&lt;Customer&gt; branchCustomers = branch.getCustomers(); for (int i = 0; i &lt; branchCustomers.size(); i++) &#123; Customer branchCustomer = branchCustomers.get(i); System.out.println(&quot;Customer: &quot; + branchCustomer.getName() + &quot;[&quot; + (i + 1) + &quot;]&quot;); if (showTransactions) &#123; System.out.println(&quot;Transactions&quot;); ArrayList&lt;Double&gt; transactions = branchCustomer.getTransactions(); for (int j = 0; j &lt; transactions.size(); j++) &#123; System.out.println(&quot;[&quot; + (j + 1) + &quot;] Amount &quot; + transactions.get(j)); &#125; &#125; &#125; return true; &#125; return false; &#125;&#125; 修改 Main.java 123456789101112131415161718public class Main &#123; public static void main(String[] args) &#123; Bank bank = new Bank(&quot;National Australia Bank&quot;); bank.addBranch(&quot;Adelaide&quot;); bank.addCustomer(&quot;Adelaide&quot;, &quot;Tim&quot;, 50.05); bank.addCustomer(&quot;Adelaide&quot;, &quot;Mike&quot;, 175.34); bank.addCustomer(&quot;Adelaide&quot;, &quot;Percy&quot;, 220.12); bank.addCustomerTransaction(&quot;Adelaide&quot;, &quot;Tim&quot;, 44.22); bank.addCustomerTransaction(&quot;Adelaide&quot;, &quot;Tim&quot;, 12.44); bank.addCustomerTransaction(&quot;Adelaide&quot;, &quot;Mike&quot;, 1.65); bank.listCustomers(&quot;Adelaide&quot;, true); &#125;&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://vincent.fishboneapps.com/tags/Java/"}]},{"title":"Java 快速學習自我挑戰 Day12","slug":"Java-快速學習自我挑戰-Day12","date":"2021-01-25T08:25:57.000Z","updated":"2021-01-27T14:03:14.332Z","comments":true,"path":"2021/01/25/Java-快速學習自我挑戰-Day12/","link":"","permalink":"https://vincent.fishboneapps.com/2021/01/25/Java-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day12/","excerpt":"","text":"Arrays、Java 內建 List、Autoboxing 和 Unboxing Arrays 設置 Array，可以用以下兩種方式來進行設置 12int[] myIntArray = new int[25];int[] myIntArray = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;; 賦予 Array 值 123myIntArray[0] = 45;myIntArray[1] = 476;myIntArray[5] = 50; 將 Array 列印出來，可以使用 .length 來取得 Array 的長度，避免錯誤發生 12345678910111213public static void main(String[] args) &#123; int[] myIntArray = new int[25]; for (int i = 0; i &lt; myIntArray.length; i++) &#123; myIntArray[i] = i * 10; &#125; printArray(myIntArray); &#125; public static void printArray(int[] array) &#123; for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(&quot;Element &quot; + i + &quot;, value is &quot; + array[i]); &#125; &#125; 使用 Array 寫一個平均計算器 12345678910111213141516171819202122232425262728293031323334import java.util.Scanner;public class Main &#123; private static Scanner scanner = new Scanner(System.in); public static void main(String[] args) &#123; int[] myIntegers = getIntegers(5); for (int i = 0; i &lt; myIntegers.length; i++) &#123; System.out.println(&quot;Element &quot; + i + &quot;, typed value was &quot; + myIntegers[i]); &#125; System.out.println(&quot;The average is &quot; + getAverage(myIntegers)); &#125; public static int[] getIntegers(int number) &#123; System.out.println(&quot;Enter &quot; + number + &quot; integer values.\\r&quot;); int[] values = new int[number]; for (int i = 0; i &lt; values.length; i++) &#123; values[i] = scanner.nextInt(); &#125; return values; &#125; public static double getAverage(int[] array) &#123; int sum = 0; for (int i = 0; i &lt; array.length; i++) &#123; sum += array[i]; &#125; return (double) sum / (double) array.length; &#125;&#125; Array 挑戰 題目 Create a program using arrays that sorts a list of integers in descending order. Descending order is highest value to lowest. In other words if the array had the values in it [106, 26, 81, 5, 15] your program should ultimately have an array with [106, 81, 26, 15, 5] in it. Set up the program so that the numbers to sort are read in from the keyboard (Scanner). Implement the following methods: getIntegers has one parameter of type int which is the size of the array. It returns an array of entered integers from the keyboard.= printArray accepts an array and prints out the contents of the array. It should be printed in the following format: Element 0 contents 106 Element 1 contents 81 Element 2 contents 26 Element 3 contents 15 Element 4 contents 5 sortIntegers accepts the unsorted array. It should sort the array and return a new array containing the sorted numbers. The scenario is: getIntegers() is called. The returned array from getIntegers() is then used to call sortIntegers(). The returned array from sortIntegers() is then printed to the console. [Do not try and implement this. It is to give you an idea of how the methods will be used] TIP: you will have to figure out how to copy the array elements from the passed array into a new array and sort them and return the new sorted array. TIP: Instantiate (create) the Scanner object inside the method. TIP: Be extremely careful about spaces in the printed message. NOTE: All methods should be defined as public static NOT public. NOTE: Do not add a main method to the solution code. 答案 修改 Main.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.Scanner;public class Main &#123; private static Scanner scanner = new Scanner(System.in); public static void main(String[] args) &#123; int[] myIntegers = getIntegers(6); int[] sorted = sortIntegers(myIntegers); printArray(sorted); &#125; public static int[] getIntegers(int capacity) &#123; System.out.println(&quot;Enter &quot; + capacity + &quot; integer values:\\r&quot;); int[] array = new int[capacity]; for (int i = 0; i &lt; array.length; i++) &#123; array[i] = scanner.nextInt(); &#125; return array; &#125; public static void printArray(int[] array) &#123; for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(&quot;Element &quot; + i + &quot; contents &quot; + array[i]); &#125; &#125; public static int[] sortIntegers(int[] array) &#123; int[] sortedArray = new int[array.length]; for (int i = 0; i &lt; array.length; i++) &#123; sortedArray[i] = array[i]; &#125; boolean flag = true; int temp; while (flag) &#123; flag = false; for (int i = 0; i &lt; sortedArray.length - 1; i++) &#123; if (sortedArray[i] &lt; sortedArray[i + 1]) &#123; temp = sortedArray[i]; sortedArray[i] = sortedArray[i + 1]; sortedArray[i + 1] = temp; flag = true; &#125; &#125; &#125; return sortedArray; &#125;&#125; 以下程式碼可以進行優化 123456int[] sortedArray = new int[array.length];for (int i = 0; i &lt; array.length; i++) &#123; sortedArray[i] = array[i];&#125;// 可以用 Java 內建的語法優化int[] sortedArray = Arrays.copyOf(array, array.length); 總結 Array 是一種數據結構可以讓你儲存多個同型態的值到一個變數中。 默認的 Array 元素會設為 0。 Array 是從 0 開始索引的：Array 有 n 個元素的索引會從 0 到 n-1，例如：10 個元素的索引是 0 到 9。 如果我們想要存取 Array 範圍外的索引，Java 會給我們 ArrayIndexOutOfBoundsException 的錯誤，這表示索引超出範圍。 存取 Array 元素我們使用中括號 [ 和 ]，這就是 Array 存取運算符。 例子 1 int[] array = new int[5] 這個 Array 包含元素從 array[0] 到 array[4]。 這 5 個元素的索引範圍是 0 到 4。 new 這個運算符或 Keyword 被用來創建 Array 或是初始化 Array 元素為它們的默認值。 在這個例子，當 int Array 生成的時候，會初始化為 0。 對於 boolean 的 Array 元素，會初始化為 false。 對於 String 或是 Objects 會初始化為 null，後面課程會說更多關於 null 的內容。 例子 2 int[] myNumbers = &#123;5, 4, 3, 2, 1&#125;; 我們可以使用初始化區塊 { 和 } 來初始化 array 為一行，我們定義的值必須要用逗號分開。 這種初始化 Array 的方式稱為匿名 Array(Anonymous Array)。 這 5 個元素的索引範圍是 0 到 4。 在這個例子，Array 元素被分別初始化為 5, 4, 3, 2, 1。 最常見的錯誤 1 存取超過範圍的索引，會出現 ArrayIndexOutOfBoundsException 的錯誤。 我們有 5 個元素，索引範圍是 0 到 4。 最常見的錯誤 2 for 迴圈要從 0 開始 1234567891011int[] myArray = &#123;10, 35, 20, 17, 18&#125;;for (int i = 1; i &lt; myArray.length; i++) &#123; System.out.println(&quot;value= &quot; + myArray[i]);&#125;====// 輸出的錯誤結果value = 35value = 20value = 17value = 18 最常見的錯誤 3 在 for 迴圈錯誤使用小於等於 i &lt;= myArray.length;，會導致 ArrayIndexOutOfBoundsException。 12345int[] myArray = &#123;10, 35, 20, 17, 18&#125;;for (int i = 1; i &lt;= myArray.length; i++) &#123; System.out.println(&quot;value= &quot; + myArray[i]);&#125; Reference Types 和 Value Types Array 和 String 都是 Reference Type，它會指向 Memory 的同個地方，所以如果其中一個變更了，另外一個也會跟著變更。 int、double 和 boolean 都是 Value Type，換句話說，它們會保存值。 看下面這個例子，如果變更一樣指向同個 Array 的 Array，兩個 Array 都會一起變更，所以要用 new 這個 Keyword 來新增一個新的 Array，就不會有這個問題。 1234567891011121314151617181920212223242526272829303132333435363738public class Main &#123; public static void main(String[] args) &#123; int myIntValue = 10; int anotherIntValue = myIntValue; System.out.println(&quot;myIntValue = &quot; + myIntValue); System.out.println(&quot;anotherIntValue = &quot; + anotherIntValue); anotherIntValue++; System.out.println(&quot;myIntValue = &quot; + myIntValue); System.out.println(&quot;anotherIntValue = &quot; + anotherIntValue); int[] myIntArray = new int[5]; int[] anotherArray = myIntArray; System.out.println(&quot;myIntArray= &quot; + Arrays.toString(myIntArray)); System.out.println(&quot;anotherArray= &quot; + Arrays.toString(anotherArray)); anotherArray[0] = 1; System.out.println(&quot;after change myIntArray= &quot; + Arrays.toString(myIntArray)); System.out.println(&quot;after change anotherArray= &quot; + Arrays.toString(anotherArray)); anotherArray = new int[] &#123;4, 5, 6, 7, 8&#125;; modifyArray(myIntArray); System.out.println(&quot;after modify myIntArray= &quot; + Arrays.toString(myIntArray)); System.out.println(&quot;after modify anotherArray= &quot; + Arrays.toString(anotherArray)); &#125; private static void modifyArray(int[] array) &#123; array[0] = 2; array = new int[] &#123;1, 2, 3, 4, 5&#125;; &#125;&#125; 最小化元素挑戰 題目 Write a method called readInteger() that has no parameters and returns an int. It needs to read in an integer from the user - this represents how many elements the user needs to enter. Write another method called readElements() that has one parameter of type int The method needs to read from the console until all the elements are entered, and then return an array containing the elements entered. And finally, write a method called findMin() with one parameter of type int[]. The method needs to return the minimum value in the array. The scenario is: 1. readInteger() is called. 2. The number returned by readInteger() is then used to call readElements(). 3. The array returned from readElements() is used to call findMin(). 4. findMin() returns the minimum number. [Do not try and implement this. It is to give you an idea of how the methods will be used] TIP: Assume that the user will only enter numbers, never letters. TIP: Instantiate (create) the Scanner object inside the method. There are two scanner objects, one for each of the two methods that are reading in input from the user. TIP: Be extremely careful about spaces in the printed message. NOTE: All methods should be defined as private static. NOTE: Do not add a main method to the solution code. 答案 修改 Main.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Scanner;public class Main &#123; private static Scanner scanner = new Scanner(System.in); public static void main(String[] args) &#123; int number = readInteger(); int[] array = readElements(number); int minNumber = findMin(array); System.out.println(&quot;The min number is &quot; + minNumber); &#125; private static int readInteger() &#123; System.out.println(&quot;Enter count:\\r&quot;); int number = scanner.nextInt(); scanner.nextLine(); return number; &#125; private static int[] readElements(int number) &#123; int[] values = new int[number]; for (int i = 0; i &lt; number; i++) &#123; System.out.println(&quot;Please enter &quot; + i + &quot; element:\\r&quot;); values[i] = scanner.nextInt(); scanner.nextLine(); &#125; return values; &#125; private static int findMin(int[] array) &#123; int minNumber = array[0]; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i] &lt; minNumber) &#123; minNumber = array[i]; &#125; &#125; return minNumber; &#125;&#125; 逆 Array 挑戰 題目 Write a method called reverse() with an int array as a parameter. The method should not return any value. In other words, the method is allowed to modify the array parameter. To reverse the array, you have to swap the elements, so that the first element is swapped with the last element and so on. For example, if the array is [1, 2, 3, 4, 5], then the reversed array is [5, 4, 3, 2, 1]. The method should first print out the newly passed in array as Array = [1, 2, 3, 4, 5] and then once it’s been reversed, print it out as Reversed array = [5, 4, 3, 2, 1] TIP: When swapping the elements, use a variable to temporarily hold the current element. NOTE: The method should be defined as private static. NOTE: Do not add a main method to the solution code. 答案 修改 Main.java 12345678910111213141516public class ReverseArray &#123; private static void reverse(int[] array) &#123; System.out.println(&quot;Array = &quot; + Arrays.toString(array)); int maxIndex = array.length - 1; int halfLength = array.length / 2; for (int i = 0; i &lt; halfLength; i++) &#123; int temp = array[i]; array[i] = array[maxIndex - i]; array[maxIndex - i] = temp; &#125; System.out.println(&quot;Reversed array = &quot; + Arrays.toString(array)); &#125;&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://vincent.fishboneapps.com/tags/Java/"}]},{"title":"Java 快速學習自我挑戰 Day11","slug":"Java-快速學習自我挑戰-Day11","date":"2021-01-24T03:07:31.000Z","updated":"2021-01-25T08:24:42.396Z","comments":true,"path":"2021/01/23/Java-快速學習自我挑戰-Day11/","link":"","permalink":"https://vincent.fishboneapps.com/2021/01/23/Java-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day11/","excerpt":"","text":"物件導向程式設計 (OOP) - Composition, Encapsulation 和 Polymorphism Encapsulation Encapsulation 是一個允許你對正在創建的 Objects 裡面的特定 Components 做限制存取的機制。 它可以用來屏蔽其它 Class 的存取，保持內部工作正常，且可以讓你修改內容的時候避免損壞。 用一個範例來了解 Encapsulation 新增 Player.java 123456789101112131415161718public class Player &#123; public String name; public int health; public String weapon; public void loseHealth(int damage) &#123; this.health = this.health - damage; if (this.health &lt;= 0) &#123; System.out.println(&quot;Player knocked out&quot;); // Reduce number of lives remaining for the player &#125; &#125; public int healthRemaining() &#123; return this.health; &#125;&#125; 修改 Main.java 12345678910111213Player player = new Player();player.name = &quot;Vincent&quot;;player.health = 20;player.weapon = &quot;Sword&quot;;int damage = 10;player.loseHealth(damage);System.out.println(&quot;Remaining health = &quot; + player.healthRemaining());damage = 11;player.health = 200;player.loseHealth(damage);System.out.println(&quot;Remaining health = &quot; + player.healthRemaining()); 這時候，如果把 Player.java 裡面的 public String name; 改成 public String fullName，整個程式碼就會出錯。 新增一個 EnhancedPlayer.java 1234567891011121314151617181920212223242526public class EnhancedPlayer &#123; private String name; private int health = 100; private String weapon; public EnhancedPlayer(String name, int health, String weapon) &#123; this.name = name; if (health &gt; 0 &amp;&amp; health &lt;= 100) &#123; this.health = health; &#125; this.weapon = weapon; &#125; public void loseHealth(int damage) &#123; this.health = this.health - damage; if (this.health &lt;= 0) &#123; System.out.println(&quot;Player knocked out&quot;); // Reduce number of lives remaining for the player &#125; &#125; public int getHealth() &#123; return health; &#125;&#125; 修改 Main.java 12EnhancedPlayer player = new EnhancedPlayer(&quot;Vincent&quot;, 200, &quot;Sword&quot;);System.out.println(&quot;Initial health is &quot; + player.getHealth()); 就算把 health 改成 hitPoints，運作仍然正常。 1234567891011121314151617181920212223242526public class EnhancedPlayer &#123; private String name; private int hitPoints = 100; private String weapon; public EnhancedPlayer(String name, int health, String weapon) &#123; this.name = name; if (health &gt; 0 &amp;&amp; health &lt;= 100) &#123; this.hitPoints = health; &#125; this.weapon = weapon; &#125; public void loseHealth(int damage) &#123; this.hitPoints = this.hitPoints - damage; if (this.hitPoints &lt;= 0) &#123; System.out.println(&quot;Player knocked out&quot;); // Reduce number of lives remaining for the player &#125; &#125; public int getHealth() &#123; return hitPoints; &#125;&#125; Encapsulation 挑戰 題目 Create a class and demonstrate proper encapsulation techniques the class will be called Printer It will simulate a real Computer Printer It should have fields for the toner Level, number of pages printed, and also whether its a duplex printer (capable of printing on both sides of the paper). Add methods to fill up the toner (up to a maximum of 100%), another method to simulate printing a page (which should increase the number of pages printed). Decide on the scope, whether to use constructors, and anything lese you think is needed. 答案 新增 Printer.java 1234567891011121314151617181920212223242526272829303132333435363738public class Printer &#123; private int tonerLevel = -1; private int pagesPrinted = 0; private boolean duplex; public Printer(int tonerLevel, boolean duplex) &#123; if (tonerLevel &gt; -1 &amp;&amp; tonerLevel &lt;= 100) &#123; this.tonerLevel = tonerLevel; &#125; this.duplex = duplex; &#125; public int addToner(int tonerAmount) &#123; if (tonerAmount &gt; 0 &amp;&amp; tonerAmount &lt;= 100) &#123; if (tonerLevel + tonerAmount &gt; 100) &#123; return -1; &#125; return tonerLevel += tonerAmount; &#125; else &#123; return -1; &#125; &#125; public int printPages(int pages) &#123; int pagesToPrint = pages; if (duplex) &#123; System.out.println(&quot;Printing in duplex mode&quot;); pagesToPrint = (pages / 2) + (pages % 2); &#125; pagesPrinted += pagesToPrint; return pagesToPrint; &#125; public int getPagesPrinted() &#123; return pagesPrinted; &#125;&#125; 修改 Main.java 1234567Printer printer = new Printer(50, true);System.out.println(printer.addToner(50));System.out.println(&quot;initial page count = &quot; + printer.getPagesPrinted());int pagesPrinted = printer.printPages(4);System.out.println(&quot;Pages printed was &quot; + pagesPrinted + &quot; new total print count for printer = &quot; + printer.getPagesPrinted());pagesPrinted = printer.printPages(2);System.out.println(&quot;Pages printed was &quot; + pagesPrinted + &quot; new total print count for printer = &quot; + printer.getPagesPrinted()); Polymorphism 在 Main.java 新增很多 Class 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Movie &#123; private String name; public Movie(String name) &#123; this.name = name; &#125; public String plot() &#123; return &quot;No plot here&quot;; &#125; public String getName() &#123; return name; &#125;&#125;class Jaws extends Movie &#123; public Jaws() &#123; super(&quot;Jaws&quot;); &#125; public String plot() &#123; return &quot;A shark eats lots of people&quot;; &#125;&#125;class IndependenceDay extends Movie &#123; public IndependenceDay() &#123; super(&quot;Independence Day&quot;); &#125; @Override public String plot() &#123; return &quot;Aliens attempt to take over planet earth&quot;; &#125;&#125;class MazeRunner extends Movie &#123; public MazeRunner() &#123; super(&quot;Maze Runner&quot;); &#125; @Override public String plot() &#123; return &quot;Kids try and escape a maze.&quot;; &#125;&#125;class StarWars extends Movie &#123; public StarWars() &#123; super(&quot;Star Wars&quot;); &#125; @Override public String plot() &#123; return &quot;Imperial Forces try to take over the universe&quot;; &#125;&#125;class Forgettable extends Movie &#123; public Forgettable() &#123; super(&quot;Forgettable&quot;); &#125; // No plot method&#125; 修改 Main.java 最主要的內容來展示 Polymorphism 12345678910111213141516171819202122232425262728public class Main &#123; public static void main(String[] args) &#123; for (int i = 1; i &lt; 11; i++) &#123; Movie movie = randomMovie(); System.out.println(&quot;Movie #&quot; + i + &quot; : &quot; + movie.getName() + &quot;\\n&quot; + &quot;Plot: &quot; + movie.plot() + &quot;\\n&quot;); &#125; &#125; public static Movie randomMovie() &#123; int randomNumber = (int) (Math.random() * 5) + 1; System.out.println(&quot;Random number generated was: &quot; + randomNumber); switch (randomNumber) &#123; case 1: return new Jaws(); case 2: return new IndependenceDay(); case 3: return new MazeRunner(); case 4: return new StarWars(); case 5: return new Forgettable(); &#125; return null; &#125;&#125; Polymorphism 挑戰 題目 We are going to go back to the car analogy. Crate a base class called Car It should have a few fields that would be appropriate for a generic car class. engine, cylinders, wheels, etc. Constructor should initialize cylinders (number of) and name, and set wheels to 4 and engine to true. Cylinders and names would be passed parameters. Create appropriate getters Create some methods like startEngine, accelerate, and brake show a message for each in the base class Now create 3 sub classes for your favorite vehicles. Override the appropriate methods to demonstrate polymorphism in use. put all classes in the one java file (this one). 答案 新增 Class 到 Main.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899class Car &#123; private boolean engine; private int cylinders; private String name; private int wheels; public Car(int cylinders, String name) &#123; this.engine = true; this.cylinders = cylinders; this.name = name; this.wheels = 4; &#125; public String startEngine() &#123; return &quot;Car -&gt; startEngine()&quot;; &#125; public String accelerate() &#123; return &quot;Car -&gt; accelerate()&quot;; &#125; public String brake() &#123; return &quot;Car -&gt; brake()&quot;; &#125; public int getCylinders() &#123; return cylinders; &#125; public String getName() &#123; return name; &#125;&#125;class Mitsubishi extends Car &#123; public Mitsubishi(int cylinders, String name) &#123; super(cylinders, name); &#125; @Override public String startEngine() &#123; return &quot;Mitsubishi -&gt; startEngine()&quot;; &#125; @Override public String accelerate() &#123; return &quot;Mitsubishi -&gt; accelerate()&quot;; &#125; @Override public String brake() &#123; return &quot;Mitsubishi -&gt; brake()&quot;; &#125;&#125;class Holden extends Car &#123; public Holden(int cylinders, String name) &#123; super(cylinders, name); &#125; @Override public String startEngine() &#123; return &quot;Holden -&gt; startEngine()&quot;; &#125; @Override public String accelerate() &#123; return &quot;Holden -&gt; accelerate()&quot;; &#125; @Override public String brake() &#123; return &quot;Holden -&gt; brake()&quot;; &#125;&#125;class Ford extends Car &#123; public Ford(int cylinders, String name) &#123; super(cylinders, name); &#125; @Override public String startEngine() &#123; return &quot;Ford -&gt; startEngine()&quot;; &#125; @Override public String accelerate() &#123; return &quot;Ford -&gt; accelerate()&quot;; &#125; @Override public String brake() &#123; return &quot;Ford -&gt; brake()&quot;; &#125;&#125; 修改 Main.java 的主要內容 123456789101112131415161718192021222324 public class Main &#123; public static void main(String[] args) &#123; Car car = new Car(8, &quot;Base Car&quot;); System.out.println(car.startEngine()); System.out.println(car.accelerate()); System.out.println(car.brake()); Mitsubishi mitsubishi = new Mitsubishi(6, &quot;Outlander VRX 4WD&quot;); System.out.println(mitsubishi.startEngine()); System.out.println(mitsubishi.accelerate()); System.out.println(mitsubishi.brake()); Ford ford = new Ford(6, &quot;Ford Falcon&quot;); System.out.println(ford.startEngine()); System.out.println(ford.accelerate()); System.out.println(ford.brake()); Holden holden = new Holden(6, &quot;Holden Commodore&quot;); System.out.println(holden.startEngine()); System.out.println(holden.accelerate()); System.out.println(holden.brake()); &#125;&#125; 可以使用內建語法 getClass().getSimpleName() 來取得 Class 的名稱 123456789101112131415161718192021class Mitsubishi extends Car &#123; public Mitsubishi(int cylinders, String name) &#123; super(cylinders, name); &#125; @Override public String startEngine() &#123; return getClass().getSimpleName() + &quot; -&gt; startEngine()&quot;; &#125; @Override public String accelerate() &#123; return getClass().getSimpleName() + &quot; -&gt; accelerate()&quot;; &#125; @Override public String brake() &#123; return getClass().getSimpleName() + &quot; -&gt; brake()&quot;; &#125;&#125; OOP 終極挑戰 題目 The purpose of this application is to help a company called Bill’s Burgers manage the process of selling their hamburgers. And in order to match Bill’s menu, you will need to create three(3) classes, Hamburger, DeluxeBurger, and HealthyBurger. For the base Hamburger class, there will need to be four variables to represent the four basic ingredients of the hamburger, name, meat, price, and breadRollType. The price variable should be of type double, while the other three are of type String. A constructor will be needed to accept these four values as parameters when creating a new hamburger. There will also need to be separate variables for four(4) possible additions to the hamburger. Those should be declared with these names: addition1Name, addition1Price, addition2Name, addition2Price, addition3Name, addition3Price, addition4Name, and addition4Price. The name variables should be of type String and the price variables should be of type double. Five(5) methods are also needed inside the Hamburger class. Four(4) for adding up to four additions to the hamburger and one(1) for printing out an itemized listing of the final hamburger with addons, if any, and the total price. Remember that a name and price must be accepted as parameters in the first four methods so that the price of the hamburger is adjusted accordingly. These methods should be named addHamburgerAddition1, addHamburgerAddition2, addHamburgerAddition3, addHamburgerAddition4, and itemizeHamburger. The first four methods do not return values, but the last method does return the total price of the hamburger of type double, which includes the base price of the hamburger plus any additional items. For the second class, DeluxeBurger, there are no additional member variables, and the constructor accepts no parameters. Instead, the constructor creates a deluxe burger with all the fixings and chips and a drink for a base price of $19.10. The constructor can be configured in any way, as long as chips and drink are added for the total price just mentioned. In this class, the four(4) methods defined in the Hamburger class for including additional toppings must each be overridden so that a message is printed stating that no additional items can be added to a deluxe burger. And for the third class, HealthyBurger, there will be four(4) additional member variables called healthyExtra1Name, healthyExtra1Price, healthyExtra2Name, and healthyExtra2Price. The names are type String and the prices are type double. The constructor for this class accepts two(2) parameters for meat and price. Those are set in the constructor along with an appropriate name for the type of burger. Two methods, addHealthyAddition1 and addHealthyAddition2 should be created that each accept a name and price for the addition, allowing for up to two(2) addons to the basic healthy burger. And finally the itemizeHamburger method created in the Hamburger class should be overridden to generate a message appropriate to the type of burger along with any addons. The method also returns the total price of the healthy burger of type double. Example input: 1234567891011121314Hamburger hamburger = new Hamburger(&quot;Basic&quot;, &quot;Sausage&quot;, 3.56, &quot;White&quot;);hamburger.addHamburgerAddition1(&quot;Tomato&quot;, 0.27);hamburger.addHamburgerAddition2(&quot;Lettuce&quot;, 0.75);hamburger.addHamburgerAddition3(&quot;Cheese&quot;, 1.13);System.out.println(&quot;Total Burger price is &quot; + hamburger.itemizeHamburger());HealthyBurger healthyBurger = new HealthyBurger(&quot;Bacon&quot;, 5.67);healthyBurger.addHamburgerAddition1(&quot;Egg&quot;, 5.43);healthyBurger.addHealthyAddition1(&quot;Lentils&quot;, 3.41);System.out.println(&quot;Total Healthy Burger price is &quot; + healthyBurger.itemizeHamburger());DeluxeBurger db = new DeluxeBurger();db.addHamburgerAddition3(&quot;Should not do this&quot;, 50.53);System.out.println(&quot;Total Deluxe Burger price is &quot; + db.itemizeHamburger()); Example output: 1234567891011121314Basic hamburger on a White roll with Sausage, price is 3.56Added Tomato for an extra 0.27Added Lettuce for an extra 0.75Added Cheese for an extra 1.13Total Burger price is 5.71Healthy hamburger on a Brown rye roll with Bacon, price is 5.67Added Egg for an extra 5.43Added Lentils for an extra 3.41Total Healthy Burger price is 14.51Cannot not add additional items to a deluxe burgerDeluxe hamburger on a White roll with Sausage &amp; Bacon, price is 14.54Added Chips for an extra 2.75Added Drink for an extra 1.81Total Deluxe Burger price is 19.10 答案 新增 Hamburger.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class Hamburger &#123; private String name; private String meat; private double price; private String breadRollType; private String addition1Name; private double addition1Price; private String addition2Name; private double addition2Price; private String addition3Name; private double addition3Price; private String addition4Name; private double addition4Price; public Hamburger(String name, String meat, double price, String breadRollType) &#123; this.name = name; this.meat = meat; this.price = price; this.breadRollType = breadRollType; &#125; public void addHamburgerAddition1(String name, double price) &#123; this.addition1Name = name; this.addition1Price = price; &#125; public void addHamburgerAddition2(String name, double price) &#123; this.addition2Name = name; this.addition2Price = price; &#125; public void addHamburgerAddition3(String name, double price) &#123; this.addition3Name = name; this.addition3Price = price; &#125; public void addHamburgerAddition4(String name, double price) &#123; this.addition4Name = name; this.addition4Price = price; &#125; public double itemizeHamburger() &#123; double hamburgerPrice = this.price; System.out.println(this.name + &quot; hamburger on a &quot; + this.breadRollType + &quot; roll with &quot; + this.meat + &quot;, price is &quot; + this.price); if (this.addition1Name != null) &#123; hamburgerPrice += this.addition1Price; System.out.println(&quot;Added &quot; + this.addition1Name + &quot; for an extra &quot; + this.addition1Price); &#125; if (this.addition2Name != null) &#123; hamburgerPrice += this.addition2Price; System.out.println(&quot;Added &quot; + this.addition2Name + &quot; for an extra &quot; + this.addition2Price); &#125; if (this.addition3Name != null) &#123; hamburgerPrice += this.addition3Price; System.out.println(&quot;Added &quot; + this.addition3Name + &quot; for an extra &quot; + this.addition3Price); &#125; if (this.addition4Name != null) &#123; hamburgerPrice += this.addition4Price; System.out.println(&quot;Added &quot; + this.addition4Name + &quot; for an extra &quot; + this.addition4Price); &#125; return hamburgerPrice; &#125;&#125; 新增 DeluxeBurger.java 123456789101112131415161718192021222324252627public class DeluxeBurger extends Hamburger &#123; public DeluxeBurger() &#123; super(&quot;Deluxe&quot;, &quot;Sausage &amp; Bacon&quot;, 14.54, &quot;White&quot;); super.addHamburgerAddition1(&quot;Chips&quot;, 2.75); super.addHamburgerAddition2(&quot;Drink&quot;, 1.81); &#125; @Override public void addHamburgerAddition1(String addition1Name, double addition1Price) &#123; System.out.println(&quot;Cannot not add additional items to a deluxe burger&quot;); &#125; @Override public void addHamburgerAddition2(String addition2Name, double addition2Price) &#123; System.out.println(&quot;Cannot not add additional items to a deluxe burger&quot;); &#125; @Override public void addHamburgerAddition3(String addition3Name, double addition3Price) &#123; System.out.println(&quot;Cannot not add additional items to a deluxe burger&quot;); &#125; @Override public void addHamburgerAddition4(String addition4Name, double addition4Price) &#123; System.out.println(&quot;Cannot not add additional items to a deluxe burger&quot;); &#125;&#125; 新增 HealthyBurger.java 123456789101112131415161718192021222324252627282930313233343536public class HealthyBurger extends Hamburger &#123; private String healthyExtra1Name; private double healthyExtra1Price; private String healthyExtra2Name; private double healthyExtra2Price; public HealthyBurger(String meat, double price) &#123; super(&quot;Healthy&quot;, meat, price, &quot;Brown rye&quot;); &#125; public void addHealthyAddition1(String name, double price) &#123; this.healthyExtra1Name = name; this.healthyExtra1Price = price; &#125; public void addHealthyAddition2(String name, double price) &#123; this.healthyExtra2Name = name; this.healthyExtra2Price = price; &#125; @Override public double itemizeHamburger() &#123; double hamburgerPrice = super.itemizeHamburger(); if (this.healthyExtra1Name != null) &#123; hamburgerPrice += this.healthyExtra1Price; System.out.println(&quot;Added &quot; + this.healthyExtra1Name + &quot; for an extra &quot; + this.healthyExtra1Price); &#125; if (this.healthyExtra2Name != null) &#123; hamburgerPrice += this.healthyExtra2Price; System.out.println(&quot;Added &quot; + this.healthyExtra2Name + &quot; for an extra &quot; + this.healthyExtra2Price); &#125; return hamburgerPrice; &#125;&#125; 修改 Main.java 12345678910111213141516171819public class Main &#123; public static void main(String[] args) &#123; Hamburger hamburger = new Hamburger(&quot;Basic&quot;, &quot;Sausage&quot;, 3.56, &quot;White&quot;); hamburger.addHamburgerAddition1(&quot;Tomato&quot;, 0.27); hamburger.addHamburgerAddition2(&quot;Lettuce&quot;, 0.75); hamburger.addHamburgerAddition3(&quot;Cheese&quot;, 1.13); System.out.println(&quot;Total Burger price is &quot; + hamburger.itemizeHamburger()); HealthyBurger healthyBurger = new HealthyBurger(&quot;Bacon&quot;, 5.67); healthyBurger.addHamburgerAddition1(&quot;Egg&quot;, 5.43); healthyBurger.addHealthyAddition1(&quot;Lentils&quot;, 3.41); System.out.println(&quot;Total Healthy Burger price is &quot; + healthyBurger.itemizeHamburger()); DeluxeBurger db = new DeluxeBurger(); db.addHamburgerAddition3(&quot;Should not do this&quot;, 50.53); System.out.println(&quot;Total Deluxe Burger price is &quot; + db.itemizeHamburger()); &#125;&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://vincent.fishboneapps.com/tags/Java/"}]},{"title":"Java 快速學習自我挑戰 Day10","slug":"Java-快速學習自我挑戰-Day10","date":"2021-01-22T13:55:25.000Z","updated":"2021-01-24T03:06:37.106Z","comments":true,"path":"2021/01/22/Java-快速學習自我挑戰-Day10/","link":"","permalink":"https://vincent.fishboneapps.com/2021/01/22/Java-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day10/","excerpt":"","text":"物件導向程式設計 (OOP) - Classes, Constructors 和 Inheritance 繼承(Inheritance) 挑戰 Class 會自動從 Object Class 繼承，所以下面的程式碼是本來應該有的樣子，為了簡便，所以省略了 extends Object 123456public class Main extends Object &#123; public static void main(String[] args) &#123; &#125;&#125; 挑戰 Start with a base class of a Vehicle, then create a Car class that inherits from this base class. Finally, crate another class, a specific type of Car that inherits from the Car class. You should be able to hand steering, changing gears, and moving (speed in other words). You will want to decide where to put the appropriate state and behaviours (fields and methods). As mentioned above, changing gears, increasing/decreasing speed should be included. For you specific type of vehicle you will want to add something specific for that type of car. 新增 Vehicle.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Vehicle &#123; private String name; private String size; private int currentVelocity; private int currentDirection; public Vehicle(String name, String size) &#123; this.name = name; this.size = size; this.currentVelocity = 0; this.currentDirection = 0; &#125; public void steer(int direction) &#123; this.currentDirection += direction; System.out.println(&quot;Vehicle.steer(): Steering at &quot; + currentDirection + &quot; degrees.&quot;); &#125; public void move(int velocity, int direction) &#123; currentVelocity = velocity; currentDirection = direction; System.out.println(&quot;Vehicle.move(): Moving at &quot; + currentVelocity + &quot; in direction &quot; + currentDirection); &#125; public String getName() &#123; return name; &#125; public String getSize() &#123; return size; &#125; public int getCurrentVelocity() &#123; return currentVelocity; &#125; public int getCurrentDirection() &#123; return currentDirection; &#125; public void stop() &#123; this.currentVelocity = 0; &#125;&#125; 新增 Car.java 12345678910111213141516171819202122232425262728public class Car extends Vehicle &#123; private int wheels; private int doors; private int gears; private boolean isManual; private int currentGear; public Car(String name, String size, int wheels, int doors, int gears, boolean isManual) &#123; super(name, size); this.wheels = wheels; this.doors = doors; this.gears = gears; this.isManual = isManual; this.currentGear = 1; &#125; public void changeGear(int currentGear) &#123; this.currentGear = currentGear; System.out.println(&quot;Car.setCurrentGear(): Change to &quot; + this.currentGear + &quot; gear.&quot;); &#125; public void changeVelocity(int speed, int direction) &#123; move(speed, direction); System.out.println(&quot;Car.changeVelocity(): Velocity &quot; + speed + &quot; direction &quot; + direction); &#125;&#125; 新增 Outlander.java 123456789101112131415161718192021222324252627282930public class Outlander extends Car &#123; private int roadServiceMonths; public Outlander(int roadServiceMonths) &#123; super(&quot;Outlander&quot;, &quot;4WD&quot;, 5, 5, 6, false); this.roadServiceMonths = roadServiceMonths; &#125; public void accelerate(int rate) &#123; int newVelocity = getCurrentVelocity() + rate; if (newVelocity == 0) &#123; stop(); changeGear(1); &#125; else if (newVelocity &gt; 0 &amp;&amp; newVelocity &lt;= 10) &#123; changeGear(1); &#125; else if (newVelocity &gt; 10 &amp;&amp; newVelocity &lt;= 20) &#123; changeGear(2); &#125; else if (newVelocity &gt; 20 &amp;&amp; newVelocity &lt;= 30) &#123; changeGear(3); &#125; else &#123; changeGear(4); &#125; if (newVelocity &gt; 0) &#123; changeVelocity(newVelocity, getCurrentDirection()); &#125; &#125;&#125; 修改 Main.java 1234567891011public class Main &#123; public static void main(String[] args) &#123; Outlander outlander = new Outlander(36); outlander.steer(45); outlander.accelerate(30); outlander.accelerate(20); outlander.accelerate(-42); &#125;&#125; 練習：圓柱體 題目 Write a class with the name Circle. The class needs one field (instance variable) with name radius of type double. The class needs to have one constructor with parameter radius of type double and it needs to initialize the fields. In case the radius parameter is less than 0 it needs to set the radius field value to 0. Write the following methods (instance methods): Method named getRadius without any parameters, it needs to return the value of radius field. Method named getArea without any parameters, it needs to return the calculated area (radius * radius * PI). For PI use Math.PI constant. Write a class with the name Cylinder that extends Circle class. The class needs one field (instance variable) with name height of type double. The class needs to have one constructor with two parameters radius and height both of type double. It needs to call parent constructor and initialize a height field. In case the height parameter is less than 0 it needs to set the height field value to 0. Write the following methods (instance methods): Method named getHeight without any parameters, it needs to return the value of height field. Method named getVolume without any parameters, it needs to return the calculated volume. To calculate volume multiply the area with height. TEST EXAMPLE → TEST CODE: 12345678Circle circle = new Circle(3.75);System.out.println(&quot;circle.radius= &quot; + circle.getRadius());System.out.println(&quot;circle.area= &quot; + circle.getArea());Cylinder cylinder = new Cylinder(5.55, 7.25);System.out.println(&quot;cylinder.radius= &quot; + cylinder.getRadius());System.out.println(&quot;cylinder.height= &quot; + cylinder.getHeight());System.out.println(&quot;cylinder.area= &quot; + cylinder.getArea());System.out.println(&quot;cylinder.volume= &quot; + cylinder.getVolume()); → OUTPUT 123456circle.radius= 3.75circle.area= 44.178646691106465cylinder.radius= 5.55cylinder.height= 7.25cylinder.area= 96.76890771219959cylinder.volume= 701.574580913447 NOTE: All methods should be defined as public NOT public static. NOTE: In total, you have to write 2 classes. NOTE: Do not add a main method to the solution code. 答案 新增 Circle.java 123456789101112131415public class Circle &#123; private double radius; public Circle(double radius) &#123; this.radius = (radius &lt; 0) ? 0 : radius; &#125; public double getRadius() &#123; return radius; &#125; public double getArea() &#123; return radius * radius * Math.PI; &#125;&#125; 新增 Cylinder.java 12345678910111213141516public class Cylinder extends Circle &#123; private double height; public Cylinder(double radius, double height) &#123; super(radius); this.height = (height &lt; 0) ? 0 : height; &#125; public double getHeight() &#123; return height; &#125; public double getVolume() &#123; return getArea() * height; &#125;&#125; 練習：游泳池面積 題目 The Swimming Company has asked you to write an application that calculates the volume of cuboid shaped pools. Write a class with the name Rectangle. The class needs two fields (instance variable) with name width and length both of type double. The class needs to have one constructor with parameters width and length both of type double and it needs to initialize the fields. In case the width parameter is less than 0 it needs to set the width field value to 0. In case the length parameter is less than 0 it needs to set the length field value to 0. Write the following methods (instance methods): Method named getWidth without any parameters, it needs to return the value of width field. Method named getLength without any parameters, it needs to return the value of length field. Method named getArea without any parameters, it needs to return the calculated area (width * length). Write a class with the name Cuboid that extends Rectangle class. The class needs one field (instance variable) with name height of type double. The class needs to have one constructor with three parameters width, length, and height all of type double. It needs to call parent constructor and initialize a height field. In case the height parameter is less than 0 it needs to set the height field value to 0. Write the following methods (instance methods): Method named getHeight without any parameters, it needs to return the value of height field. Method named getVolume without any parameters, it needs to return the calculated volume. To calculate volume multiply the area with height. TEST EXAMPLE → TEST CODE: 12345678910Rectangle rectangle = new Rectangle(5, 10);System.out.println(&quot;rectangle.width= &quot; + rectangle.getWidth());System.out.println(&quot;rectangle.length= &quot; + rectangle.getLength());System.out.println(&quot;rectangle.area= &quot; + rectangle.getArea());Cuboid cuboid = new Cuboid(5,10,5);System.out.println(&quot;cuboid.width= &quot; + cuboid.getWidth());System.out.println(&quot;cuboid.length= &quot; + cuboid.getLength());System.out.println(&quot;cuboid.area= &quot; + cuboid.getArea());System.out.println(&quot;cuboid.height= &quot; + cuboid.getHeight());System.out.println(&quot;cuboid.volume= &quot; + cuboid.getVolume()); → OUTPUT 12345678rectangle.width= 5.0rectangle.length= 10.0rectangle.area= 50.0cuboid.width= 5.0cuboid.length= 10.0cuboid.area= 50.0cuboid.height= 5.0cuboid.volume= 250.0 NOTE: All methods should be defined as public NOT public static. NOTE: In total, you have to write 2 classes. NOTE: Do not add a main method to the solution code. 答案 新增 Rectangle.java 123456789101112131415161718192021public class Rectangle &#123; private double width; private double length; public Rectangle(double width, double length) &#123; this.width = (width &lt; 0) ? 0 : width; this.length = (length &lt; 0) ? 0 : length; &#125; public double getWidth() &#123; return width; &#125; public double getLength() &#123; return length; &#125; public double getArea() &#123; return width * length; &#125;&#125; 新增 Cuboid.java 12345678910111213141516public class Cuboid extends Rectangle &#123; private double height; public Cuboid(double width, double length, double height) &#123; super(width, length); this.height = (height &lt; 0) ? 0 : height; &#125; public double getHeight() &#123; return height; &#125; public double getVolume() &#123; return getArea() * height; &#125;&#125; 物件導向程式設計 (OOP) - Composition, Encapsulation 和 Polymorphism Composition 在 Inheritance 的地方，我們使用了 Car 和 Vehicle 的例子，可以理解成 Car 就是 Vehicle 的一種。但是在某些情況，例如：電腦有機殼、螢幕和主機板，機殼不等於電腦；螢幕也不等於電腦；主機板也不等於電腦，我們就不用 Inheritance，用 Composition 更適合這樣的情境，同時，電腦這個 Class 還可以繼承三種 Class，而不僅僅只能 extends 一種 Class。以下用 Java 呈現電腦的範例。 新增 Motherboard.java 12345678910111213141516171819202122232425262728293031323334353637383940public class Motherboard &#123; private String model; private String manufacturer; private int ramSlots; private int cardSlots; private String bios; public Motherboard(String model, String manufacturer, int ramSlots, int cardSlots, String bios) &#123; this.model = model; this.manufacturer = manufacturer; this.ramSlots = ramSlots; this.cardSlots = cardSlots; this.bios = bios; &#125; public void loadProgram(String programName) &#123; System.out.println(&quot;Program &quot; + programName + &quot; is now loading...&quot;); &#125; public String getModel() &#123; return model; &#125; public String getManufacturer() &#123; return manufacturer; &#125; public int getRamSlots() &#123; return ramSlots; &#125; public int getCardSlots() &#123; return cardSlots; &#125; public String getBios() &#123; return bios; &#125;&#125; 新增 Monitor.java 12345678910111213141516171819202122232425262728293031323334public class Monitor &#123; private String model; private String manufacturer; private int size; private Resolution nativeResolution; public Monitor(String model, String manufacturer, int size, Resolution nativeResolution) &#123; this.model = model; this.manufacturer = manufacturer; this.size = size; this.nativeResolution = nativeResolution; &#125; public void drawPixelAt(int x, int y, String color) &#123; System.out.println(&quot;Drawing pixel at &quot; + x + &quot;,&quot; + y + &quot; in colour &quot; + color); &#125; public String getModel() &#123; return model; &#125; public String getManufacturer() &#123; return manufacturer; &#125; public int getSize() &#123; return size; &#125; public Resolution getNativeResolution() &#123; return nativeResolution; &#125;&#125; 新增 Resolution.java 1234567891011121314151617public class Resolution &#123; private int width; private int height; public Resolution(int width, int height) &#123; this.width = width; this.height = height; &#125; public int getWidth() &#123; return width; &#125; public int getHeight() &#123; return height; &#125;&#125; 新增 Case.java 12345678910111213141516171819202122232425262728293031323334public class Case &#123; private String model; private String manufacturer; private String powerSupply; private Dimensions dimensions; public Case(String model, String manufacturer, String powerSupply, Dimensions dimensions) &#123; this.model = model; this.manufacturer = manufacturer; this.powerSupply = powerSupply; this.dimensions = dimensions; &#125; public void pressPowerButton() &#123; System.out.println(&quot;Power button pressed&quot;); &#125; public String getModel() &#123; return model; &#125; public String getManufacturer() &#123; return manufacturer; &#125; public String getPowerSupply() &#123; return powerSupply; &#125; public Dimensions getDimensions() &#123; return dimensions; &#125;&#125; 新增 Dimensions.java 123456789101112131415161718192021222324public class Dimensions &#123; private int width; private int height; private int depth; public Dimensions(int width, int height, int depth) &#123; this.width = width; this.height = height; this.depth = depth; &#125; public int getWidth() &#123; return width; &#125; public int getHeight() &#123; return height; &#125; public int getDepth() &#123; return depth; &#125;&#125; 修改 Main.java 1234567891011121314151617public class Main &#123; public static void main(String[] args) &#123; Dimensions dimensions = new Dimensions(20, 20, 5); Case theCase = new Case(&quot;220B&quot;, &quot;Dell&quot;, &quot;240&quot;, dimensions); // 我們也可以使用 new 的方式來新增物件 Monitor theMonitor = new Monitor(&quot;27 inch Beast&quot;, &quot;Acer&quot;, 27, new Resolution(2540, 1440)); Motherboard theMotherboard = new Motherboard(&quot;BJ-200&quot;, &quot;Asus&quot;, 4, 6, &quot;v2.44&quot;); PC thePC = new PC(theCase, theMonitor, theMotherboard); thePC.getMonitor().drawPixelAt(1500, 1200, &quot;red&quot;); thePC.getMotherboard().loadProgram(&quot;Windows 1.0&quot;); thePC.getTheCase().pressPowerButton(); &#125;&#125; 如何選擇 Composition 和 Inheritance？ 如果你使用 Java，推薦先使用 Composition，這會給你更多額外的優點和彈性，但是還是需要看你想要解決的問題來決定。 挑戰 題目 Create a single room of a house using composition. Think about the things that should be included in the room. Maybe physical parts of the house but furniture as well Add at least one method to access an object via a getter and then that objects public method as you saw in the previous video then add at least one method to hide the object e.g. not using a getter but to access the object used in composition within the main class like you saw in this video. 答案 新增 Bedroom.java 12345678910111213141516171819202122232425262728293031public class Bedroom &#123; private String name; private Wall wall1; private Wall wall2; private Wall wall3; private Wall wall4; private Ceiling ceiling; private Bed bed; private Lamp lamp; public Bedroom(String name, Wall wall1, Wall wall2, Wall wall3, Wall wall4, Ceiling ceiling, Bed bed, Lamp lamp) &#123; this.name = name; this.wall1 = wall1; this.wall2 = wall2; this.wall3 = wall3; this.wall4 = wall4; this.ceiling = ceiling; this.bed = bed; this.lamp = lamp; &#125; public Lamp getLamp() &#123; return lamp; &#125; public void makeBed() &#123; System.out.println(&quot;Bedroom -&gt; Making bed&quot;); bed.make(); &#125;&#125; 新增 Wall.java 123456789101112public class Wall &#123; private String direction; public Wall(String direction) &#123; this.direction = direction; &#125; public String getDirection() &#123; return direction; &#125;&#125; 新增 Ceiling.java 123456789101112131415161718public class Ceiling &#123; private int height; private int paintedColor; public Ceiling(int height, int paintedColor) &#123; this.height = height; this.paintedColor = paintedColor; &#125; public int getHeight() &#123; return height; &#125; public int getPaintedColor() &#123; return paintedColor; &#125;&#125; 新增 Bed.java 12345678910111213141516171819202122232425262728293031323334353637383940public class Bed &#123; private String style; private int pillows; private int height; private int sheets; private int quilt; public Bed(String style, int pillows, int height, int sheets, int quilt) &#123; this.style = style; this.pillows = pillows; this.height = height; this.sheets = sheets; this.quilt = quilt; &#125; public void make() &#123; System.out.println(&quot;Bed -&gt; Making&quot;); &#125; public String getStyle() &#123; return style; &#125; public int getPillows() &#123; return pillows; &#125; public int getHeight() &#123; return height; &#125; public int getSheets() &#123; return sheets; &#125; public int getQuilt() &#123; return quilt; &#125;&#125; 新增 Lamp.java 12345678910111213141516171819202122232425262728public class Lamp &#123; private String style; private boolean battery; private int globRating; public Lamp(String style, boolean battery, int globRating) &#123; this.style = style; this.battery = battery; this.globRating = globRating; &#125; public void turnOn() &#123; System.out.println(&quot;Lamp -&gt; Turning on&quot;); &#125; public String getStyle() &#123; return style; &#125; public boolean isBattery() &#123; return battery; &#125; public int getGlobRating() &#123; return globRating; &#125;&#125; 修改 Main.java 1234567891011121314Wall wall1 = new Wall(&quot;West&quot;);Wall wall2 = new Wall(&quot;East&quot;);Wall wall3 = new Wall(&quot;South&quot;);Wall wall4 = new Wall(&quot;North&quot;);Ceiling ceiling = new Ceiling(12, 55);Bed bed = new Bed(&quot;Modern&quot;, 4, 3, 2, 1);Lamp lamp = new Lamp(&quot;Classic&quot;, false, 75);Bedroom bedroom = new Bedroom(&quot;Vincent&quot;, wall1, wall2, wall3, wall4, ceiling, bed, lamp);bedroom.makeBed();bedroom.getLamp().turnOn();","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://vincent.fishboneapps.com/tags/Java/"}]},{"title":"Java 快速學習自我挑戰 Day9","slug":"Java-快速學習自我挑戰-Day9","date":"2020-06-22T00:43:52.000Z","updated":"2021-01-22T14:09:05.637Z","comments":true,"path":"2020/06/21/Java-快速學習自我挑戰-Day9/","link":"","permalink":"https://vincent.fishboneapps.com/2020/06/21/Java-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day9/","excerpt":"","text":"物件導向程式設計 (OOP) - Classes, Constructors 和 Inheritance 挑戰 地毯花費計算器 題目 The Carpet Company has asked you to write an application that calculates the price of carpeting for rectangular rooms. To calculate the price, you multiply the area of the floor (width times length) by the price per square meter of carpet. For example, the area of the floor that is 12 meters long and 10 meters wide is 120 square meters. To cover the floor with a carpet that costs $8 per square meter would cost $960. Write a class with the name Floor. The class needs two fields (instance variables) with name width and length of type double. The class needs to have one constructor with parameters width and length of type double and it needs to initialize the fields. In case the width parameter is less than 0 it needs to set the width field value to 0, in case the length parameter is less than 0 it needs to set the length field value to 0. Write the following methods (instance methods): Method named getArea without any parameters, it needs to return the calculated area (width * length). Write a class with the name Carpet. The class needs one field (instance variable) with name cost of type double. The class needs to have one constructor with parameter cost of type double and it needs to initialize the field. In case the cost parameter is less than 0 it needs to set the cost field value to 0. Write the following methods (instance methods): Method named getCost without any parameters, it needs to return the value of cost field Write a class with the name Calculator. The class needs two fields (instance variables) with name floor of type Floor and carpet of type Carpet. The class needs to have one constructor with parameters floor of type Floor and carpet of type Carpet and it needs to initialize the fields. Write the following methods (instance methods): Method named getTotalCost without any parameters, it needs to return the calculated total cost to cover the floor with a carpet. TEST EXAMPLE 123456789101112131415→ TEST CODE:Carpet carpet = new Carpet(3.5);Floor floor = new Floor(2.75, 4.0);Calculator calculator = new Calculator(floor, carpet);System.out.println(&quot;total= &quot; + calculator.getTotalCost());carpet = new Carpet(1.5);floor = new Floor(5.4, 4.5);calculator = new Calculator(floor, carpet);System.out.println(&quot;total= &quot; + calculator.getTotalCost());→ OUTPUTtotal= 38.5total= 36.45 NOTE: All methods should be defined as public NOT public static. NOTE: In total, you have to write 3 classes. NOTE: Do not add a main method to the solution code. 2. 答案 Floor.java 1234567891011121314151617181920212223242526272829public class Floor &#123; private double width; private double length; public Floor(double width, double length) &#123; if (width &lt; 0) &#123; this.width = 0; &#125; else &#123; this.width = width; &#125; if (length &lt; 0) &#123; this.length = 0; &#125; else &#123; this.length = length; &#125; &#125; public double getArea() &#123; return this.width * this.length; &#125;&#125; Carpet.java 1234567891011121314151617181920public class Carpet &#123; private double cost; public Carpet(double cost) &#123; if (cost &lt; 0) &#123; this.cost = 0; &#125; else &#123; this.cost = cost; &#125; &#125; public double getCost() &#123; return this.cost; &#125;&#125; Calculator.java 12345678910111213141516public class Calculator &#123; private Floor floor; private Carpet carpet; public Calculator(Floor floor, Carpet carpet) &#123; this.floor = floor; this.carpet = carpet; &#125; public double getTotalCost() &#123; return floor.getArea() * carpet.getCost(); &#125;&#125; 複數操作 (Complex Operation) 題目 A complex number is a number that can be expressed in the form a + bi, where a and b are real numbers, and i is a solution of the equation x2 = −1. Because no real number satisfies this equation, i is called an imaginary number. For the complex number a + bi, a is called the real part, and b is called the imaginary part. To add or subtract two complex numbers, just add or subtract the corresponding real and imaginary parts. For instance, the sum of 5 + 3i and 4 + 2i is 9 + 5i. For another, the sum of 3 + i and –1 + 2i is 2 + 3i. Write a class with the name ComplexNumber. The class needs two fields (instance variables) with name real and imaginary of type double. It represents the Complex Number. The class needs to have one constructor. The constructor has parameters real and imaginary of type double and it needs to initialize the fields. Write the following methods (instance methods): * Method named getReal without any parameters, it needs to return the value of real field. * Method named getImaginary without any parameters, it needs to return the value of imaginary field. * Method named add with two parameters real and imaginary of type double, it needs to add parameters to fields. In other words, it needs to do a complex number add operation as described above. * Method named add with one parameter of type ComplexNumber. It needs to add the ComplexNumber parameter to the corresponding instance variables. * Method named subtract with two parameters real and imaginary of type double, it needs to subtract parameters from fields, in other words, it needs to do a complex number subtract operation as described above. * Method named subtract with one parameter other of type ComplexNumber. It needs to subtract the other parameter from this complex number. TEST EXAMPLE 12345678910111213141516171819202122→ TEST CODE:ComplexNumber one = new ComplexNumber(1.0, 1.0);ComplexNumber number = new ComplexNumber(2.5, -1.5);one.add(1,1);System.out.println(&quot;one.real= &quot; + one.getReal());System.out.println(&quot;one.imaginary= &quot; + one.getImaginary());one.subtract(number);System.out.println(&quot;one.real= &quot; + one.getReal());System.out.println(&quot;one.imaginary= &quot; + one.getImaginary());number.subtract(one);System.out.println(&quot;number.real= &quot; + number.getReal());System.out.println(&quot;number.imaginary= &quot; + number.getImaginary());→ OUTPUTone.real= 2.0one.imaginary= 2.0one.real= -0.5one.imaginary= 3.5number.real= 3.0number.imaginary= -5.0 NOTE: Try to avoid duplicated code. NOTE: All methods should be defined as public NOT public static. NOTE: In total, you have to write 6 methods. NOTE: Do not add a main method to the solution code. 2. 答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ComplexNumber &#123; private double real; private double imaginary; public ComplexNumber(double real, double imaginary) &#123; this.real = real; this.imaginary = imaginary; &#125; public double getReal() &#123; return real; &#125; public double getImaginary() &#123; return imaginary; &#125; public void add(double real, double imaginary) &#123; this.real += real; this.imaginary += imaginary; &#125; public void add(ComplexNumber complex) &#123; this.real += complex.getReal(); this.imaginary += complex.getImaginary(); &#125; public void subtract(double real, double imaginary) &#123; this.real -= real; this.imaginary -= imaginary; &#125; public void subtract(ComplexNumber complex) &#123; this.real -= complex.getReal(); this.imaginary -= complex.getImaginary(); &#125;&#125; 繼承(Inheritance) 繼承會用動物的概念來去解釋，比方說要寫一個動物的 Class，動物會有共同的東西，比方大腦，身體，腿，眼睛，但是蛇沒有腿，有些蜘蛛也沒有眼睛，所以有些東西會是共用的，共用的部分，可以使用繼承的方式來實現。首先，新增一個 Animal 的 Class。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Animal &#123; private String name; private int brain; private int body; private int size; private int weight; public Animal(String name, int brain, int body, int size, int weight) &#123; this.name = name; this.brain = brain; this.body = body; this.size = size; this.weight = weight; &#125; public void eat() &#123; System.out.println(&quot;Animal.eat() called&quot;); &#125; public void move() &#123; &#125; public String getName() &#123; return name; &#125; public int getBrain() &#123; return brain; &#125; public int getBody() &#123; return body; &#125; public int getSize() &#123; return size; &#125; public int getWeight() &#123; return weight; &#125;&#125; 再新增一個 Dog 的 Class，並使用 extends 去繼承，我們可以在繼承的 Class 新增一些新的類別，比方說，牙齒、尾巴等等，使用 super() 語法繼承上面一層的 Class，如果想覆寫(Overiding)方法，可以使用 @Override。 12345678910111213141516171819202122232425262728293031public class Dog extends Animal &#123; private int eyes; private int legs; private int tail; private int teeth; private String coat; public Dog(String name, int size, int weight, int eyes, int legs, int tail, int teeth, String coat) &#123; super(name, 1, 1, size, weight); this.eyes = eyes; this.legs = legs; this.tail = tail; this.teeth = teeth; this.coat = coat; &#125; private void chew() &#123; System.out.println(&quot;Dog.chew() called&quot;); &#125; @Override public void eat() &#123; System.out.println(&quot;Dog.eat() called&quot;); chew(); super.eat(); &#125;&#125; 新增 walk(), run()，但是用不同的方式呼叫 move，如果直接使用 move()，他會呼叫同個 Class 裡面的 move()，如果同個 Class 沒有 move()，就會去呼叫上層的 move()，而使用 super.move() 會直接呼叫上層的 move()。 1234567891011121314151617181920212223242526public class Dog extends Animal &#123; ... public void walk() &#123; System.out.println(&quot;Dog.walk() called&quot;); super.move(5); &#125; public void run() &#123; System.out.println(&quot;Dog.run() called&quot;); move(10); &#125; private void moveLegs(int speed) &#123; System.out.println(&quot;Dog.moveLegs called&quot;); &#125; @Override public void move(int speed) &#123; System.out.println(&quot;Dog.move() called&quot;); moveLegs(speed); super.move(speed); &#125;&#125; 新增一個 Fish.java，再次練習繼承的概念。 123456789101112131415161718192021222324252627282930313233public class Fish extends Animal&#123; private int gills; private int eyes; private int fins; public Fish(String name, int brain, int body, int size, int weight, int gills, int eyes, int fins) &#123; super(name, 1, 1, size, weight); this.gills = gills; this.eyes = eyes; this.fins = fins; &#125; private void rest() &#123; &#125; private void moveMuscles() &#123; &#125; private void moveBackFin() &#123; &#125; private void swim(int speed) &#123; moveMuscles(); moveBackFin(); super.move(speed); &#125;&#125; Reference vs Object vs Instance vs Class 透過建房子來了解這些名詞的概念。 Class 就是藍圖，使用藍圖，我們可以根據這個計畫建立很多房子。 每一個蓋的房子就是 Object，也稱為 Instance。 每一棟房子都有實體地址，也就是說，你想要告訴別人你住在哪裡，你必須給他們地址(或許寫在一張紙上)，這就稱為 Reference。 你可以複製 Reference 多少次都可以，但是你還是只有一棟房子，所以我們複製藍圖的時候，地址並不是現在要蓋的那一棟。 我們將 References 當作 parameters 傳送到 Constructors 和 Methods。 一開始創建物件，給予 blueHouse 藍色的 Reference，然後定義 anotherHouse 等於 blueHouse，這時候他們會共用一個 Object，所以當設定 anotherHouse 為黃色的時候，blueHouse 也會變成黃色，這時候再定義一個 greenHouse Reference 為 green，然後再次定義 anotherHouse 等於 greenHouse，這時候他們又會共用一個 Object，而 blueHouse 自己一個 Object，最後當 getColor() 的時候，blueHouse 就會等於黃色，而 greenHouse 和 anotherHouse 就等於綠色。 12345678910111213141516171819202122public class Main &#123; public static void main(String[] args) &#123; House blueHouse = new House(&quot;blue&quot;); House anotherHouse = bluehouse; System.out.println(blueHouse.getColor()); // blue System.out.println(anotherHouse.getColor()); // blue anotherHouse.setColor(&quot;yellow&quot;); System.out.println(blueHouse.getColor()); // yellow System.out.println(anotherHouse.getColor()); // yellow House greenHouse = new House(&quot;green&quot;); anotherHouse = greenHouse; System.out.println(blueHouse.getColor()); // yellow System.out.println(greenHouse.getColor()); // green System.out.println(anotherHouse.getColor()); //green &#125;&#125; this vs super 關鍵字 super 是用來呼叫上層的 Class 成員(變數和方法)，而關鍵字 this 是用來呼叫同一層的 Class 成員(變數和方法)，但是當 Instance 有相同的變數名稱，this 就是必要的。 注意：我們可以在 Class 裡面同時使用 this 和 super，但是 static 區域(靜態 Class 或靜態 Method)是不行的，如果想要在靜態區域做任何嘗試，都會導致編譯器錯誤。 關鍵字 this 很常被使用在 Constructors 和 Setters，偶而也會在 Getters 裡使用(對使用者比較容易)，下面的例子中，this 被使用在 Constructors 和 Setters，因為有同樣的名稱所以一定要用 this，在 Getter 中，我們沒有任何相同的參數，所以關鍵字 this 是選擇性的。 12345678910111213141516171819Class House &#123; private String color; public House(String color) &#123; this.color = color; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125;&#125; 關鍵字 super 很常跟 method overriding 一起使用，我們會使用 super 在當前 Class 呼叫上層 Class 同名的 Method，如果沒有使用 super 會導致 Recursive Call(遞歸呼叫)，意思就是他會無止盡的呼叫 Method，直到記憶體用盡，這就為什麼 super 是必要的。 在 Java 中，我們有 this() 和 super() 的 Call，() 被稱為 Call，因為它很像一般的 Method Call。 使用 this() 來呼叫一個 Constructor，這個 Constructor 是在同一個 Class 的其它 overloaded Constructor。 this() 只能被使用在 Constructor，而且它必須用在 Constructor 的第一行陳述句，而它被用來當作 Constructor chaining 的功用，當一個 Constructor 呼叫另外一個 Constructor 可以幫助減少程式碼。 呼叫上層 Constructor 唯一的方式就是呼叫 super()，所以它也被稱為上層 Constructor Java 編譯器會自動放一個 super() 作為預設的 Call，而且被編譯器插入的 super 都是沒有參數的。 super() 的 Call 一定要放在每一個 Constructor 的第一行陳述句。 即使 Abstract Classes 有 Constructors，但是你不能使用新的關鍵字來實例化 Abstract Class。 Abstract Classes 仍然是一個 super Class，所以當有人建立一個 Concrete Class Instance，它的 Constructors 還是會執行的。 注意：一個 Constructor 可以有 super() 和 this()，但是不能同時使用這兩個關鍵字。 好的 Constructor 範例如下，第一個 Constructor 呼叫第二個，第二個 Constructor 呼叫第三個，而第三個初始化所有 Instance 變數。不管我們呼叫哪一個 Constructor，最後變數都會在第三個 Constructor 做初始化。這就是知名的 Construcor Chaining，第三個 Constructor 有責任來初始化所有變數。 1234567891011121314151617181920212223242526272829class Rectangle &#123; private int x; private int y; private int width; private int height; // 1st constructor public Rectangle() &#123; this(0, 0); // calls 2nd constructor &#125; // 2nd constructor public Rectangle(int width, int height) &#123; this(0, 0, width, height); // calls 3rd constructor &#125; // 3rd constructor public Rectangle(int x, int y, int width, int height) &#123; // initialize variables this.x = x; this.y = y; this.width = width; this.height = height; &#125;&#125; 在範例中，我們有一個 Class Shape，它有 x 和 y 的變數，而 Class Rectangle 繼承 Class Shape 的變數並加上 width 和 height。在 Retangle 裡面，第一個 Constructor 呼叫第二個 Constructor，第二個 Constructor 呼叫了有變數 x 和 y 的上層 Constructor。上層的 Constructor 會初始化 x 和 y，而 Rectangle 的第二個 Constructor 會初始化 width 和 height 變數。在這邊我們同時有 super() 和 this() 的 Calls。 123456789101112131415161718192021222324252627282930class Shape &#123; private int x; private int y; public Shape(int x, int y) &#123; this.x = x; this.y = y; &#125;&#125;class Rectangle extends Shape &#123; private int width; private int height; // 1st constructor public Retangle(int x, int y) &#123; this(x, y, 0, 0); // calss 2nd constructor &#125; // 2nd constructor public Rectangle(int x, int y, int width, int height) &#123; super(x, y); // calls constructor from parent (Shape) this.width = width; this.height = height; &#125;&#125; 方法過載(Method Overloading) vs 方法覆寫(Method Overriding) 回顧 方法過載 方法過載就是在同一個 Class 放入好幾個相同名字的方法，但是這些方法有不同的變數。 這些方法回傳的值型態可以不一樣也可以一樣，這種方法可以讓我們重複使用相同的方法。 方法過載很好使用，因為它減少了重複的程式碼，而且我們可以不用記住很多種方法的名稱。 方法過載跟多態性(Polymorphism) 無關，但是 Java 開發者常常把方法過載當作 Compile Time Polymorphism。 換句話說，編譯器決定哪個方法被呼叫是根據方法名稱、回傳型態和參數列表。 我們可以過載 static 和 Instance 方法。 通常來說，過載只會發生在同一個 Class，但是在下層 Class 的同一種方法也可以被當作過載。 這是因為下層 Class 繼承從上層 Class 的一個方法，並在下層 Class 使用這個方法來過載的另一個方法。 如果以下兩個原則被達成，方法會被視為過載 方法有兩個相同的名稱。 方法有不同的變數。 如果方法達到以上兩個原則，它們可能或可能不會 有不同的變數回傳型態。 有不同的存取修改器(Access Modifier)。 回傳受檢查或未檢查過的異常(Exception)。 方法覆寫 方法覆寫就是有一個在下層 Class 的方法已經存在上層有相同方法(相同名稱、相同參數)的 Class。 透過擴展(Extending)上層 Class，下層 Class 會取得上層 Class 所有的方法(這些方法又被稱為衍生方法(Derived Method))。 方法覆寫又被稱為 運行多態(Runtime Polymorphism) 或動態方法分配(Dynamic Method Dispatch)，因為在運行時是透過 JVM 來決定哪個方法被呼叫。 當我們覆寫方法時，會建議放 @override 在方法前面，這是一個註解，當編譯器看到註解發現我們沒有跟隨覆寫的規則時，就會顯示錯誤給我們。 我們不能覆寫 static，只能覆寫 Instance 方法。 如果以下原則被達成，方法會被視為覆寫 它有相同名字和相同參數。 下層的回傳型態要和上層回傳型態相同。 它不同有較低層級的存取修改器(Access Modifier)。 例如：上層方法是 protected，下層方法使用 private 是不允許的，但是使用 public 是允許的。 關於方法覆寫還有一些很重要的點 只有繼承的方法才可以被覆寫，換句話說，方法只能在下層被覆寫。 Constructors 和 private 方法不能被覆寫。 方法是 final 也不能被覆寫。 下層 Class 使用 super.methodName() 來呼叫上層要被覆寫的方法。 回顧 方法過載 方法覆寫 提供重新使用一個有同名字的方法。 用來覆寫一個從上層繼層的 Class 的行為。 通常都在同一個 Class，但是有時侯也可以在下層 Class。 一定要在兩個有上層-下層或 IS-A 關係的 Classes 裡面。 一定要有不同參數。 一定要有相同參數和相同名稱。 可以有不同的回傳型態。 一定要有相同的回傳型態或是協變(covariant)的回傳型態(下層)。 可以有不同的存取修改器(private, protected, public)。 一定不能有低權限的存取修改器，但是可以較高權限的存取修改器。 可以回傳不同異常。 一定不能回傳一個新的或是更廣泛的受檢異常(Checked Exception)。 static vs Instance 方法 靜態方法(Static Method) 靜態方法 用 static 修改器來表示。 靜態方法不能直接存取 Instance 方法或是 Instance 變數。 它們通常被用在不需要 Instance 的任何資料(從 this 來的資料)的操作。 關鍵字 this 就是當前 Class 的 Instance。 在靜態方法，我們不能使用 this 關鍵字。 當你看到一個方法不需要使用 Instance 變數，那個變數就應該被定義為靜態方法。 例如：main 就是一個靜態方法，它在 JVM 啟動程式的時候就會被呼叫。 Instance 方法 Instance 方法屬於 Class 的 Instance。 要使用 Instance 方法，我們首先必須要使用關鍵字 new 初始化 Class。 Instance 方法可以直接存取 Instance 方法和 Instance 變數。 Instance 方法也可以直接存取靜態方法和靜態變數。 要使用 Instance 還是 static 方法？ 它需要任何欄位(Instance 變數)或 Instance 方法嗎？ Yes: 它可能是 Instance 方法。 No: 它可能是 靜態方法。 static vs Instance 變數 靜態變數 使用關鍵字 static 來宣告變數。 靜態變數又被稱為 static member variables。 那個 Class 的每一個 Instance 共享相同的靜態變數。 如果那個變數被改變了，所有的 Instance 都會看到那個改變。 靜態變數並不常常被使用，但是有時候非常有用。 例如：我們使用 Scanner 讀取用戶輸入，我們可以宣告 scanner 為靜態變數。 如此一來，所有的靜態方法就都可以直接讀取靜態變數。 在範例中，我們第一次定義 name 為 rex，第二次定義 name 為 fluffy，最後兩次輸出都會是 fluffy，因為靜態變數一旦被改變，會全域進行改變，所以在正常的情境下，使用 Instance 會比較合理。 12345678910111213141516171819202122232425class Dog &#123; private static String name; public Dog(String name) &#123; Dog.name = name; &#125; public void printName() &#123; System.out.println(&quot;name= &quot; + name); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Dog rex = new Dog(&quot;rex&quot;); // Create Instance (rex) Dog fluffy = new Dog(&quot;fluffy&quot;); // Create Instance (fluffy) rex.printName(); // print fluffy fluffy.printName(); // print fluffy &#125;&#125; Instance 變數 它們不使用關鍵字 static。 Instance 變數又被稱為 fields 或 member variables。 Instance 變數屬於一個 Class 的特定 Instance。 每一個 Instance 都會有一個 Instance 變數的備份。 每一個 Instance 都會有不同的值或狀態(state)。 Instance 變數代表 Instance 的 state。 在範例中我們用 Instance，所以會兩次會輸出不同的結果，每個 Instance 有自己的值和狀態， 12345678910111213141516171819202122232425class Dog &#123; private String name; public Dog(String name) &#123; Dog.name = name; &#125; public void printName() &#123; System.out.println(&quot;name= &quot; + name); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Dog rex = new Dog(&quot;rex&quot;); // Create Instance (rex) Dog fluffy = new Dog(&quot;fluffy&quot;); // Create Instance (fluffy) rex.printName(); // print rex fluffy.printName(); // print fluffy &#125;&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://vincent.fishboneapps.com/tags/Java/"}]},{"title":"Java 快速學習自我挑戰 Day8","slug":"Java-快速學習自我挑戰-Day8","date":"2020-06-18T17:35:23.000Z","updated":"2021-01-25T08:24:26.377Z","comments":true,"path":"2020/06/18/Java-快速學習自我挑戰-Day8/","link":"","permalink":"https://vincent.fishboneapps.com/2020/06/18/Java-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day8/","excerpt":"","text":"物件導向程式設計 (OOP) - Classes, Constructors 和 Inheritance Classes 真實世界的物件有兩種特徵，狀態(State)和行為(Behavior)，在物件導向程式裡面，同樣也有狀態和行為。Class 則是用來創建物件的模板，前面我們使用的都是原始資料型態(Primtive Data Type)，可以用的非常有限，而使用 Class 可以自定義資料型態，雖然在真實意義上這麼說，並不是很準確，但是我們可以知道 Class 能夠有強力的用戶自定義資料型態。 在 src 目錄底下點選右鍵，New &gt; Java Class 新增 Car。 123456789101112131415161718192021222324252627public class Car &#123; private int doors; private int wheels; private String model; private String engine; private String color; public void setModel(String model) &#123; String validModel = model.toLowerCase(); if (validModel.equals(&quot;carrera&quot;) || validModel.equals(&quot;commodore&quot;)) &#123; this.model = model; &#125; else &#123; this.model = &quot;Unknown&quot;; &#125; &#125; public String getModel() &#123; return this.model; &#125;&#125; 在 Main 引入 class 並使用。 12345678910111213public class Main &#123; public static void main(String[] args) &#123; Car porsche = new Car(); Car holden = new Car(); porsche.setModel(&quot;Carrera&quot;); System.out.println(&quot;Model is &quot; + porsche.getModel()); &#125;&#125; 加總計算機 挑戰 Write a class with the name SimpleCalculator. The class needs two fields (instance variables) with names firstNumber and secondNumber both of type double. Write the following methods (instance methods): Method named getFirstNumber without any parameters, it needs to return the value of firstNumber field. Method named getSecondNumber without any parameters, it needs to return the value of secondNumber field. Method named setFirstNumber with one parameter of type double, it needs to set the value of the firstNumber field. Method named setSecondNumber with one parameter of type double, it needs to set the value of the secondNumberfield. Method named getAdditionResult without any parameters, it needs to return the result of adding the field values of firstNumber and secondNumber. Method named getSubtractionResult without any parameters, it needs to return the result of subtracting the field values of secondNumber from the firstNumber. Method named getMultiplicationResult without any parameters, it needs to return the result of multiplying the field values of firstNumber and secondNumber. Method named getDivisionResult without any parameters it needs to return the result of dividing the field values of firstNumber by the secondNumber. In case the value of secondNumber is 0 then return 0. TEST EXAMPLE 123456789101112131415161718TEST CODE:SimpleCalculator calculator = new SimpleCalculator();calculator.setFirstNumber(5.0);calculator.setSecondNumber(4);System.out.println(&quot;add= &quot; + calculator.getAdditionResult());System.out.println(&quot;subtract= &quot; + calculator.getSubtractionResult());calculator.setFirstNumber(5.25);calculator.setSecondNumber(0);System.out.println(&quot;multiply= &quot; + calculator.getMultiplicationResult());System.out.println(&quot;divide= &quot; + calculator.getDivisionResult());OUTPUTadd= 9.0subtract= 1.0multiply= 0.0divide= 0.0 TIPS: add= 9.0 is printed because 5.0 + 4 is 9.0 subtract= 1.0 is printed because 5.0 - 4 is 1.0 multiply= 0.0 is printed because 5.25 * 0 is 0.0 divide= 0.0 is printed because secondNumber is set to 0 NOTE: All methods should be defined as public NOT public static. NOTE: In total, you have to write 8 methods. NOTE: Do not add the main method to the solution code. 2. 答案 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class SimpleCalculator &#123; private double firstNumber; private double secondNumber; public double getFirstNumber() &#123; return this.firstNumber; &#125; public double getSecondNumber() &#123; return this.secondNumber; &#125; public void setFirstNumber(double firstNumber) &#123; this.firstNumber = firstNumber; &#125; public void setSecondNumber(double secondNumber) &#123; this.secondNumber = secondNumber; &#125; public double getAdditionResult() &#123; return this.firstNumber + this.secondNumber; &#125; public double getSubtractionResult() &#123; return this.firstNumber - this.secondNumber; &#125; public double getMultiplicationResult() &#123; return this.firstNumber * this.secondNumber; &#125; public double getDivisionResult() &#123; if (this.secondNumber == 0) &#123; return 0; &#125; return this.firstNumber / this.secondNumber; &#125;&#125; Person 挑戰 Write a class with the name Person. The class needs three fields (instance variables) with the names firstName, lastName of type String and age of type int. Write the following methods (instance methods): Method named getFirstName without any parameters, it needs to return the value of the firstName field. Method named getLastName without any parameters, it needs to return the value of the lastName field. Method named getAge without any parameters, it needs to return the value of the age field. Method named setFirstName with one parameter of type String, it needs to set the value of the firstName field. Method named setLastName with one parameter of type String, it needs to set the value of the lastName field. Method named setAge with one parameter of type int, it needs to set the value of the age field. If the parameter is less than 0 or greater than 100, it needs to set the age field value to 0. Method named isTeen without any parameters, it needs to return true if the value of the age field is greater than 12 and less than 20, otherwise, return false. Method named getFullName without any parameters, it needs to return the full name of the person. In case both firstName and lastName fields are empty, Strings return an empty String. In case lastName is an empty String, return firstName. In case firstName is an empty String, return lastName. To check if s String is empty, use the method isEmpty from the String class. For example, firstName.isEmpty() returns true if the String is empty or in other words, when the String does not contain any characters. TEST EXAMPLE 12345678910111213141516171819202122TEST CODE:Person person = new Person();person.setFirstName(&quot;&quot;); // firstName is set to empty stringperson.setLastName(&quot;&quot;); // lastName is set to empty stringperson.setAge(10);System.out.println(&quot;fullName= &quot; + person.getFullName());System.out.println(&quot;teen= &quot; + person.isTeen());person.setFirstName(&quot;John&quot;); // firstName is set to Johnperson.setAge(18);System.out.println(&quot;fullName= &quot; + person.getFullName());System.out.println(&quot;teen= &quot; + person.isTeen());person.setLastName(&quot;Smith&quot;); // lastName is set to SmithSystem.out.println(&quot;fullName= &quot; + person.getFullName());OUTPUTfullName=teen= falsefullName= Johnteen= truefullName= John Smith NOTE: All methods should be defined as public NOT public static. NOTE: In total, you have to write 8 methods. NOTE: Do not add the main method to the solution code. 2. 答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Person &#123; private String firstName; private String lastName; private int age; public String getFirstName() &#123; return this.firstName; &#125; public String getLastName() &#123; return this.lastName; &#125; public int getAge() &#123; return this.age; &#125; public void setFirstName(String firstName) &#123; this.firstName = firstName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public void setAge(int age) &#123; if (age &lt; 0 || age &gt; 100) &#123; this.age = 0; &#125; else &#123; this.age = age; &#125; &#125; public boolean isTeen() &#123; return this.age &gt; 12 &amp;&amp; this.age &lt; 20; &#125; public String getFullName() &#123; if (this.firstName.isEmpty() &amp;&amp; this.lastName.isEmpty()) &#123; return &quot;&quot;; &#125; else if (this.lastName.isEmpty()) &#123; return this.firstName; &#125; else if (this.firstName.isEmpty()) &#123; return this.lastName; &#125; else &#123; return this.firstName + &quot; &quot; + this.lastName; &#125; &#125;&#125; Constructors 挑戰 Create a new class for a bank account. Create fields for the account number, balance, customer name, email and phone number. Create getters and setters for each field Create two additional methods 1. To allow the customer to deposit funds (this should increment the balance field). 2. To allow the customer to withdraw funds. This should deduct from the balance field, but not allow the withdrawal to complete if their are insufficient funds. You will want to create various code in the Main class (the one created bu IntelliJ) to confirm your code is working. Add some System.out.println’s in the two methods above as well. 2. 答案 新增一個 Account 的 Java Class，然後新增變數 12345678public class Account &#123; private String number; private double balance; private String customerName; private String customerEmailAddress; private String customerPhoneNumber;&#125; 然後使用 IntelliJ 自動生成 getter 和 setter，點選選單 Code &gt; Generate &gt; 選擇所有變數，就會自動產生 getter 和 setter，最後再將 deposit 和 withdrawal 的功能加上去就完成了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class Account &#123; private String number; private double balance; private String customerName; private String customerEmailAddress; private String customerPhoneNumber; public void deposit(double depositAmount) &#123; this.balance += depositAmount; System.out.println(&quot;Deposit of &quot; + depositAmount + &quot; made. New balance is &quot; + this.balance); &#125; public void withdrawal(double withdrawalAmount) &#123; if (this.balance - withdrawalAmount &lt; 0) &#123; System.out.println(&quot;Only &quot; + this.balance + &quot; available. Withdrawal not processed.&quot;); &#125; else &#123; this.balance -= withdrawalAmount; System.out.println(&quot;Withdrawal of &quot; + withdrawalAmount + &quot; processed. Remaining = &quot; + this.balance); &#125; &#125; public String getNumber() &#123; return number; &#125; public void setNumber(String number) &#123; this.number = number; &#125; public double getBalance() &#123; return balance; &#125; public void setBalance(double balance) &#123; this.balance = balance; &#125; public String getCustomerName() &#123; return customerName; &#125; public void setCustomerName(String customerName) &#123; this.customerName = customerName; &#125; public String getCustomerEmailAddress() &#123; return customerEmailAddress; &#125; public void setCustomerEmailAddress(String customerEmailAddress) &#123; this.customerEmailAddress = customerEmailAddress; &#125; public String getCustomerPhoneNumber() &#123; return customerPhoneNumber; &#125; public void setCustomerPhoneNumber(String customerPhoneNumber) &#123; this.customerPhoneNumber = customerPhoneNumber; &#125;&#125; 在 Main Java Class 進行測試 12345678910111213public class Main &#123; public static void main(String[] args) &#123; Account bobsAccount = new Account(); bobsAccount.withdrawal(100.0); bobsAccount.deposit(50.0); bobsAccount.withdrawal(100.0); bobsAccount.deposit(51.0); bobsAccount.withdrawal(100.0); &#125;&#125; 在上面，我們並沒有定義預設值，我們可以在 Class 裡面使用 Constructor 定義預設值。 123456789public Account(String number, double balance, String customerName, String customerEmailAddress, String customerPhoneNumber) &#123; System.out.println(&quot;Account with constructor parameters called.&quot;); this.number = number; this.balance = balance; this.customerName = customerName; this.customerEmailAddress = customerEmailAddress; this.customerPhoneNumber = customerPhoneNumber;&#125; 定義完成之後，我們可以在 Main 的地方，在創建物件的時候就呼叫 Constructor。 1Account bobsAccount = new Account(&quot;12345&quot;, 0.00, &quot;Bob Brown&quot;, &quot;myemail@bob.com&quot;, &quot;(087) 123-4567&quot;); Constructor 可以 overloaded，可以在空的 Constructor 裡面呼叫別的 Constructor。然後這個 this 的呼叫動作一定要在第一行，否則無法執行。 123456public Account() &#123; // 一定要在第一行 this(&quot;56789&quot;, 2.50, &quot;Default name&quot;, &quot;Default address&quot;, &quot;Default phone&quot;); System.out.println(&quot;Empty constructor called&quot;); &#125; 千萬不要在 Constructor 裡面呼叫 setter，因為這樣可以確保值是被初始化的。 假設我們需要設定一個 Constructor，有兩個預設值，其他的要根據傳入的值去設定，我們會選擇重複使用主要的 Constructor。 1234public Account(String customerName, String customerEmailAddress, String customerPhoneNumber) &#123; this(&quot;9999&quot;, 100.55, customerName, customerEmailAddress, customerPhoneNumber);&#125; 挑戰 Create a new class VipCustomer. It should have 3 fields name, credit limit, and email address. Create 3 constructors. 1st constructor empty should call the constructor with 3 parameters with default values. 2nd constructor should pass on the 2 values it receives and add a default value for the 3rd. 3rd constructor should save all fields. Create getters only for this using code generation of Intellij as setters won’t be needed test and confirm it works. 答案 新增一個 VipCustomer 的 Class 1234567891011121314151617181920212223242526272829303132333435363738public class VipCustomer &#123; private String name; private double creditLimit; private String emailAddress; public VipCustomer() &#123; this(&quot;Default Name&quot;, 300.0, &quot;default@email.com&quot;); &#125; public VipCustomer(String name, double creditLimit) &#123; this(name, creditLimit, &quot;unknown@email.com&quot;); &#125; public VipCustomer(String name, double creditLimit, String emailAddress) &#123; this.name = name; this.creditLimit = creditLimit; this.emailAddress = emailAddress; &#125; public String getName() &#123; return name; &#125; public double getCreditLimit() &#123; return creditLimit; &#125; public String getEmailAddress() &#123; return emailAddress; &#125;&#125; 在 Main 確定是否確實執行 Constructor 123456789101112131415VipCustomer person1 = new VipCustomer();System.out.println(person1.getName());VipCustomer person2 = new VipCustomer(&quot;Bob&quot;, 2500.0);System.out.println(person2.getName());VipCustomer person3 = new VipCustomer(&quot;Tim&quot;, 100.0, &quot;tim@email.com&quot;);System.out.println(person3.getName());System.out.println(person3.getEmailAddress());===== OUTPUT =====Default NameBobTimtim@email.com 挑戰 牆壁面積 題目 Write a class with the name Wall. The class needs two fields (instance variables) with name width and height of type double. The class needs to have two constructors. The first constructor does not have any parameters (no-arg constructor). The second constructor has parameters width and height of type double and it needs to initialize the fields. In case the width is less than 0 it needs to set the width field value to 0, in case the height parameter is less than 0 it needs to set the height field value to 0. Write the following methods (instance methods): Method named getWidth without any parameters, it needs to return the value of width field. Method named getHeight without any parameters, it needs to return the value of height field. Method named setWidth with one parameter of type double, it needs to set the value of the width field. If the parameter is less than 0 it needs to set the width field value to 0. Method named setHeight with one parameter of type double, it needs to set the value of the height field. If the parameter is less than 0 it needs to set the height field value to 0. Method named getArea without any parameters, it needs to return the area of the wall. TEST EXAMPLE 12345678910111213141516→ TEST CODE:1 Wall wall = new Wall(5,4);2 System.out.println(&quot;area= &quot; + wall.getArea());3 4 wall.setHeight(-1.5);5 System.out.println(&quot;width= &quot; + wall.getWidth());6 System.out.println(&quot;height= &quot; + wall.getHeight());7 System.out.println(&quot;area= &quot; + wall.getArea());→ OUTPUT:area= 20.0width= 5.0height= 0.0area= 0.0 NOTE: All methods should be defined as public NOT public static. NOTE: In total, you have to write 5 methods and 2 constructors. NOTE: Do not add a main method to the solution code. 2. 答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class Wall &#123; private double width; private double height; public Wall() &#123; this(0.0, 0.0); &#125; public Wall(double width, double height) &#123; if (width &lt; 0) &#123; this.width = 0; &#125; else &#123; this.width = width; &#125; if (height &lt; 0) &#123; this.height = 0; &#125; else &#123; this.height = height; &#125; &#125; public double getWidth() &#123; return width; &#125; public double getHeight() &#123; return height; &#125; public void setWidth(double width) &#123; if (width &lt; 0) &#123; this.width = 0; &#125; else &#123; this.width = width; &#125; &#125; public void setHeight(double height) &#123; if (height &lt; 0) &#123; this.height = 0; &#125; else &#123; this.height = height; &#125; &#125; public double getArea() &#123; return this.width * this.height; &#125;&#125; 點 題目 You have to represent a point in 2D space. Write a class with the name Point. The class needs two fields (instance variables) with name x and y of type int. The class needs to have two constructors. The first constructor does not have any parameters (no-arg constructor). The second constructor has parameters x and y of type int and it needs to initialize the fields. Write the following methods (instance methods): Method named getX without any parameters, it needs to return the value of x field. Method named getY without any parameters, it needs to return the value of y field. Method named setX with one parameter of type int, it needs to set the value of the x field. Method named setY with one parameter of type int, it needs to set the value of the y field. Method named distance without any parameters, it needs to return the distance between this Point and Point 0,0 as double. Method named distance with two parameters x, y both of type int, it needs to return the distance between this Point and Point x,y as double. Method named distance with parameter another of type Point, it needs to return the distance between this Point and another Point as double. How to find the distance between two points?To find a distance between points A(xA,yA) and B(xB,yB), we use the formula: d(A,B)=√ (xB − xA) * (xB - xA) + (yB − yA) * (yB - yA) Where √ represents square root. TEST EXAMPLE 12345678910111213141516→ TEST CODE:Point first = new Point(6, 5);Point second = new Point(3, 1);System.out.println(&quot;distance(0,0)= &quot; + first.distance());System.out.println(&quot;distance(second)= &quot; + first.distance(second));System.out.println(&quot;distance(2,2)= &quot; + first.distance(2, 2));Point point = new Point();System.out.println(&quot;distance()= &quot; + point.distance());OUTPUTdistance(0,0)= 7.810249675906654distance(second)= 5.0distance(2,2)= 5.0distance()= 0.0 NOTE: Use Math.sqrt to calculate the square root √. NOTE: Try to avoid duplicated code. NOTE: All methods should be defined as public NOT public static. NOTE: In total, you have to write 7 methods. NOTE: Do not add a main method to the solution code. 2. 答案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Point &#123; private int x; private int y; public Point() &#123; this(0, 0); &#125; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public int getY() &#123; return y; &#125; public void setX(int x) &#123; this.x = x; &#125; public void setY(int y) &#123; this.y = y; &#125; public double distance() &#123; return distance(0, 0); &#125; public double distance(int xB, int yB) &#123; return Math.sqrt((double) ((xB - this.x) * (xB - this.x) + (yB - this.y) * (yB - this.y))); &#125; public double distance(Point z) &#123; return distance(z.x, z.y); &#125;&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://vincent.fishboneapps.com/tags/Java/"}]},{"title":"Java 快速學習自我挑戰 Day7","slug":"Java-快速學習自我挑戰-Day7","date":"2020-05-27T15:30:04.000Z","updated":"2021-01-25T08:24:19.844Z","comments":true,"path":"2020/05/27/Java-快速學習自我挑戰-Day7/","link":"","permalink":"https://vincent.fishboneapps.com/2020/05/27/Java-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day7/","excerpt":"","text":"控制流陳述句 從 String 解析出值 使用 Integer.parseInt 就可以將 String 轉換為 int。 1234567891011121314151617181920public static void main(String[] args) &#123; String numberAsSting = &quot;2018&quot;; System.out.println(&quot;numberAsString = &quot; + numberAsSting); int number = Integer.parseInt(numberAsSting); System.out.println(&quot;number = &quot; + number); numberAsSting += 1; number += 1; System.out.println(&quot;numberAsString = &quot; + numberAsSting); System.out.println(&quot;number = &quot; + number);&#125;-----numberAsString = 2018number = 2018numberAsString = 20181number = 2019 同樣地，使用 Double.parseDouble 也可將 String 轉換為 double. 1234567891011121314151617181920public static void main(String[] args) &#123; String numberAsSting = &quot;2018.125&quot;; System.out.println(&quot;numberAsString = &quot; + numberAsSting); double number = Double.parseDouble(numberAsSting); System.out.println(&quot;number = &quot; + number); numberAsSting += 1; number += 1; System.out.println(&quot;numberAsString = &quot; + numberAsSting); System.out.println(&quot;number = &quot; + number);&#125;-----numberAsString = 2018.125number = 2018.125numberAsString = 2018.1251number = 2019.125 如果 String 無法轉換成 int 就會出現 Exception 錯誤。 12345678910111213141516public static void main(String[] args) &#123; String numberAsSting = &quot;2018test&quot;; System.out.println(&quot;numberAsString = &quot; + numberAsSting); int number = Integer.parseInt(numberAsSting); System.out.println(&quot;number = &quot; + number);&#125;-----numberAsString = 2018testException in thread &quot;main&quot; java.lang.NumberFormatException: For input string: &quot;2018test&quot; at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.base/java.lang.Integer.parseInt(Integer.java:652) at java.base/java.lang.Integer.parseInt(Integer.java:770) at com.fishboneapps.Main.main(Main.java:10) 題目一 Write a method named canPack with three parameters of type int named bigCount, smallCount, and goal. The parameter bigCount represents the count of big flour bags (5 kilos each). The parameter smallCount represents the count of small flour bags (1 kilo each). The parameter goal represents the goal amount of kilos of flour needed to assemble a package. Therefore, the sum of the kilos of bigCount and smallCount must be at least equal to the value of goal. The method should return true if it is possible to make a package with goal kilos of flour. If the sum is greater than goal, ensure that only full bags are used towards the goal amount. For example, if goal = 9, bigCount = 2, and smallCount = 0, the method should return false since each big bag is 5 kilos and cannot be divided. However, if goal = 9, bigCount = 1, and smallCount = 5, the method should return true because of 1 full bigCount bag and 4 full smallCount bags equal goal, and it’s okay if there are additional bags left over. If any of the parameters are negative, return false. 123456EXAMPLE INPUT/OUTPUT:* canPack (1, 0, 4); should return false since bigCount is 1 (big bag of 5 kilos) and goal is 4 kilos.* canPack (1, 0, 5); should return true since bigCount is 1 (big bag of 5 kilos) and goal is 5 kilos.* canPack (0, 5, 4); should return true since smallCount is 5 (small bags of 1 kilo) and goal is 4 kilos, and we have 1 bag left which is ok as mentioned above.* canPack (2, 2, 11); should return true since bigCount is 2 (big bags 5 kilos each) and smallCount is 2 (small bags of 1 kilo), makes in total 12 kilos and goal is 11 kilos. * canPack (-3, 2, 12); should return false since bigCount is negative. NOTE: The method canPack should be defined as public static like we have been doing so far in the course. NOTE: Do not add a main method to the solution code. 題目一(答案) 1234567891011121314public class FlourPacker &#123; public static boolean canPack(int bigCount, int smallCount, int goal) &#123; if (bigCount &lt; 0 || smallCount &lt; 0 || goal &lt; 0) &#123; return false; &#125; if (bigCount * 5 &gt; goal) &#123; return smallCount &gt;= goal % 5; &#125; return smallCount &gt;= goal - (bigCount * 5); &#125;&#125; 題目二 Write a method named getLargestPrime with one parameter of type int named number. If the number is negative or does not have any prime numbers, the method should return -1 to indicate an invalid value. The method should calculate the largest prime factor of a given number and return it. 123456EXAMPLE INPUT/OUTPUT:* getLargestPrime (21); should return 7 since 7 is the largest prime (3 * 7 = 21)* getLargestPrime (217); should return 31 since 31 is the largest prime (7 * 31 = 217)* getLargestPrime (0); should return -1 since 0 does not have any prime numbers* getLargestPrime (45); should return 5 since 5 is the largest prime (3 * 3 * 5 = 45)* getLargestPrime (-1); should return -1 since the parameter is negative HINT: Since the numbers 0 and 1 are not considered prime numbers, they cannot contain prime numbers. NOTE: The method getLargestPrime should be defined as public static like we have been doing so far in the course. NOTE: Do not add a main method to the solution code. 題目二(答案) 123456789101112131415161718192021public class LargestPrime &#123; public static int getLargestPrime(int number) &#123; if (number &lt; 2) &#123; return -1; &#125; int largestPrime = 2; while (largestPrime &lt; number) &#123; if (number % largestPrime != 0) &#123; largestPrime++; &#125; else &#123; number /= largestPrime; largestPrime = 2; &#125; &#125; return largestPrime; &#125;&#125; 題目三 Write a method named printSquareStar with one parameter of type int named number. If number is &lt; 5, the method should print “Invalid Value”. The method should print diagonals to generate a rectangular pattern composed of stars (*). This should be accomplished by using loops (see examples below). 1234567891011121314151617181920212223242526272829303132EXAMPLE INPUT/OUTPUT:EXAMPLE 1printSquareStar(5); should print the following:→ NOTE: For text in Code Blocks below, use code icon &#123;...&#125; on Udemy******* *** * *** *******Explanation:***** 5 stars** ** 2 stars space 2 stars* * * 1 star space 1 star space 1 star** ** 2 stars space 2 stars***** 5 starsEXAMPLE 2printSquareStar(8); should print the following:********** *** * * ** ** ** ** ** * * *** ********** The patterns above consist of a number of rows and columns (where number is the number of rows to print). For each row or column, stars are printed based on four conditions (Read them carefully): In the first or last row In the first or last column When the row number equals the column number When the column number equals rowCount - currentRow + 1 (where currentRow is current row number) HINT: Use a nested loop (a loop inside of a loop). HINT: To print on the same line, use the print method instead of println, e.g. System.out.print(&quot; &quot;); prints a space and does not “move” to another line. HINT: To “move” to another line, you can use an empty println call, e.g. System.out.println(); . NOTE: The method printSquareStar should be defined as public static like we have been doing so far in the course. NOTE: Do not add a main method to the solution code. 題目三(答案) 12345678910111213141516171819202122232425262728293031323334public class DiagonalStar &#123; public static void printSquareStar(int number) &#123; if (number &lt; 5) &#123; System.out.println(&quot;Invalid Value&quot;); return; &#125; for (int row = 1; row &lt;= number; row++) &#123; for (int column = 1; column &lt;= number; column++) &#123; if (row == 1 || row == number) &#123; System.out.print(&quot;*&quot;); &#125; else if (column == 1 || column == number) &#123; System.out.print(&quot;*&quot;); &#125; else if (row == column) &#123; System.out.print(&quot;*&quot;); &#125; else if (column == (number - row + 1)) &#123; System.out.print(&quot;*&quot;); &#125; else &#123; System.out.print(&quot; &quot;); &#125; &#125; System.out.println(&quot;&quot;); &#125; &#125;&#125; 讀取用戶輸入 我們用 Scanner 來讀取用戶的輸入，用 nextLine() 將輸入讀取出來，也可以使用 nextInt() 將輸入讀取成 int，需要注意的是，在數字後面會有換行字元問題，需要再加上 nextLine() 來解決問題。 12345678910111213141516171819public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.println(&quot;Enter your year of birth: &quot;); int YearOfBirth = scanner.nextInt(); scanner.nextLine(); //handle next line character(enter key) System.out.println(&quot;Enter your name: &quot;); String name = scanner.nextLine(); int age = 2018 - YearOfBirth; System.out.println(&quot;Your name is &quot; + name + &quot;, and you are &quot; + age + &quot; years old.&quot;); scanner.close(); &#125;&#125; 用戶輸入的問題和解決方案 如果用戶輸入負數，可以直接計算年紀是不是在合理範圍內，如果不在就返回錯誤，另外針對用戶輸入字元的話，可以用 scanner.hasNextInt() 來確定是否為數字。 1234567891011121314151617181920212223242526272829303132import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.println(&quot;Enter your year of birth: &quot;); boolean hasNextInt = scanner.hasNextInt(); if (hasNextInt) &#123; int YearOfBirth = scanner.nextInt(); scanner.nextLine(); //handle next line character(enter key) System.out.println(&quot;Enter your name: &quot;); String name = scanner.nextLine(); int age = 2018 - YearOfBirth; if (age &gt;= 0 &amp;&amp; age &lt;= 100) &#123; System.out.println(&quot;Your name is &quot; + name + &quot;, and you are &quot; + age + &quot; years old.&quot;); &#125; else &#123; System.out.println(&quot;Invalid year of birth.&quot;); &#125; &#125; else &#123; System.out.println(&quot;Unable to parse year of birth.&quot;); &#125; scanner.close(); &#125;&#125; 讀取用戶輸入挑戰 挑戰 Read 10 numbers from the console entered by the user and print the sum of those numbers. Create a Scanner like we did in the previous video. Use the hasNextInt() method from the scanner to check if the user has entered an int value. If hasNextInt() returns false, print the message “Invalid Number”. Continue reading nutil you have read 10 numbers. Before the user enters each number, print the message “Enter number #x:” where x represents the count, i.e. 1, 2, 3, 4, etc. For example, the first message printed to the user would be “Enter number #1:”, the next “Enter number #2:”, and so on. Hint: Use a while loop. Use a counter variable for counting valid nubmers. Close the scanner after you don’t need it anymore. Create a project with the name ReadingUserInputChallenge. 答案 123456789101112131415161718192021222324252627282930import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int counter = 1; int sum = 0; while (counter &lt;= 10) &#123; System.out.println(&quot;Enter number #&quot; + counter + &quot;:&quot;); boolean isAnInt = scanner.hasNextInt(); if (!isAnInt) &#123; System.out.println(&quot;Invalid Value&quot;); // handle the enter character scanner.nextLine(); continue; &#125; sum += scanner.nextInt(); System.out.println(&quot;The sum of numbers: &quot; + sum); counter++; &#125; scanner.close(); &#125;&#125; 最小和最大挑戰 挑戰 Read the numbers from the console entered by the user and print the minimum and maximum number the user has entered. Befroe the user enters the number, print the message “Enter number:”. If the user enters an invalid number, break out of the loop and print the minimum and maximum number. Hint: Use an endless while loop. Bonus: Create a project with the name MinAndMaxInputChanllenge. 答案 1234567891011121314151617181920212223242526272829303132333435363738import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int Min = 0; int Max = 0; while (true) &#123; System.out.println(&quot;Enter number:&quot;); boolean isAnInt = scanner.hasNextInt(); if (!isAnInt) &#123; System.out.println(&quot;Invalid Value&quot;); break; &#125; int input = scanner.nextInt(); if (Min == 0 &amp;&amp; Max == 0) &#123; Min = input; Max = input; &#125; else if (input &gt; Max) &#123; Max = input; &#125; else if (input &lt; Min) &#123; Min = input; &#125; scanner.nextLine(); //handle input &#125; System.out.println(&quot;The min value is &quot; + Min + &quot;, and the max value is &quot; + Max); scanner.close(); &#125;&#125; 輸入計算機 挑戰 Write a method called inputThenPrintSumAndAverage that does not have any parameters. The method should not return anything (void) and it needs to keep reading int numbers from the keyboard. When the user enters something that is not an int then it needs to print a message in the format “SUM = XX AVG = YY”. XX represents the sum of all entered numbers of type int. YY represents the calculated average of all numbers of type long. 123456789101112131415161718EXAMPLES OF INPUT/OUTPUT:EXAMPLE 1:INPUT:12345aOUTPUTSUM = 15 AVG = 3EXAMPLE 2:INPUT:helloOUTPUT:SUM = 0 AVG = 0 TIP: Use Scanner to read an input from the user. TIP: Use casting when calling the round method since it needs double as a parameter. NOTE: Use the method Math.round to round the calculated average (double). The method round returns long. NOTE: Be mindful of spaces in the printed message. NOTE: Be mindful of users who may type an invalid input right away (see example above). NOTE: The method inputThenPrintSumAndAverage should be defined as public static like we have been doing so far in the course. NOTE: Do not add the main method to the solution code. 2. 答案 1234567891011121314151617181920212223242526import java.util.Scanner; public class InputCalculator &#123; public static void inputThenPrintSumAndAverage() &#123; Scanner scanner = new Scanner(System.in); int sum = 0; int average = 0; int count = 1; while (true) &#123; // 監控輸入內容 boolean isAnInt = scanner.hasNextInt(); if (!isAnInt) &#123; System.out.println(&quot;SUM = &quot; + sum + &quot; AVG = &quot; + average); break; &#125; sum += scanner.nextInt(); average = Math.round((float) sum / (float) count); count++; &#125; scanner.close(); &#125;&#125; 畫畫的工作 挑戰 Bob is a wall painter and he needs your help. You have to write a program that helps Bob calculate how many buckets of paint he needs to buy before going to work. Bob might also have some extra buckets at home. He also knows the area that he can cover with one bucket of paint. Write a method named getBucketCount with 4 parameters. The first parameter should be named width of type double. This parameter represents the width of the wall. The second parameter should be named height of type double. This parameter represents the height of the wall. The third parameter should be named areaPerBucket. This parameter represents the area that can be covered with one bucket of paint. The fourth parameter should be named extraBuckets. This parameter represents the bucket count that Bob has at home. The method needs to return a value of type int that represents the number of buckets that Bob needs to buy before going to work. To calculate the bucket count, refer to the notes below. If one of the parameters width, height or areaPerBucket is less or equal to 0 or if extraBuckets is less than 0, the method needs to return -1 to indicate an invalid value. If all parameters are valid, the method needs to calculate the number of buckets and return it. 1234Examples of input/output:*getBucketCount(-3.4, 2.1, 1.5, 2); → should return -1 since the width parameter is invalid*getBucketCount(3.4, 2.1, 1.5, 2); → should return 3 since the wall area is 7.14, a single bucket can cover an area of 1.5 and Bob has 2 extra buckets home.*getBucketCount(2.75, 3.25, 2.5, 1); → should return 3 since the wall area is 8.9375, a single bucket can cover an area of 2.5 and Bob has 1 extra bucket at home. Bob does not like to enter 0 for the extraBuckets parameter so he needs another method. Write another overloaded method named getBucketCount with 3 parameters namely width, height, and areaPerBucket (all of type double). This method needs to return a value of type int that represents the number of buckets that Bob needs to buy before going to work. To calculate the bucket count, refer to the notes below. If one of the parameters width, height or areaPerBucket is less or equal to 0, the method needs to return -1 to indicate an invalid value. If all parameters are valid, the method needs to calculate the number of buckets and return it. 1234Examples of input/output:*getBucketCount(-3.4, 2.1, 1.5); → should return -1 since the width parameter is invalid*getBucketCount(3.4, 2.1, 1.5); → should return 5 since the wall area is 7.14, and a single bucket can cover an area of 1.5.*getBucketCount(7.25, 4.3, 2.35); → should return 14 since the wall area is 31.175, and a single bucket can cover an area of 2.35. In some cases, Bob does not know the width and height of the wall but he knows the area of a wall. He needs you to write another method. Write another overloaded method named getBucketCount with 2 parameters namely, area and areaPerBucket (both of type double). The method needs to return a value of type int that represents the number of buckets that Bob needs to buy before going to work. To calculate the bucket count, refer to the notes below. If one of the parameters area or areaPerBucket is less or equal to 0, the method needs to return -1to indicate an invalid value. If all parameters are valid, the method needs to calculate the number of buckets and return it. 1234Examples of input/output:*getBucketCount(3.4, 1.5); → should return 3 since the area is 3.4 and a single bucket can cover an area of 1.5*getBucketCount(6.26, 2.2); → should return 3 since the wall area is 6.26 and a single bucket can cover an area of 2.2.*getBucketCount(3.26, 0.75); → should return 5 since the wall area is 3.26, and a single bucket can cover an area of 0.75 . Do your best to help Bob. NOTE: Use the method Math.ceil to round the number of calculated buckets (double) then convert it into an int before returning the value from the methods. NOTE: All methods should be defined as public static like we have been doing so far in the course. NOTE: Do not add the main method to the solution code. 答案 123456789101112131415161718192021222324252627282930313233343536public class PaintJob &#123; public static int getBucketCount(double width, double height, double areaPerBucket, int extraBuckets) &#123; if (width &lt;= 0 || height &lt;= 0 || areaPerBucket &lt;= 0 || extraBuckets &lt; 0) &#123; return -1; &#125; double area = width * height; double leftArea = area - (areaPerBucket * extraBuckets); return (int) Math.ceil(leftArea / areaPerBucket); &#125; public static int getBucketCount(double width, double height, double areaPerBucket) &#123; if (width &lt;= 0 || height &lt;= 0 || areaPerBucket &lt;= 0) &#123; return -1; &#125; double area = width * height; return (int) Math.ceil(area / areaPerBucket); &#125; public static int getBucketCount(double area, double areaPerBucket) &#123; if (area &lt;= 0 || areaPerBucket &lt;= 0) &#123; return -1; &#125; return (int) Math.ceil(area / areaPerBucket); &#125;&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://vincent.fishboneapps.com/tags/Java/"}]},{"title":"Java 快速學習自我挑戰 Day6","slug":"Java-快速學習自我挑戰-Day6","date":"2020-05-24T07:10:49.000Z","updated":"2021-01-25T08:24:11.970Z","comments":true,"path":"2020/05/24/Java-快速學習自我挑戰-Day6/","link":"","permalink":"https://vincent.fishboneapps.com/2020/05/24/Java-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day6/","excerpt":"","text":"控制流陳述句 數字和挑戰 Write a method with the name sumDigits that has one int parameter called number. If parameter is &gt;= 10 then the method should process the number and return sum of all digits, otherwise return -1 to indicate an invalid value. The number from 0-9 have 1 digit so we don’t want to process them, also we don’t want to process negative numbers, so also return -1 for negative numbers. For example calling the method sumDigits(125) should return 8 since 1 + 2 + 5 = 8. Calling the method sumDigit(1) should return -1 as per requirements described above. Add some code to the main method to test out the sumDigits method to determine that it is working correctly for valid and invalid values passed as arguments. Hint Use n % 10 to extract the least-significant digit. Use n = n /10 to discard the least-significant digit. The method needs to be static like other methods so far in the course. Tip Create a project with the name DigitSumChallenge. 數字和挑戰(解答) 123456789101112131415161718192021222324public static void main(String[] args) &#123; System.out.println(sumDigits(125)); System.out.println(sumDigits(-125)); System.out.println(sumDigits(5)); System.out.println(sumDigits(23123));&#125;private static int sumDigits(int number) &#123; if (number &lt; 10) &#123; return -1; &#125; int sum = 0; while (number &gt; 0) &#123; int digit = number % 10; sum += digit; number /= 10; &#125; return sum;&#125; 題目一 Write a method called isPalindrome with one int parameter called number. The method needs to return a boolean. It should return true if the number is a palindrome number otherwise it should return false. Check the tips below for more info about palindromes. 1234Example Input/OutputisPalindrome(-1221); → should return trueisPalindrome(707); → should return trueisPalindrome(11212); → should return false because reverse is 21211 and that is not equal to 11212. Tip: What is a Palindrome number? A palindrome number is a number which when reversed is equal to the original number. For example: 121, 12321, 1001 etc. Tip: Logic to check a palindrome number Find the the reverse of the given number. Store it in some variable say reverse. Compare the number with reverse. If both are the the same then the number is a palindrome otherwise it is not. Tip: Logic to reverse a number Declare and initialize another variable to store the reverse of a number, for example reverse = 0. Extract the last digit of the given number by performing the modulo division (remainder). Store the last digit to some variable say lastDigit = num % 10. Increase the place value of reverse by one. To increase place value multiply the reverse variable by 10 e.g. reverse = reverse * 10. Add lastDigit to reverse. Since the last digit of the number is processed, remove the last digit of num. To remove the last digit divide number by 10. Repeat steps until number is not equal to (or greater than) zero. A while loop would be good for this coding exercise. Tip: Be careful with negative numbers. They can also be palindrome numbers. Tip: Be careful with reversing a number, you will need a parameter for comparing a reversed number with the starting number (parameter). NOTE: The method isPalindrome needs to be defined as public static like we have been doing 題目一(答案) 1234567891011121314151617public class NumberPalindrome &#123; public static boolean isPalindrome(int number) &#123; int reverse = 0; int originalNumber = number; while (number != 0) &#123; reverse *= 10; int lastDigit = number % 10; reverse += lastDigit; number /= 10; &#125; return originalNumber == reverse; &#125;&#125; 題目二 Write a method named sumFirstAndLastDigit with one parameter of type int called number. The method needs to find the first and the last digit of the parameter number passed to the method, using a loop and return the sum of the first and the last digit of that number. If the number is negative then the method needs to return -1 to indicate an invalid value. 123456Example input/output* sumFirstAndLastDigit(252); → should return 4, the first digit is 2 and the last is 2 which gives us 2+2 and the sum is 4.* sumFirstAndLastDigit(257); → should return 9, the first digit is 2 and the last is 7 which gives us 2+7 and the sum is 9.* sumFirstAndLastDigit(0); → should return 0, the first digit and the last digit is 0 since we only have 1 digit, which gives us 0+0 and the sum is 0.* sumFirstAndLastDigit(5); → should return 10, the first digit and the last digit is 5 since we only have 1 digit, which gives us 5+5 and the sum is 10.* sumFirstAndLastDigit(-10); → should return -1, since the parameter is negative and needs to be positive. NOTE: The method sumFirstAndLastDigit needs to be defined as public static like we have been doing so far in the course. NOTE: Do not add a main method to solution code. 題目二(答案) 12345678910111213141516171819202122public class FirstLastDigitSum &#123; public static int sumFirstAndLastDigit(int number) &#123; if (number &lt; 0) &#123; return -1; &#125; int lastDigit = number % 10; int firstDigit = 0; while (number &gt; 0) &#123; if (number &lt; 10) &#123; firstDigit = number; break; &#125; number /= 10; &#125; return lastDigit + firstDigit; &#125;&#125; 題目三 Write a method named getEvenDigitSum with one parameter of type int called number. The method should return the sum of the even digits within the number. If the number is negative, the method should return -1 to indicate an invalid value. 1234EXAMPLE INPUT/OUTPUT:* getEvenDigitSum(123456789); → should return 20 since 2 + 4 + 6 + 8 = 20* getEvenDigitSum(252); → should return 4 since 2 + 2 = 4* getEvenDigitSum(-22); → should return -1 since the number is negative NOTE: The method getEvenDigitSum should be defined as public static like we have been doing so far in the course. NOTE: Do not add a main method to the solution code. 題目三(答案) 1234567891011121314151617181920212223public class EvenDigitSum &#123; public static int getEvenDigitSum(int number) &#123; if (number &lt; 0) &#123; return -1; &#125; int sum = 0; while (number &gt; 0) &#123; int remainder = number % 10; if (remainder % 2 == 0) &#123; sum += remainder; &#125; number /= 10; &#125; return sum; &#125;&#125; 題目四 Write a method named hasSharedDigit with two parameters of type int. Each number should be within the range of 10 (inclusive) - 99 (inclusive). If one of the numbers is not within the range, the method should return false. The method should return true if there is a digit that appears in both numbers, such as 2 in 12 and 23; otherwise, the method should return false. 1234EXAMPLE INPUT/OUTPUT:* hasSharedDigit(12, 23); → should return true since the digit 2 appears in both numbers* hasSharedDigit(9, 99); → should return false since 9 is not within the range of 10-99* hasSharedDigit(15, 55); → should return true since the digit 5 appears in both numbers NOTE: The method hasSharedDigit should be defined as public static like we have been doing so far in the course. NOTE: Do not add a main method to the solution code. 題目四(答案) 12345678910111213141516public class SharedDigit &#123; public static boolean hasSharedDigit(int firstNumber, int secondNumber) &#123; if (firstNumber &lt; 10 || firstNumber &gt; 99 || secondNumber &lt; 10 || secondNumber &gt; 99) &#123; return false; &#125; int firstNumberLastDigit = firstNumber % 10; int firstNumberFirstDigit = firstNumber / 10; int secondNumberLastDigit = secondNumber % 10; int secondNumberFirstDigit = secondNumber / 10; return firstNumberLastDigit == secondNumberLastDigit || firstNumberLastDigit == secondNumberFirstDigit || firstNumberFirstDigit == secondNumberLastDigit || firstNumberFirstDigit == secondNumberFirstDigit; &#125;&#125; 題目五 Write a method named hasSameLastDigit with three parameters of type int. Each number should be within the range of 10 (inclusive) - 1000 (inclusive). If one of the numbers is not within the range, the method should return false. The method should return true if at least two of the numbers share the same rightmost digit; otherwise, it should return false. 1234EXAMPLE INPUT/OUTPUT:* hasSameLastDigit (41, 22, 71); → should return true since 1 is the rightmost digit in numbers 41 and 71* hasSameLastDigit (23, 32, 42); → should return true since 2 is the rightmost digit in numbers 32 and 42* hasSameLastDigit (9, 99, 999); → should return false since 9 is not within the range of 10-1000 Write another method named isValid with one parameter of type int. The method needs to return true if the number parameter is in range of 10(inclusive) - 1000(inclusive), otherwise return false. 1234EXAMPLE INPUT/OUTPUT* isValid(10); → should return true since 10 is within the range of 10-1000* isValid(468); → should return true since 468 is within the range of 10-1000* isValid(1051); → should return false since 1051 is not within the range of 10-1000 NOTE: All methods need to be defined as public static as we have been doing so far in the course. NOTE: Do not add a main method to the solution code. 題目五(答案) 12345678910111213141516171819public class LastDigitChecker &#123; public static boolean hasSameLastDigit(int firstNumber, int secondNumber, int thirdNumber) &#123; if (!isValid(firstNumber) || !isValid(secondNumber) || !isValid(thirdNumber)) &#123; return false; &#125; int firstNumberLastDigit = firstNumber % 10; int secondNumberLastDigit = secondNumber % 10; int thirdNumberLastDigit = thirdNumber % 10; return firstNumberLastDigit == secondNumberLastDigit || secondNumberLastDigit == thirdNumberLastDigit || thirdNumberLastDigit == firstNumberLastDigit; &#125; public static boolean isValid(int number) &#123; return number &gt;= 10 &amp;&amp; number &lt;= 1000; &#125;&#125; 題目六 Write a method named getGreatestCommonDivisor with two parameters of type int named first and second. If one of the parameters is &lt; 10, the method should return -1 to indicate an invalid value. The method should return the greatest common divisor of the two numbers (int). The greatest common divisor is the largest positive integer that can fully divide each of the integers (i.e. without leaving a remainder). For example 12 and 30: 12 can be divided by 1, 2, 3, 4, 6, 12 30 can be divided by 1, 2, 3, 5, 6, 10, 15, 30 The greatest common divisor is 6 since both 12 and 30 can be divided by 6, and there is no resulting remainder. 12345EXAMPLE INPUT/OUTPUT:* getGreatestCommonDivisor(25, 15); should return 5 since both can be divided by 5 without a remainder* getGreatestCommonDivisor(12, 30); should return 6 since both can be divided by 6 without a remainder* getGreatestCommonDivisor(9, 18); should return -1 since the first parameter is &lt; 10* getGreatestCommonDivisor(81, 153); should return 9 since both can be divided by 9 without a remainder HINT: Use a while or a for loop and check if both numbers can be divided without a remainder. HINT: Find the minimum of the two numbers. NOTE: The method getGreatestCommonDivisor should be defined as public static like we have been doing so far in the course. NOTE: Do not add a main method to the solution code. 題目六(答案) 1234567891011121314151617181920212223242526272829303132333435public class GreatestCommonDivisor &#123; public static int getGreatestCommonDivisor(int first, int second) &#123; if (first &lt; 10 || second &lt; 10) &#123; return -1; &#125; int largeNumber = 0; int smallNumber = 0; // 找出兩數中哪個數字大 if (first &gt; second) &#123; largeNumber = first; smallNumber = second; &#125; else &#123; largeNumber = second; smallNumber = first; &#125; // 找出數字小的因數，拿去給大數字除，如果可以整除，表示它也是大數的因數，也就是他們的共同最大公因數 int i = smallNumber; int greatestCommonDivisor = 0; while (i &gt;= 1) &#123; if (smallNumber % i == 0 &amp;&amp; largeNumber % i == 0) &#123; greatestCommonDivisor = i; break; &#125; i--; &#125; return greatestCommonDivisor; &#125;&#125; 題目七 Write a method named printFactors with one parameter of type int named number. If number is &lt; 1, the method should print “Invalid Value”. The method should print all factors of the number. A factor of a number is an integer which divides that number wholly (i.e. without leaving a remainder). For example, 3 is a factor of 6 because 3 fully divides 6 without leaving a remainder. In other words 6 / 3 = 2. 12345EXAMPLE INPUT/OUTPUT:* printFactors(6); → should print 1 2 3 6* printFactors(32); → should print 1 2 4 8 16 32* printFactors(10); → should print 1 2 5 10* printFactors(-1); → should print &quot;Invalid Value&quot; since number is &lt; 1 HINT: Use a while or for loop. NOTE: When printing numbers, each number can be in its own line. They don’t have to be separated by a space. For example, the printout for printFactors(10); can be: 1 2 5 10 NOTE: The method printFactors should be defined as public static like we have been doing so far in the course. NOTE: Do not add a main method to the solution code. 題目七(答案) 123456789101112131415public class FactorPrinter &#123; public static void printFactors(int number) &#123; if (number &lt; 1) &#123; System.out.println(&quot;Invalid Value&quot;); &#125; for (int i = 1; i &lt;= number; i++) &#123; if (number % i == 0) &#123; System.out.println(i); &#125; &#125; &#125;&#125; 題目八 What is the perfect number? A perfect number is a positive integer which is equal to the sum of its proper positive divisors. Proper positive divisors are positive integers that fully divide the perfect number without leaving a remainder and exclude the perfect number itself. For example, take the number 6: Its proper divisors are 1, 2, and 3 (since 6 is the value of the perfect number, it is excluded), and the sum of its proper divisors is 1 + 2 + 3 = 6. Therefore, 6 is a perfect number (as well as the first perfect number). Write a method named isPerfectNumber with one parameter of type int named number. If number is &lt; 1, the method should return false. The method must calculate if the number is perfect. If the number is perfect, the method should return true; otherwise, it should return false. 12345EXAMPLE INPUT/OUTPUT:* isPerfectNumber(6); should return true since its proper divisors are 1, 2, 3 and the sum is 1 + 2 + 3 = 6* isPerfectNumber(28); should return true since its proper divisors are 1, 2, 4, 7, 14 and the sum is 1 + 2 + 4 + 7 + 14 = 28* isPerfectNumber(5); should return false since its only proper divisor is 1 and the sum is 1 not 5* isPerfectNumber(-1); should return false since the number is &lt; 1 HINT: Use a while or for loop. HINT: Use the remainder operator. NOTE: The method isPerfectNumber should be defined as public static like we have been doing so far in the course. NOTE: Do not add a main method to the solution code. 題目八(答案) 12345678910111213141516171819public class PerfectNumber &#123; public static boolean isPerfectNumber(int number) &#123; if (number &lt; 1) &#123; return false; &#125; int sum = 0; for (int i = 1; i &lt; number; i++) &#123; if (number % i == 0) &#123; sum += i; &#125; &#125; return sum == number; &#125;&#125; 題目九 Write a method called numberToWords with one int parameter named number. The method should print out the passed number using words for the digits. If the number is negative, print “Invalid Value”. To print the number as words, follow these steps: Extract the last digit of the given number using the remainder operator. Convert the value of the digit found in Step 1 into a word. There are 10 possible values for that digit, those being 0, 1, 2, 3, 4, 5, 6, 7, 8, 9. Print the corresponding word for each digit, e.g. print “Zero” if the digit is 0, “One” if the digit is 1, and so on. Remove the last digit from the number. Repeat Steps 2 through 4 until the number is 0. The logic above is correct, but in its current state, the words will be printed in reverse order. For example, if the number is 234, the logic above will produce the output “Four Three Two” instead of “Two Three Four”. To overcome this problem, write a second method called reverse. The method reverse should have one int parameter and return the reversed number (int). For example, if the number passed is 234, then the reversed number would be 432. The method reverse should also reverse negative numbers. Use the method reverse within the method numberToWords in order to print the words in the correct order. Another thing to keep in mind is any reversed number with leading zeroes (e.g. the reversed number for 100 is 001). The logic above for the method numberToWords will print “One”, but that is incorrect. It should print “One Zero Zero”. To solve this problem, write a third method called getDigitCount. The method getDigitCount should have one int parameter called number and return the count of the digits in that number. If the number is negative, return -1 to indicate an invalid value. For example, if the number has a value of 100, the method getDigitCount should return 3 since the number 100 has 3 digits (1, 0, 0). 12345Example Input/Output - getDigitCount method* getDigitCount(0); should return 1 since there is only 1 digit* getDigitCount(123); should return 3* getDigitCount(-12); should return -1 since the parameter is negative* getDigitCount(5200); should return 4 since there are 4 digits in the number 12345Example Input/Output - reverse method* reverse(-121); should return -121* reverse(1212); should return 2121* reverse(1234); should return 4321* reverse(100); should return 1 12345Example Input/Output - numberToWords method* numberToWords(123); should print &quot;One Two Three&quot;.* numberToWords(1010); should print &quot;One Zero One Zero&quot;.* numberToWords(1000); should print &quot;One Zero Zero Zero&quot;.* numberToWords(-12); should print &quot;Invalid Value&quot; since the parameter is negative. HINT: Use a for loop to print zeroes after reversing the number. As seen in a previous example, 100 reversed becomes 1, but the method numberToWords should print “One Zero Zero”. To get the number of zeroes, check the difference between the digit count from the original number and the reversed number. NOTE: When printing words, each word can be in its own line. For example, numberToWords(123); can be: One Two Three They don’t have to be separated by a space. NOTE: The methods numberToWords, getDigitCount, reverse should be defined as public static like we have been doing so far in the course. NOTE: In total, you have to write 3 methods. NOTE: Do not add a main method to the solution code. 題目九(答案) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105public class NumberToWords &#123; public static void numberToWords(int number) &#123; if (number &lt; 0) &#123; System.out.println(&quot;Invalid Value&quot;); &#125; int remainder; int reverseNumber = reverse(number); int digitCount = getDigitCount(number); int count = 0; while (reverseNumber &gt; 0) &#123; remainder = reverseNumber % 10; switch (remainder) &#123; case 0: System.out.println(&quot;Zero&quot;); break; case 1: System.out.println(&quot;One&quot;); break; case 2: System.out.println(&quot;Two&quot;); break; case 3: System.out.println(&quot;Three&quot;); break; case 4: System.out.println(&quot;Four&quot;); break; case 5: System.out.println(&quot;Five&quot;); break; case 6: System.out.println(&quot;Six&quot;); break; case 7: System.out.println(&quot;Seven&quot;); break; case 8: System.out.println(&quot;Eight&quot;); break; case 9: System.out.println(&quot;Nine&quot;); break; default: System.out.println(&quot;Invalid Value&quot;); break; &#125; count++; reverseNumber /= 10; &#125; if (digitCount != count) &#123; int leftZero = digitCount - count; for (int i = 0; i &lt; leftZero; i++) &#123; System.out.println(&quot;Zero&quot;); &#125; &#125; &#125; public static int getDigitCount(int number) &#123; if (number &lt; 0) &#123; return -1; &#125; if (number == 0) &#123; return 1; &#125; int count = 0; while (number &gt; 0) &#123; count++; number /= 10; &#125; return count; &#125; public static int reverse(int number) &#123; // 123 -&gt; 321, 100 -&gt; 1 int reverseNumber = 0; int remainder; while (number != 0) &#123; remainder = number % 10; if (reverseNumber != 0) &#123; reverseNumber = (reverseNumber * 10) + remainder; &#125; else &#123; reverseNumber = remainder; &#125; number /= 10; &#125; return reverseNumber; &#125;&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://vincent.fishboneapps.com/tags/Java/"}]},{"title":"Java 快速學習自我挑戰 Day5","slug":"Java-快速學習自我挑戰-Day5","date":"2020-05-15T11:47:01.000Z","updated":"2020-06-22T17:13:55.105Z","comments":true,"path":"2020/05/15/Java-快速學習自我挑戰-Day5/","link":"","permalink":"https://vincent.fishboneapps.com/2020/05/15/Java-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day5/","excerpt":"","text":"控制流陳述句(Control Flow Statements) Switch 陳述句 Switch 陳述句就是 if-else 的取代版本，如果條件很多的情況下，用 switch 會更簡潔，也可以同時定義很多 case 並執行一種命令。最重要的是，每個 case 最後面一定要加上 break，否則會繼續執行，最後一個可以不加，但是為了程式碼的完整性，會建議加上。 12345678910111213141516int switchValue = 1;switch (switchValue) &#123; case 1: System.out.println(&quot;Value was one&quot;); break; case 2: System.out.println(&quot;Value was two&quot;); break; case 3: case 4: case 5: System.out.println(&quot;was a 3, or a 4, or a 5&quot;); System.out.println(&quot;Actually, it was &quot; + switchValue); break; default: System.out.println(&quot;Was not one or two&quot;); break;&#125; 挑戰 Create a new switch statement using char instead of int create a new char variable create a switch statement testing for A, B, C, D or E display a message if any of these are found and then break Add a default which displays a message saying not found 挑戰(答案) 12345678910char charValue = &#x27;A&#x27;;switch (charValue) &#123; case &#x27;A&#x27;: case &#x27;B&#x27;: case &#x27;C&#x27;: case &#x27;D&#x27;: case &#x27;E&#x27;: System.out.println(charValue + &quot; was found.&quot;); break; default: System.out.println(&quot;Could not found A, B, C, D or E&quot;); break;&#125; 星期挑戰 挑戰 Write a method with the name printDayOfTheWeek that has one parameter of type int and name it day. The method should not return any value (hint: void) Using a switch statement print “Sunday”, “Monday”, …, “Saturday” if the int parameter “day” is 0, 1, …, 6 respectively, otherwise it should print “Invalid day” Bonus Write a second solution using if then else, instead of using switch. Create a new project in IntelliJ with the name “DayOfTheWeekChallenge” 挑戰(答案) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public static void main(String[] args) &#123; printDayOfTheWeek(-1); printDayOfTheWeek(0); printDayOfTheWeek(1); printDayOfTheWeek(2); printDayOfTheWeek(3); printDayOfTheWeek(4); printDayOfTheWeek(5); printDayOfTheWeek(6); printDayOfTheWeekIf(-1); printDayOfTheWeekIf(0); printDayOfTheWeekIf(1); printDayOfTheWeekIf(2); printDayOfTheWeekIf(3); printDayOfTheWeekIf(4); printDayOfTheWeekIf(5); printDayOfTheWeekIf(6);&#125;private static void printDayOfTheWeek(int day) &#123; switch (day) &#123; case 0: System.out.println(&quot;Sunday&quot;); break; case 1: System.out.println(&quot;Monday&quot;); break; case 2: System.out.println(&quot;Tuesday&quot;); break; case 3: System.out.println(&quot;Wednesday&quot;); break; case 4: System.out.println(&quot;Thursday&quot;); break; case 5: System.out.println(&quot;Friday&quot;); break; case 6: System.out.println(&quot;Saturday&quot;); break; default: System.out.println(&quot;Invalid day&quot;); break; &#125;&#125;private static void printDayOfTheWeekIf(int day) &#123; if (day == 0) &#123; System.out.println(&quot;Sunday&quot;); &#125; else if (day == 1) &#123; System.out.println(&quot;Monday&quot;); &#125; else if (day == 2) &#123; System.out.println(&quot;Tuesday&quot;); &#125; else if (day == 3) &#123; System.out.println(&quot;Wednesday&quot;); &#125; else if (day == 4) &#123; System.out.println(&quot;Thursday&quot;); &#125; else if (day == 5) &#123; System.out.println(&quot;Friday&quot;); &#125; else if (day == 6) &#123; System.out.println(&quot;Saturday&quot;); &#125; else &#123; System.out.println(&quot;Invalid day&quot;); &#125;&#125; 挑戰 題目一 Write a method called printNumberInWord. The method has one parameter number which is the whole number. The method needs to print “ZERO”, “ONE”, “TWO”, … “NINE”, “OTHER” if the int parameter number is 0, 1, 2, … 9 or other for any other number including negative numbers. You can use if-else statement or switch statement whatever is easier for you. NOTE: Method printNumberInWord needs to be public static for now, we are only using static methods. NOTE: Do not add main method to solution code. 題目一(答案) 12345678910111213141516171819202122232425262728293031323334353637383940public class NumberInWord &#123; public static void printNumberInWord(int number) &#123; switch (number) &#123; case 0: System.out.println(&quot;ZERO&quot;); break; case 1: System.out.println(&quot;ONE&quot;); break; case 2: System.out.println(&quot;TWO&quot;); break; case 3: System.out.println(&quot;THREE&quot;); break; case 4: System.out.println(&quot;FOUR&quot;); break; case 5: System.out.println(&quot;FIVE&quot;); break; case 6: System.out.println(&quot;SIX&quot;); break; case 7: System.out.println(&quot;SEVEN&quot;); break; case 8: System.out.println(&quot;EIGHT&quot;); break; case 9: System.out.println(&quot;NINE&quot;); break; default: System.out.println(&quot;OTHER&quot;); break; &#125; &#125;&#125; 題目二 Write a method isLeapYear with a parameter of type int named year. The parameter needs to be greater than or equal to 1 and less than or equal to 9999. If the parameter is not in that range return false. Otherwise, if it is in the valid range, calculate if the year is a leap year and return true if it is, otherwise return false. A year is a leap year if it is divisible by 4 but not by 100, or it is divisible by 400. 12345Examples of input/output:* isLeapYear(-1600); → should return false since the parameter is not in the range (1-9999)* isLeapYear(1600); → should return true since 1600 is a leap year* isLeapYear(2017); → should return false since 2017 is not a leap year* isLeapYear(2000); → should return true because 2000 is a leap year ​NOTE: The solution to the Leap Year coding exercise earlier in the course created the isLeapYear method. You can use that solution if you wish. Write another method getDaysInMonth with two parameters month and year. ​Both of type int. If parameter month is &lt; 1 or &gt; 12 return -1. ​ If parameter year is &lt; 1 or &gt; 9999 then return -1. This method needs to return the number of days in the month. Be careful about leap years they have 29 days in month 2 (February). You should check if the year is a leap year using the method isLeapYear described above. 123456Examples of input/output:* getDaysInMonth(1, 2020); → should return 31 since January has 31 days.* getDaysInMonth(2, 2020); → should return 29 since February has 29 days in a leap year and 2020 is a leap year.* getDaysInMonth(2, 2018); → should return 28 since February has 28 days if it&#x27;s not a leap year and 2018 is not a leap year.* getDaysInMonth(-1, 2020); → should return -1 since the parameter month is invalid.* getDaysInMonth(1, -2020); → should return -1 since the parameter year is outside the range of 1 to 9999. HINT: Use the switch statement. NOTE: Methods isLeapYear and getDaysInMonth need to be public static like we have been doing so far in the course. NOTE: Do not add a main method to solution code. 題目二(答案) 12345678910111213141516171819202122232425262728293031323334353637383940414243public class NumberOfDaysInMonth &#123; public static boolean isLeapYear(int year) &#123; if (year &lt; 1 || year &gt; 9999) &#123; return false; &#125; int yearDividedByFour = year % 4; int yearDividedByHundred = year % 100; int yearDividedByFourHundred = year % 400; return (yearDividedByFour == 0 &amp;&amp; yearDividedByHundred == 0 &amp;&amp; yearDividedByFourHundred == 0) || (yearDividedByFour == 0 &amp;&amp; yearDividedByHundred != 0); &#125; public static int getDaysInMonth(int month, int year) &#123; if ((month &lt; 1 || month &gt; 12) || (year &lt; 1 || year &gt; 9999)) &#123; return -1; &#125; if (isLeapYear(year)) &#123; switch (month) &#123; case 1: case 3: case 5: case 7: case 8: case 10: case 12: return 31; case 2: return 29; case 4: case 6: case 9: case 11: return 30; &#125; &#125; switch (month) &#123; case 1: case 3: case 5: case 7: case 8: case 10: case 12: return 31; case 2: return 28; case 4: case 6: case 9: case 11: return 30; &#125; return -1; &#125;&#125; For 陳述句 For 迴圈又被稱為迭代(iteration)，在 increment 的地方，會根據條件執行疊加，可以一次加 1，也可以加 5，在 conditon 的地方設定條件，如果條件為 false，這個回圈(Loop) 就不會繼續執行，在 init 的地方定義起始值。另外，分號是必要的，不能省略。 123for (init; condition; increment) &#123; execute line (code block)&#125; 下面這個程式碼會不會回傳任何東西，因為 number 永遠符合條件，這種迴圈稱為無止盡迴圈(endless loop)，很多情況下，它可能會導致程式錯誤，或是用盡記憶體。 123for (int number = 100; number &gt; 0; number += 10) &#123; System.out.println(&quot;number = &quot; + number);&#125; 使用 For 迴圈查詢某一範圍的數字是否為質數，回傳的結果可以用 String.format 來避免回傳過多位數。也可以使用 break 讓程式跳離 For 迴圈。 123456789101112131415161718192021222324252627282930313233343536373839public static void main(String[] args) &#123; for (int i=2; i&lt;9; i++) &#123; System.out.println(&quot;10000 at &quot; + i + &quot;% interest = &quot; + String.format(&quot;%.2f&quot;, calculateInterest(10000.0, i))); &#125; for (int i=8; i&gt;1; i--) &#123; System.out.println(&quot;10000 at &quot; + i + &quot;% interest = &quot; + String.format(&quot;%.2f&quot;, calculateInterest(10000.0, i))); &#125; int count = 0; for (int i=10; i&lt;50; i++) &#123; if (isPrime(i)) &#123; count++; System.out.println(&quot;Number &quot; + i + &quot; is a prime number.&quot;); &#125; if (count == 3) &#123; System.out.println(&quot;Exiting for loop&quot;); break; &#125; &#125;&#125;public static boolean isPrime(int n) &#123; if (n == 1) &#123; return false; &#125; for (int i = 2; i &lt;= n/2; i++) &#123; if (n % i == 0) &#123; return false; &#125; &#125; return true;&#125; 3 和 5 之和挑戰 挑戰 Create a for statement using a range of numbers from 1 to 1000 inclusive. Sum all the numbers that can be divided with both 3 and also with 5 For those numbers that met the above conditions, print out the number. break out of the loop once you find 5 numbers that met the above condtions. After breaking out of the loop print the sum of the numbers that met the above conditions. Note: Type all code in main method 挑戰(答案) 12345678910111213141516171819public static void main(String[] args) &#123; int count = 0; int sum = 0; for (int i = 1; i &lt;= 1000; i++) &#123; if (i % 3 == 0 &amp;&amp; i % 5 == 0) &#123; count++; sum += i; System.out.println(&quot;Found number = &quot; + i); &#125; if (count == 5) &#123; break; &#125; &#125; System.out.println(&quot;Sum = &quot; + sum);&#125; 奇數之和挑戰 挑戰 Write a method called isOdd with an int parameter and call it number. The method needs to return a boolean. Check that number is &gt; 0, if it is not return false. If number is odd return true, otherwise return false. Write a second method called sumOdd that has 2 int parameters start and end, which represent a range of numbers. The method should use a for loop to sum all odd numbers in that range including the end and return the sum. It should call the method isOdd to check if each number is odd. The parameter end needs to be greater than or equal to start and both start and end parameters have to be greater than 0. If those conditions are not satisfied return -1 from the method to indicate invalid input. 1234567Example input/output:* sumOdd(1, 100); → should return 2500* sumOdd(-1, 100); → should return -1* sumOdd(100, 100); → should return 0* sumOdd(13, 13); → should return 13 (This set contains one number, 13, and it is odd)* sumOdd(100, -100); → should return -1* sumOdd(100, 1000); → should return 247500 TIP: use the remainder operator to check if the number is odd NOTE: Both methods needs to be defined as public static like we have been doing so far in the course. NOTE: Do not add a main method to solution code. 2. 挑戰(答案) 1234567891011121314151617181920212223public class SumOddRange &#123; public static boolean isOdd(int number) &#123; return number &gt; 0 &amp;&amp; number % 2 != 0; &#125; public static int sumOdd(int start, int end) &#123; if (start &lt; 0 || end &lt; 0 || end &lt; start) &#123; return -1; &#125; int sum = 0; for (int i = start; i &lt;= end; i ++) &#123; if (isOdd(i)) &#123; sum += i; &#125; &#125; return sum; &#125;&#125; while 和 do 陳述句 while 語法，{} 裡面定義迴圈程式碼區塊，condition 的部分加上條件。 123while (condition) &#123;&#125; do-while 語法，最後的分號是必要的，{} 裡面定義迴圈程式碼區塊，do-while 至少會執行一次，然後才會檢查條件。 123do &#123;&#125; while (condition); 使用 while 寫出跟 for 陳述句一樣語法，基本上邏輯都是一樣的，有 init 起始值、condition 條件以及 increment 增加值， 1234567891011// while 語法int count = 1;while (count &lt; 5) &#123; System.out.println(&quot;count = &quot; + count) count ++;&#125;// for 語法for (int i = 0; i &lt; 5; i++) &#123; System.out.println(&quot;i = &quot; + i)&#125; 在 while 迴圈裡面使用 continue 可以跳過後面的所有程式碼，使用 break 可以脫離迴圈。 while 迴圈在執行程式碼之前就會先檢查條件， do-while 迴圈至少會將程式碼區塊執行過一次，才檢查條件，所以要小心條件，很容易 會進入無止盡的迴圈或是沒有執行的迴圈。 秘訣：總是檢查條件和表達式(condtions/expressions) Create a method called isEvenNumber that takes a parameter of type int. Its purpose is to determine if the argument passed to the method is an even number or not. return true if an even number, otherwise return false. Make it record the total number of even numbers it has found and break once 5 found and at the end, display the total number of even numbers found. 8. 挑戰(答案) 1234567891011121314151617181920212223242526public static void main(String[] args) &#123; int number = 4; int finishNumber = 20; int evenNumbersFound = 0; while (number &lt;= finishNumber) &#123; number++; if (!isEvenNumber(number)) &#123; continue; &#125; System.out.println(&quot;Even number = &quot; + number); evenNumbersFound++; if (evenNumbersFound == 5) &#123; break; &#125; &#125; System.out.println(&quot;Total even numbers found = &quot; + evenNumbersFound);&#125;public static boolean isEvenNumber(int number) &#123; return number % 2 == 0;&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://vincent.fishboneapps.com/tags/Java/"}]},{"title":"Java 快速學習自我挑戰 Day4","slug":"Java-快速學習自我挑戰-Day4","date":"2020-05-11T01:50:37.000Z","updated":"2021-01-25T08:23:58.121Z","comments":true,"path":"2020/05/10/Java-快速學習自我挑戰-Day4/","link":"","permalink":"https://vincent.fishboneapps.com/2020/05/10/Java-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day4/","excerpt":"","text":"題目練習 題目五 Write a method areEqualByThreeDecimalPlaces with two parameters of type double. The method should return boolean and it needs to return true if two double numbers are the same up to three decimal places. Otherwise, return false. 12345EXAMPLES OF INPUT/OUTPUT:* areEqualByThreeDecimalPlaces(-3.1756, -3.175); → should return true since numbers are equal up to 3 decimal places.* areEqualByThreeDecimalPlaces(3.175, 3.176); → should return false since numbers are not equal up to 3 decimal places* areEqualByThreeDecimalPlaces(3.0, 3.0); → should return true since numbers are equal up to 3 decimal places.* areEqualByThreeDecimalPlaces(-3.123, 3.123); → should return false since numbers are not equal up to 3 decimal places. TIP: Use paper and pencil. TIP: Use casting. NOTE: The areEqualByThreeDecimalPlaces method needs to be defined as public static like we have been doing so far in the course. NOTE: Do not add a main method to solution code. 題目五(答案) 1234567public class DecimalComparator &#123; public static boolean areEqualByThreeDecimalPlaces(double firstNumber, double secondNumber) &#123; int transformedFirstNumber = (int) (firstNumber * 1000); int transformedSecondNumber = (int) (secondNumber * 1000); return transformedFirstNumber == transformedSecondNumber; &#125;&#125; 12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; boolean isIdentical = DecimalComparator.areEqualByThreeDecimalPlaces(-3.1756, -3.175); System.out.println(isIdentical); isIdentical = DecimalComparator.areEqualByThreeDecimalPlaces(3.175, 3.176); System.out.println(isIdentical); isIdentical = DecimalComparator.areEqualByThreeDecimalPlaces(3.0, 3.0); System.out.println(isIdentical); isIdentical = DecimalComparator.areEqualByThreeDecimalPlaces(-3.123, 3.123); System.out.println(isIdentical); &#125;&#125; 題目六 Write a method hasEqualSum with 3 parameters of type int. The method should return boolean and it needs to return true if the sum of the first and second parameter is equal to the third parameter. Otherwise, return false. 1234EXAMPLES OF INPUT/OUTPUT:* hasEqualSum(1, 1, 1); should return false since 1 + 1 is not equal to 1* hasEqualSum(1, 1, 2); should return true since 1 + 1 is equal to 2* hasEqualSum(1, -1, 0); should return true since 1 + (-1) is 1 - 1 and is equal to 0 NOTE: The hasEqualSum method needs to be defined as public static like we have been doing so far in the course. NOTE: Do not add a main method to solution code. 題目六(答案) 12345public class EqualSumChecker &#123; public static boolean hasEqualSum(int firstNumber, int secondNumber, int thirdNumber) &#123; return firstNumber + secondNumber == thirdNumber; &#125;&#125; 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; boolean isEqual = EqualSumChecker.hasEqualSum(1, 1, 1); System.out.println(isEqual); isEqual = EqualSumChecker.hasEqualSum(1, 1, 2); System.out.println(isEqual); isEqual = EqualSumChecker.hasEqualSum(1, -1, 0); System.out.println(isEqual); &#125;&#125; 題目七 We’ll say that a number is “teen” if it is in the range 13 -19 (inclusive). Write a method named hasTeen with 3 parameters of type int. The method should return boolean and it needs to return true if one of the parameters is in range 13(inclusive) - 19 (inclusive). Otherwise return false. 1234EXAMPLES OF INPUT/OUTPUT:* hasTeen(9, 99, 19); should return true since 19 is in range 13 - 19* hasTeen(23, 15, 42); should return true since 15 is in range 13 - 19* hasTeen(22, 23, 34); should return false since numbers 22, 23, 34 are not in range 13-19 Write another method named isTeen with 1 parameter of type int. The method should return boolean and it needs to return true if the parameter is in range 13(inclusive) - 19 (inclusive). Otherwise return false. 123EXAMPLES OF INPUT/OUTPUT:* isTeen(9); should return false since 9 is in not range 13 - 19* isTeen(13); should return true since 13 is in range 13 - 19 NOTE: All methods need to be defined as public static like we have been doing so far in the course. NOTE: Do not add a main method to solution code. 題目七(答案) 1234567891011public class TeenNumberChecker &#123; public static boolean hasTeen(int firstAge, int secondAge, int thirdAge) &#123; return (firstAge &gt;= 13 &amp;&amp; firstAge &lt;= 19) || (secondAge &gt;= 13 &amp;&amp; secondAge &lt;= 19) || (thirdAge &gt;= 13 &amp;&amp; thirdAge &lt;= 19); &#125; public static boolean isTeen(int firstAge) &#123; return (firstAge &gt;= 13 &amp;&amp; firstAge &lt;= 19); &#125;&#125; 123456789101112131415161718public class Main &#123; public static void main(String[] args) &#123; boolean hasTeen = TeenNumberChecker.hasTeen(9, 99, 19); System.out.println(hasTeen); hasTeen = TeenNumberChecker.hasTeen(23, 15, 42); System.out.println(hasTeen); hasTeen = TeenNumberChecker.hasTeen(22, 23, 34); System.out.println(hasTeen); boolean isTeen = TeenNumberChecker.isTeen(9); System.out.println(isTeen); isTeen = TeenNumberChecker.isTeen(13); System.out.println(isTeen); &#125;&#125; 方法多載(Method Overloading) 方法多載就是一個功能可以允許我們使用超過一種同樣名稱的方法，只要我們使用不同的變數。它就是一個功能可以創建很多同名的方法並有不同的應用。呼叫一個多載的方法可以運行該方法特別的應用。 挑戰 Create a method called calcFeetAndInchesToCentimeters. It needs to have two parameters. Feet is the first parameter, inches is the second parameter． You should validate that the first parameter feet is &gt;= 0. You should validate that the second parameter inches is &gt;=0 and &lt;= 12. return -1 from the method if either of the above is not true. If the parameters are valid, then calculate how many centimeters comprise the feet and inches passed to this method and return that value. Create a second method of the same name but with only one parameter, inches is the parameter, validate that its &gt;= 0, return -1 if it is not true. But if its valid, then calculate how many feet are in the inches and then here is the tricky part call the other overloaded method passing the correct feet and inches calculated so that it can calculate correctly. hints: Use double for your number data types is probably a good idea. 1 inch = 2.54cm and 1 foot = 12 inches. use the link I give you to confirm your code is calculating correctly. calling another overloaded method just require you to use the right number of parameters. 3. 挑戰的答案 123456789101112131415161718192021222324252627public static void main(String[] args) &#123; calcFeetAndInchesToCentimeters(8, 4); calcFeetAndInchesToCentimeters(-10);&#125;public static double calcFeetAndInchesToCentimeters(double feet, double inches) &#123; if (feet &lt; 0 || inches &lt; 0 || inches &gt; 12) &#123; return -1; &#125; double centimeters = (feet * 12 * 2.54) + (inches * 2.54); System.out.println(feet + &quot; feet, &quot; + inches + &quot; inches = &quot; + centimeters + &quot; cm&quot;); return centimeters;&#125;public static double calcFeetAndInchesToCentimeters(double inches) &#123; if (inches &lt; 0) &#123; return -1; &#125; int feet = (int) inches / 12; int remainingInches = (int) inches % 12; System.out.println(inches + &quot; inches is equal to &quot; + feet + &quot; feet and &quot; + remainingInches + &quot; inches&quot;); return calcFeetAndInchesToCentimeters(feet, remainingInches);&#125; 方法多載的好處 它改善了程式碼的可讀性和重複使用性。 記住一個名稱比起記住很多名稱更容易。 保持命名方法的一致性，單一名稱的方法是很常被使用的。 方法多載給予程式設計師彈性去呼叫一個有不同變數型態但相似的方法。 秒和分的挑戰 題目 Create a method called getDurationString with two parameters, first parameter minutes and second parameter seconds. You should validate that teh first parameter minutes is &gt;= 0. You should validate that the second parameter seconds is &gt;=0 and &lt;= 59. The method should return “Invalid value” in teh method if either of the above are not true. If the parameters are valid then calculate how many hours minutes and seconds equal the minutes and seconds passed to this method and return that value as string in format “XXh XXm ZZs” where XX represents a number of hours, YY the minutes and ZZ the seconds. Create a second method of the same name but with only one parameter seconds. Validate that it is &gt;= 0, and retrun “Invalid value” if it is not true. If it is valid, then calculate how many minutes are in the seconds value and then call the other overloaded method passing the correct minutes and seconds calculated so that it can calculate correctly. Call both methods to print values to the console. Tips: Use int or long for your number data types is probably a good idea. 1 minute = 60 seconds and 1 hour = 60 minutes or 3600 seconds. Methods should be static as we have used previously. Bonus: For the input 61 minutes output should be 01h 01m 00s, but it is ok it is 1h 1m 0s (Tip: use if-else) Create a new console project and call it SecondsAndMinutesChallenge 答案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Main &#123; public static void main(String[] args) &#123; System.out.println(getDurationString(3945)); &#125; private static String getDurationString(int minutes, int seconds) &#123; // 驗證分鐘是否大於 0，且秒是否介於 0-59 之間 if (minutes &lt; 0 || (seconds &lt; 0 || seconds &gt; 59)) &#123; return &quot;Invalid Value&quot;; &#125; int hours = minutes / 60; int remainingMinutes = minutes % 60; String hoursString = hours + &quot;h&quot;; if (hours &lt; 10) &#123; hoursString = &quot;0&quot; + hoursString; &#125; String minutesString = minutes + &quot;m&quot;; if (minutes &lt; 10) &#123; minutesString = &quot;0&quot; + minutesString; &#125; String secondsString = seconds + &quot;s&quot;; if (seconds &lt; 10) &#123; secondsString = &quot;0&quot; + secondsString; &#125; return hoursString + &quot; &quot; + minutesString + &quot; &quot; + secondsString; &#125; private static String getDurationString(int seconds) &#123; // 驗證秒是否大於 0 if (seconds &lt; 0) &#123; return &quot;Invalid Value&quot;; &#125; int minutes = seconds / 60; int remainingSeconds = seconds % 60; return getDurationString(minutes, remainingSeconds); &#125;&#125; final 就是 constant 變數裡面的一個關鍵字，如果定義了，就不能改變它。可以將上面的程式碼改成下面這樣。 12345678910private static final String INVALID_VALUE_MESSAGE = &quot;Invalid value&quot;;...if (minutes &lt; 0 || (seconds &lt; 0 || seconds &gt; 59)) &#123; return INVALID_VALUE_MESSAGE;&#125;...if (seconds &lt; 0) &#123; return INVALID_VALUE_MESSAGE;&#125; 四個挑戰 題目一 Write a method named area with one double parameter named radius. The method needs to return a double value that represents the area of a circle. If the parameter radius is negative then return -1.0 to represent an invalid value. Write another overloaded method with 2 parameters x and y (both doubles), where x and y represent the sides of a rectangle. The method needs to return an area of a rectangle. If either or both parameters is/are a negative return -1.0 to indicate an invalid value. For formulas and PI value please check the tips below. 12345Examples of input/output:* area(5.0); should return 78.53975* area(-1); should return -1 since the parameter is negative* area(5.0, 4.0); should return 20.0 (5 * 4 = 20)* area(-1.0, 4.0); should return -1 since first the parameter is negative TIP: The formula for calculating the area of a rectangle is x * y. TIP: The formula for calculating a circle area is radius * radius * PI. TIP: For PI use a constant from Math class e.g. Math.PI NOTE: All methods need to be defined as public static like we have been doing so far in the course. NOTE: Do not add a main method to your solution code! 題目一(答案) 123456789101112131415161718192021public class AreaCalculator &#123; public static double area(double radius) &#123; if (radius &lt; 0) &#123; return -1; &#125; // 計算圓面積 return radius * radius * Math.PI; &#125; public static double area(double x, double y) &#123; if (x &lt; 0 || y &lt; 0) &#123; return -1; &#125; // 計算三角形面積 return x * y; &#125;&#125; 題目二 Write a method printYearsAndDays with parameter of type long named minutes. The method should not return anything (void) and it needs to calculate the years and days from the minutes parameter. If the parameter is less than 0, print text “Invalid Value”. Otherwise, if the parameter is valid then it needs to print a message in the format “XX min = YY y and ZZ d”. XX represents the original value minutes. YY represents the calculated years. ZZ represents the calculated days. 1234EXAMPLES OF INPUT/OUTPUT:* printYearsAndDays(525600); → should print &quot;525600 min = 1 y and 0 d&quot;* printYearsAndDays(1051200); → should print &quot;1051200 min = 2 y and 0 d&quot;* printYearsAndDays(561600); → should print &quot;561600 min = 1 y and 25 d&quot; TIPS: Be extra careful about spaces in the printed message. Use the remainder operator 1 hour = 60 minutes 1 day = 24 hours 1 year = 365 days NOTES The printYearsAndDays method needs to be defined as public static like we have been doing so far in the course. Do not add main method to solution code. The solution will not be accepted if there are extra spaces 題目二(答案) 123456789101112131415public class MinutesToYearsDaysCalculator &#123; public static void printYearsAndDays(long minutes) &#123; if (minutes &lt; 0) &#123; System.out.println(&quot;Invalid Value&quot;); &#125; else &#123; // 將分鐘轉換成年和天 long days = minutes / 60 / 24; long years = days / 365; long remainingDays = days % 365; System.out.println(minutes + &quot; min = &quot; + years + &quot; y and &quot; + remainingDays + &quot; d&quot;); &#125; &#125;&#125; 題目三 Write a method printEqual with 3 parameters of type int. The method should not return anything (void). If one of the parameters is less than 0, print text “Invalid Value”. If all numbers are equal print text “All numbers are equal” If all numbers are different print text “All numbers are different”. Otherwise, print “Neither all are equal or different”. 12345EXAMPLES OF INPUT/OUTPUT:* printEqual(1, 1, 1); should print text All numbers are equal* printEqual(1, 1, 2); should print text Neither all are equal or different* printEqual(-1, -1, -1); should print text Invalid Value* printEqual(1, 2, 3); should print text All numbers are different TIP: Be extremely careful about spaces in the printed message. NOTES The solution will not be accepted if there are extra spaces. The method printEqual needs to be defined as public static like we have been doing so far in the course. Do not add main method to solution code. 題目三(答案) 1234567891011121314public class IntEqualityPrinter &#123; public static void printEqual(int first, int second, int third) &#123; if (first &lt; 0 || second &lt; 0 || third &lt; 0) &#123; System.out.println(&quot;Invalid Value&quot;); &#125; else if (first == second &amp;&amp; second == third) &#123; System.out.println(&quot;All numbers are equal&quot;); &#125; else if (first != second &amp;&amp; second != third &amp;&amp; third != first) &#123; System.out.println(&quot;All numbers are different&quot;); &#125; else &#123; System.out.println(&quot;Neither all are equal or different&quot;); &#125; &#125;&#125; 題目四 The cats spend most of the day playing. In particular, they play if the temperature is between 25 and 35 (inclusive). Unless it is summer, then the upper limit is 45 (inclusive) instead of 35. Write a method isCatPlaying that has 2 parameters. Method needs to return true if the cat is playing, otherwise return false 1st parameter should be of type boolean and be named summer it represents if it is summer. 2nd parameter represents the temperature and is of type int with the name temperature. 1234EXAMPLES OF INPUT/OUTPUT:* isCatPlaying(true, 10); should return false since temperature is not in range 25 - 45 * isCatPlaying(false, 36); should return false since temperature is not in range 25 - 35 (summer parameter is false)* isCatPlaying(false, 35); should return true since temperature is in range 25 - 35 NOTES The isCatPlaying method needs to be defined as public static like we have been doing so far in the course. Do not add the main method to the solution code. 題目四(答案) 1234567891011public class PlayingCat &#123; public static boolean isCatPlaying(boolean summer, int temperature) &#123; if (!summer) &#123; return temperature &gt;= 25 &amp;&amp; temperature &lt;= 35; &#125; else &#123; return temperature &gt;= 25 &amp;&amp; temperature &lt;= 45; &#125; &#125;&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://vincent.fishboneapps.com/tags/Java/"}]},{"title":"Java 快速學習自我挑戰 Day3","slug":"Java-快速學習自我挑戰-Day3","date":"2020-05-08T08:51:10.000Z","updated":"2020-06-22T17:13:55.105Z","comments":true,"path":"2020/05/08/Java-快速學習自我挑戰-Day3/","link":"","permalink":"https://vincent.fishboneapps.com/2020/05/08/Java-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day3/","excerpt":"","text":"Java 教學 - 表達式(Expressions)、陳述句(Statements)、程式碼區塊(Code Blocks)、方法(Methods)…等等 關鍵字(Keywords)和表達式(Expressions) Java Keyword 列表 int int = 5;，這樣的語法會出現錯誤，關鍵字是被保留的，所以在命名變數的時候，不能使用跟關鍵字同名的變數。 裡面的 kilometers = (100 * 1.609344);、highScore = 50;、highScore == 50、&quot;This is an expression.&quot; 都是表達式，double kilometers = (100 * 1.609344);、int highScore = 50; 則是陳述句(statement)，而 System.out.println(&quot;This is an expression.&quot;); 則是一個方法(method) 123456double kilometers = (100 * 1.609344);int highScore = 50;if (highScore == 50) &#123; System.out.println(&quot;This is an expression.&quot;);&#125; 陳述句(Statements)、空白(Whitespace)、縮排(Indentation) 一行陳述句的結尾要有分號，中間不管放多少空白，Java 都可以讀取。 寫程式碼一定要有縮排，沒有縮排不會影響功能，但是會影響閱讀。 程式碼區塊(Code Blocks)和 If-then-else 控制陳述句(Control Statement) if-else if-else 的範例。 123456789101112boolean gameOver = true;int score = 800;int levelCompleted = 5;int bonus = 100;if (score &lt; 5000 &amp;&amp; score &gt; 1000) &#123; System.out.println(&quot;Your score was less than 5000 but greater than 1000&quot;);&#125; else if (score &lt; 1000) &#123; System.out.println(&quot;Your score was less than 1000&quot;);&#125; else &#123; System.out.println(&quot;Got here.&quot;);&#125; 在最後一行會發生錯誤，因為在 if 的程式碼區塊裡面，完成之後，就會將 finalScore 刪除。 123456if (gameOver) &#123; int finalScore = score + (levelCompleted * bonus); System.out.println(&quot;Your final score was &quot; + finalScore);&#125;int savedFinalScore = finalscore; //error 程式碼區塊裡面的內容，叫做 scope，後面會細說。 挑戰：將 score 設定為 10000，levelCompleted 設定為 8，bonus 設定為 200，然後確定上面的程式碼一樣被執行。 可以將變數重複利用，不需要在前面在定義變數原始型態，直接給變數名稱數值。 12345678score = 10000;levelCompleted = 8;bonus = 200;if (gameOver) &#123; int finalScore = score + (levelCompleted * bonus); System.out.println(&quot;Your final score was &quot; + finalScore);&#125; if-then-else 回顧 if 陳述句根據表達式的值來判別要執行哪個陳述句或是程式碼區塊內容，換句話說，就是根據特定條件。 程式碼區塊會用 { } 來定義，在裡面可以執行一到多行的陳述句。 我們可以在 if 陳述句後面使用 else，當條件是錯誤的時候，else 的區塊程式碼會被執行。 我們還可以使用 else if 去驗證多條件。 基本的 if-else 陳述句架構如下： 12345if (condition) &#123; if statement (block)&#125; else &#123; else statement (block)&#125; Java 裡的方法(Methods) 方法是用來讓重複功能寫在一起，只要呼叫方法就可以，不需要重複寫一樣的程式碼。 public static 就是方法，void 就是不回傳值，如果需回傳值，就要像 calculateScore 在前面加上想要回傳的值的原始型態。 123456789101112131415public static void main(String[] args) &#123; calculateScore(true, 800, 5, 100); calculateScore(true, 10000, 8, 200);&#125;public static int calculateScore(boolean gameOver, int score, int levelCompleted, int bonus) &#123; if (gameOver) &#123; int finalScore = score + (levelCompleted * bonus); System.out.println(&quot;Your final score was &quot; + finalScore); return finalScore; &#125; return -1;&#125; 為什麼回傳 -1？找不到值、或是錯誤就會回傳 -1。 更多方法(Methods)和挑戰 挑戰：創建一個方法叫做 displayHighScorePosition，有兩個參數分別是 playerName 和 highScorePosition，要顯示訊息 playerName + “manage to get that position &quot; + highScorePosition + &quot; on the high score table”。再創建一個方法叫做 calculateHighScorePosition，只有一個參數 playerScore，要回傳 int，當分數 &gt; 1000 回傳 1，分數 &gt; 500 且 &lt; 1000 回傳 2，分數 &gt; 100 且 &lt; 500 回傳 3，其餘回傳 4，最後分別顯示以下分數的結果 1500, 900, 400, 50。 123456789101112131415161718192021222324252627public static void main(String[] args) &#123; int highScorePosition = calculateHighScorePosition(1500); displayHighScorePosition(&quot;Tim&quot;, highScorePosition); highScorePosition = calculateHighScorePosition(900); displayHighScorePosition(&quot;Bob&quot;, highScorePosition); highScorePosition = calculateHighScorePosition(400); displayHighScorePosition(&quot;Percy&quot;, highScorePosition); highScorePosition = calculateHighScorePosition(50); displayHighScorePosition(&quot;Gilbert&quot;, highScorePosition);&#125;public static void displayHighScorePosition(String playerName, int highScorePosition) &#123; System.out.println(playerName + &quot; managed to get into position &quot; + highScorePosition + &quot; on the high school table&quot;);&#125;public static int calculateHighScorePosition(int playerScore) &#123; if (playerScore &gt;= 1000) &#123; return 1; &#125; else if (playerScore &gt;= 500) &#123; return 2; &#125; else if (playerScore &gt;= 100) &#123; return 3; &#125; return 4;&#125; calculateHighScorePosition 的程式碼也可以改寫如下 1234567891011121314public static int calculateHighScorePosition(int playerScore) &#123; int position = 4; // assuming position 4 will be returned if (playerScore &gt;= 1000) &#123; position = 1; &#125; else if (playerScore &gt;= 500) &#123; position = 2; &#125; else if (playerScore &gt;= 100) &#123; position = 3; &#125; return position;&#125; DiffMerge 工具 DiffMerge 是一個程式在任何作業系統下都可以幫助你視覺地比較和合併檔案。 用 DiffMerge 可以視覺地比較一個檔案或整個資料夾的程式碼。 DiffMerge 下載頁面 題目練習 題目一 Write a method called toMilesPerHour that has 1 parameter of type double with the name kilometersPerHour. This method needs to return the rounded value of the calculation of type long. If the parameter kilometersPerHour is less than 0, the method toMilesPerHour needs to return -1 to indicate an invalid value. Otherwise, if it is positive, calculate the value of miles per hour, round it and return it. For conversion and rounding, check the notes in the text below. 123456Examples of input/output:* toMilesPerHour(1.5); → should return value 1* toMilesPerHour(10.25); → should return value 6* toMilesPerHour(-5.6); → should return value -1* toMilesPerHour(25.42); → should return value 16* toMilesPerHour(75.114); → should return value 47 Write another method called printConversion with 1 parameter of type double with the name kilometersPerHour. This method should not return anything (void) and it needs to calculate milesPerHour from the kilometersPerHour parameter. Then it needs to print a message in the format “XX km/h = YY mi/h”. XX represents the original value kilometersPerHour. YY represents the rounded milesPerHour from the kilometersPerHour parameter. If the parameter kilometersPerHour is &lt; 0 then print the text “Invalid Value”. 123456Examples of input/output:* printConversion(1.5); → should print the following text (into the console - System.out): 1.5 km/h = 1 mi/h* printConversion(10.25); → should print the following text (into the console - System.out): 10.25 km/h = 6 mi/h* printConversion(-5.6); → should print the following text (into the console - System.out): Invalid Value* printConversion(25.42); → should print the following text (into the console - System.out): 25.42 km/h = 16 mi/h* printConversion(75.114); → should print the following text (into the console - System.out): 75.114 km/h = 47 mi/h Use method Math.round to round the number of calculated miles per hour(double). The method round returns long. How to use the method round and how it works? The Math.round() is a built-in math method which returns the closest long to the argument. The result is rounded to an integer by adding 1/2, taking the floor of the result after adding 1/2, and typecasting the result to type long. The method returns the value of the argument rounded to the nearest int value. USAGE EXAMPLE: 123456789101112double number = 1.5;long rounded = Math.round(number);System.out.println(&quot;rounded= &quot; + rounded);System.out.println(&quot;with 3.9= &quot; + Math.round(3.9));System.out.println(&quot;with 4.5= &quot; + Math.round(4.5));int sum = 45;int count = 10;// typecasting so result is double e.g. double / int -&gt; doubledouble average = (double) sum / count;long roundedAverage = Math.round(average);System.out.println(&quot;average= &quot; + average);System.out.println(&quot;roundedAverage= &quot; + roundedAverage); OUTPUT: 12345rounded= 2with 3.9= 4with 4.5= 5average= 4.5roundedAverage= 5 TIP: In the method printConversion, call the method toMilesPerHour instead of duplicating the code. NOTE: All methods should be defined as public static like we have been doing so far in the course. NOTE: 1 mile per hour is 1.609 kilometers per hour NOTE: Do not add a main method to the solution code. 題目一(解答) 1234567891011121314151617181920212223public class SpeedConverter &#123; public static long toMilesPerHour(double kilometersPerHour) &#123; if (kilometersPerHour &lt; 0) &#123; return -1; &#125; long milesPerHour = Math.round(0.621371192 * kilometersPerHour); return milesPerHour; &#125; public static void printConversion(double kilometersPerHour) &#123; if (kilometersPerHour &lt; 0) &#123; System.out.println(&quot;Invalid Value&quot;); &#125; else &#123; long milesPerHour = toMilesPerHour(kilometersPerHour); System.out.println(kilometersPerHour + &quot; km/h = &quot; + milesPerHour + &quot; mi/h&quot;); &#125; &#125;&#125; 12345678910111213public class Main &#123; public static void main(String[] args) &#123; SpeedConverter.printConversion(1.5); SpeedConverter.printConversion(10.25); SpeedConverter.printConversion(-5.6); SpeedConverter.printConversion(25.42); SpeedConverter.printConversion(75.114); &#125;&#125; 題目二 Write a method called printMegaBytesAndKiloBytes that has 1 parameter of type int with the name kiloBytes. The method should not return anything (void) and it needs to calculate the megabytes and remaining kilobytes from the kilobytes parameter. Then it needs to print a message in the format “XX KB = YY MB and ZZ KB”. XX represents the original value kiloBytes. YY represents the calculated megabytes. ZZ represents the calculated remaining kilobytes. For example, when the parameter kiloBytes is 2500 it needs to print “2500 KB = 2 MB and 452 KB” If the parameter kiloBytes is less than 0 then print the text “Invalid Value”. 1234EXAMPLE INPUT/OUTPUT* printMegaBytesAndKiloBytes(2500); → should print the following text: &quot;2500 KB = 2 MB and 452 KB&quot;* printMegaBytesAndKiloBytes(-1024); → should print the following text: &quot;Invalid Value&quot; because parameter is less than 0.* printMegaBytesAndKiloBytes(5000); → should print the following text: &quot;5000 KB = 4 MB and 904 KB&quot; TIP: Be extremely careful about spaces in the printed message. TIP: Use the remainder operator TIP: 1 MB = 1024 KB NOTE: Do not set kilobytes parameter value inside your method. NOTE: The solution will not be accepted if there are extra spaces. NOTE: The printMegaBytesAndKiloBytes method needs to be defined as public static like we have been doing so far in the course.NOTE: Do not add a main method to solution code. 題目二(解答\b) 12345678910public static void printMegaBytesAndKiloBytes(int kiloBytes) &#123; if (kiloBytes &lt; 0) &#123; System.out.println(&quot;Invalid Value&quot;); &#125; else &#123; int megaBytes = (int) Math.floor( kiloBytes / 1024d ); int extraKiloBytes = kiloBytes - (megaBytes * 1024); System.out.println(kiloBytes + &quot; KB = &quot; + megaBytes + &quot; MB and &quot; + extraKiloBytes + &quot; KB&quot;); &#125;&#125; 1234567891011public class Main &#123; public static void main(String[] args) &#123; MegaBytesConverter.printConversion(2500); MegaBytesConverter.printConversion(-1024); MegaBytesConverter.printConversion(5000); &#125;&#125; 題目三 We have a dog that likes to bark. We need to wake up if the dog is barking at night! Write a method shouldWakeUp that has 2 parameters. 1st parameter should be of type boolean and be named barking it represents if our dog is currently barking. 2nd parameter represents the hour of the day and is of type int with the name hourOfDay and has a valid range of 0-23. We have to wake up if the dog is barking before 8 or after 22 hours so in that case return true. In all other cases return false. If the hourOfDay parameter is less than 0 or greater than 23 return false. 12345Examples of input/output:* shouldWakeUp (true, 1); → should return true* shouldWakeUp (false, 2); → should return false since the dog is not barking.* shouldWakeUp (true, 8); → should return false, since it&#x27;s not before 8.* shouldWakeUp (true, -1); → should return false since the hourOfDay parameter needs to be in a range 0-23. TIP: Use the if else statement with multiple conditions. NOTE: The shouldWakeUp method needs to be defined as public static like we have been doing so far in the course. NOTE: Do not add a main method to solution code. 題目三(解答) 12345678910111213141516public static boolean shouldWakeUp(boolean isBarking, int hourOfDay) &#123; // 驗證 hourOfDay 是否是 0-23 if (hourOfDay &gt; 23 || hourOfDay &lt; 0) &#123; return false; &#125; // 如果 isBarking true，且 hourOfDay 小於 8 或大於 23，會傳 true if (isBarking == true) &#123; if (hourOfDay &lt; 8 || hourOfDay &gt; 22) &#123; return true; &#125; &#125; return false;&#125; 12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; boolean shouldWakeUp = BarkingDog.shouldWakeUp(true, 1); System.out.println(shouldWakeUp); shouldWakeUp = BarkingDog.shouldWakeUp(false, 2); System.out.println(shouldWakeUp); shouldWakeUp = BarkingDog.shouldWakeUp(true, 8); System.out.println(shouldWakeUp); shouldWakeUp = BarkingDog.shouldWakeUp(true, -1); System.out.println(shouldWakeUp); &#125;&#125; 題目四 Write a method isLeapYear with a parameter of type int named year. The parameter needs to be greater than or equal to 1 and less than or equal to 9999. If the parameter is not in that range return false. Otherwise, if it is in the valid range, calculate if the year is a leap year and return true if it is a leap year, otherwise return false. To determine whether a year is a leap year, follow these steps: If the year is evenly divisible by 4, go to step Otherwise, go to step 5.2. If the year is evenly divisible by 100, go to step Otherwise, go to step 4.3. If the year is evenly divisible by 400, go to step Otherwise, go to step 5.4. The year is a leap year (it has 366 days). The method isLeapYear needs to return true. The year is not a leap year (it has 365 days). The method isLeapYear needs to return false. The following years are not leap years: 1700, 1800, 1900, 2100, 2200, 2300, 2500, 2600 This is because they are evenly divisible by 100 but not by 400. The following years are leap years: 1600, 2000, 2400 This is because they are evenly divisible by both 100 and 400. 12345Examples of input/output:* isLeapYear(-1600); → should return false since the parameter is not in range (1-9999)* isLeapYear(1600); → should return true since 1600 is a leap year* isLeapYear(2017); → should return false since 2017 is not a leap year* isLeapYear(2000); → should return true because 2000 is a leap year NOTE: The method isLeapYear needs to be defined as public static like we have been doing so far in the course. NOTE: Do not add a main method to solution code. 題目四(答案) 1234567891011121314151617public static boolean isLeapYear(int year) &#123; // year 必須要大於等於 1，且要小於等於 9999 if (year &lt; 1 || year &gt; 9999) &#123; return false; &#125; // 1. 如果年可以被 4 除，就往下，其餘的不是閏年 // 2. 如果年可以被 100 除，就往下，其餘的是閏年 // 3. 如果年可以被 400 除，就往下，其餘不是閏年 int dividedByFour = year % 4; int dividedByHundred = year % 100; int dividedByFourHundreds = year % 400; return (dividedByFour == 0 &amp;&amp; dividedByHundred == 0 &amp;&amp; dividedByFourHundreds == 0) || (dividedByFour == 0 &amp;&amp; dividedByHundred != 0); &#125; 12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; boolean isLeapYear = LeapYear.isLeapYear(-1600); System.out.println(isLeapYear); isLeapYear = LeapYear.isLeapYear(1600); System.out.println(isLeapYear); isLeapYear = LeapYear.isLeapYear(2017); System.out.println(isLeapYear); isLeapYear = LeapYear.isLeapYear(2000); System.out.println(isLeapYear); &#125;&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://vincent.fishboneapps.com/tags/Java/"}]},{"title":"Java 快速學習自我挑戰 Day2","slug":"Java-快速學習自我挑戰-Day2","date":"2020-05-06T04:48:45.000Z","updated":"2021-01-25T08:23:53.950Z","comments":true,"path":"2020/05/06/Java-快速學習自我挑戰-Day2/","link":"","permalink":"https://vincent.fishboneapps.com/2020/05/06/Java-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day2/","excerpt":"","text":"第一步 - PartII Java 型態轉換(Java Casting) Casting 就是將數字從一個型態轉為另一個型態，我們將我們想要的型態放到 () 裡面，像這樣：(byte) (myMinByteValue / 2) 其它語言也有型態轉換，這不是 Java 獨有的功能。 如果不指定型態，Java 會默認為 Integer。 原始型態挑戰 挑戰：創建一個 byte 變數並設為有效的 byte 數字，再創建一個 short 和 int，也同樣設為有效的 short 和 int 數字，最後，再創建一個 long 的變數等於 50000 + 10 * (byte 值 + short 值 + integer 值)。 整體來說，Integer 是最好的原始型態，就算你使用 Long，你會看到 Java 為你解決了很多複雜的問題，你不需要對 Long 做型態轉換，因為 Long 會接受 Integer (最大的 Integer 一定可以放進去 Long 裡面)， 1234567891011121314public class Main &#123; public static void main(String[] args) &#123; byte byteValue = 10; short shortValue = 20; int intValue = 50; long longTotal = 50000L + 10L * (byteValue + shortValue + intValue); System.out.println(longTotal); short shortTotal = (short) (1000 + 10 * (byteValue + shortValue + intValue)); System.out.println(shortTotal); &#125;&#125; 原始型態的浮點數和倍精度浮點數(float &amp; double) 不像整數，浮點數有小數點，3.14159 就是一個浮點數。 浮點數又稱為實數(real number)，當我們在計算需要精度更高的時候，我們就會用浮點數。 精度 (precision) 指的是被型態佔用的格式和數量，單精度佔用 32 位元(也就是寬度 32)，雙精度佔用 64 位元(也就是寬度 64)。 浮點數 的範圍是 1.4E-45 到 3.4028235E+38，而雙精度更精確，範圍是 4.9E-324 到 1.7976931348623157E+308。透過以下程式碼可以驗證原始型態的範圍。 123456789float myMinFloatValue = Float.MIN_VALUE;float myMaxFloatValue = Float.MAX_VALUE;System.out.println(&quot;Float minimum value = &quot; + myMinFloatValue);System.out.println(&quot;Float maximum value = &quot; + myMaxFloatValue);double myMinDoubleValue = Double.MIN_VALUE;double myMaxDoubleValue = Double.MAX_VALUE;System.out.println(&quot;Double minimum value = &quot; + myMinDoubleValue);System.out.println(&quot;Double maximum value = &quot; + myMaxDoubleValue); 我們定義三個變數，發現如果新增一個 float 的變數，會出現錯誤，是因為在浮點數，默認為 double，所以在後面加一個 f 宣告為 float 就不會出現錯誤。 123int myIntValue = 5;float myFloatValue = 5.25f;double myDoubleValue = 5.25; 挑戰：前面用 type casting 將 byte 和 short 轉換為 int，你想想要怎麼對 float 做轉換來消除錯誤呢？ 直接在前面加上 (float) 做型態轉換。 float myFloatValue = (float) 5.25; 現在不推薦使用 float，double 浮點數才是首選的浮點數型態，而且不推薦使用 type casting，直接在後面加上 f 是更簡單的做法。 浮點數精度和一個挑戰 直接將這些變數打印出來，會發現 float 和 double 打印出來的都是 5.0，因為是浮點數。 123456int myIntValue = 5;float myFloatValue = 5f;double myDoubleValue = 5d;System.out.println(&quot;MyIntValue = &quot; + myIntValue);System.out.println(&quot;myFloatValue = &quot; + myFloatValue);System.out.println(&quot;myDoubleValue = &quot; + myDoubleValue); 對這些變數做運算，int 會出現 2，因為它是整數，剩下的打印出 2.5，因為浮點數可以計算小數點，所以會得到比較精準的答案。 1234567891011int myIntValue = 5 / 2;float myFloatValue = 5f / 2f;double myDoubleValue = 5d / 2d;System.out.println(&quot;MyIntValue = &quot; + myIntValue);System.out.println(&quot;myFloatValue = &quot; + myFloatValue);System.out.println(&quot;myDoubleValue = &quot; + myDoubleValue);------MyIntValue = 2myFloatValue = 2.5myDoubleValue = 2.5 這時候再改除以 3，在這邊就可以看到 double 比 float 還要更精準。 1234567891011int myIntValue = 5 / 3;float myFloatValue = 5f / 3f;double myDoubleValue = 5d / 3d;System.out.println(&quot;MyIntValue = &quot; + myIntValue);System.out.println(&quot;myFloatValue = &quot; + myFloatValue);System.out.println(&quot;myDoubleValue = &quot; + myDoubleValue);------MyIntValue = 1myFloatValue = 1.6666666myDoubleValue = 1.6666666666666667 也可以不用 d，直接在數字後面加上 .00 對 Java 來說就會是 double 的浮點數。 double myDoubleValue = 5.00 / 3.00; 為什麼使用 double? 在現代的電腦，相同的 double 數值比 float 數值還要快。 Java 庫裡面，特定的數學函式時常用有一種特定寫法來處理 double 而不是 float，而且結果都是回傳 double 的。 它更精確，而且可以處理更大量的數字。 在現實世界中，很多庫都用 double，也正因為如此，如果你不指定資料型態為 d 或 f，Java 會默認 double 是浮點數的資料型態。 挑戰：將磅轉換為公斤 步驟一：創建一個適合的變數儲存\u001d磅，並讓它轉換為公斤。 步驟二：計算結果。例如：公斤數根據磅的變數來計算，再創建一個適合的變數儲存公斤。 步驟三：打印出結果。 提示：1 磅等於 0.45359237 公斤。 123double numberOfPounds = 200d;double convertedKilograms = numberOfPounds * 0.45359237d;System.out.println(&quot;Converted kilograms = &quot; + convertedKilograms); double 一樣也可以用 _ 來分隔，讓閱讀更容易。 double anotherNumber = 3_000_000.4_567_890d; 重點整理 整理來說，float 和 double 對一般浮點數操作都是很棒的，但是兩者對需要精確計算的地方並不好，這是因為浮點數儲存的限制，並不是 Java 的問題。 Java 有一個 class 叫做 BigDecimal 可以克服這個的問題，我們後面會講到，但是要記得像是貨幣的計算，需要精度非常準確的計算，浮點數是不能使用的。 原始型態 Char 和 Boolean char 只能儲存一個字元(character)，什麼情況下會用到這種原始型態，像是遊戲裡面會記錄使用者最後打入的按鍵。 一個 char 佔用 2 位元組，也就是 16 位元，因此他的寬度為 16，它不是1 位元組的原因是它允許儲存一個 Unicode 字母。 Unicode 是一種國際編碼標準，用在不同語言和腳本中，每一個字母、數字和符號都有獨一無二的數值可以用在不同的平台和程式。 在英文字母中，只有 A-Z 26 個字母，也就是說只要 26 個字元就能表示整個英文字母，但是其它語言需要更多字元，通常是多很多。 Unicode 允許我們使用 2 位元組來表示這些語言，char 在記憶體中可以表示 65535 個不同型態字元中的其中一個。 可以去 Unicode Table 查看 Unicode 的表，可以用 \\u 表示 Unicode。 1234char myChar = &#x27;D&#x27;;char myUnicodeChar = &#x27;\\u0044&#x27;;System.out.println(myChar);System.out.println(myUnicodeChar); 也可以測試將著作權的符號打印出來。 12char myCopyrightChar = &#x27;\\u00A9&#x27;;System.out.println(myCopyrightChar); 布林(Boolean)原始型態：布林值允許兩種選擇，True 或 False，Yes 或 No，1 或 0，在 Java 裡，boolean 原始型態只能設定成兩種值，true 和 false，它們非常有用，而且會常常在寫程式的時候用到。 我們可以用 boolean 定義變數為布林，如果要知道顧客年紀是否超過 21 歲，可以將變數命名為 isCustomerOverTwentyOne，這很直覺也很好追蹤，後面會說到更多命名變數，類和方法。 1234boolean myTrueBooleanValue = true;boolean myFalseBooleanValue = false;boolean isCustomerOverTwentyOne = true; 原始型態回顧和字串(String)原始型態 八個原始型態的回顧 全部：byte、short、int、long、float、double、char、boolean 最常用：int、double、boolean String String 是 Java 的一種資料型態，它不是原始型態，它其實是一個類(Class)，但是它在 Java 有點被偏愛，所以它比一般類更好使用，你可以用跟一般類不一樣的方式對待它。 String 是一串字元，上面講到 Char 只能放一個字元(或是 Unicode 字元)，而 String 可以放入一連串的字元，技術上來說，它的 MAX_VALUE 可以放入 21.4 億的 int，這是很大量的字元。 String 可以對自己加上內容，然後打印出來，Unicode 也是可以的。 1234567891011String myString = &quot;This is a string&quot;;System.out.println(&quot;My string is equal to &quot; + myString);myString = myString + &quot;, and this is more.&quot;;System.out.println(&quot;My string is equal to &quot; + myString);myString = myString + &quot; \\u00A9 2020&quot;;System.out.println(&quot;My string is equal to &quot; + myString);------My string is equal to This is a stringMy string is equal to This is a string, and this is more.My string is equal to This is a string, and this is more. © 2020 String 裡面的數字會被當成文字處理，並沒有辦法做數學的計算。 123456String numberString = &quot;250.55&quot;;numberString = numberString + &quot;49.95&quot;;System.out.println(numberString);------250.5549.95 就算在 String 後面加上數字型態的數字，最後還是會當作文字處理。 1234567String lastString = &quot;10&quot;;int myInt = 50;lastString = lastString + myInt;System.out.println(&quot;My last string is &quot; + lastString);------My last string is 1050 就算用 double，還是一樣會當文字處理。 123456double doubleNumber = 120.47d;lastString = lastString + doubleNumber;System.out.println(&quot;My last string is &quot; + lastString);------My last string is 1050120.47 Java 的 String 是不可變的(Immutable) 當我說可以刪除 String，嚴格上來說是不正確的，因為 Java 的 String 是不可變的，所以說，你在創建 String 之後是不能改變 String 的，取而代之的，新的 String 是再次創建的。 所以在上面這個例子，lastSting 不是附加上 120.47 這個值，而是新 String 被創建了，這個新 String 包含之前的 lastString 加上用文字表示的 double 值 120.47。 結果是一樣的，lastString 有正確的值，然而，新的 String 被創建，而舊的被拋棄。 不要擔心覺得這個不合理，後面會細說，在這邊，我想特別強調 String 是 Immutable (不可變的)。 我們用的程式碼再創建 String 是沒有效率的 最後一個新的 String 被創建，像這樣的方式是沒有效率的，而且不推薦的。後面會用 StringBuffer，這個就可以讓 String 被改變了。 在我們處理 StringBuffer，我們需要了解類(class)，而且，後面你會遇到用這種風格(String + Value)寫的程式碼，所以用 StringBuffer 對你很有用。 運算符(Operators)、運算數(Operands)、表達式(Expressions) 什麼是運算符(Operator)？ Java 的 運算符(Operator) 是特殊符號，用來對一個、兩個、或三個運算數執行特定的操作，最後返回結果。例如：我們用 + 運算符來相加兩個數的值。 什麼是運算數(Operand)？ 運算數(Operand)是一個專有名詞，用來描述被運算符操作的任何物件。 如果我們看這個陳述句(statement)：int myVar = 15 + 12，+ 是運算符，而 15 和 12 是運算數，用文字表示的變數也是運算數。 double mySalary = hoursWorked * hourlyRate，在這邊，hoursWorked 和 hourlyRate 都是運算數，而且 * 是 運算符。 什麼是表達式(Expression)？ 一個表達式是由變數、文字、回傳值的方法(還沒講到)和運算符所組成。 int myVar = 15 + 12，15 + 12 就是表達式，最後會回傳 27。 double mySalary = hoursWorked * hourlyRate，hoursWorked * hourlyRate 是表達式，所以如果 hoursWorked 是 10.00，hourlyRate 是 20.00，最後這個表達式會回傳 200.00。 什麼是註解(Comment)？ 註解會被電腦忽略，被加到程式碼裡面是為了幫助描述某件事，註解是為了人而存在的。 我們用 // 在任何程式碼前面，或是在空白的一行，任何在 // 後面的內容到這一行的結尾都會被忽略。 除了可以用來描述一個程式碼的內容，註解也被用來暫時性地禁用程式碼。 這邊可以看到，在第三行的時候指定了 result 給 previousResult，後面 previousResult 並沒有被改變，所以就算後面 result 改變了，previousResult 在最後也不會改變。另外展示運算符 (+, -, *, /, %)。 123456789101112131415161718192021222324int result = 1 + 2; // 1 + 2 = 3System.out.println(&quot;1 + 2 = &quot; + result);int previousResult = result;System.out.println(&quot;previousResult = &quot; + previousResult);result = result - 1; // 3 - 1 = 2;System.out.println(&quot;3 - 1 = &quot; + result);System.out.println(&quot;previousResult = &quot; + previousResult);result = result * 10; // 2 * 10 = 20;System.out.println(&quot;2 * 10 = &quot; + result);result = result / 5; // 20 / 5 = 4System.out.println(&quot;20 / 5 = &quot; + result);result = result % 3; // the remainder of (4 % 3) = 1;System.out.println(&quot;4 % 3 = &quot; + result);------1 + 2 = 3previousResult = 33 - 1 = 2previousResult = 32 * 10 = 2020 / 5 = 44 % 3 = 1 縮寫運算符 可以用 ++, --, +=, -=, *=, /= 來進行運算的縮寫。 1234567891011121314151617181920212223int result = 1;// result = result + 1;result++; // 1 + 1 = 2;System.out.println(&quot;1 + 1 = &quot; + result);result--; // 2 - 1 = 1;System.out.println(&quot;2 - 1 = &quot; + result);// result = result + 2;result += 2; // 1 + 2 = 3System.out.println(&quot;1 + 2 = &quot; + result);// result = result * 10;result *= 10; // 3 * 10 = 30System.out.println(&quot;3 * 10 = &quot; + result);// result = result / 3;result /= 3; // 30 / 3 = 10System.out.println(&quot;30 / 3 = &quot; + result);// result = result - 2;result -= 2; // 10 - 2 = 8;System.out.println(&quot;10 - 2 = &quot; + result); if-then 陳述句(statement) if-then 是最基本的控制流陳述句，當特定值為 true 時，它告訴程式應該執行哪個區塊。 條件式邏輯(Conditonal Logic)在 Java 使用特定陳述句，讓我們當條件是 false 或 true 的時候，檢查一個條件或執行特定程式碼。 在 if 條件下，如果沒有程式碼區塊(code block)，它只會判斷後執行第一行，第二行會當成正常的程式碼運行。所以我們應該要使用程式碼區塊，程式碼區塊可以讓不只一行的程式碼運行。 1234567boolean isAlien = false;if (isAlien == true) System.out.println(&quot;It is not an alien!&quot;); System.out.println(&quot;And I am scared of aliens&quot;);------And I am scared of aliens 使用程式碼區塊可以讓 if 陳述句更清楚，而且可執行超過一行。 123456789boolean isAlien = false;if (isAlien == false) &#123; System.out.println(&quot;It is not an alien!&quot;); System.out.println(&quot;And I am scared of aliens&quot;);&#125;------It is not an alien!And I am scared of aliens 邏輯 AND 運算符 &gt;, &lt;, &gt;=, &lt;= 分別對應數學上的大於、小於、大於等於、小於等於，&amp;&amp; 雙連字號(double ampersands) 就是邏輯 AND 的意思，後面會細說單連字號(bitwise AND)和雙連字號的差別，雙連字號用在左右兩邊的表達式都是 true 的時候，該條件才成立。 123456789int topScore = 80;if (topScore &gt;= 100) &#123; System.out.println(&quot;You got the high school!&quot;);&#125;int secondTopScore = 60;if (topScore &gt; secondTopScore &amp;&amp; topScore &lt; 100) &#123; System.out.println(&quot;Greater than second top score and less than 100&quot;);&#125; 可以讓在 &amp;&amp; 的旁邊兩個表達式加上 ()，可以更清楚要判斷的條件，而且輸出結果也不會改變。 123if ((topScore &gt; secondTopScore) &amp;&amp; (topScore &lt; 100)) &#123; System.out.println(&quot;Greater than second top score and less than 100&quot;);&#125; 邏輯 OR 運算符 OR 運算符，只要左右其中一個表達式為 true，則結果為 true，基本用法和 AND 一致。 123if ((topScore &gt; 90) || (secondTopScore &lt;= 90)) &#123; System.out.println(&quot;Either or both of conditions are true&quot;);&#125; 邏輯 AND 和邏輯 OR AND 運算符在 Java 中有兩種形式，OR 也是。 &amp;&amp; 是邏輯 AND，用來執行 boolean 運算數的運算 - 檢查條件是否為 true 或 false。 &amp; 是一個位元運算符(bitwise operator)，用在位元等級的運算。 同樣地，|| 是邏輯 OR，用來執行 boolean 運算數的運算 - 檢查條件是否為 true 或 false。 同樣地，| 是一個位元運算符(bitwise operator)，用在位元等級的運算。 分配運算符和相等運算符 第一行我們宣告了 newValue int，它使用了分配運算符(=)去分配 50 給 newValue。不要在 if-then 陳述句裡面使用分配運算符，而要使用相等運算符(==)。 1234567int newValue = 50;if (newValue = 50) &#123; System.out.println(&quot;This is an error&quot;);&#125;if (newValue == 50) &#123; System.out.println(&quot;This is true&quot;);&#125; 這邊在 if 後面使用 isCar = true 是指定 isCar 變數為 true，最後會返回 true，這個 if 條件句的內容就會被執行。 1234567boolean isCar = false;if (isCar = true) &#123; System.out.println(&quot;This is not supposed to happen&quot;);&#125;------This is not supposed to happen 縮寫運算符。 12if (isCar == true)if (isCar) 12if (isCar == false)if (!isCar) NOT 運算符 ! 或 NOT 被稱為邏輯補運算符 (Logical Complement Operator) 用來與 boolean 測試它的替代值，我們看到上面 (isCar) 是 true，再變數之前加上 !，就可以檢查相反的值 false。 推薦使用縮寫運算符 (isCar) 或 (!isCar)，第一，可以避免使用分配運算符的錯誤，第二，程式碼更為簡潔。 三元運算符 (ternary operator) 三元運算符是一個捷徑，透過給予的條件，去分配兩個值中的其中一個給一個變數。它是 if-then-else 陳述句的快捷版。 12345isCar = true;boolean wasCar = isCar ? true : false;if (wasCar) &#123; System.out.println(&quot;wasCar is true;&quot;);&#125; 三元運算符的使用 第一個運算數 ageOfClient == 20：我們要檢查的條件，它必須回傳 true 或 false。 第二個運算數 true：true 是我們分配給 isEighteenOrOver 的值，如果前面的條件為 true，則為 true。 第三個運算數 false: false 是我們分配給 isEighteenOrOver 的值，如果前面的條件為 false，則為 false。 最後會回傳 true，因為 ageOfClient == 20 是 true。 最好使用 () 會更容易閱讀。可以改寫成 boolean isEighteenOrOver = (ageOfClient == 20) ? true : false; 12int ageOfClient = 20;boolean isEighteenOrOver = ageOfClient == 20 ? true : false; 運算符優先級和運算符挑戰 運算符的總表 運算符的優先級 挑戰：測試你學到的運算符 創建一個 double 變數，值為 20.00。 創建第二個 double 變數，值為 80.00。 相加以上兩個變數，並乘以 100.00。 使用餘數運算符，將第三步驟取得的值用 40.00 取得餘數，我們在這堂課用係數(modulus)或餘數運算符在整數上，但是我們也可以把餘數用在 double。 創建一個 boolean 變數，如果步驟四的餘數為 0，則為 true，如果不是 0，則為 false。 輸出這個 boolean 值。 寫一個 if-then 陳述句，如果步驟五的 boolean 值不為 true，回傳 “Got some remainder”。 答案 1234567891011double myFirstValue = 20.00d;double mySecondValue = 80.00d;double myValuesTotal = (myFirstValue + mySecondValue) * 100.00d;System.out.println(&quot;myValuesTotal = &quot; + myValuesTotal);double theRemainder = myValuesTotal % 40.00d;System.out.println(&quot;theRemainder = &quot; + theRemainder);boolean isNoRemainder = (theRemainder == 0) ? true : false;System.out.println(&quot;isNoRemainder = &quot; + isNoRemainder);if (!isNoRemainder) &#123; System.out.println(&quot;Got some remainder&quot;);&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://vincent.fishboneapps.com/tags/Java/"}]},{"title":"Java 快速學習自我挑戰 Day1","slug":"Java-快速學習自我挑戰-Day1","date":"2020-05-02T02:13:36.000Z","updated":"2021-01-25T08:23:41.568Z","comments":true,"path":"2020/05/01/Java-快速學習自我挑戰-Day1/","link":"","permalink":"https://vincent.fishboneapps.com/2020/05/01/Java-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day1/","excerpt":"","text":"課前準備 問問題的技巧 盡可能地精準的問問題：貼上程式碼，加一些畫面截圖。 問別人沒問過的問題：在問問題之前，先找找看別人有沒有問過。 成為工程師的四個階段 Unconscious Incompetence (無意識的無能)：在剛開始起步的時候，你不知道你不會什麼，所以不要做長期規劃，應該要專注在基礎上面。 Conscious Incompetence (有意識的無能)：你做一些調查，有一些基礎，知道你不會什麼，所以你意識到你需要學這些不會的技能，同時，你也意識到獲得這些技能的價值。 Conscious Competence (有意識的有能力)：在這個階段，你需要不斷讓自己沈浸在在練習之中，否則有些東西會開始遺忘，最重要的事，你學習的東西開始有意義。 Unconscious competence (無意識的有能力)：寫程式對你來說變成第二個本能，你會覺得寫程式很簡單，你寫程式的時候不需要總是過度專注，當你在寫程式的時候，你就會知道要使用哪種算法，他是自然而來的，因為你已經瞭解它了。 總結：堅持下去，許下承諾會堅持你的訓練和練習，並且定期練習和學習。 環境部署 為什麼安裝 JDK 11？ 現行版本已經到 JDK 14，但是 JDK 11 是 LTS 版本，安全性更新會持續到 2026 年，目前大公司都持續使用這個版本，下個 LTS 版本為 JDK 17，預計 2021 年 9 月發佈。 如何選擇正確的 JDK Vendor 和 JVM (Java Virtual Machine)？ Hotspot JVM 是最常用來部署的 JVM，OpenJ9 是 JVM 另外一個替代方案，OpenJ9 是開源的，佔用記憶體較少，而且比很多典型的應用還要更快。 Amazon Corretto 有免費技術支援，專注在 LTS 版本，還大量被使用在 Amazon 的生產環境服務器，而且 Amazon 把他們開發的程式碼在貢獻回去給 OpenJDK。 對學生來說，哪個版本更好？AdoptJDK 是一個不錯的選擇，因為它安裝很容易；Amazon Corretto 是另外一個不錯的選擇。 安裝 JDK (Java Development Kit) 下載 Amazon Corretto。 安裝完成之後，在命令行執行 java -version，就會跳出 Java 的版本。 安裝的路徑會在 /Library/Java/JavaVirtualMachines。 安裝 IntelliJ IDEA 下載 IntelliJ IDEA。 直接雙擊進行安裝，所有設定都用預設的。 設定 IntelliJ IDEA 進去編輯器之前，點擊右下角的 Configure -&gt; Structure for New Projects，選擇 Project Settings -&gt; Project -&gt; Project JDK -&gt; 選擇 Corretto JDK。 選擇左邊列的 Platform Settings -&gt; SDKs，將原本的 11 修改為 Corretto-11，以後有多種版本的 SDK 做切換時，名稱不會搞混，點選確認後回到選擇專案視窗。 再次點擊右下角的 Configure -&gt; Preferences -&gt; Editor -&gt; General -&gt; Auto Import，將以下兩個選項打勾 Add unambiguous imports on the fly Optimize imports on the fly (for current project) 選擇 Preferences -&gt; Editor -&gt; General -&gt; Code Folding，將以下四個選項取消勾選 General -&gt; Imports Java -&gt; One-line methods Java -&gt; “Closures” (anonymous classes implementing one method, before Java 8) Java -&gt; Generic constructor and method parameters 第一步 介紹 這個部分會做一個 Hello World 專案，並介紹 Java 關鍵字、變數、資料型態、主方法、表達式、運算符、原始型別、字符串。 Hello World 專案 選擇 Create New Project，選擇 Java，不勾選任何東西，選擇下一步，不使用任何 Template，選擇下一步，創建資料夾名稱 HelloWorld，最後選擇完成。 在 src 的資料夾按右鍵，選擇 New -&gt; Java Class，輸入 Hello 來新增 Class。 12public class Hello &#123; &#125; Java Class 的觀念 Java 的程式有關鍵字 (Keywords)，每一個都有個別的意義，而且有時候需要在特定順序下使用。 藉由使用一些特定規則、使用關鍵字組合來撰寫 Java 程式，這些組合在一起就是一個 Java 程式。 關鍵字是字母大小敏感的，public、Public 和 PUBLIC 是不一樣的。 public 和 class 是兩個 Java 關鍵字，它們有不同的意思。 public 關鍵字是存取修改器 (access modifier)，存取修改器可以讓我們定義範圍，或是哪些其它地方的程式碼或甚至其他人的程式碼可以存取這個程式碼。 現在我們使用 public 來提供完整的存取權限。 定義一個 class，class 關鍵字用來定義接下來的關鍵字 - Hello，Hello 在這個例子中用 {} 來定義 class 區塊。 所以，定義一個 class 需要有可選擇的存取修改器，接著 class，後面再接著 {}。 {} 用來定義 class 的內容，任何內容在 {} 之間的都是 class 的一部分。 定義主方法 什麼是方法(method)？ 方法是一個或多個展現功能的陳述句集合，我們會使用主方法(main method)讓 Java 在運行程式的時候會去尋找它，它是任何 Java 程式碼的入口處。 你可以創建自己的方法，但是我們先創建主方法。 1234public class Hello &#123; public static void main(String[] args) &#123; &#125;&#125; 主方法觀念 public 是一個存取修改器，在定義 class 的時候就說過了。 static 是一個需要瞭解其他概念才能解釋的 Java 關鍵字，現在，只要知道我們需要一個 static 讓 Java 找到我們這個方法，並運行我們即將添加的程式碼。 void 是另外一個 Java 關鍵字，用來表示這個方法不會回傳任何東西，後面會說更多關於 void 的事情。 方法宣告裡的 () 是一個強制、而且可選擇放入一個或多個變數，這些變數會傳進去方法裡面，後面一樣會說更多。 可以在編輯器裡面嘗試運行主方法，選擇「Run ‘Hello.main()’」 程式碼區塊 (code block) 程式碼區塊是用來定義一個程式碼區塊，在一個方法宣告裡面，它是必要的，我們會在裡面新增一些陳述句來執行一些任務。 在主方法裡面新增打印 Hello World 12345public class Hello &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello World&quot;); &#125;&#125; 陳述句 (statement) 陳述句是一個完整可被執行的命令，而且可以包含一個或多個表達式(expression)，後面都會細說。 Hello World 挑戰和常見錯誤 挑戰如何將你的名字打印出來？ 12345public class Hello &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello, Vincent&quot;); &#125;&#125; 常見錯誤 ‘;’ expected，沒有加分號 ‘)’ expected，沒有加括號 Illegal line end in string literal，字符串文字沒有對應結尾 如果執行之後出現錯誤，雙擊錯誤訊息可以直接跳到錯誤的那一行 變數 什麼是變數？ 變數是一種儲存資料在你的電腦中的一種方式，變數可以透過我們給予變數的名稱來被存取，而電腦會處理這些變數要儲存在記憶體的哪個地方。 變數，就像名稱一樣，他的內容是可變的。 我們要做的就是告知電腦我們想用變數儲存什麼類型的資料，然後給予這個變數一個名稱。 我們可以為變數定義很多資料型態，這些被稱為資料型態(data types)，我們也可以猜到，資料型態在 Java 中也是一種關鍵字。 所以，讓我們從定義 int 開始，int 是整數(integer)的縮寫，整數就是沒有任何小數點的數字。 要定義一個變數，我們必須要指定資料型態，然後給予變數名稱，我們有時候使用一個表達式來初始化帶有值的變數。 在主方法裡面定義一個 myFirstNumber int myFirstNumber = 5; 上面這一行就是一個宣告陳述句(declaration statement) 宣告陳述句透過指出資料型態、名字、有時候設定變數的值來定義一個變數。 在上面的宣告陳述句，我們定義一個 int，名字叫做 myFirstNumber，而且值被分派或是初始化為 5，所以我們在宣告一個變數為 int 型態、名字為 myFirstNumber，而且分派值為 5。 什麼是表達式(expression)？ 表達式是評估一個值的構造，我們在後面會討論更多。 挑戰：查看第一個 System.out.println 陳述句，想想看如何在下面打印出 myFirstNumber 這個變數。 12int myFirstNumber = 5;System.out.println(myFirstNumber); 在 Java 中，任何被兩個雙引號放在中間的內容，都會被當作字串符文字，他的值不像變數，是不能被改變。 System.out.println(&quot;MyFirstNumber&quot;); 也可以對變數做運算。 12int myFirstNumber = (10 + 5) + (2 * 10);System.out.println(myFirstNumber); Java 運算符(operators) Java 運算符就是利用運算符號對一個變數或值進行操作，+, -, *, / 對應加減乘除。 還有更多運算符，後面會做講解。 開始使用表達式 (expression) 挑戰：創建額外的變數，新增 mySecondNumber，它是 int 型態且指定數值為 12，另外新增 myThirdNumber，它是 int 型態且指定數值為 6。 將這些變數相加後，打印出來。 123456789101112public class Hello &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello, Vincent&quot;); int myFirstNumber = (10 + 5) + (2 * 10); int mySecondNumber = 12; int myThirdNumber = 6; int myTotal = myFirstNumber + mySecondNumber + myThirdNumber; System.out.println(myTotal); &#125;&#125; 也可以將在變數裡做其它變數的運算 123456789101112public class Hello &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello, Vincent&quot;); int myFirstNumber = (10 + 5) + (2 * 10); int mySecondNumber = 12; int myThirdNumber = myFirstNumber * 2; int myTotal = myFirstNumber + mySecondNumber + myThirdNumber; System.out.println(myTotal); &#125;&#125; 挑戰：新增一個變數 myLastOne，它是 int 型態，且希望它的值是 1000 減掉 myTotal 當前值，最後並打印出 myLastOne。 123456789101112131415public class Hello &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello, Vincent&quot;); int myFirstNumber = (10 + 5) + (2 * 10); int mySecondNumber = 12; int myThirdNumber = myFirstNumber * 2; int myTotal = myFirstNumber + mySecondNumber + myThirdNumber; System.out.println(myTotal); int myLastOne = 1000 - myTotal; System.out.println(myLastOne); &#125;&#125; 原始型態 Java 原始型態是最基本的資料型態，int 就是八個原始型態中的一個。 八個原始型態分別是，boolean，byte，char，short，int，long，float 和 double，這些就是資料操作的基本組件。 Java 套包(Java Package)是用來組織你的 Java 專案的，要把這個當成是資料夾路徑，舉例來說 com.company，就是 com 底下有一個子目錄叫做 company，就是公司網域反過來寫。所以 company.com 會變成 com.company，後面會說到更多 Package 的東西。 創建一個新的專案，這次在第二步驟的時候，把 Create project from template 打勾，專案名稱為 ByteShortIntLong，並將 base package 改為 com.company。 包裝類(Wrapper Classes)，Java 使用包裝類的概念到八種原始型態，在 int 的案例中，我們可以使用 Integer 來向 int 執行操作。在這個例子中，我們使用 MIN_VALUE 和 MAX_VALUE 讓 Java 告訴我們 Integer 可以儲存的最大和最小的範圍。 1234int myMinIntValue = Integer.MIN_VALUE;int myMaxIntValue = Integer.MAX_VALUE;System.out.println(&quot;Integer Minimum Value = &quot; + myMinIntValue);System.out.println(&quot;Integer Maximum Value = &quot; + myMaxIntValue); 我們在 myMaxIntValue 加 1，會發現打印出來是負數，這個就稱為溢位(overflow)，反過來也是一樣，但是反過來的狀況叫做不足位(underflow)，這些狀況電腦會直接跳回最小數或最大數，這通常不是我們想要的，所以要注意。 12System.out.println(&quot;Busted Max Value = &quot; + (myMaxIntValue + 1));System.out.println(&quot;Busted Min Value = &quot; + (myMinIntValue - 1)); 後面會提到其它種類型的資料型態可以儲存更多資料，所以程式設計師要知道在哪種狀況下要使用哪種資料型態。 在 Java7 版本之後，如果數字比較難以閱讀的話，可以用底線分隔開，系統一樣可以讀出來。例如：int myMaxIntText = 2_147_483_647 Byte，Short，Long 和寬度 使用和剛剛一樣的方式把 Byte 最大和最小值打印出來，通常來說，在現在電腦非常資源非常充足的情況下，使用 byte 的情況會比較少，如果考慮效能問題，這個可能是其中一個原因，它比較節省空間，速度也比較快。 1234byte myMinByteValue = Byte.MIN_VALUE;byte myMaxByteValue = Byte.MAX_VALUE;System.out.println(&quot;Byte Minimum Value = &quot; + myMinByteValue);System.out.println(&quot;Byte Maximum Value = &quot; + myMaxByteValue); 繼續用剛剛的方法，將 Short 的最大和最小值打印出來，最大值為 32767，最小值為 -32768，所以 Byte 和 Short 有相同的溢位和不足位的問題，但是它們有不同的範圍。 1234short myMinShortValue = Short.MIN_VALUE;short myMaxShortValue = Short.MAX_VALUE;System.out.println(&quot;Short Minimum Value = &quot; + myMinShortValue);System.out.println(&quot;Short Maximum Value = &quot; + myMaxShortValue); 原始型態的大小和寬度 一個 Byte 佔用 8 位元(bit)，一個位元並不是原始型態，我們有 boolean，但是它跟 Byte 完全不是同一件事情，後面會細說，所以一個 Byte 佔用 8 位元，我們可以說 byte 的寬度為 8。 short 可以儲存大量數字，佔用 16 位元，所以寬度為 16。 int 可以儲存更大量數字，佔用 32 位元，所以寬度為 32。 不同的原始型態佔用不同的記憶體大小，我們可以知道 int 跟 byte 比起來，佔用了 4 倍的記憶體。 這些數字對對你來說並不是特別相關，但是面試作為題目的時候，知道特定資料類型佔用不同的空間是有用的。 Long 佔用 64 位元，是 Int 的 2 倍，在宣告 Long 的時候，如果值比 Integer 的最大值還要大的時候，需要在值後面加上 L，否則會出現錯誤，因為 Java 會把數字當成 Integer 來處理。 12long bigLongLiteralValue = 2_147_483_647_123L;System.out.println(bigLongLiteralValue);","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://vincent.fishboneapps.com/tags/Java/"}]},{"title":"Docker 快速學習自我挑戰 II Day8","slug":"Docker-快速學習自我挑戰-II-Day8","date":"2020-03-06T08:53:37.000Z","updated":"2020-06-22T17:12:36.756Z","comments":true,"path":"2020/03/06/Docker-快速學習自我挑戰-II-Day8/","link":"","permalink":"https://vincent.fishboneapps.com/2020/03/06/Docker-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-II-Day8/","excerpt":"","text":"Service 簡介和演示 不要直接使用和管理 Pods，為什麼？ 當我們使用 ReplicaSet 或 ReplicaController 做水平擴展 Scale 的時候，Pods 有可能會被 Terminated 當我們使用 Deployment 的時候，我們去更新 Docker Image Version，舊的 Pods 會被 Terminated，新的 Pods 會被創建 創建 Service kubectl expose 命令，會給我們的 pod 創建一個 Service，供外部訪問 Service 主要有三種類型，一種叫 Cluster ip(只供 Cluster 內部訪問)，一種叫 NodePort，一種叫外部的 Loadbalancer 另外也可以使用 DNS，但是 DNS 要 add-on 接續上次的 Pods，先讓 nginx 可以被外部訪問 kubectl expose pods nginx-pod 使用 kubectl get svc 會看到 nginx-pod 的 ip 10.104.59.208 進去 minikube 的裡面，curl 10.104.59.208，會回傳 nginx 服務 新增 deployment_python_http.yml 1234567891011121314151617181920212223apiVersion: apps/v1kind: Deploymentmetadata: name: service-testspec: replicas: 2 selector: matchLabels: app: service_test_pod template: metadata: labels: app: service_test_pod spec: containers: - name: simple-http image: python:2.7 imagePullPolicy: IfNotPresent command: [&quot;/bin/bash&quot;] args: [&quot;-c&quot;, &quot;echo \\&quot;&lt;p&gt;Hello from $(hostname)&lt;/p&gt;\\&quot; &gt; index.html; python -m SimpleHTTPServer 8080&quot;] ports: - name: http containerPort: 8080 先進去機器 minikube ssh 把 python Image 先 pull 下來 docker pull python:2.7 新增 Deployment kubectl create -f deployment_python_http.yml 進去 minikube 裡面 minikube ssh，分別對兩個 Pods 的 ip 執行 curl，就會回傳不同的 hostname curl 172.17.0.6:8080 curl 172.17.0.7:8080 使用 kubectl get deployment 查看 deployment 名稱，並對外開放 kubectl expose deployment service-test 使用 kubectl get svc 會發現新增了一個 service-test，對 service-test 多次執行 curl，會發現每次返回的 hostname 都不一定一樣，也就是說，service 會自動做負載均衡 curl 10.99.229.174:8080 我們要做不停機更新，先在 minikube 裡面不停的 curl while true; do curl 10.99.229.174:8080;done 用編輯的方式進行更新，使用以下指令會跳出 Deployment 的 yml 檔案，修改 args 為 new version of helloworld，並儲存 kubectl edit deployment service-test 使用 kubectl get pods 就會看到之前兩個 Pods Terminated，而且啟動了兩個新的 Pods，但是更新過程中，還是有幾秒鐘的版本穿插的問題，因為沒有使用 Rolling Update，詳細可參考 Rolling Update 文檔 NodePort 的 Service 以及 Label 的簡單實用 首先清理環境，把所有 Services 和 Pods 都刪除 在 K8s 裡面，幾乎所有的資源都可以設置 label，label 的形式是一對 key 和 value 組成，label 不只可以設置一個 先使用之前的 pod_nginx.yml 創建資源 kubectl create -f pod_nginx.yml 將端口開放，類型設置為 NodePort kubectl expose pods nginx-pod --type=NodePort 使用 kubectl get svc 顯示 Service 的端口，再用 kubectl get node -o wide 顯示出 minikube 的 ip 地址，直接在本地瀏覽器輸入 http://192.168.99.101:32394/ 就可以訪問 nginx 服務了 先刪除 NodePort 的 Service kubectl delete service nginx-pod 可以自己手動新增 Service，首先新增一個 service_nginx.yml，target port 的設置可以使用 cat pod_nginx.yml 打開之前新增 pod 的 yml，裡面就有定義 ports name 是 nginx port，這邊的 selector 就是創建資源的 label，可以使用 kubectl get pods --show-labels 查看 labels 12345678910111213apiVersion: v1kind: Servicemetadata: name: nginx-servicespec: ports: - port: 32333 nodePort: 32333 targetPort: nginx-port protocol: TCP selector: app: nginx type: NodePort 使用 kubectl create -f service_nginx.yml 新增 Service，並使用 kubectl get svc 查看服務確實啟動，到本地瀏覽器輸入 http://192.168.99.101:33333/ 就可以訪問 nginx 服務了 新增 pod_busybox.yml 123456789101112131415apiVersion: v1kind: Podmetadata: name: busybox-pod labels: app: busyboxspec: nodeSelector: hardware: good containers: - name: busybox-container image: busybox command: - sleep - &quot;360000&quot; 使用 kubectl create -f pod_busybox.yml 創建 Pod，但是當用 kubectl get pods 查看，會看到這個 Pod 顯示 Pending，使用 kubectl get node --show-labels 查看 node 標籤會發現沒有 hardware:good 的標籤，所以才顯示 Pending 給 minikube 加上 label kubectl label node minikube hardware=good 再使用 kubectl get pods 查看就會發現 busybox 的 pod 啟動了 總結：ClusterIP 只能是內部訪問，所以它不能提供服務，我們可以透過 NodePort 去提供服務，但是會有幾個問題，(1) NodePort 的範圍只能是 30000-32767，(2) Expose 會在所有節點上提供給外部訪問，所以 NodePort 在實際的 Production 環境也不怎麼使用，但是可以用，在 Production 環境大家用的比較多的就是 Loadbalancer 或是 ExternalName，Loadbalancer 需要結合雲服務商去使用，ExternalName 就是使用 DNS 服務 kubectl 指令補全 kubectl completion zsh 更新 zsh source &lt;(kubectl completion zsh) 使用 Kops 在 DigitalOcean 上面搭建 K8s 集群 Kops Github Page：Kops 是用於 Production 級別的 K8s 安裝、升級和管理 註冊一個域名，把以下三個 NameServer 指向 DigitalOcean ns1.digitalocean.com ns2.digitalocean.com ns3.digitalocean.com 進入 DigitalOcean API 介面，申請一個 Personal access tokens 和一個 Spaces access keys 在畫面右上角點擊 Create Space，新增一個空間，這邊的空間名是全網唯一的 使用 dig 指令查看域名狀態，如果都有回傳內容，代表網域生效 dig +short pcelab.info ns dig +short pcelab.info soa 參考 DigitalOcean 文件創建 Cluster 設定參數 12345678export KOPS_STATE_STORE=do://&lt;bucket-name&gt;export DIGITALOCEAN_ACCESS_TOKEN=&lt;access-token&gt;export S3_ENDPOINT=sgp1.digitaloceanspaces.comexport S3_ACCESS_KEY_ID=&lt;access-key-id&gt;export S3_SECRET_ACCESS_KEY=&lt;secret-key&gt;export KOPS_FEATURE_FLAGS=&quot;AlphaAllowDO&quot; 使用 kops 新增 Cluster 和 Master 節點 kops create cluster --cloud=digitalocean --name=kops.pcelab.info --image=ubuntu-18-04-x64 --networking=weave --zones=sgp1 --ssh-public-key=~/.ssh/id_rsa.pub --node-size=s-1vcpu-1gb 驗證 Cluster kops validate cluster 查看 Node 是否生成 kubectl get nodes --show-labels 進入 master 去做操作 ssh -i ~/.ssh/id_rsa admin@api.kops.pcelab.info 容器的基本監控 使用 docker ps 查看 Container，再使用 docker top [Container id] 就可以查看 Container 的進程，有點類似 Linux 內建的 top 功能 docker stats 可以實時打印出後台正在運行的 Container 的系統佔用狀態，包含佔了多少內存，多少 CPU，使用 ctrl + C 可以退出 在虛擬機上面安裝 Weave Scope，並修改權限 sudo curl -L git.io/scope -o /usr/local/bin/scope sudo chmod a+x /usr/local/bin/scope 啟動 Weave Scope scope launch 192.168.205.10 啟動後的畫面如下圖，進去可以去做一些操作 也可以同時監控兩台機器，需要在兩台機器上面都輸入以下命令 scope launch [機器 1 IP] [機器 2 IP] Gitlab CI 安裝 設置一台 Ubuntu 的主機，安裝過程可以參考 Gitlab CI Runner 文檔 安裝 Docker curl -sSL https://get.docker.com | sh 安裝 Gitlab CI Runner 12curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash sudo apt-get install gitlab-ci-multi-runner -y 查看是否正常運行 sudo gitlab-ci-multi-runner status 設置 Docker 權限 123sudo usermod -aG docker gitlab-runnersudo service docker restartsudo gitlab-ci-multi-runner restart 在 Hexo 使用 Gitlab CI 註冊 gitlab-runner，tag 輸入 hexo，executor 輸入 docker sudo gitlab-ci-multi-runner register 在後台 Gitlab 專案裡面選擇 Settings &gt; CI/CD &gt; Runner 就會看到剛剛新增的 Runner，並且選擇下面的 Variables 新增 SSH_PRIVATE_KEY，將本地的 ~/.ssh/id_rsa 的內容複製到 SSH_PRIVATE_KEY 的 Value 在 Hexo 目錄新增 .gitlab-ci.yml 12345678910111213141516171819202122232425262728before_script: - &#x27;which ssh-agent || ( apt-get update -y &amp;&amp; apt-get install openssh-client -y )&#x27; - eval $(ssh-agent -s) - ssh-add &lt;(echo &quot;$SSH_PRIVATE_KEY&quot;) - mkdir -p ~/.ssh - chmod 700 ~/.ssh - ssh-keyscan -t rsa gitlab.fishboneapps.com &gt;&gt; ~/.ssh/known_hosts ## Make sure that rsync is installed - &#x27;which rsync || ( apt-get update -y &amp;&amp; apt-get install rsync -y)&#x27;stages: - buildbuild_job: stage: build tags: - hexo script: - npm -g install hexo -f --no-optional - npm cache verify - npm install -f --no-optional - hexo cl &amp;&amp; hexo g - hexo deploy - echo &quot;Deploy succssed!&quot; cache: key: $&#123;CI_BUILD_REF_NAME&#125; paths: - node_modules/ 將更新推送到 Gitlab 之後，進去專案的 CI/CD &gt; Pipelines 就可以查看進度","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://vincent.fishboneapps.com/tags/Kubernetes/"}]},{"title":"Docker 快速學習自我挑戰 II Day7","slug":"Docker-快速學習自我挑戰-II-Day7","date":"2020-03-04T06:27:55.000Z","updated":"2020-06-22T17:12:32.377Z","comments":true,"path":"2020/03/04/Docker-快速學習自我挑戰-II-Day7/","link":"","permalink":"https://vincent.fishboneapps.com/2020/03/04/Docker-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-II-Day7/","excerpt":"","text":"Docker Cloud Docker Cloud 提供容器管理，編排，部署的托管服務 Docker Cloud 的模塊 關聯雲服務 AWS、Azure 添加節點作為 Docker Host 創建服務 Service 創建 Stack Image 管理 Docker Cloud 兩種運行模式 Standard 模式：一個 Node 就是一個 Docker Host Swarm 模式：多個 Node 組成的 Swarm Cluster Docker Cloud 自動 Build Docker Image 在 Docker Hub 新增一個 Repository 並關聯到 Github 帳戶，並綁定 Repository 在 Build 頁面選擇要 build 的 Repository，其餘設定如下圖，最後選擇 Save and Build 儲存之後，Docker Cloud 會自動 build，這時候可以修改 Repository 內容和新增 Release，這些操作都會觸發 Docker Cloud 自動 build 的流程，如此一來就實現 Docker Autobuild 的功能 Docker Cloud 的 CI &amp; CD 把 Repository 下載下來之後，進行修改，並 push 到 Github 之後，再 pull request，系統會自動進行測試，測試完成之後，就可以進行 merge request(合併分支的人就可以參考測試的結果，選擇是否合併分支)，最後 Docker Cloud 會自動 build 並發佈到網站上，這樣就是一整套 CI &amp; CD Docker 企業版本地安裝 進入 Docker EE，找尋對應作業系統的頁面 我要安裝 Ubuntu 版本的，進去試用一個月填寫相關資料 使用 Vagrantfile 安裝虛擬機，因為 Docker EE 需要至少 4G 記憶體，所以記憶體設定為 4GB 123456789101112131415161718192021222324252627282930313233343536373839# -*- mode: ruby -*-# vi: set ft=ruby :Vagrant.require_version &quot;&gt;= 1.6.0&quot;boxes = [ &#123; :name =&gt; &quot;docker-ee-manager&quot;, :eth1 =&gt; &quot;192.168.205.50&quot;, :mem =&gt; &quot;4096&quot;, :cpu =&gt; &quot;1&quot; &#125;, &#123; :name =&gt; &quot;docker-ee-worker&quot;, :eth1 =&gt; &quot;192.168.205.60&quot;, :mem =&gt; &quot;4096&quot;, :cpu =&gt; &quot;1&quot; &#125;]Vagrant.configure(2) do |config| config.vm.box = &quot;ubuntu/bionic64&quot; boxes.each do |opts| config.vm.define opts[:name] do |config| config.vm.hostname = opts[:name] config.vm.provider &quot;vmware_fusion&quot; do |v| v.vmx[&quot;memsize&quot;] = opts[:mem] v.vmx[&quot;numvcpus&quot;] = opts[:cpu] end config.vm.provider &quot;virtualbox&quot; do |v| v.customize [&quot;modifyvm&quot;, :id, &quot;--memory&quot;, opts[:mem]] v.customize [&quot;modifyvm&quot;, :id, &quot;--cpus&quot;, opts[:cpu]] end config.vm.network :private_network, ip: opts[:eth1] end endend 按照文檔開始安裝 移除舊版本 Docker，因為沒有安裝，會顯示 Unable to locate sudo apt-get remove docker docker-engine docker-ce docker-ce-cli docker.io 在 Manager 和 Worker 更新套件並安裝套件 123456$ sudo apt-get update$ sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common 在 Manager 和 Worker 設置 Repository - 設置 Docker EE URL，這個 URL 會在申請一個月試用的頁面右下角取得 DOCKER_EE_URL=&quot;&lt;DOCKER-EE-URL&gt;&quot; 在 Manager 和 Worker 設置 Docker EE 版本 DOCKER_EE_VERSION=19.03 在 Manager 和 Worker 添加官方的 GPG key curl -fsSL &quot;$&#123;DOCKER_EE_URL&#125;/ubuntu/gpg&quot; | sudo apt-key add - 在 Manager 和 Worker 驗證 Key 的指紋為 DD91 1E99 5A64 A202 E859 07D6 BC14 F10B 6D08 5F96 sudo apt-key fingerprint 6D085F96 在 Manager 和 Worker 設置 Repository 1234sudo add-apt-repository \\ &quot;deb [arch=$(dpkg --print-architecture)] $DOCKER_EE_URL/ubuntu \\ $(lsb_release -cs) \\ stable-$DOCKER_EE_VERSION&quot; 在 Manager 和 Worker 安裝 Docker Engine 123sudo apt-get updatesudo apt-get install docker-ee docker-ee-cli containerd.ioapt-cache madison docker-ee 在 Manager 和 Worker 查看 Docker 版本 sudo docker version 只在 Manager 節點安裝 UCP(Universal Control Plane)，需要設置後台帳號密碼 123456docker container run --rm -it --name ucp \\ -v /var/run/docker.sock:/var/run/docker.sock \\ docker/ucp:3.2.5 install \\ --host-address &lt;node-ip-address&gt; \\ --interactive --pod-cidr 10.0.0.0/16 安裝完成之後進入 UCP 介面(https://192.168.205.50:443)，登入並上傳 License，接下來到 Node 區塊，選擇添加 node，裡面會有一串 docker-swarm 的命令，直接貼到 Worker 節點就完成連接了 最後，還可以安裝 DTR (Docker Trusted Registry)，在 UCP 左上角的介面點擊 Admin &gt; Admin Setting &gt; Docker Trusted Registry，在裡面可以選擇安裝的節點，並設置外部 ip 及把 Disable TLS Verification 打勾，就會取得指令，直接進入 Workder 節點安裝 Kubernetes 在 Kubernetes，Manager 稱之為 Master 節點，Worker 稱為 Node 節點，Master 節點對外會提供一些接口 Master 節點有一個 API Server，會向外開放接口，透過 API 可以訪問 Service，Scheduler 是一個調度模塊，會控制 Container 服務要放在哪個節點，Controller 是一個控制，Container 可以做擴展和負載均衡，假設設定 Replica=2，那麼 Controller 就會維持有兩個 Container 在運行，etcd 就是一個分佈式的儲存，主要儲存整個 K8s 的狀態和配置 Pod 就是 Container 調度裡面的最小單位，一個 pod 就是具有相同 Namespace 的 Container 組合，Namespace 可以有 User Namespace 或是 Network Namespace，但是主要是以 Network Namespace 組合為主，Docker 是創建 Pod 所使用的 Container 技術，Kubelet 會做創建 Container、Network 和 Volume 的管理，kube-proxy 用來做端口的代理和轉發，還有服務發現和負載均衡都是透過 kube-proxy 來實現的，Fluentd 主要是做日誌的採集、儲存和查詢，同時，它還有其他插件，比方說 DNS 模塊，提供 DNS 服務，UI 就是儀表板介面，可以透過網頁的方式去查看整個 K8s 的集群，還有最重要的 Image Registry，主要會從上面去拉取 Docker 的 Image 安裝 K8s 單節點的 K8s - minikube 多節點的 K8s - kubeadm 雲端版的 K8s - kops 企業版的 k8s - tectonic - 如果節點少於 10 個是免費的 k8s 的雲端實驗室 - Play with Kubernetes 先安裝 k8s 命令行，按照安裝文件操作 brew install kubectl 使用 kubectl version --client 測試 cubectl 是否安裝完成 使用 minikube start --vm-driver=virtualbox --registry-mirror=https://registry.docker-cn.com --image-mirror-country=cn --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers 創建一個單節點的 k8s Cluster 使用 kubectl config view 查看 minikube 創建的組態 使用 kubectl config get-contexts 查看 context，在本地可以用不同的 cubectl context 連接不同的 Cluster 使用 kubectl cluster-info 查看 Cluster 的狀態 使用 minikube ssh 可以進入用 minikube 創建的虛擬機器裡面 K8s 最小調度單位 Pod 我們不對 Container 做直接操作，因為 Pod 已經是最小單位了，一個 pod 裡面可以包含一個或多個 Container，一個 Pod 會共享一個 Namespace，假設在一個 pod 裡面啟動了兩個 Container，這個概念就像在本地啟動了兩個進程，Container 的通信可以直接透過 localhost 新增一個 pod_nginx.yml 1234567891011121314// 指定版本apiVersion: v1kind: Podmetadata: name: nginx labels: app: nginx// 定義的 Containerspec: containers: - name: nginx image: nginx ports: - containerPort: 80 使用 kubectl create -f pod_nginx.yml 新增 pod，使用 kubectl delete -f pod_nginx.yml 刪除 pod 使用 kubectl get pods 查看 pod 狀態，會看到有一個 nginx 的 pod 在運行 使用 kubectl get pods -o wide 查看更詳細的資訊，會有 ip 和 Node 使用 minikube ssh 就可以進去虛擬機器裡面，再用 docker ps 就可以看到裡面運行的 Contaienr 使用 docker network ls 查看網路，並查看 brige 網路 docker network inspect [Network id]，就可以看到 nginx Container 的 ip 為 172.17.0.4 使用 kubectl get pods -o wide 會發現 ip 也是 172.17.0.4 也可以直接使用 kubectl exec -it nginx sh 進入到 Container 裡面，但是如果 pod 裡面有兩個 Container 以上，它預設會進入第一個 Container，指令裡面有一個 -c 可以指定進去哪個 Container 使用 kubectl describe pods nginx 也可以查看 nginx pod 的詳細資訊，包含 ip 地址、Container、Namespace 和端口號等等 先進去 minikube 裡面 minikube ssh 使用 ping 172.17.0.4 是可以連通的，使用 curl 172.17.0.4 也會回傳 nginx 的網頁 在 minikube 裡面 ip a 查詢到 ip 為 192.168.99.101，在本地機器 ping 192.168.99.101 也會連通，使用 kubectl port-forward nginx 8080:80 將 nginx 的服務對外開放，在本地就可以用 http://127.0.0.1:8080/ 連通網站 ReplicaSet 和 ReplicaController 使用指令刪除 nginx pod kubectl delete -f pod_nginx.yml 新增 rc_nginx.yml，我們在這個 yml 文件定義了 ReplicaSet 12345678910111213141516171819apiVersion: v1kind: ReplicationControllermetadata: name: nginxspec: replicas: 3 selector: app: nginx template: metadata: name: nginx labels: app: nginx spec: containers: - name: nginx image: nginx ports: - containerPort: 80 使用 rc_nginx.yml 啟動 pod kubectl create -f rc_nginx.yml 使用 kubectl get pods 查看 pod 狀態，並刪除其中一個 Container kubectl delete pods [Container id]，再使用 kubectl get pods 會看到 Cluster 自動會再啟動一個 Container 可以透過 scale 的方式增加或減少 pods，並用 kubectl get pods 查看 pod 狀態 減少 kubectl scale rc nginx --replicas=2 增加 kubectl scale rc nginx --replicas=4 使用 kubectl get pods -o wide 查看網路狀態，在 Docker Swarm 的時候，使用 vip 解決 Container 通信問題，pods 的通信在後面說 使用 kubectl delete -f rc_nginx.yml 刪除 ReplicaController 的 pod 根據 Kubernetes ReplicaSet 文檔，ReplicaSet 是用來維持 pod 數量的 新增 rs_nginx.yml，我們在這個 yml 文件定義了 ReplicaSet 12345678910111213141516171819202122apiVersion: apps/v1kind: ReplicaSetmetadata: name: nginx labels: tier: frontendspec: replicas: 3 selector: matchLabels: tier: frontend template: metadata: name: nginx labels: tier: frontend spec: containers: - name: nginx image: nginx ports: - containerPort: 80 使用 kubectl create -f rs_nginx.yml 新增 pod Scale ReplicaSet kubectl scale rs nginx --replicas=2 Deployment 根據 Kubernetes Deployment 文檔，Deployment 為 Pods 和 ReplicaSet 提供聲明更新，如果用 Deployment 創建的 replicas，是不能個別操作或使用 delete 刪除的，一定要對 Deployment 進行操作 新增 deployment_nginx.yml，定義類型為 Deployment 123456789101112131415161718192021apiVersion: apps/v1kind: Deploymentmetadata: name: nginx-deployment labels: app: nginxspec: replicas: 3 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.12.2 ports: - containerPort: 80 透過指令創建 deployment kubectl create -f deployment_nginx.yml 使用 kubectl get deployment 查看 Deployment 啟動的狀態，使用 kubectl get rs 查看 ReplicaSet 的狀態，會發現 Deployment 會自動創建 REplicaSet，使用 kubectl get deployment -o wide 顯示更多資訊 升級 Deployment kubectl set image deployment nginx-deployment nginx=nginx:1.13 使用 kubectl get deployment -o wide 查看會發現 nginx 已升級為 1.13 使用 kubectl get rs 查看 ReplicaSet 會發現會新增一個新的 ReplicaSet，且停用舊的 ReplicaSet， 使用指令查看升級的版本 kubectl rollout history deployment nginx-deployment 使用 undo 指令回到上一個版本 kubectl rollout undo deployment nginx-deployment 使用升級指令回到最新版本 kubectl set image deployment nginx-deployment nginx=nginx:1.13 Deployment 提供一個方法可以將端口向外開放 kubectl expose deployment nginx-deployment --type=NodePort 實際上，它是創建了一個 Service，使用 kubectl get svc 查看 Service，會看到它 expose 32141 端口，那麼通過 curl 192.168.99.101:32141 就可以訪問 nginx 了 本地設定多 Cluster K8s K8s 設定多 Cluster 文檔 K8s 基礎網路 Network 新增 pod_busybox.yml 12345678910111213apiVersion: v1kind: Podmetadata: name: busybox-pod labels: app: busyboxspec: containers: - name: busybox-container image: busybox command: - sleep - &quot;360000&quot; 新增 pod_nginx.yml 12345678910111213apiVersion: v1kind: Podmetadata: name: nginx-pod labels: app: nginxspec: containers: - name: nginx-container image: nginx ports: - name: nginx-port containerPort: 80 把這兩個 pods 啟動 kubectl create -f pod_busybox.yml kubectl create -f pod_nginx.yml 查看兩個 pods 的狀態 kubectl get pods -o wide 進去 busybox 的 Shell 裡面 kubectl exec -it busybox-pod sh Ping 另外一個 pod 是可以通的 ping 172.17.0.8 關於 Cluster 跨機器的網路通信可以參考 Kubernetes Network 文檔，Kubernetes 對網路有以下三點基本要求 所有的 Container 都可以互相溝通，而且不需要 NAT 所有的 Node 都可以跟所有的 Container 互相溝通，而且不需要 NAT(反之亦然) Container 看到自己的 ip 是什麼，其他人看到它也要是相同的 ip","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://vincent.fishboneapps.com/tags/Docker/"},{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://vincent.fishboneapps.com/tags/Kubernetes/"}]},{"title":"Docker 快速學習自我挑戰 II Day6","slug":"Docker-快速學習自我挑戰-II-Day6","date":"2020-03-02T02:20:53.000Z","updated":"2020-06-22T17:12:20.057Z","comments":true,"path":"2020/03/01/Docker-快速學習自我挑戰-II-Day6/","link":"","permalink":"https://vincent.fishboneapps.com/2020/03/01/Docker-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-II-Day6/","excerpt":"","text":"容器編排 Swarm 到處使用 Container 很麻煩，為了解決這些問題，Docker Swarm 就出現了 如何管理這麼多容器？ 如何橫向擴展？ 如果容器 down 了，如何自動恢復？ 如何更新容器不影響業務？ 如何監控和追蹤這些容器？ 如何調度容器的創建？ 如何保護隱私數據？ Swarm 是集群，有集群就有節點，有節點就有角色，Swarm 總共有兩個角色，一個叫做 Manager，另一個叫做 Worker，Manager 就是大腦的角色，為了避免故障，Manager 至少要有兩個節點，但是多節點就會涉及到同步的問題，如何把 Manager A 的資料同步到 Manager B？這裡面就會用到內置的分佈式儲存的數據庫，數據是透過 Raft 協議去做的同步，Raft 能保證 Manager 之間的資料是對稱的，而 Worker 就是工作的節點，而這些工作的節點數據也是要同步的，它們會透過 Gossip network 來進行同步，這就是 Docker Swarm 的基礎架構 Services 和 Replicas，這邊的 Service 和 Docker Compose 的 Service 基本是一樣的，一個 Service 就代表一個 Container，在 Replicas 的模式下，要橫向去做擴展，一個 Replica 就是一個 Container，如下圖，我們要做 3 個 Replicas，它就會產生 3 個 Container，調度系統就會把 Container 調度到不同的 node 上面，透過一個 Swarm Manager 的節點去部署 Service 的時候，我們是不知道這些 Service 會運行在哪些 Swarm Node 上面的，這會透過 Swarm Scheduler 調度演算法去計算的，它會去看哪些 Node 負載比較輕，就會把 Container 調度到上面 Swarm 創建 Service 調度的過程，我們會在 Swarm Manager 做一些調度的決策，最後 Service 會部署在某個 Node 上面 創建一個 3 個 Nodes 的 Swarm 集群 先使用 Vagrant 創建 3 台機器 連進去第一台機器，並初始化 Docker Swarm，它就會產生讓 Worker 加入的指令 docker swarm init --advertise-addr=192.168.205.13 在每個 worker 上執行初始化所產生的指令，就可以加入 Docker Swarm docker swarm join --token SWMTKN-1-0beqcld9mv5m3w4fg1hdg3kcwqankezakxcj3k4ml0pbwq7pzj-f19znzunp0rc7kjiqfxuy4g4g 192.168.205.13:2377 在 manager 上執行 docker node ls 查看 Node 狀態，就會看到 1 個 manager，兩個 workers，Docker Swarm 就部署完畢了 Service 的創建維護和水平擴展 在 manager 上創建一個 Service docker service create --name demo busybox sh -c &quot;while true;do sleep 3600;done&quot; 使用 docker service ls 查看 Service 狀態 使用 docker service ps demo 查看 Service 運行位置 使用 docker ps 查看 container 會發現名稱是 demo 加上一堆亂數，因為 demo 是 Service 的名稱，不是 Container 的名稱 水平擴展 demo docker service scale demo=5 docker service ps demo 可以顯示所有 Container 的狀態，去個別的 Node 使用 docker ps 可以查看 Container 是否運行在對應的機器上 在 worker1 上刪除一個容器 docker rm -f 16be3f59200c，並在 manager 上執行 docker service ps 會發現 Replicas 剩下 4 個，過一下子，再執行 docker service ps 又會變回 5 個了 使用 docker service ps demo 就會看到剛剛在 worker1 刪除的 Container shutdown 了，它又在 worker2 又啟動了一個，如果 Swarm 發現有 Container 被停止了，就會立刻在任意一個節點上啟動一個 使用 docker service rm demo 可以刪除 Service，如果在節點上執行 docker ps 看到還有 Container，那是因為後台操作比較複雜，Swarm 需要看 Container 分佈在哪些 Node 上面，所以，只要稍微等一下，就會全部停止了 在 Swarm 集群通過 Service 部署 WordPress 為了要讓 Swarm 裡面的 Container 互相溝通，需要在 manager 先新增網路 docker network create -d overlay demo 在 manager 查看網路 docker network ls 會看到剛剛新增的 demo，但是去 worker1 和 worker2 會找不到這個 demo 先不管網路，先新增 mysql Service docker service create --name mysql --env MYSQL_ROOT_PASSWORD=root --env MYSQL_DATABASE=wordpress --network demo --mount type=volume,source=mysql-data,destination=/var/lib/mysql mysql:5.7 接下來，在新增 wordpress Service docker service create --name wordpress -p 80:80 --env WORDPRESS_DB_PASSWORD=root --env WORDPRESS_DB_HOST=mysql --network demo wordpress docker service ps wordpress 查看 WordPress 服務運行在哪個節點，在瀏覽器用該節點 ip 進入 WordPress 網站頁面，並進行安裝，安裝完成就確定 MySQL 和 WordPress 這兩個 Service 是可以互享訪問的 我們可以知道 WordPress Container 是在 worker2，使用 worker2 的 ip 可以訪問網站，但是使用 manager 和 worker1 的 ip 一樣也可以訪問網站，這個原因在下個章節會說明 前面提到網路的問題，在新增完 Service 之後，我們可以看到 1 個 Service 在 manager，一個在 worker1，使用 docker network ls 就會看到前面新增的 demo 網路，而在沒有 Service 的 worker2 則看不到這個網路，也就是說，Swarm 在 worker1 新增 Service 的同時，也會讓 Overlay 的網路進行同步，前面提到多 Container 通信是使用 etcd，而 Docker Swarm 是不需要使用第三方的服務，本身底層的機制就會同步網路的創建 集群服務間通訊的 Routing Mesh Docker Swarm 的 Service 之間的溝通是透過 DNS 服務來實現，Swarm 本身有 DNS 服務發現的功能，在新增 Service 的同時， Swarm 就會把 Service 的紀錄新增到 DNS 紀錄裡，我們透過 DNS 紀錄就可以知道 Service 的 ip 地址，但是 Service 的 ip 地址並不是 Container 的 ip 地址，它會有一個 vip(虛擬 ip) 地址(如果 Service 有進行 scale 的情況下， container 不一定會在哪個節點上面，某個 Container shutdown 了，Swarm 會自動在其它節點新增 Container，這時候 Container 的 ip 地址都會改變，所以如果根據 Container 的實際地址去紀錄的話，這樣是很不穩定的)，Service 分配到的 vip 地址是不會變的，但是這個不變的 ip 後面會指向的真實 ip，它會在 Service 上創建一個 Container，它是透過 LVS 去實現的 創建一個 whoami 的 Service docker service create --name whoami -p 8000:8000 --network demo -d jwilder/whoami 查看 Service 在哪個 Node 上面 docker service ps whoami 在該 Node 執行 curl 127.0.0.1:8000 就會回傳 Container id 再創建一個 busybox 的 Service docker service create --name client -d --network demo busybox:1.28 sh -c &quot;while true; do sleep 3600; done&quot; 查看 Service 在哪個 Node 上面 docker service ps client 在該 Node 上執行進入 Container docker exec -it client.1.kjw6og8khm6g8q2s8nhznrkg1 sh 我們去 ping whoami 這個 Service ping whoami，會發現是可以通的，但是會發現它 ping 的是 10.0.1.24，並不是 Container 的實際 ip 接下來，我們把 whoami 進行擴展並查看 Service 運行在哪個 Node 上面 docker service scale whoami=2 docker service ps whoami 在該 Node 查看 Container docker ps，就會發現新增的 whoami 運行在該 Node 上面 我們再次在 busybox 的 Container 上 ping whoami，發現還是可以通，而且它的 ip 還是 10.0.1.24，現在有兩個 whoami，但是只有一個名稱，到底是 ping 了哪個 Container 呢？現在的 10.0.1.24 其實不是兩個 Container 中的其中一個地址，而是一個 vip 地址 我們可以有 whoami Container Node 查詢 ip，會發現 10.0.1.24 不存在任何這兩個 Container 中 docker exec whoami.1.miy2t0q5khq02gqlg1txk1d4v ip a docker exec whoami.2.am4jalucvzl0tazkr0qnnxdho ip a 再次在 busybox 查詢 nslookup whoami，會發現回傳的地址是 10.0.1.24，使用 nslookup tasks.whoami，就會回傳 Container 的真實 ip 1234567/ # nslookup tasks.whoamiServer: 127.0.0.11Address 1: 127.0.0.11Name: tasks.whoamiAddress 1: 10.0.1.25 whoami.1.miy2t0q5khq02gqlg1txk1d4v.demoAddress 2: 10.0.1.30 whoami.2.am4jalucvzl0tazkr0qnnxdho.demo 我們可以嘗試把 whoami Service 橫向擴展，docker service scale whoami=3，在 Busybox Node 使用 nslookup tasks.whoami 就會返回 3 筆 DNS 紀錄 接下來繼續在 busybox 裡面操作 wget whoami:8000，並讀取 more index.html，查看 Container id，然後刪除 rm -rf index.html，再次操作 wget whoami:8000，並讀取 more index.html，查看 Container id，會發現 Container id 改變了，也就是說，我們每次讀取的 Container 是不同的，這些負載平衡的操作，都是透過 LVS 實現的 Routing Mesh 的兩種體現 Internal - Container 和 Container 之間的訪問透過 Overlay 網路(通過 vip 虛擬 ip)，Container 間透過 Service name 就可以訪問，如果 Service scale 的話，通過 vip 訪問會自動做負載平衡 Ingress - 如果 Service 有綁定接口，則此服務可以通過任意 Swarm 節點的相應接口訪問，下章節會更詳細的講 Internal Load Balacing 會自動透過 VIP 做負載平衡到每一個 Service 節點上 我們在 Client Container 訪問別的 Service 的時候，會先查詢 DNS，把 Service Name 解析成具體的 vip，然後會透過 Iptables 和 IPVS 來負載平衡到各個 Service 節點上 Docker Stack 部署 WordPress 查看 Docker Compose Version 3 Reference 的 deploy 的配置命令 ENDPOINT_MODE - 網路模式，默認為 vip，還有一種 dnsrr，全稱為 DNS round-robin，負載平衡用輪流的方式來進行 LABELS - 標籤 MODE - 模式，默認為 replicated，可以生成很多 Container，另一種選項為 global，只會有一個 container PLACEMENT - 可以放入一些限制和偏好設置，例如：constraints 若設置為 node.role == manager，則該 Service 只會產生在 manager 節點 REPLICAS - 複製個體，可以設定有幾個複製體 RESOURCES - 資源限制，可以優先分配 cpu 和 memory 給特定 Service RESTART_POLICY - 重啟參數，可以設置一些延遲或是最大重啟次數 UPDATE_CONFIG - 更新的時候，遵循的原則，假設我設定 parallelism: 2，那麼更新一次可以更新兩個 Replicas，設置 delay: 10s，每次更新的延遲就為 10 秒，也就是說要等第一個更新完成後 10 秒才能更第二個 前面用過 Docker Compose 在本地部署 WordPress，現在要把 WordPress 部署到 Docker Swarm 裡面，將之前的 docker-compose.yml 檔案進行修改，首先要修改網路為 Overlay，然後 Service 部分加上一些 deploy 的參數 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647version: &#x27;3&#x27;services: web: image: wordpress ports: - 8080:80 environment: WORDPRESS_DB_HOST: mysql WORDPRESS_DB_PASSWORD: root networks: - my-network depends_on: - mysql deploy: mode: replicated replicas: 3 restart_policy: condition: on-failure delay: 5s max_attempts: 3 update_config: parallelism: 1 delay: 10s mysql: image: mysql:5.7 environment: MYSQL_ROOT_PASSWORD: root MYSQL_DATABASE: wordpress volumes: - mysql-data:/var/lib/mysql networks: - my-network deploy: mode: global placement: constraints: - node.role == managervolumes: mysql-data:networks: my-network: driver: overlay 利用 docker-compose.yml 啟動 Stack docker stack deploy wordpress --compose-file=docker-compose.yml 可以利用 docker stack ls，docker stack services wordpress 和 docker stack ps wordpress 查看 Stack 裡面 Service 部署的情況 打開瀏覽器進入任何一台虛擬機的 ip，都可以開啟 WordPress 的服務，確認安裝完成之後，就可以用 docker stack rm wordpress 把 Stack 刪除 Docker Secret 的管理和使用 MySQL 的密碼屬於敏感資訊，在 Production 的情況下，要避免直接放在 docker-compose 裡面，所以就需要 Docker Secret 什麼是 Secret？ 用戶名密碼 SSH Key TLS 認證 任何不想被看到的數據 在 Manager 節點會有基於 Raft 的分布式儲存，它能讓 Manager 之間的節點同步，而且存在內置的分佈式儲存的數據是加密的，Manager 和 Worker 之間的通信也通過 TLS 加密，像是 Private Key 也都加密過後存在 Manager 節點的硬碟上的 Secret Management 存在 Manager 節點 Raft 資料庫裡 Secret 可以指定給一個 Service，這個 Service 就能看到這個 Secret 在 Container 內部 Secret 看起來像是文件，但實際是在記憶體中 在 Manager 節點新增一個檔案 vim password 並輸入 admin123，再將此檔案新增為 Secret Key docker secret create my-pw password 使用 docker secret ls 就可以看到剛剛新增的 Key 了 上面的方法是用檔案新增 Key，也可以透過直接在指令回傳密碼的方式新增 echo &quot;adminadmin&quot; | docker secret create my-pw2 - 可以使用 docker secret ls 就可以查看到有兩個密碼了，也可以用 docker secret rm my-pw 刪除不要的密碼 可以直接在新增 Service 的時候把 key 加上去 docker service create --name client --secret my-pw2 busybox sh -c &quot;while true; do sleep 3600; done&quot; 我們可以直接進去 Service 查看密碼，就會在 /run/secrets/ 目錄下看到原始的密碼 docker exec -it client.1.k88i6xpjbtq34jk5vodnmxgby sh cat /run/secrets/my-pw2 透過 Secret Key 創建 MySQL docker service create --name db --secret my-pw2 -e MYSQL_ROOT_PASSWORD_FILE=/run/secrets/my-pw2 mysql 找到 MySQL 所在的 Node 進入 MySQL 裡面 docker exec -it db.1.ygxjss26mnd4bj3t1w46xeop7 sh 確認 Secret Key 是否存在 ls /run/secrets 嘗試使用 Secret Key 登入 MySQL，可以成功登入，證明 Secret Key 生效了 mysql -u root -p Docker Secret 在 Stack 中的使用 修改 docker-compose.yml 的 Secret Key 對應部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455version: &#x27;3.1&#x27;services: web: image: wordpress ports: - 8080:80 secrets: - my-pw2 environment: WORDPRESS_DB_HOST: mysql WORDPRESS_DB_PASSWORD_FILE: /run/secrets/my-pw2 networks: - my-network depends_on: - mysql deploy: mode: replicated replicas: 3 restart_policy: condition: on-failure delay: 5s max_attempts: 3 update_config: parallelism: 1 delay: 10s mysql: image: mysql:5.7 secrets: - my-pw2 environment: MYSQL_ROOT_PASSWORD_FILE: /run/secrets/my-pw2 MYSQL_DATABASE: wordpress volumes: - mysql-data:/var/lib/mysql networks: - my-network deploy: mode: global placement: constraints: - node.role == managervolumes: mysql-data:networks: my-network: driver: overlaysecrets: my-pw2: external: true 啟動 WordPress 的 Stack docker service deploy wordpress -c=docker-compose.yml 可以查看 Stack Service 狀態 docker stack services wordpress 打開瀏覽器，安裝 WordPress 確定網站正常運行 Service 更新 在運行狀態下更新 Service，而 Service 是運行在 Production 環境下面的，在更新狀態下，我們要避免服務停止 首先，新增一個 demo 的 Overlay 網路 docker network create -d overlay demo 新建一個 web 的 Service docker service create --name web --publish 80:5000 --network demo fishboneapps/python-hello-world:1.0 啟動完成之後，先進行 Scale docker service scale web=2 查看 Service 狀態 docker service ps web 檢查一下現在的服務狀態，會看到現在顯示 Hello Docker, Version 1.0 curl 127.0.0.1 在 Worker1 上進行循環 curl，讓我們查看在更新的過程中，服務是否中斷 sh -c &quot;while true; do curl 127.0.0.1&amp;sleep 1; done&quot; 使用 docker service update 進行更新，可以更新 Secret Key、Publish Port 和 Image 等等 docker service update --image fishboneapps/python-hello-world:2.0 web 會發現在 Workder1 上面的 curl 會自動跳成 2.0，且服務沒有中斷，這時候可以透過 docker service ps web 查看到服務更新的過程 測試更新 Service 端口，更新端口業務一定會中斷，因為訪問都是透過 vip + 端口去實現的，如果端口改變了，vip 的端口也會改變 docker service update --publish-rm 80:5000 --publish-add 8080:5000 web Docker Stack 沒有更新的功能，只需要修改 docker-compose.yml，然後一樣執行 deploy 就會完成更新，流程跟 Service 一樣，docker-compose.yml 會有 update_config 的參數，它會依據這個 config 進行更新","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://vincent.fishboneapps.com/tags/Docker/"}]},{"title":"Docker 快速學習自我挑戰 II Day5","slug":"Docker-快速學習自我挑戰-II-Day5","date":"2020-03-01T08:06:04.000Z","updated":"2020-06-22T17:12:20.057Z","comments":true,"path":"2020/03/01/Docker-快速學習自我挑戰-II-Day5/","link":"","permalink":"https://vincent.fishboneapps.com/2020/03/01/Docker-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-II-Day5/","excerpt":"","text":"Docker 的數據持久化和數據共享 Container 是在 Image 之上去創建的，Container 可以讀寫數據，而 Image 只能夠讀取，但是 Container 裡面所寫入的數據，只會存在 Container 裡面，如果刪除 Container，寫入的數據會全部消失。但是有一種需求，資料庫的 Container 會有數據的讀寫，在這種情況下，Docker 就需要數據持久化。 Container 裡面會有一個 Program，把檔案寫入 File System，這些檔案會存在 Container 的 Layer 中，我們把數據的部分，額外 Mount 一個 Volume，這樣一來，數據就會被永久保存。 Docker 持久化數據的方案 基於本地文件系統的 Volume。可以在執行 docker create 或是 docker run 的時，通過 -v 參數將主機目錄作為 Container 的 Volume，這部分功能便是基於本地系統的 Volume 管理。 基於外掛的 Volume。支持第三方的儲存方案，例如：AWS。 Volume 類型 受管理的 Data Volume，由 Docker 後台自動創建。 綁定掛載的 Volume，具體掛載位置可由用戶指定。 安裝 Vagrant Plugin 列出所有外掛 vagrant plugin list 安裝 vagrant scp vagrant plugin install vagrant-scp 把本地資料複製到虛擬機裡面 vagrant scp labs/ docker_node1:/home/vagrant/labs/ 數據持久化 Data Volume MySQL Docker file 裡面有一行，VOLUME /var/lib/mysql 就是將數據存到虛擬主機的目錄，實現數據持久化，讓數據不會因為 Container 消失而消失 創建一個 MySQL 的 Container，並使用沒有密碼的環境變數 docker run -d --name mysql1 -e MYSQL_ALLOW_EMPTY_PASSWORD mysql 這時候用 docker ps 查看 Container 會發現 mysql1 沒有啟動成功，使用 docker logs mysql1 查看，就會顯示要指定 MYSQL_ROOT_PASSWORD 123452020-03-01 02:36:05+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.19-1debian9 started.2020-03-01 02:36:05+00:00 [Note] [Entrypoint]: Switching to dedicated user &#x27;mysql&#x27;2020-03-01 02:36:05+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.19-1debian9 started.2020-03-01 02:36:06+00:00 [ERROR] [Entrypoint]: Database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD 在創建 MySQL container 的同時，也會新增一個 Volume，要將該 Volume 移除 docker rm mysql1 docker volume ls docker volume rm [Volume id] 再次創建一個 MySQL 的 Container docker run -d --name mysql1 -e MYSQL_ALLOW_EMPTY_PASSWORD=true mysql 這時候我們可以去查看新增的 Volume 的細節，裡面就會看到這個 Volume 連結到本地的 /var/lib/docker/volumes/[Volume id]/_data 這個位置 docker volume ls docker volume inspect [Volume id] 我們在創建第二個 MySQL 的 Container docker run -d --name mysql2 -e MYSQL_ALLOW_EMPTY_PASSWORD=true mysql 這時候再 docker volume ls，就會發現新增了一個新增的 Volume 把 Container 停止並刪除，再查看 Container 狀態就會發現沒有任何退出或在執行的 Container 了 docker stop mysql1 mysql2 docker rm mysql1 mysql2 docker ps -a 使用 docker volume ls 查看 Volume，之前新增的都還在，但是會發現命名太複雜，我們可以自定義 Volume 名稱，先把所有的 volume 移除 docker volume rm [volume1 id] [volume2 id] 創建一個 MySQL 的 Container 並指定 Volume 名稱為 mysql，路徑為 /var/lib/mysql docker run -d -v mysql:/var/lib/mysql --name mysql1 -e MYSQL_ALLOW_EMPTY_PASSWORD=true mysql 使用 docker volume ls 查看 Volume，就會看到新增的 mysql Volume 為了驗證 MySQL 的數據持久，我們進去 mysql1 的 Container 新增一個新的 database 123456docker exec -it mysql1 /bin/bashmysql -u rootshow databases;create database docker;exit;exit 停止並刪除 Container docker rm -f mysql1 創建一個新的 MySQL 的 Container，並連結到之前的 Volume docker run -d -v mysql:/var/lib/mysql --name mysql2 -e MYSQL_ALLOW_EMPTY_PASSWORD=true mysql 進去 mysql2 的 Container 查看 databases，會發現之前新增的 Database 還存在 123docker exec -it mysql2 /bin/bashmysql -u rootshow databases; 數據持久化 Bind Mounting Bind Mounting 就是做映射 docker run -v /home/aaa:/root/aaa ，可以將本地目錄和 Container 目錄做映射，如果本地目錄修改， Container 的數據內容也會修改，反之亦然 新增一個 Dockerfile 123456789101112# this same shows how we can extend/change an existing official image from Docker HubFROM nginx:latest# highly recommend you always pin versions for anything beyond dev/learnWORKDIR /usr/share/nginx/html# change working directory to root of nginx webhost# using WORKDIR is prefered to using &#x27;RUN cd /some/path&#x27;COPY index.html index.html# I don&#x27;t have to specify EXPOSE or CMD because they&#x27;re in my FROM 在同一個目錄新增 index.html 12345678910111213&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello Docker! &lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 將 Dockerfile 封裝成 Image docker build -t fishboneapps/nginx-volume-test . 創建一個新的 Container docker run -d -p 80:80 --name web fishboneapps/nginx-volume-test 這時候執行 curl 指令，就會得到 nginx 服務器回傳的 index.html curl 127.0.0.1 這時候移除 web Container docker rm -f web 再新增一個 Container 將虛擬機目錄映射到 nginx 的默認目錄 docker run -d -p 80:80 -v $(pwd):/usr/share/nginx/html --name web fishboneapps/nginx-volume-test 進入 web Container 就會發現虛擬機目錄裡面的 Dockerfile 出現在裡面，再新增一個 test.txt 1234docker exec -it web /bin/bashlstouch test.txtexit 在虛擬機的目錄 ls 就會發現剛剛在 container 裡面新增的 test.txt 存在該目錄，也就是說這兩個目錄是同步的 在本地機器的 Vagrant 目錄也會出現 test.txt，因為 Vagrant 目錄與虛擬機目錄也用同樣的方式進行同步 開發者利器 Docker + Bind Mounting 開啟一個 flask 服務的 Container docker run -d -p 80:5000 -v $(pwd):/skeleton --name flask fishboneapps/flask-skeleton 這時候透過本地的瀏覽器就可以讀取頁面(看 Vagrantfile 設置的 ip)，我使用的是 192.168.205.12 http://192.168.205.12/ 隨便打開檔案進行修改，就會發現網站會跟著變動 根據前面所學部署一個 WordPress 新增一個 MySQL 的 Container docker run -d --name mysql -v mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=wordpress mysql:5.7 新增一個 WordPress 的 Container docker run -d -e WORDPRESS_DB_HOST=mysql:3306 --link mysql -p 8080:80 wordpress 透過本地的瀏覽器就可以讀取頁面，就會看到 WordPress 的網站了 但是透過這種方式來建立 docker 的服務，會很繁瑣，而且管理也較為複雜，我們想把這些整合成一個 group，Docker Compose 就是為了解決這個問題而誕生了 Docker Compose 是什麼 多 Container 的 App 太麻煩 要 docker build image 或是從 Docker Hub pull Image 要創建多個 container 要管理這些 container (啟動和刪除) Docker Compose 是什麼 Docker Compose 是一個工具(基於 Docker 的命令列工具) 這個工具可以透過 YAML 定義多 Container 的 Docker 應用 通過一條命令就可以根據 YAML 文件的定義去創建或管理多個 Container 默認文件：docker-compose.yml，三大概念：Services, Networks, Volumes Services 一個 Service 代表一個 Container，這個 Container 可以從 Docker Hub Image 來創建，或是從本地的 Dockerfile build 出來的 Image 來創建 Services 的啟動類似 docker run，我們可以給其指定 Network 和 Volume。 以下用 docker-compose 的 service 和 docker run 產生同樣的容器 12345678910# Docker Composeservices: db: image: postgres:9.4 volumes: - &quot;db-data:/var/lib/postgresql/data&quot; networks: - back-tier# docker run&gt; docker run -d --network back-tier -v db-data:/var/lib/postgresql/data postgres:9.4 Volumes 和 Networks 在跟 services 一樣的級別底下會有 volumes 和 networks 12345678910111213# Docker Composevolumes: db-datanetworks: front-tier: driver: bridge back-tier: driver: bridge# docker volume 和 docker network&gt; docker volume create db-data&gt; docker network create -d bridge back-tier 新增一個 WordPress 的 docker-compose.yml 12345678910111213141516171819202122232425262728293031# docker-compose 版本version: &#x27;3&#x27;services: wordpress: image: wordpress ports: - 8080:80 environment: WORDPRESS_DB_HOST: mysql WORDPRESS_DB_PASSWORD: root networks: - my-bridge mysql: image: mysql:5.7 environment: MYSQL_ROOT_PASSWORD: root MYSQL_DATABASE: wordpress volumes: - mysql-data:/var/lib/mysql networks: - my-bridgevolumes: mysql-data:networks: my-bridge: driver: bridge 使用 docker-compose.yml 在虛擬機上安裝 docker-compose，按照官方文件進行安裝 1234# 下載 Docker Composesudo curl -L &quot;https://github.com/docker/compose/releases/download/1.25.4/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose# 給予權限sudo chmod +x /usr/local/bin/docker-compose 在剛剛建立 wordpress.yml 的資料夾啟動 Container，這邊的 -f 預設就是 docker-compose.yml，可以不填 docker-compose -f docker-compose.yml up 如果執行 docker-compose up 之後再使用 Command + C 退出會直接停止服務，所以可以讓指令在後台執行 docker-compose up -d，如果想要 debug 看 log，才會使用 docker-compose up docker-composer 相關指令 docker-compose stop 會停止服務 docker-compose down 會刪除所有服務(包含 Cotainers, Images, Volumes 和 Networks) docker-compose start 可以啟動服務 docker-compose ps 查看服務狀態 docker-compose images 查看所有 Images docker-compose exec 對 Container 執行指令 docker-compose exec 和 docker exec 基本上是一樣的，執行以下指令可以直接進去 Container 裡 docker-compose exec mysql bash docker-compose exec wordpress bash 將 wordpress 服務停止並刪除 docker-compose down 新增 docker-compose.yml 123456789101112131415version: &quot;3&quot;services: redis: image: redis web: build: context: . dockerfile: Dockerfile ports: - 8080:5000 environment: REDIS_HOST: redis 新增 Dockerfile 1234567FROM python:2.7LABEL maintaner=&quot;vincent@fishboneapps.com&quot;COPY . /appWORKDIR /appRUN pip install flask redisEXPOSE 5000CMD [ &quot;python&quot;, &quot;app.py&quot; ] 新增 app.py 1234567891011121314151617from flask import Flaskfrom redis import Redisimport osimport socketapp = Flask(__name__)redis = Redis(host=os.environ.get(&#x27;REDIS_HOST&#x27;, &#x27;127.0.0.1&#x27;), port=6379)@app.route(&#x27;/&#x27;)def hello(): redis.incr(&#x27;hits&#x27;) return &#x27;Hello Container World! I have been seen %s times and my hostname is %s.\\n&#x27; % (redis.get(&#x27;hits&#x27;),socket.gethostname())if __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, port=5000, debug=True) 使用 docker-compose up 就可以啟動服務了，這時候打開本地的瀏覽器就可以看到 flask 的頁面了 水平擴展和附載均衡 用 docker-compose 的 --scale 啟動三個 web，但是會出現錯誤，會顯示 8080 已被佔用 docker-compose up --scale= web=3 -d 修改 docker-compose.yml 把 port 刪除 12345678910111213version: &quot;3&quot;services: redis: image: redis web: build: context: . dockerfile: Dockerfile environment: REDIS_HOST: redis 這時候在分別執行以下命令，Container 就會被啟動 docker-compose up -d docker-compose up --scale web=3 -d 關閉所有的 Contaienr docker-compose down 修改 docker-compose.yml，加上 loadbalancer 12345678910111213141516171819202122version: &quot;3&quot;services: redis: image: redis web: build: context: . dockerfile: Dockerfile environment: REDIS_HOST: redis lb: image: dockercloud/haproxy links: - web ports: - 8080:80 volumes: - /var/run/docker.sock:/var/run/docker.sock 啟動 docker-compose docker-compose up -d 把網頁內容讀取出來 curl 127.0.0.1:8080 會返回 Container 的 id Hello Container World! I have been seen 1 times and my hostname is 5620b14f864a. 然後把 web 服務擴展成 3 個 docker-compose up --scale web=3 -d 再把網頁內容讀出來，會發現有 3 個 Container id 會輪流出現 12345678Hello Container World! I have been seen 2 times and my hostname is 5620b14f864a.Hello Container World! I have been seen 3 times and my hostname is 923de444e90d.Hello Container World! I have been seen 4 times and my hostname is 1fde842de3f1.Hello Container World! I have been seen 5 times and my hostname is 5620b14f864a.Hello Container World! I have been seen 6 times and my hostname is 923de444e90d.Hello Container World! I have been seen 7 times and my hostname is 1fde842de3f1.Hello Container World! I have been seen 8 times and my hostname is 5620b14f864a.Hello Container World! I have been seen 9 times and my hostname is 923de444e90d. 我們也可以把服務擴展成 5 台 docker-compose up --scale web=5 -d 這時候直接 curl 10 次 for i in `seq 10`; do curl 127.0.0.1:8080; done 12345678910Hello Container World! I have been seen 10 times and my hostname is 5620b14f864a.Hello Container World! I have been seen 11 times and my hostname is 923de444e90d.Hello Container World! I have been seen 12 times and my hostname is 1fde842de3f1.Hello Container World! I have been seen 13 times and my hostname is 37c3b132c4bd.Hello Container World! I have been seen 14 times and my hostname is c2e3df63ddec.Hello Container World! I have been seen 15 times and my hostname is 5620b14f864a.Hello Container World! I have been seen 16 times and my hostname is 923de444e90d.Hello Container World! I have been seen 17 times and my hostname is 1fde842de3f1.Hello Container World! I have been seen 18 times and my hostname is 37c3b132c4bd.Hello Container World! I have been seen 19 times and my hostname is c2e3df63ddec. 同樣地，也可以減少擴展 docker-compose up --scale web=3 -d Docker Compose 是用於本地開發的一個工具，並不適合用於 Production，它就是為了方便在本地看部署的結果","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://vincent.fishboneapps.com/tags/Docker/"}]},{"title":"Docker 快速學習自我挑戰 II Day4","slug":"Docker-快速學習自我挑戰-II-Day4","date":"2020-02-28T07:09:54.000Z","updated":"2020-06-22T17:12:20.057Z","comments":true,"path":"2020/02/28/Docker-快速學習自我挑戰-II-Day4/","link":"","permalink":"https://vincent.fishboneapps.com/2020/02/28/Docker-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-II-Day4/","excerpt":"","text":"Docker 網路簡介 Docker 網路 單機：Bridge Network / Host Network / None Network 多機：Overlay Network 用 Vagrant 開啟兩台機器，新增 Vagrantfile 網路基本概念 如果要跟 Web 服務器通訊，流程是，打開瀏覽器，取得服務器內容，這個過程使用的是 HTTP 協議。 傳輸網站數據，就需要理解網路的分層，TCP/IP 協議如下圖，傳輸層(Transport Layer)裡面，TCP 協議是可靠的協議，而 UDP 協議是不可靠的，而 HTTP 協議就屬於應用層(Application Layer)，主要是用來傳輸數據的。 路由基本就像是交通一樣，他會選一條路徑進行資料傳輸。 Public IP 和 Private IP Public IP：全球資訊網裡的唯一標示，可以訪問。 Private IP：不可以在全球資訊網裡面使用，僅供內部企業使用。 網路轉換地址 NAT：NAT 會記住內部地址和端口號，並轉換成外部地址和端口號才將數據傳送到全球資訊網，然後在全球資訊網的查詢結果，會返回到 NAT，NAT 會再將外部地址和端口號轉換回內部地址和端口號，並將數據回傳給該電腦。 Ping 和 Telnet ping：ping 使用的是 ICMP 協議，可以驗證 IP 的可達性，但是如果沒有回應，並不一定是該 ip 的機器沒有啟動，有可能機器有防火牆或是其他路由器的原因。 telnet：檢查服務的可用性。 安裝 Wireshark，可以查看網路數據包。 Linux 網路命名空間 進入 node1 執行以下命令 docker run -d --name=test1 busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot; 進入 busybox docker exec -it test1 /bin/sh 在 busybox 裡面執行 ip a，會看到容器有自己的 ip 新增一個新容器 docker run -d --name=test2 busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot; 執行 docker exec test2 ip a，就會發現容器 test2 有自己的 ip，而且 test1 和 test2 可以互相 ping 通的。 Linux Namespace 實作 查看 Namespace 列表 sudo ip netns list 刪除 Namespace sudo ip netns delete test1 新增 Namespace sudo ip netns add test1 查看 Namespace ip，查看之後會發現，(1) 它沒有 ip 地址。(2) 它的狀態是 DOWN 的，沒有運行起來。 sudo ip netns exec test1 ip a 把 test1 啟動 sudo ip netns exec test1 ip link set dev lo up 透過以下指令查看會發現 mode 變成 unknown，因為只有單一端口是沒有辦法啟動的 sudo ip netns exec test1 ip link 新增一個可以連線的虛擬連線與端口 sudo ip link add veth-test1 type veth peer name veth-test2 透過 ip link 查看端口就會發現新增了兩個端口，但是狀態都是 DOWN 且沒有 ip 地址 12349: veth-test2@veth-test1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/ether 6e:4f:90:eb:c8:a8 brd ff:ff:ff:ff:ff:ff10: veth-test1@veth-test2: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000 link/ether be:85:ba:89:b9:08 brd ff:ff:ff:ff:ff:ff 將 veth-test1 添加到 test1 的 Namespace 裡 sudo ip link set veth-test1 netns test1 查看 test1 的 Namespace 端口就會發現 10 號端口被加上去 sudo ip netns exec test1 ip link 在本地查看 ip link，就會發現 10 不見了，因為已經添加到 test1 的 Namespace 裡面 把端口也加到 test2，查看後就會發現 9 被添加到 test2 的 Namespace 裡面 sudo ip link set veth-test2 netns test2 sudo ip netns exec test2 ip link 將 ip 分配給端口 sudo ip netns exec test1 ip addr add 192.168.1.1/24 dev veth-test1 sudo ip netns exec test2 ip addr add 192.168.1.2/24 dev veth-test2 啟動端口 sudo ip netns exec test1 ip link set dev veth-test1 up sudo ip netns exec test2 ip link set dev veth-test2 up 執行以下命令，就會看到 ip sudo ip netns exec test1 ip a 透過以下指令，可以互 ping 機器 sudo ip netns exec test1 ping 192.168.1.2 sudo ip netns exec test2 ping 192.168.1.1 以上就是容器互通的原理，用 linux Namespace 的方式進行實現 Docker bridge0 詳解 停止 test2 容器並刪除 docker stop test2 docker rm test2 列出 docker 機器的網路 docker network ls 查看 bridge 網路的內容，會發現裡面有一項是 containers，而 container 正是 test1，就會知道 test1 的網路正是連接到這個 bridge docker network inspect c6e6281b109f 使用 ip a 查看虛擬機的網路列表，會輸出以下內容，裡面可以看到虛擬機的 docker0 接口用 veth 連線到容器裡面的網路 123456789104: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:80:06:0b:9a brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80::42:80ff:fe06:b9a/64 scope link valid_lft forever preferred_lft forever6: veth25ca999@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default link/ether ee:18:e0:2f:0c:56 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet6 fe80::ec18:e0ff:fe2f:c56/64 scope link valid_lft forever preferred_lft forever 使用 docker exec test1 ip a 列出 test1 容器的網路，會輸出以下內容，會發現 eth0 是和上面的 veth25ca999 連在一起的 123456781: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever5: eth0@if6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever 安裝 Bridge-utils 驗證連線 sudo apt-get install -y bridge-utils 在虛擬機使用 brctl show，就會看到 docker0 是和 veth25ca999 連接的 再開啟一個 test2 的容器 docker run -d --name=test2 busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot; 再次檢查 bridge 的網路，就會發現多一個 test2 的容器 docker network inspect bridge 這時候再執行一次 ip a，就會發現多一個 veth，因為多一個容器，就需要多一條線進行連接 12345678910111213144: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:80:06:0b:9a brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80::42:80ff:fe06:b9a/64 scope link valid_lft forever preferred_lft forever6: veth25ca999@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default link/ether ee:18:e0:2f:0c:56 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet6 fe80::ec18:e0ff:fe2f:c56/64 scope link valid_lft forever preferred_lft forever10: veth93b61b7@if9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default link/ether ea:ed:e9:82:86:dc brd ff:ff:ff:ff:ff:ff link-netnsid 1 inet6 fe80::e8ed:e9ff:fe82:86dc/64 scope link valid_lft forever preferred_lft forever 再次執行 brctl show，就會發現 docker0 連接兩個 veth bridge name bridge id STP enabled interfaces docker0 8000.024280060b9a no veth25ca999 veth93b61b7 以下圖片解釋 (1) 容器之間如何互相溝通 (2) 容器如何連接到外網 容器之間的 Link 停止 test2 容器並刪除 docker stop test2 docker rm test2 再次創建 test2 容器並 link 到 test1，使用 --link 就是新增 dns 紀錄 docker run -d --name=test2 --link=test1 busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot; 進去 test2 裡面執行命令 docker exec -it test2 /bin/sh 使用 ping test1，會發現可以 ping 到容器 test1 link 是有方向性的，因為只在 test2 link 到 test1，所以可以在 test2 容器 ping test1 容器，但是在 test1 上面是沒有辦法直接用 ping test2 來 ping 到 test2 容器的 再次停止 test2 容器並刪除，再次創建 test2，但是不要 link docker stop test2 docker rm test2 docker run -d --name=test2 busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot; 自己新增一個 Bridge docker network create -d bridge my-bridge 用 docker network ls 就可以查看新增的 bridge 用 brctl show 查看，就可以看到新增的 bridge 新增 test3 容器，並連接到新增的 bridge docker run -d --name=test3 --network my-bridge busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot; 用 brctl show 查看，就會看到新增的 bridge 連接到 test3 容器上 也可以用 docker network inspect my-bridge 查看新增的 bridge 連接到 test3 容器上 可以將已存在的容器連接到新增的 bridge 上面 docker network connect my-bridge test2 再用 docker network inspect my-bridge 查看新增的 bridge 也已連接到 test2 容器上 進去 test3 容器執行命令 docker exec -it test3 /bin/sh 在 test3 容器直接 ping test2，但是沒有使用 link，還是可以 ping 通，因為默認自己新增的 bridge 上的容器會自動 link ping test2 再進入 test2 容器執行命令 docker exec -it test2 /bin/sh 嘗試 ping test3 可以通，但是 ping test1 就不能通了，因為默認自己新增的 bridge 上的容器會自動 link 將 test1 連接到 my-bridge，再進去 test2 容器，ping test1 就可以通了。 docker network connect my-bridge test1 docker exec -it test2 /bin/sh ping test1 容器端口映射 新增一個 nginx 的容器 docker run --name web -d nginx 查看 web 的 ip 地址 docker network inspect bridge ping web 的容器，會發現在虛擬主機上是可以 ping 通的 ping 172.17.0.4 使用 telnet 測試網站是否可以連線，發現也可以連線 telnet 172.17.0.4 80 使用 curl 也可以把 html 頁面顯示出來，這樣就可以知道可以訪問 web 容器的 80 服務 curl http://172.17.0.4 先把 web 容器停止並刪除 docker stop web docker rm web 新增 web 容器，並把容器的 80 port 映射到虛擬主機的 80 port docker run --name web -d -p 80:80 nginx 在虛擬主機上 curl 127.0.0.1，就會出現 html 頁面 容器網路的 host 和 none none 新增 test1 容器並將網路連接到 none docker run -d --name=test1 --network none busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot; 查看 none，會發現 none 連接到 test1 容器，而它沒有 MAC 地址和 ip 地址 docker network inspect none 進去 test1 容器查看 ip，會發現除了 localhost 沒有其他網路接口，所以除了使用 exec 的方式，其它方法都不能訪問到這個容器 docker exec -it test1 ip a 基本上不會用到 none 這個網路，這個網路可能是用來放置一些安全性較高的密碼，只能透過本地進行訪問。 host 停止並刪除 test1，再新增一個 test1 容器並將網路連接到 host docker stop test1 docker rm test1 docker run -d --name=test1 --network host busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot; 查看 host，會發現 host 連接到 test1 容器，而它一樣沒有 MAC 地址和 ip 地址 docker network inspect host 進去 test1 容器查看 ip，會發現裡面的接口會和虛擬主機的網路配置一樣 docker exec -it test1 ip a host 網路會跟虛擬主機上的網路共享一個網路，這種方式創建的容器，端口可能會有衝突 多容器複雜應用的部署 建立一個 redis 容器，這邊不使用 -p 6379:6379，因為 redis 不需要被外界訪問 docker run -d --name redis redis 將根目錄下的文件進行打包 docker build -t fishboneapps/flask-redis . 將 image 啟動成容器 docker run -d --link redis --name flask-redis -e REDIS_HOST=redis fishboneapps/flash-redis 進去 flask-redis 容器查看環境變量，就會發現裡面有 REDIS_HOST=redis，這樣一來就可以直接 ping redis 容器 docker exec -it flask-redis /bin/bash env ping redis 在容器裡面就可以直接執行 flask 的網頁 curl 127.0.0.1:5000 因為 5000 端口沒有映射到虛擬機器上，所以要把 flask-redis 停掉刪除並重新新增容器 docker stop flask-redis docker rm flask-redis docker run -d -p 5000:5000 --link redis --name flask-redis -e REDIS_HOST=redis fishboneapps/flash-redis 這時候再去 curl，就會發現次數還是繼續累加，因為 redis 容器沒有關閉 curl 127.0.0.1:5000 啟動容器的時候，可以給容器設定環境變數 -e docker run -d --name test1 -e Fishboneapps=vincent busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot; 檢查容器的環境變量，就會看到上面設置的環境變量 docker exec -it test1 env Overlay 和 Underlay 的通信解釋 在兩台機器上面分別部署兩個 Docker 需要用 XLAN 將 Docker 傳出來的網路數據包封裝到虛擬主機的數據包上。而在這個情境下，在虛擬主機傳送的數據包底層就會有該虛擬主機要傳遞的來源和目的 ip，這個數據包就稱為 Underlay；而這個數據包上面就會放入 Docker 所要傳送的數據包，這個數據包就稱為 Overlay。Docker 通信的邏輯如下圖： Docker Overlay 網路和 etcd 實現多機容器通信 在 node1 上安裝 etcd wget https://github.com/coreos/etcd/releases/download/v3.0.12/etcd-v3.0.12-linux-amd64.tar.gz tar zxvf etcd-v3.0.12-linux-amd64.tar.gz cd etcd-v3.0.12-linux-amd64 1234567nohup ./etcd --name docker-node1 --initial-advertise-peer-urls http://192.168.205.10:2380 \\--listen-peer-urls http://192.168.205.10:2380 \\--listen-client-urls http://192.168.205.10:2379,http://127.0.0.1:2379 \\--advertise-client-urls http://192.168.205.10:2379 \\--initial-cluster-token etcd-cluster \\--initial-cluster docker-node1=http://192.168.205.10:2380,docker-node2=http://192.168.205.11:2380 \\--initial-cluster-state new&amp; 在 node2 上安裝 etcd wget https://github.com/coreos/etcd/releases/download/v3.0.12/etcd-v3.0.12-linux-amd64.tar.gz tar zxvf etcd-v3.0.12-linux-amd64.tar.gz cd etcd-v3.0.12-linux-amd64 1234567nohup ./etcd --name docker-node2 --initial-advertise-peer-urls http://192.168.205.11:2380 \\--listen-peer-urls http://192.168.205.11:2380 \\--listen-client-urls http://192.168.205.11:2379,http://127.0.0.1:2379 \\--advertise-client-urls http://192.168.205.11:2379 \\--initial-cluster-token etcd-cluster \\--initial-cluster docker-node1=http://192.168.205.10:2380,docker-node2=http://192.168.205.11:2380 \\--initial-cluster-state new&amp; 在 node1 和 node2 的 etcd 目錄底下檢查 cluster 狀態，確認是否 healthy ./etcdctl cluster-health 在 node1 上重啟 Docker 服務 sudo service docker stop sudo /usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --cluster-store=etcd://192.168.205.10:2379 --cluster-advertise=192.168.205.10:2375&amp; 在 node2 上重啟 Docker 服務 sudo service docker stop sudo /usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --cluster-store=etcd://192.168.205.11:2379 --cluster-advertise=192.168.205.11:2375&amp; 在 node1 上創建一個 overlay 的 network docker network create -d overlay demo 在 node1 和 node2 上面執行 docker network ls 都會看到 demo，因為 demo 會從 node1 同步到 node2 使用以下指令查看同步的內容 12./etcdctl ls /docker/nodes //查看節點./etcdctl ls /docker/network/v1.0/network //可以看到回傳的 id 和 docker network 上一樣 在 node1 上創建使用 demo 網路的機器 sudo docker run -d --name test1 --net demo busybox sh -c &quot;while true; do sleep 3600; done&quot; 在 node2 上創建使用 demo 網路的機器 sudo docker run -d --name test2 --net demo busybox sh -c &quot;while true; do sleep 3600; done&quot; 在 node1 上直接 ping test2 的容器，不管是 ping ip 或是容器名稱都可以連通 docker exec test1 ping 10.0.0.3 docker exec test1 ping test2 查看 test1 容器的網路 docker exec test1 ip a，就會發現結構如下圖， 會有兩個網路，gwbridge 是連接實體外部網路，而 overlay 的網路 ovnet 是負責容器溝通的內部網路","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://vincent.fishboneapps.com/tags/Docker/"}]},{"title":"英文文法重點整理(3)","slug":"英文文法重點整理-3","date":"2020-02-22T05:33:09.000Z","updated":"2020-06-22T17:17:07.836Z","comments":true,"path":"2020/02/22/英文文法重點整理-3/","link":"","permalink":"https://vincent.fishboneapps.com/2020/02/22/%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95%E9%87%8D%E9%BB%9E%E6%95%B4%E7%90%86-3/","excerpt":"","text":"文法整理摘錄自 Betty S. Azar 的基礎英文文法書，若有侵權，煩請來信告知，我將於第一時間刪除所有相關文章。 第七章 可數和不可數名詞 7-1 可數和不可數 可數名詞，單數：a + 名詞、one + 名詞，複數：名詞 + -s 單數：a book / one book 複數：books / two books / some books / a lot of books 不可數名詞，單數：不能用 a 和 one，複數：不可數名詞沒有複數形式 單數：mail / some mail / a lot of mail 複數：(沒有複數形式) 常見的不可數名詞 advice mail bread pepper furniture money cheese rice help music coffee salt homework traffic food soup information vocabulary fruit sugar jewelry weather meat tea luck work milk water 7-2 使用 A 與 An 的比較 a 和 an 被用在單數可數名詞前面，dog 和 animal 都是單數可數名詞。 A dog is an animal. an 用在字首為母音 a, e, i 和 o 單詞前面，例如：an apartment, an elephant, an idea, an ocean。注意：單數名詞前面有形容詞，而形容詞是母音開頭的，就要使用 an。 I work in an office. Mr. Tang is an old man. 如果單字開頭為 u 且是母音聲音，前面就要用 an，例如： an nucle, an ugly picture；如果單字開頭為 u 且發音為 /yu/，前面就要用 a，例如：a university。 I have an uncle. He works at a university. 有些單字開頭為 h，但是 h 不發音，取而代之的，這些單字從母音開始發音，那麼就要使用 an，例如：an hour, an honor。大部分 h 開頭的單字，h 都是要發音的，如果 h 是要發印的，要使用 a。 I need an hour to finish my work. I live in a house. He lives in a hotel. 7-3 使用 A/An 和 Some 的比較 a/an 被使用在單數可數名詞前面，some 被使用在複數可數名詞前面。 I have a pen. I have some pens. some 被用在不可數名詞前面 I have some rice. 7-4 不可數名詞的量詞 計量單位被用在表達不可數名詞的精確數量，例如：a glass of, a cup of, a piece of。some water = 不精確數量，a glass of water = 精確數量 I’d like some water. I’d like a glass of water. I’d like a cup of coffee. I’d like a piece of fruit. 常見的計量表達 a bag of rice a bunch of bananas a jar of pickles a bar of soap a can of corn a loaf of bread a bottle of olive oil a carton of milk a piece of cheese a bowl of cereal a glass of water a sheet of paper a box of candy a head of lettuce a tube of toothpaste 7-5 使用 Many, Much, A Few, A Little many 跟複數可數名詞一起使用；much 跟不可數名詞一起使用；a few 跟複數可數名詞一起使用；a little 跟不可數名詞一起使用。 I don’t get many letters. I don’t get much mail. Jan gets a few letters. Ken gets a little mail. 7-6 使用 The 當說話者和聆聽者在心裡都有相同東西，說話者會使用 the，the 表示名詞是特定的(不是一般的)。 A: Where’s Max? B: He’s in the kitchen. A 和 B 在心中都知道相同的廚房。 A: I have two pieces of fruit for us, an apple and a banana. What would you like? B: I’d like the apple, please. 當 B 說 the apple，A 和 B 在心中都有相同的蘋果 A: It’s a nice summer day today. The sky is blue. The sun is hot. B: Yes, I really like summer. A 和 B 都在想相同的天空(他們只有一個天空可以想)和相同的太陽(他們只有一個太陽可以想) the 跟單數可數名詞 / 複數可數名詞 / 不可數名詞一起使用，換句話說，the 可以用三種名詞的任何一種。 Nick has a pen and a pencil. The pen is blue. The pencil is yellow. Nick has some pens and pencils. The pen are blue. The pencils are yellow. Nick has some rice and some cheese. The rice is white. The cheese is yellow. 注意：說話者對第二次提到的名詞用 the，當說話者第二次說到一個名詞，說話者和聆聽者都在想同樣的東西。 第一次提到：I have a pen. 第二次提到：The pen is blue. 7-7 使用 Ø (無冠詞)來表達概述 無冠詞(符號為 Ø)被用來與複數可數名詞 / 不可數名詞一起來表達概述 Ø Apples are good for you. Ø Students use Ø pens and Ø pencils. I like to listen to Ø music. Ø Rice is good for you. 比較 Apples are good for you. 上面的句子，apples 是概述的，它表示所有的蘋果、任何的蘋果，在這邊 Ø (無冠詞)被使用。 Tim and Jan ate some fruit. The apples were very good, but the bananas were too old. 上面的句子，apples 是特定的，所以 the 放在它前面，它表示 Tim 和 Jan 吃的特定的蘋果。 I like to listen to music. 上面的句子，music 是概述的。 We went to a concet last night. The music was very good. 上面的句子，music 是特定的。 7-8 使用 Some 和 Any 使用 some 在肯定句。 Vera has some money. 使用 any 在否定句。 Vera doesn’t have any money. 在問句中，用 some 或是 any。 Does Vera have any money? Does Vera have some money? any 與不可數名詞和複數名詞一起使用。 I don’t have any money. I don’t have any matches. 第八章 表達過去時間 Part I 8-1 使用 Be：過去時間 現在時間 vs. 過去時間 I am in class today. / I was in class yesterday. Alison is sick today. / Alison was sick yesterday. My friends are at home today. / My friends were at home yesterday. I / she / he / it + was，we / you / they + were 單數：I was / you were(一個人) / she was / he was / it was 複數：we were / you were(多於一個人) / they were 8-2 Be 的簡單過去式：否定 否定縮寫：was + not = wasn’t，were + not = weren’t I was not in class yesterday. I wasn’t in class yesterday. I / she / he / it + wasn’t，we / you / they + weren’t They were not at home last night. They weren’t at home last night. 8-3 Be 的過去問句 YES/NO 問句 =&gt; 短回答 (長回答) Were you in class yesterday? =&gt; Yes, I was.(I was in class yesterday.) / No, I wasn’t.(I wasn’t in class yesterday.) Was Carlos tired last night? =&gt; Yes, he was.(He was tired last night.) / No, he wasn’t.(He wasn’t tired last night.) 資訊問句 =&gt; 短回答 (長回答) Where were you yesterday? =&gt; In class.(I was in class yesterday.) When was Emily sick? =&gt; Last week.(She was sick last week.) 8-4 簡單過去式：使用 -ed 動詞 + -ed = 簡單過去式。I / you / she / he / it / we / they + walked(動詞 + -ed)。 簡單現在 / 簡單過去 I walk to school every day. / I walked to school yesterday. Ann walks to school every day. / Ann walked to school yesterday. 8-5 過去時間單字：Yesterday, Last 和 Ago 注意從現在到過去的時間表達改變。 現在 -&gt; 過去 today -&gt; yesterday this morning -&gt; yesterday morning this afternoon -&gt; yesterday afternoon this evening -&gt; yesterday evening tonight -&gt; last night this week -&gt; last week yesterday 常常跟 morning, afternoon 和 evening 一起使用。 Bob was here yesterday. / yeasterday morning. / yesterday afternoon. / yesterday evening. last 常常跟 night、長時間(week, month, year)、季節(spring, summer…等等)和星期幾一起使用。 Sue was here last night. / last week. / last weekend. / last month. / last year. / last spring. / last summer. / last fall. / last winter. / last Monday. / last Tuesday. / last Wednesday. / …等等 ago 表示「在過去」，它會加在特定長度時間(例如：two minutes + ago, five years + ago)後面。 Tom was here five minutes ago. / two hour ago. / three days ago. / a (one) week ago. / six months ago. / a (one) year ago. 8-6 簡單過去式：不規則動詞(分類一) 有些動詞沒有 -ed 的形式，它們的過去型態是不規則的。 現在 - 簡單過去 come - came do - did eat - ate get - got go - went have - had put - put see - saw sit - sat sleep - slept stand - stood write - wrote 現在式 / 過去式 I come to class every day. / I came to class yesterday. I do my homework every day. / I did my homework yesterday. Meg eats breakfast every morning. / Meg ate breakfast yesterday morning. 8-7 簡單過去式：否定 I / you / she / he / it / we / they + did not + 主要動詞。注意：主要動詞和 did not 一起使用時，使用原形動詞。 I did not walk to school yesterday. You did not walk to school yesterday. Tim did not eat lunch yesterday. They did not come to class yesterday. 錯誤：I did not walked to school yesterday. 錯誤：Tim did not ate lunch yesterday. 否定縮寫：did + not = didn’t。 I didn’t walk to school yesterday. Tim didn’t eat lunch yesterday. 例外：當主要動詞為 be 的時候，不能使用 did。參考 8-2 和 8-3。 正確：Dan wasn’t here yesterday. 錯誤：Dan didn’t be here yesterday. 8-8 簡單過去式：Yes/No 問句 DID + 主詞 + 主要動詞 =&gt; 短回答 (長回答) Did Tess walk to school? =&gt; Yes, she did.(She walked to school.) / No, she didn’t.(She didn’t walk to school.) Did you come to class? =&gt; Yes, I did.(I came to class.) / No, I didn’t.(I didn’t come to class.) 8-9 簡單過去式：不規則動詞(分類二) 現在 - 簡單過去 bring - brought buy - bought catch - caught drink - drank drive - drove read - read (過去簡單式的 read 發音和顏色的 red 一樣) ride - rode run - ran teach - taught think - thought 8-10 簡單過去式：不規則動詞(分類三) 現在 - 簡單過去 break - broke fly - flew hear - heard leave - left meet - met pay - paid ring - rang send - sent sing - sang speak - spoke take - took wake up - woke up 8-11 簡單過去式：不規則動詞(分類四) 現在 \b- 簡單過去 begin - began find - found lose - lost hang - hung say - said sell - sold steal - stole tell - told tear - tore wear - wore 第九章 表達過去時間 Part II 9-1 簡單過去式：使用 Where, Why, When 和 What Time 問句 =&gt; 短回答 Did you go downtown? =&gt; Yes, I did. / No, I didn’t. Where did you go? =&gt; Downtown. Were you downtown? =&gt; Yes, I was. / No, I wasn’t. Where were you? =&gt; Downtown. Did you run because you were late? =&gt; Yes, I did. / No, I didn’t. Why did you run? =&gt; Because I was late. Why didn’t you walk? =&gt; Because I was late. Did Ann come at six? =&gt; Yes, she did. / No, she didn’t. When / What time did Ann come? =&gt; At six. what time 通常詢問一個時鐘上特定的時間。when 的回答可以是時間的各種表達。 What time did Ann come? =&gt; At six. / Seven o’clock. / Around 9:30. When did Ann come? =&gt; At six. / Friday. / June 15th. / Last week. / Three days ago. 9-2 What 問句 what 被用來當你想要找一個東西的問句，who 被用來當你想要找一個人的問句。(參考 9-3 的 who 問句) (疑問詞 + 助動詞 + 主詞 + 主動詞) =&gt; 短回答 (長回答) Did Carol buy a car? =&gt; Yes, she did. (She bought a car.) What did Carol buy? =&gt; A car. (She bought a car.) Is Fred holding a book? =&gt; Yes he is. (He’s holding a book.) What is Fred holding? =&gt; A book. (He’s holding a book.) a car 是動詞的受詞，what 是動詞的受詞。 Carol bought a car. What did Carol buy? 9-3 Who 和 Whom 問句 what 用來詢問關於 物品 的問句，who 用來詢問關於 人 的問句。 What did they see? =&gt; A boat. (They saw a boat.) Who did they see? =&gt; Jay. (They saw Jay.) 以下例句意思都一樣。whom 在正式英文中被用來當作動詞的受詞或是介系詞。who，不是whom，常常被用在日常的英文中。whom 是非常正式的英文，whom 很少被使用在日常口語英文中。 Who did they see? =&gt; Jay. (They saw Jay.) Whom did they see? =&gt; Jay. (They saw Jay.) who(m) 是動詞的受詞，常見的問句語序：疑問詞 + 助動詞 + 主詞 + 主要動詞。who 是問句的主詞，不 使用常見的問句語序。當使用 who 當作問句的主詞時，不要 使用 does, do 或是 did，無論如何 不要 更改動詞：問句中的動詞形式和答案的動詞形式一樣。 Who(m) did they see? =&gt; Jay. (They saw Jay.) Who saw Jay? =&gt; Ella. (Ella saw Jay.) who lives there? =&gt; Ed. (Ed lives there.) Who came? =&gt; Eva. (Eva came.) 不正確：Who did come? 9-4 簡單過去式：不規則動詞(分類五) 現在 \b- 簡單過去 cost - cost cut - cut forget - forgot give - gave hit - hit hurt - hurt lend - lent make - made shut - shut spend - spent understand - understood 9-5 簡單過去式：不規則動詞(分類六) 現在 \b- 簡單過去 blow - blew draw - drew fall - fell feel - felt grow - grew keep - kept know - knew swim - swam throw - threw win - won 9-6 簡單過去式：不規則動詞(分類七) 現在 \b- 簡單過去 become - became bend - bent bite - bit build - built feed - fed fight - fought hide - hid hold - held shake - shook 9-7 時間子句裡的 Before 和 After 一個子句就是有一個主詞和一個動詞的一組文字。一個主句就是一個完整的句子。如果是不完整句型，就需要連接主句。時間子句會以時間單字開頭，例如：before 或是 after。before + S + V = 時間子句。after + S + V = 時間子句 I(S) ate(V) breakfast. = 一個主句 before I(S) went(V) to class = 一個時間子句 I(S) ate(V) breakfast[主句] before I went to class.[時間子句] Before I went to class,[時間子句] I(S) ate(V) breakfast.[主句] 一個時間子句可以接在一個主句後面，一個時間子句也可以接在主要子句前面(注意：當一個時間子句放在主句前面，要放一個逗點在兩個子句之間，當時間子句接在主句後面，逗點則不被使用。)，意思上都不會改變。 We took a walk[主句] after we finished our work.[時間子句] After we finished our work,[時間子句] we took a walk.[主句] before 和 after 不會總是加上時間子句，它們有時候也被當作介系詞並在後面加上名詞受詞，可以參考 1-8 和 6-3 的介詞短語。 We took a walk after the movie.[介詞短語] I had a cup of coffee before class.[介詞短語] 9-8 時間子句裡的 When when 可以加上時間子句。when + S + V = 一個時間子句。when the rain stopped 是一個時間子句。注意：名詞(Tom)會出現在代名詞(he)之前。 When the rain stopped, we took a walk. 或 We took a walk when the rain stopped. when 也可以加上問句(參考 3-11 關於 when 的問句)，一個問句是一個完整的句子，一個時間子句不是完整的句子。 When did the rain stop? = 一個問句 when the rain stopped = 一個時間子句 9-9 現在進行式和過去進行式 現在進行式描述就在說話的同時，一個活動正在進行。參考 4-1。這邊例句中的 right now 就是 10:00，Boris 在十點前開始坐下，在十點的時候正在坐著。 It’s 10:00 now. Boris is sitting in class. 過去進行式描述一件事情在過去的一個特定時間，一個活動正在進行。這邊例句中，Boris 在昨天 10:00 之前就開始坐在教室，而在昨天 10:00，坐在教室正在進行。 It was 10:00. Boris was sitting in class. 現在進行式和過去進行式的形式都包含 be + -ing，現在進行式使用現在形式的 be：am, is 和 are + -ing。 It’s 10:00. I am sitting in class. / Boris is sitting in class. / We are sitting in class. 過去進行式使用過去形式的 be：was 和 were + -ing。 It was 10:00. Boris was sitting in class. / We were sitting in class. 9-10 與過去進行式使用 While while + 主詞 + 動詞 = 一個時間子句。While I was sleeping 是一個時間子句，while = 在那段時間。一個 while 子句描述一件活動正在進行中的同時，另外一件活動在發生。一個 while 子句的動詞通常使用過去進行式(例如：was sleeping)。 The phone rang while I was sleeping. 或 While I was sleeping, the phone rang. (注意：當一個時間子句放在主句前面，要放一個逗點在兩個子句之間，當時間子句接在主句後面，逗點則不被使用。) 9-11 簡單過去式和過去進行式比較 簡單過去 描述活動或是狀態開始和結束在一個過去的特定時間(例如：yesterday, last night)。 Jane called me yesterday. I talked to Jane for an hour last night. What time did you get up this morning? 過去進行 描述一個活動過去正在某個時間進行，而這個時間，另外一個動作也同時發生。例句中，Jane 打電話的時候，學習這件事情正在進行。when 通常跟簡單過去活動一起使用。 I was studying when Jane called me last night. While I was studying last night, Jane called. 如果時間子句和主句在一個句子中都是簡單過去，它表示時間子句裡的動作先發生了，然後主句的動作才接著發生。例句中，先開始下雨，我才打開雨傘。 I opened my umbrella[主句] when it began to rain.[時間子句] 比較 When the phone rang, I answered it. (電話先響，我才回應。) When the phone rang, I was studying. (學習正在進行，電話才響。)","categories":[{"name":"English Learning","slug":"English-Learning","permalink":"https://vincent.fishboneapps.com/categories/English-Learning/"}],"tags":[{"name":"English Grammer","slug":"English-Grammer","permalink":"https://vincent.fishboneapps.com/tags/English-Grammer/"}]},{"title":"英文文法重點整理(2)","slug":"英文文法重點整理-2","date":"2020-02-21T03:50:51.000Z","updated":"2020-06-22T17:17:07.836Z","comments":true,"path":"2020/02/20/英文文法重點整理-2/","link":"","permalink":"https://vincent.fishboneapps.com/2020/02/20/%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95%E9%87%8D%E9%BB%9E%E6%95%B4%E7%90%86-2/","excerpt":"","text":"文法整理摘錄自 Betty S. Azar 的基礎英文文法書，若有侵權，煩請來信告知，我將於第一時間刪除所有相關文章。 第四章 使用現在進行式 4-1 Be + -ing：現在進行式 當說一個句子，I am in class. I am sitting. I am not standing. 這個動作(sitting)就是當下在發生的，而且我同時把這個句子說出來。am, is, are 是助動詞，sitting 是主要動詞。am, is, are + -ing = 現在進行式 am + -ing, I am sitting in class right now. is + -ing, Rita is sitting in class right now. are + -ing, You are sitting in class right now. 4-2 -ing 的拼法 規則一：子音 + -e =&gt; 去 -e 加 -ing smile =&gt; smiling write =&gt; writing 規則二：母音 ＋ 子音 =&gt; 重複子音 + -ing sit =&gt; sitting run =&gt; running 特例：w, x, y 不重複，例如：snow =&gt; snowing, fix =&gt; fixing, say =&gt; saying 規則三：兩個母音 + 一個子音 =&gt; 加 -ing；不重複子音 read =&gt; reading rain =&gt; raining 規則四：兩個子音 =&gt; 加 -ing；不重複子音 stand =&gt; standing push =&gt; pushing 4-3 現在進行式：否定 現在進行式否定：am/is/are + not + -ing I am not sleeping. I am awake. Ben isn’t listening. He’s daydreaming. Mr. and Mrs. Silva aren’t watching TV. They’re reading. 4-4 現在進行式：問句 問句 =&gt; 短回答（長回答） Is Marta sleeping? =&gt; Yes, she is. (She’s sleeping.) / No, she’s not. (She’s not sleeping.) / No, she isn’t. (She isn’t sleeping.) Are you watching TV? =&gt; Yes, I am. (I’m watching TV.) / No, I’m not. (I’m not watching TV.) 現在進行式：疑問詞的問句 Where is Marta sleeping? =&gt; In bed. (She’s sleeping in bed.) What is Ted watching? =&gt; A movie. (Ted is watching a movie.) Why are you watching TV? =&gt; Because I like this program. (I’m watching TV because I like this program.) 4-5 現在簡單式 vs. 現在進行式 定義 現在簡單式表達習慣或是日常活動，常用的時間詞為 every day, every year, every month, often, sometimes, never，現在簡單式還常用 do 和 does 在否定句和問句。 現在進行式表達當下正在進行的動作，而且說話者正在說話，常用的時間詞為 now, right now, today，現在進行式還常用 am, is, are 在否定句和問句。 陳述句 現在簡單式 I talk every day. You talk every day. He, She, it talks every day. We talk every day. They talk every day. 現在進行式 I am talking now. You are talking now. He, She, it is talking now. We are talking now. They are talking now. 否定句 現在簡單式 I don’t talk. You don’t talk. He, She, It doesn’t talk. We don’t talk. They don’t talk. 現在進行式 I am not talking. You are not talking. He, She, It is not talking. We are not talking. They are not talking. 問句 現在簡單式 Do I talk? Do you talk? Does he, she, it talk? Do we talk? Do they talk? 現在進行式 Am I talking? Are you talking? Is he, she, it talking? Are we talking? Are they talking? 4-6 非行為動詞不能用在現在進行式 有些動詞不能被用在現在進行式，他們叫做『非行為動詞』。want 是一個非行為動詞，want 表達的是身體或心理需求，不是一種行為\b；hear 是一個非行為動詞，hear 表達的是感官的體驗，不是一種行為。 I’m hungry right now. I want an apple. 錯誤：I am wanting an apple. I hear a siren. Do you hear it too? 錯誤：I’m hearing a siren. Are you hearing it too? 非行為動詞 dislike / hate / like / love / need / want hear / see / smell / taste believe / know / think (有時候被當作進行式動詞-參考 4-8) / understand 4-7 See, Look At, Watch, Hear, Listen To see = 非行為動詞，seeing 會發生是因為眼睛打開，seeing 是一種身體行為，不是一個計畫好的行為；look at = 行為動詞，looking 是一種計畫好的或有目的的行為，looking 會發生是有理由的；watch = 行為動詞，我會長時間 watch 某樣東西，短時間 look at 某樣東西。 I see many things in this room. I'm looking at the clock. I want to know the time. Bob is watching TV. hear = 非行為動詞，hearing 是一種非計畫性行為，他表達的是一種身體行為。listen (to) = 行為動詞，listening 發生是有目的的。 I’m in my apartment. I’m trying to study. I hear music form the next apartment. The music is loud. I’m in my apartment. I’m studying. I have an iPod. I'm listening to music. I like to listen to music when I study. 4-8 Think About 和 Think That think about + 一個名詞 I think about my family every day. (關於家人的想法每天都在我心裡) I am thinking about grammar right now. (我的心裡很慌亂，關於文法的想法現在就在我心裡) think that + 一個陳述句：人們使用 think that 當他們想要表達自己相信的事情。 I think that Emma is lazy. (在我看來，Emma 很懶惰，我相信 Emma 很懶惰) 錯誤：I am thinking that Emma is lazy. Ed thinks that I am lazy. I think that the weather is nice. 現在進行式常常跟 think about 一起使用，現在進行式則幾乎不使用 think that。 人們常常省略在 think 後面的 that，尤其是在口說的時候。 I think that Marco is a nice person. I think Marco is a nice person. 第五章 談論現在 5-1 使用 It 談論時間 在英文中，人們使用 it 表達時間。 What day is it? =&gt; It’s Monday. What month is it? =&gt; It’s September. What year is it? =&gt; It’s (2014). What’s the date today? =&gt; It’s September 15th. / It’s the 15th of September. What time is it? =&gt; It’s 9:00. (美式英語使用冒號(:)在小時和分之間；英式英語使用點(.)在小時和分之間) / It’s nine. / It’s nine o’clock. / It’s 9:00 A.M. 5-2 時間介系詞 AT：at + 時鐘上的準確時間，at + night We have class at one o’clock. I have an appointment with the doctor at 3:00. We sleep at night. IN：in + 一個準確的月份，in + 一個準確的年，in + the morning，in + the afternoon，in + the evening My birthday is in October. I was born in 1989. We have class in the morning. Bob has class in the afternoon. I study in the evening. ON：on + 一週中準確的一天，on + 一個準確日期 I have class on Monday(s). I was born on October 31. I was born on Octover 31, 1991. FROM…TO：from(一個準確的時間)to(一個準確的時間) We have class from 1:00 to 2:00. 5-3 使用 It 和 What 談論天氣 在英文中，當說到天氣的時候，人們通常使用 it。 It’s sunny today. It’s hot and humid today. It’s a nice day today. 人們通常用 What’s the weather like? 或是 How’s the weather 詢問天氣。What 通常使用在詢問溫度。 What’s the weather like in Istanbul in January? How’s the weather in Moscow in the summer? What’s the temperature in Bangkok today? 5-4 There + Be There + be 用來說某物存在於一個特定地點，注意：主詞接在 be 後面：there is + 單數名詞，there are + 複數名詞 There is a bird in the tree. There are four birds in the tree. 縮寫：there + is = there’s，there + are = there’re There’s a bird in the tree. There’re four birds in the tree. 5-5 There + Be：Yes/No 問句 Is there an apple in the refrigerator? Yes, there is. No, there isn’t. Are there eggs in the refrigerator? Yes, there are. No, there aren’t. 5-6 There + Be：使用 How Many 來問問題 How many chapters are there in this book? Fifteen. (There are 15 chapters in this book.) How many provinces are there in Canada? Ten. (There are ten provinces in Canada.) 注意：how many 後面接著的名詞是複數 How many words do you see? 錯誤：How many word do you see? 5-7 地點的介系詞 on = 介系詞，my desk = 介受詞，on my desk = 介詞短語 My book is on my desk. 一個人會 lives in a city / a state / a country / a continent\b, on a street / avenue / road 等等, at a street address Ned lives in Miami. / in Florida. / in the United States. / in North America. Meg lives on Hill Street. She lives at 4472 Hill Street. in 用在房間裡面：in the kitchen, in the classroom, in the hall, in my bedroom 等等。 My father is in the kitchen. At + work, school, home 表達活動 Ivan is at work. =&gt; Ivan 在他的辦公室工作(或是其他工作地點)。 Yoko is at school. =&gt; Yoko 是一個學生，她正在學習(或者，他是老師，她正在教學)。 Olga is at home. =&gt; Olga 在家做事情。 In + bed, class, hospital, jail，這些具有特殊的意義 Siri is in bed. =&gt; Siri 在棉被下正在休息或是睡覺。 Tim is in class. =&gt; Tim 正在學習(或是正在教書)。 Mr. Lee is in the hospital. =&gt; Mr. Lee 生病了，他是個病人。 Paul is in jail/prison. =&gt; Paul 是囚犯，他不能自由離開。 注意：美式英文 = in the hospital，英式英文 = in hospital. 5-8 更多地點的介系詞：清單 above beside in back of in the middle of on around between in the back of inside on top of at far (away) from in front of near outside behind in in the front of next to under below 在旁邊 The book is beside the cup. The book is next to the cup. The book is near the cup. 在中間 The book is between two cups. 離很遠 The book is far away from the cup. 在上面 The cup is on the book. The cup is on top of the book. 在下面 The cup is under the book. 在上面（不接觸） The cup is above the book. 在周圍 The hand is around the cup. 在後面 The man is in back of the bus. The man is behind the bus. 在裡面的後面 The man is in the back of the bus. (男人在公車的後座上) 在前面 The man is in front of the bus. 在外面(8 和 10 都是在外面，可以用以下句子替代) The man is outside the bus. 在裡面的前面 The man is in the front of the bus. (男人在公車的前座上) 在中間 The man is in the middle of the bus. 在裡面(9、12 和 13 都是在裡面，可以用以下句子替代) The man is inside the bus. 5-9 Would like 以下例子的意思都一樣，但是 would like 通常比 want 更有禮貌，I would like 是比 I want 更好的說法。 I’m thirsty. I want a glass of water. I’m thirsty. I would like a glass of water. 注意：would 不加結尾 -s，like 不加結尾 -s I would like / You would like / She would like / He would like / We would like / They would like a glass of water. would 在口說和寫作上都常常與代名詞一起縮寫，在口說中，would 也常常與名詞縮寫。寫作：Ray would like to come. / 口說： Ray’d like to come. I’d = I would you’d = you would she’d = she would he’d = he would we’d = we would they’d = they would 注意：would like 可以在後面加上不定詞 I would like to eat a sandwich. 在問句中，would 會在主詞之前 Would you like some tea? would 獨立用在對 would like 問句的短回答中。它在短回答中不能縮寫。 Yes, I would. (I would like some tea.) 5-10 Would Like 和 Like 比較 I would like to go to the zoo 就是我想去動物園。would like 就表示我現在或未來想做某件事情。 I like to go to the zoo 就是我喜歡動物園。like 就是我常常，通常或時常喜歡某件事情。 第六章 名詞和代名詞 6-1 名詞：主詞和受詞 一個名詞被用來當作句子的主詞；一個名詞被用來當作一個動詞的受詞（有些動詞後面可以接受詞，稱為及物動詞(v.t.)，有些動詞後面不能接受詞，稱為不及物動詞(v.i.)）。 birds 是一個名詞，它被用來當作句子的主詞。 Birds fly. pen 是一個名詞，它前面有冠詞 a，a pen 被用來當作動詞 is holding 的受詞。 Karl is holding a pen. 6-2 名詞當作介受詞 一個名詞也可以被用來介詞的受詞。 in 是介系詞，名詞 sky (前面有冠詞 the) 是介系詞 in 的受詞。in the sky 是介詞短語(短語 = 一組文字)。 Birds fly in the sky. 注意：介詞短語緊接著在它所指示的名詞後面。錯誤：Karl is holding in his hand a pen. Karl is holding a pen in his hand. 一些常見的介系詞 about between for near to across by from of under at during in on with 6-3 跟名詞在一起的形容詞 形容詞(adj.)描述一個名詞。在文法中，我們說形容詞修飾名詞，「修飾」就是只改變一點點，形容詞賦予一個名詞一點不一樣的意思：cold weather, hot weather, nice weather, bad weather。形容詞接在名詞前面。 I don’t like cold weather. Alex is a happy child. The hungry body has a fresh apple. 提醒：形容詞也可以接在 be 後面，形容詞描述一個句子的主詞。(參考 1-7) The weather is cold. 常見的形容詞 beautiful - ugly good - bad angry hungry big - little happy - sad bright important big - small large - small busy intelligent boring - interesting long - short delicious interesting cheap - expensive noisy - quiet exciting kind clean - dirty old - new famous lazy cold - hot old - young favorite nervous dangerous - safe poor - rich free nice dry - wet sour - sweet fresh ripe easy - hard strong - weak healthy serious easy - difficult honest wonderful 6-4 主詞代詞和受詞代詞 主詞 - 受詞 / I - me / you - you / she - her / he - him / it - it / we - us / you - you / they - them 主詞代詞 / 受詞代詞 I speak English / Bob knows me. You speak English / Bob knows you. She speaks English / Bob knows her. He speaks English / Bob knows him. It speaks English / Bob knows it. We speak English / Bob talks us. You speak English / Bob talks you. They speak English / Bob talks them. 代名詞跟名詞有同樣的意思，He 和 Tony 意思一樣；Him 和 Tony 意思一樣。在文法中，我們說代名詞指向一個名詞，代名詞 he 和 him 都指向名詞 Tony I know Tony. He is a friendly person. I like Tony. I know him well. 有時候代名詞指向一個名詞短語，it 指向整個短語 a red book。 I have a red book. It is on my desk. 6-5 名詞：單數和複數形式 大部分的名詞變成複數，加 -s。 單數 / 複數 one pen / two pens one apple / three apples one cup / four cups one elephant / five elephants 名詞結尾：子音 + -y，複數形式：去 y 改 i，再加 -es 單數 / 複數 baby / babies city / cities 名詞結尾：母音 + -y，複數形式：加 -s。 單數 / 複數 boy / boys key / keys 名詞結尾：-fe 或是 -f，複數形式：去 f 改 v，加 -s 或是 -es 單數 / 複數 wife / wives thief / thieves 名詞結尾：-sh, -ch, -ss, -x，複數形式：加 -es，讀音：/əz/ 單數 / 複數 dish / dishes match / matches class / classes box / boxes 名詞結尾：子音 + -o，複數形式：加 -es，名詞結尾：母音 + -o，複數形式：加 -s 單數 / 複數 tomato / tomatoes potato / patatoes zoo / zoos radio / radios 6-6 名詞：不規則複數形式 特殊的不規則複數形式，單數 / 複數。 child / children 例：Mr. Smith has one child. / Mr. Cook has two children. foot / feet 例：I have a right foot and a left foot. I have two feet man / men 例：I see a man on the street. I see two men on the street. mouse / mice 例：My cat sees a mouse. Cats like to catch mice. tooth / teeth 例：My tooth hurts. My teeth are white. woman / women 例：There’s one woman in our class. There are ten women in your class. 同樣的不規則複數形式，單數 / 複數。 sheep / sheep 例：Annie drew a picture of one sheep. Tommy drew a picture of two sheep. fish / fish 例：Bob has an aquarium. He has one fish. Sue has an aquarium. She has seven fish. 沒有單數形式的不規則複數形式，單數 / 複數。 (none)[people 永遠是複數，它沒有單數形] / people 例：There are fifteen people in this room. (注意：people 不能有 -s) 6-7 所有格代名詞：Mine, Yours, His, Hers, Ours, Theirs 一個所有格形容詞會使用在一個名詞前面：my book。 This book belongs to me. It is my book. (所有格形容詞) It is mine. (所有格代名詞) That book belongs to you. It is your book. (所有格形容詞) It is yours. (所有格代名詞) 一個所有格代名詞會獨立使用，後面不接任何名詞。 That book is mime. 錯誤：That is mime book. 所有格形容詞和所有格代名詞 所有格形容詞 所有格代名詞 my mine you yours her hers his his our ours their theirs 6-8 所有格名詞 表示一個人有某樣東西，加一個撇號(‘)和 -s 在一個單數名詞後面。單數的所有格名詞：名詞 + 撇號(’) + -s。 單數名詞 / 所有格形式 friend / friend’s My friend has a car. / My friend’s car is blue. student / student’s The student has a book. / The student’s book is red. 加一個撇號(‘)在複數名詞後面(在 -s 後面)。複數的所有格名詞：名詞 + -s + 撇號(’)。 複數名詞 / 所有格形式 students / students’ The students have books. / The students’ books are red. friends / friends’ My friends have a car. / My friends’ car is blue. 6-9 使用 Whose 的問句 Whose 問關於所有權的問題，Whose 常常和一個名詞一起使用。 Whose book is this? Mine. / It’s mine. / It’s my book. Whose books are these? Rita’s. / They’re Rita’s. / They’re Rita’s books. 如果意思很清楚的話，Whose 可以在沒有名詞的情況下使用。 Whose is this? (說話者指向一本書) Whose are these? (說話者指向一些書) Who’s = who is，Whose 和 who’s 的發音一樣。 Who’s your teacher? 6-10 所有格：不規則複數形式 不規則複數名詞(children, men, women, people) 有不規則的複數所有格形式，撇號(')會加在最後的 -s前面。規則複數所有格名詞：the students’ books，不規則複數所有格名詞：the women’s books。 The children’s toys are on the floor. That store sells men’s clothing. That store sells women’s clothing. I like to know about other people’s lives.","categories":[{"name":"English Learning","slug":"English-Learning","permalink":"https://vincent.fishboneapps.com/categories/English-Learning/"}],"tags":[{"name":"English Grammer","slug":"English-Grammer","permalink":"https://vincent.fishboneapps.com/tags/English-Grammer/"}]},{"title":"英文文法重點整理(1)","slug":"英文文法重點整理-1","date":"2020-01-16T04:00:41.000Z","updated":"2020-06-22T17:17:07.836Z","comments":true,"path":"2020/01/15/英文文法重點整理-1/","link":"","permalink":"https://vincent.fishboneapps.com/2020/01/15/%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95%E9%87%8D%E9%BB%9E%E6%95%B4%E7%90%86-1/","excerpt":"","text":"文法整理摘錄自 Betty S. Azar 的基礎英文文法書，若有侵權，煩請來信告知，我將於第一時間刪除所有相關文章。 第一章節：使用 Be 1-1 單數代名詞 + Be I am late. You are late. She is late. He is late. It is late. Maria (She) is late. Tom (He) is late. Bus 10 (It) is late. 1-2 複數代名詞 + Be We are here. You are here. They are here. Sam and I (We) are here. Sam and you (You) are here. Sam and Lisa (They) are here. 1-3 單數名詞 + Be Canada is a country. Canada = 單數名詞，is = 單數動詞，country = 單數名詞，“a” 出現在單數名詞之前；在例句中，“a” 就出現在單數名詞 country 之前。 “a” 叫做冠詞(article) Bali is an island. “a” 和 “an” 是一樣的意思，也都是冠詞(article)。 “a” 是使用在子音(除了母音之外的所有字母)之前的，例如：b, c, d, f, g… 等等，Example: a bed, a cat, a dog, a friend, a girl “an” 是使用在母音之前的，例如：a, e, i, o, u，Example: an animal, an ear, an island, an office. 特例：u 之前有時候不是用 “an”，例如：a university 1-4 複數名詞 + Be Cats are animals. Cats = 複數名詞，are = 複數動詞，animals = 複數名詞 單數：a cat, an animal，複數：cats, animals 複數名詞用 -s 結尾，“a” 和 “an” 只能用在單數名詞 單數：a city, a country, 複數：cities, countries 有些單數名詞以 -y 結尾的，有特別的複數形式：去 -y 加 ies Canada and China are countries. 兩個名詞以 and 連接，後面會接著 are，兩個名詞在一起表示是複數的。 1-5 Be 的縮寫形式 AM 的縮寫 I + am =&gt; I’m IS 的縮寫 she + is =&gt; she’s he + is =&gt; he’s it + is =&gt; it’s ARE 的縮寫 you + are =&gt; you’re we + are =&gt; we’re they + are =&gt; they’re 備註 當人們在說話的時候，常常將兩個字放在一起，縮寫就是將兩個字放在一起。 主詞代名詞 + be 常常被用在寫作和口說 縮寫中間的撇號稱為 “apostrophe” (') 1-6 Be 的否定詞 否定詞的縮寫形式 I am not a teacher. 縮寫：I'm not You are not a teacher. 縮寫：you're not / you aren’t She is not a teacher. 縮寫：she's not / she isn’t He is not a teacher. 縮寫：he's not / he isn’t It is not a city. 縮寫：it's not / it isn’t We are not teachers. 縮寫：we're not / we aren’t You are not teachers. 縮寫：you're not / you aren’t They are not teachers. 縮寫：they're not / they aren’t 備註： not 讓句子成為否定。 be 和 not 可以被縮寫。 “I am” 跟 be 只有一種縮寫形式，其餘和 be 皆有兩種縮寫形式。 1-7 Be + 形容詞 名詞 + Be + 形容詞 A ball is round. Balls are round. Mary is intelligent. Mary and Tom are intelligent. 代名詞 + Be + 形容詞 I am hungry. She is young. They are happy. 備註： 形容詞常常跟隨一種形式的 be (am, is, are)。 形容詞提供在句首的名詞和代名詞的資訊，在句首的名詞和代名詞叫做『主詞』。 1-8 Be + 地方 Maria is here. / Bob is at the library here 是一個地方。 at the library 是一個地方。 be 常常在後面加上一個地方 Maria is here. / there. / downstairs. / upstairs. / inside. / outside. / downtown. 地方可以只有一個詞。 Bob is at the library. / on the bus. / in his room. / at work. / next Maria. 地方可能是個介系詞組(介系詞 + 名詞) 常見介系詞 on / in / next to / above / under / behind / from / at / between 1-9 Be 的基本句型模式 I am a student. 在句子最前面的名詞或代名詞稱為『主詞』。 He is intelligent. be 是『動詞』，幾乎所有的英文句子都有一個主詞和一個動詞。 We are in class. / She is upstairs. 基本的完整句子是一個主詞 + be 動詞 + 名詞 / 形容詞 / 地方。 第二章節：使用 Be 和 Have 2-1 Be 的 Yes/No 問題 Am I early? =&gt; I am early. Is Ana a student? =&gt; Ana is a student. Are they at home? =&gt; They are at home. 備註 在問題中，be 會出現在主詞前面。 問題的結尾用 ?(question mark)，回答的結尾用 .(period)。 2-2 Yes/No 問題的簡答 Is Kari a student? =&gt; Yes, she is. / No, she’s not. / No, she isn’t. Are they at home? =&gt; Yes, they are. / No, they aren’t. / No, they’re not. Are you ready? =&gt; Yes, I am. / No, I’m not. 備註： yes 的簡答不能使用縮寫。以下為錯誤的範例：Yes, she’s. / Yes, they’re. / Yes, I’m. 2-3 Be 的問題：使用 Where Where 問的是地方，Where出現在句首，be 之前。 問題 =&gt; 簡答（長回答） Is the book on the table? =&gt; Yes, it is. (The book is on the table.) Are the books on the table? =&gt; Yes, they are. (The books are on the table.) Where 問題 =&gt; 簡答（長回答） Where is the book? =&gt; On the table. (The book is on the table.) Where are the books? =&gt; On the table. (The books are on the table.) 2-4 使用 Have 和 Has 單數 I have a pen. You have a pen. She has a pen. He has a pen. It has a pen. 複數 We have pens. You have pens. They have pens. 備註 I / you / we / they + have she / he / it + has 2-5 使用 My, Your, Her, His, Our, Their 單數 I have a book. My book is red. You have a book. Your book is red. She has a book. Her book is red. He has a book. His book is red. 複數 We have books. Our books are red. You have books. Your books are red. They have books. Their books are red. 備註 主格 =&gt; 所有格 I =&gt; my you =&gt; your she =&gt; her he =&gt; his we =&gt; our they =&gt; their I possess a book. = I have a book = It is my book. my, your, her, his, our, their 稱為『所有格』，他們放在名詞前面 2-6 使用 This 和 That this book = 書在我附近，that book = 書不在我附近 I have a book in my hand. This book is red. I see a book on your desk. That book is blue. This is my book. That is your book. 縮寫：that is = that’s That’s her book. 在英文口說中，this is 的發音為 “this’s”，但是不能使用在寫作當中。 This is (“This’s”) her book. 2-7 使用 These 和 Those this 的複數為 these，that 的複數為 those My books are on my desk. These are my books. Your books are on your desk. Those are your books. 2-8 用 What 和 Who 提出問題 + Be What 是問關於物品；Who 是問關於人。is 後面會跟著單數詞；are 後面會跟著複數詞。 What is this(thing)? It’s a pen. Who is that(person)? That’s Mr. Lee. What are those(things)? They’re pens. Who are they? They’re Mr. and Mrs. Lee. 縮寫：what is = what’s, who is = who’s What’s this? Who’s that man? 第三章 使用現在簡單式 3-1 現在簡單式的格式和基本意思 第三人稱單數(she, he, it)的動詞會加上 -s，例如：talks。 I talk. You talk. He talks. She talks. It rains. We talk. They talk. 簡單現在是表達習慣。 I eat breakfast every morning. Olga speaks English every day. We sleep every night. They go to the beach every weekend. 3-2 頻率副詞 主詞 + always(100%) / usually / often / sometimes(50%) / seldom / rarely / never(0%) + 動詞，這些詞彙稱為『頻率副詞』，他們通常出現在主詞和簡單現在動詞中間。（有些頻率副詞也可以出現在句首或是句尾，例如：Sometimes I get up at seven. / I sometimes get up at seven. / I get up at seven sometimes.） Ivan always eats breakfast. Maria usually eats breakfast. They often watch TV. We sometimes watch TV. Sam seldom drinks milk. Rita rarely drinks milk. I never drink milk. 其他頻率表達：我們可以用一年/一個月/一週/一天內發生多少次來表達頻率 I drink tea once a day. / two times(twice) a day. / three times a day. / four times a day. I see my grandparents three times a week. I see my aunt once a month. I see my cousin Sam twice a year. every 是單數，在 every 後面的名詞必須是單數：錯誤範例：every mournings。 I dee my doctor every year. 3-3 頻率副詞的位置 頻率副詞會在現在簡單式 be 的後面：am, is, are。 主詞 + BE + 頻率副詞 I am always late. You are usually late. He is often late. She is sometimes late. It is seldom late. We are rarely late. They are never late. 頻率副詞會出現在所有簡單現在動詞之前，除了 be 以外。 主語 + 頻率副詞 + 其它簡單現在動詞 Tom always comes late. Tom usually comes late. Tom often comes late. Tom sometimes comes late. Tom seldom comes late. Tom rarely comes late. Tom never comes late. 3-4 結尾 -es 的拼寫和發音 動詞結尾：-sh, -ch, -ss, -x，拼寫：加上 -es，讀音：/əz/。 push =&gt; pushes =&gt; push/əz/ teach =&gt; teaches =&gt; teach/əz/ kiss =&gt; kisses =&gt; kiss/əz/ fix =&gt; fixes =&gt; fix/əz/ 3-5 結尾為 -y 加上 -s/-es 動詞結尾：子音 + -y，拼寫：改 y 為 i，並加上 -es cry =&gt; cries try =&gt; tries 動詞結尾：母音 + -y，拼寫：加 -s pay =&gt; pays enjoy =&gt; enjoys 3-6 不規則單數動詞：Has, Does, Goes have, do, go 有不規則的第三人稱單數，have =&gt; has, do =&gt; does, go =&gt; goes，結尾 -s 發音為 /z/ I have a book. He has(/hæz/) a book. I do my work. She does(/dəz/) her work. They go to school. She goes(/gowz/) to school. 3-7 Like To, Want To, Need To like, want, need 後面要加上不定詞，不定詞 = to + 動詞原形。need to 比 want to 還強烈，need to = 必要的，重要的。 I like to travel. It’s fun. I want to travel. I have vacation time next month. I need to travel. for my job. I have no choice. 3-8 現在簡單式：否定 否定：I / You / We / They + do not + 主要動詞，He / She / It + does not + 主要動詞。do 和 does 稱為『助動詞』。在第三人稱單數中，主要動詞不加上 s，-s 加在助動詞上了。 I do not drink coffee. You do not drink coffee. We do not drink coffee. They do not drink coffee. He does not drink coffee. She does not drink coffee. It does not drink coffee. 縮寫：do not = don’t, does not = doesn’t，大家經常(usually)在說話用縮寫，寫作時常常(often)使用縮寫。 I don’t drink coffee. He doesn’t drink coffee. 3-9 現在簡單式：Yes/No 問題 現在簡單式的問題形式：Do I / Do you / Does he / Does she / Does it / Do we / Do they + 主要動詞（原形）。主要動詞沒有結尾 -s，結尾 -s 已經在 does 中了。 Do I work? Do you work? Does he work? Does she work? Does it work? Do we work? Do they work? 當主要動詞是 be 的形式，do 就不能使用，參考 2-1 Am I late? Are you ready? Is he a teacher? Are we early? Are they at home? Are you a student? 錯誤範例：Do you be a student? do, don’t, does, doesn’t 可以用在現在簡單式的 yes/no 問題，並當作簡答。 Do you like fish? =&gt; Yes, I do. / No, I don’t. Does Liam like fish? =&gt; Yes, he does. / No, he doesn’t. do 也可以當作主要動詞。 Brad does his homework. Does Brad do his homework? 3-10 現在簡單式：用 Where 和 What 詢問資訊問題 Where 詢問地點的資訊，問 yes/no 問題的格式和問資訊問題的格式是一樣的：Do/Does + 主詞 + 主要動詞 Do they live in Miami? Yes, they do. / No, they don’t. Where do they live? In Miami. Does Gina live in Rome? Yes, she does. / No, she doesn’t. Where does Gina live? In Rome. What 詢問事情的資訊。 Do they need help? Yes, she does. / No, she doesn’t. What do they need? Help. Does Lee need help? Yes, he does. / No, he doesn’t. What does Lee need? Help. 3-11 現在簡單式：用 When 和 What Time 詢問資訊問題 when 和 what time 詢問時間的資訊 When do you go to class? At nine o’clock. What time do you go to class? At nine o’clock. When does Anna eat dinner? At six P.M. What time does Anna eat dinner? At six P.M. 頻率副詞通常會直接接在問題的主詞後面：Question word + does/do + 主詞 + usually + 主要動詞 What time do you usually go to class?","categories":[{"name":"English Learning","slug":"English-Learning","permalink":"https://vincent.fishboneapps.com/categories/English-Learning/"}],"tags":[{"name":"English Grammer","slug":"English-Grammer","permalink":"https://vincent.fishboneapps.com/tags/English-Grammer/"}]},{"title":"Docker 快速學習自我挑戰 II Day3","slug":"Docker-快速學習自我挑戰-II-Day3","date":"2019-05-31T03:19:45.000Z","updated":"2020-06-22T17:12:20.057Z","comments":true,"path":"2019/05/30/Docker-快速學習自我挑戰-II-Day3/","link":"","permalink":"https://vincent.fishboneapps.com/2019/05/30/Docker-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-II-Day3/","excerpt":"","text":"Dockerfile 語法梳理與最佳實踐 Dockerfile 語法 FROM 語法：為了安全，盡量使用官方的 Image 作為 Base Image FROM scratch 製作 Base Image FROM centos 使用 Base Image FROM ubuntu:14.04 Label 語法：Metadata 不可少，可以理解成註釋 LABEL maintainer=&quot;vincent@fishboneapps.com&quot; LABEL version=&quot;1.0&quot; LABEL description=&quot;This is the description&quot; RUN 語法：為了美觀，複雜的 RUN 用反斜線換行！避免無用分層，合併多條命令成一行！ 12RUN yum update &amp;&amp; yam install -y vim \\python-dev # 反斜線換行 123RUN apt-get update &amp;&amp; apt-get install -y perl \\pwgen --no-install-recommends &amp;&amp; rm -rf \\/var/lib/apt/lists/* # 注意清理 cache 1RUN /bin/bash -c &#x27;source $HOME/.bashrc; echo $HOME WORKDIR 語法：用 WORKDIR，不要用 RUN cd！盡量使用絕對目錄 1WORKDIR /root 123WORKDIR /test # 如果沒有會自動創建 test 目錄WORKDIR demoRUN pwd # 輸出結果是 /test/demo ADD 和 COPY 語法：大部分情況，COPY 比 ADD 好，ADD 除了 COPY 的功能以外，還有額外的解壓縮功能。添加遠端文件/目錄要使用 curl 或者 wget。 1ADD hello / # 將本地的檔案傳到 Image 裡面 1ADD test.tar.gz / # 添加到根目錄並解壓 12WORKDIR /rootADD hello test/ # /root/test/hello 12WORKDIR /rootCOPY hello test/ # /root/test/hello ENV 語法：盡量使用 ENV 增加可維護性 123ENV MYSQL_VERSION 5.6 # 設置常量RUN apt-get install -y mysql-server = &quot;$&#123;MYSQL_VERSION&#125;&quot; \\ &amp;&amp; rm -rf /var/lib/apt/lists/* # 引用常量 VOLUME 和 EXPOSE 語法：儲存和網路，後面單獨講。 CMD 和 ENTRYPOINT 語法：後面單獨講。 Docker 語法參考網址 RUN vs. CMD vs. ENTRYPOINT 語法說明 RUN：執行命令並創建新的 Image Layer CMD：設置容器啟動後默認執行的命令和參數 ENTRYPOINT：設置容器啟動時運行的命令 SHELL 和 Exec 格式 SHELL 格式 123RUN apt-get install -y vimCMD echo &quot;hello docker&quot;ENTRYPOINT echo &quot;hello docker&quot; Exec 格式 123RUN [ &quot;apt-get&quot;, &quot;install&quot;, &quot;-y&quot;, vim ]CMD [ &quot;/bin/echo&quot;, &quot;hello docker&quot; ]ENTRYPOINT [ &quot;/bin/echo&quot;, &quot;hello docker&quot; ] 兩種 Dockerfile 格式 SHELL 格式 123FROM centosENV name DockerENTRYPOINT echo &quot;hello $name&quot; Exec 格式 123FROM centosENV name DockerENTRYPOINT [ &quot;/bin/echo&quot;, &quot;hello $name&quot; ] CMD 語法 容器啟動時默認執行的命令 如果 docker run 指定了其它命令，CMD 命令被忽略 如果定義了多個 CMD，只有最後一行會執行 ENTRYPOINT 語法 讓容器以應用程序或者服務的形式運行 不會被忽略，一定會執行 最佳實踐：寫一個 shell 腳本作為 entrypoint 12345COPY docker-entrypoint.sh /usr/local/bin/ENTRYPOINT [&quot;docker-entrypoint.sh]EXPOSE 27017CMD [&quot;mongod&quot;] 鏡像的發佈 docker login 登入 Docker Hub 帳號 docker push fishboneapps/hello-world:latest 上傳到遠端倉庫 docker pull fishboneapps/hello-world 從遠端倉庫拉回本地 推薦的方式是透過 Github 去做關聯，然後只要維護在 Github 上面的 Dockerfile，最後 Docker Hub 會自動幫我們做 build 搭建私有的 Registry 如果想要架設私有的 Docker Hub，可以使用 Registry 安裝 Registry docker run -d -p 5000:5000 --restart always --name registry registry:2 在本地重新 build Image docker build -t [ip]:5000/hello-world . 如果直接 push，會顯示有安全性問題，所要先在 /etc/docker 裡面新增 daemon.json vim /etc/docker/daemon.json 123&#123; &quot;insecure-registries&quot;: [&quot;[ip]:5000&quot;]&#125; 然後再修改 /lib/systemd/system/docker.service，在裡面新增一行 EnvironmentFile 12345...ExecStart=/usr/bin/docerdEnvironmentFile=-/etc/docker/daemon.jsonExecReload=/bin/kill -s HUP $MAINPID... 重啟 docker sudo service docker restart 上傳到遠端 Registry docker push [ip]:5000/hello-world 因為 Registry 沒有 Web 介面，所以可以使用 Docker Registry API 來驗證上傳是否成功 Dockerfile 實戰 測試運行 python flask 新增 app.py 1234567from flask import Flaskapp = Flask(__name__)@app.route(&#x27;/&#x27;)def hello(): return &quot;hello docker&quot;if __name__ == &#x27;__main__&#x27;: app.run() 安裝 python sudo apt-get install -y python2.7 安裝 python-pip sudo apt-get install -y python-pip 安裝 flask pip install flask 如果遇到 locale 問題，可以使用以下指令 export LC_ALL=&quot;en_US.UTF-8&quot; export LANGUAGE=&quot;en_US.UTF-8&quot; 用 Dockerfile 來封裝 python flask 新增目錄 mkdir flask-hello-world 跳轉到目錄裡面，新增 Dockerfile cd flask-hello-world 新增 Dockerfile vim Dockerfile 1234567FROM python:3.6LABEL maintainer=&quot;Fishboneapps&lt;vincent@fishboneapps.com&gt;&quot;RUN pip install flaskCOPY app.py /app/WORKDIR /appEXPOSE 5000CMD [&quot;python&quot;, &quot;app.py&quot;] 將 Dockerfile 製作成 Image docker build -t fishboneapps/flask-hello-world . 運行製作好的 Image docker run -d fishboneapps/flask-hello-world Dockerfile 總結 Dockerfile 編寫分三步驟 第一步（環境）：引入庫，安裝套件，環境的搭建 第二步（代碼）：通過 COPY 或是 ADD 添加到 Image 裡面 第三步（CMD）：運行程序 容器的操作 Docker Exec 命令 docker exec -it [容器id] [執行命令] docker exec -it 1f7e35f8a8b6 /bin/bash 檢查 python 的服務 ps -ef | grep python 改成運行 python，就會看到直接進去 python 的 shell 裡面 docker exec -it 1f7e35f8a8b6 python 可以在 shell 裡面測試運行 Hello Docker，然後退出 12print (&quot;hello docker&quot;)exit() 打印出容器的 ip 地址 docker exec -it 1f7e35f8a8b6 ip a 停止容器 docker stop [容器id] docker stop 1f7e35f8a8b6 刪除所有停止的容器 docker rm $(docker ps -aq) 建立容器並指定名稱，如果不指定名稱的話，Docker 會分配一個名字 docker run -d --name=demo fishboneapps/flask-hello-world 停止容器也可以用 name，name 是唯一的 docker stop demo 開始容器一樣也可以用 name docker start demo 顯示容器的詳細資訊 docker inspect demo 顯示容器的 logs docker logs demo Docker container 命令文檔 Dockerfile 實戰(2) 壓力測試工具 - Stress 開啟一個 ubuntu 容器 docker run -it ubuntu:18.04 安裝 stress sudo apt-get update &amp;&amp; apt-get install -y stress 找尋 stress 路徑 which stress 查看 stress 命令 stress --help 123456-v, --verbose be verbose // 顯示更多資料-m, --vm N spawn N workers spinning on malloc()/free() // 生成 worker --vm-bytes B malloc B bytes per vm worker (default is 256MB) // 分配記憶體給 worker，默認 256MB --vm-stride B touch a byte every B bytes (default is 4096) --vm-hang N sleep N secs before free (default none, 0 is inf) --vm-keep redirty memory instead of freeing and reallocating 測試 stress stress --vm 1 --verbose 分配 500000M 的記憶體給 Worker 會無法分配，因為 Host 機器沒有那麼多記憶體 stress --vm 1 --vm-bytes 500000M --verbose 將以上步驟打包成 docker image，新增 Dockerfile 1234FROM ubuntu:18.04RUN apt-get update &amp;&amp; apt-get install -y stressENTRYPOINT [&#x27;/usr/bin/stress&#x27;]CMD [] 製作成 image docker build -t fishboneapps/ubuntu-stress . ENTRYPOINT + CMD[] 的形式，可以在啟動容器時，指定命令參數 docker run -it fishboneapps/ubuntu-stress --vm 1 --verbose 容器資源限制 使用剛剛的 ubuntu-stress，只分配 200M 的 memory 給容器，容器會退出，因為記憶體不足 docker run --memory=200M fishboneapps/ubuntu-stress --vm 1 --verbose --vm-bytes 500M –cpu-shares 命令，是指定容器的相對權重，開啟 3 個 terminal 進行測試 第一個 termianl 執行 docker run --cpu-shares=10 --name=test1 fishboneapps/ubuntu-stress --cpu 1 第二個 terminal 執行 docker run --cpu-shares=5 --name=test2 fishboneapps/ubuntu-stress --cpu 1 第三個 terminal 執行 top 進行監控 監控後會發現，cpu 的占比，test1 容器的 cpu 占比會是 test2 容器的 2 倍，總和 cpu 的使用量約為 100%","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://vincent.fishboneapps.com/tags/Docker/"}]},{"title":"Docker 快速學習自我挑戰 II Day2","slug":"Docker-快速學習自我挑戰-II-Day2","date":"2019-05-22T03:35:09.000Z","updated":"2020-06-22T17:12:20.057Z","comments":true,"path":"2019/05/21/Docker-快速學習自我挑戰-II-Day2/","link":"","permalink":"https://vincent.fishboneapps.com/2019/05/21/Docker-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-II-Day2/","excerpt":"","text":"Docker 的架構和底層技術 Docker Platform Docker 提供了一個開發，打包，運行 App 的平台 把 App 和底層 Infrastructure 隔離開來 Docker Engine Docker Engine 是 Docker 最重要的組件 後台進程（dockerd），提供了 REST API Server，還有 CLI 接口 在虛擬機裡面可以看 Docker 版本 sudo docker version 看 Docker 後台運行的狀態 ps -ef | grep docker Docker 底層技術支持 Namespaces：做隔離 pid, net, ipc, mnt, uts Control groups：做資源限制 Union file systems: Container 和 Image 的分層 Docker Image 概述 Image 概述 Image 使用的架構 文件和 meta data 的集合（root filesystem） 分層的，並且每一層都可以添加改變刪除文件，成為一個新的 Image 不同的 Image 可以共享相同的 layer Image 本身是唯讀的 Image 實作 列出現在有的 docker image sudo docker image ls Image 的獲取 用 Dockerfile 建立 從 Registry 拉取 sudo docker pull ubuntu:14.04 sudo docker image ls 去掉 sudo，因為每次都要打 sudo 很不方便 新增 docker 的 group sudo groupadd docker，會顯示已經存在，所以可以不用新增 新增用戶到 docker group 裡面 sudo gpasswd -a vagrant docker 重啟 docker 服務 sudo service docker restart 退出虛擬機 exit 再次進入就可以不用 sudo 權限執行 docker vagrant ssh 製作 Base Image 下載 Hello World docker pull hello-world 執行 Hello World Container docker run hello-world 新增一個資料夾 mkdir hello-world 新增一個 hello.c vim hello.c 12345#include&lt;stdio.h&gt;int main() &#123; printf(&quot;hello docker\\n&quot;);&#125; 安裝 C 語言編譯相關套件 sudo apt-get install gcc sudo apt-get install build-essential 編譯 Hello.c，輸出可執行文件 hello gcc -static hello.c -o hello 執行 hello ./hello 新增 Dockerfile vim Dockerfile 123FROM scratchADD hello /CMD [&quot;/hello&quot;] -t 指定 tag，用 docker id + image 的名字，在最後面加個 . 表示在當前目錄找 Dockerfile docker build -t fishboneapps/hello-world . 透過 docker history 來看分層 docker history fishboneapps/hello-world:latest 運行 image，如果返回 hello docker 代表這個 image 是可以當作 container 去執行的 docker run fishboneapps/hello-world 認識 Container 什麼是 Container? 透過 Image 創建 在 Image layer 之上建立一個 container layer（可讀寫） 可以把 Image 理解成 class，而 Container 是運行實例 Image 是負責儲存和分發的，而 Container 是負責運行 app Container 實作 列出所有 Container docker container ls 列出當前所有容器，包含正在運行以及退出的 docker container ls -a 運行 docker run centos 會發現什麼都沒有，接下來執行 docker container ls 也會發現什麼都沒有 但是運行 docker container ls -a 就會發現 centos 的 container 退出了 運行之後，會發現進入一個操作系統，-i 就是交互式，讓 docker 持續開啟，就算沒有連結，-t 就是 tty，就是連線到 Container 裡面 docker run -it centos 再運行 docker container ls 就會發現出現了 centos docker container ls -a 等於 docker ps -a docker container rm .... 等於 docker rm docker image ls 等於 docker images docker image rm 等於 docker rmi 列出所有關閉的 Container docker container ls -aq docker container ls -a | awk &#123;'print$1'&#125; 刪除所有 Container docker rm $(docker container ls -aq) 列出所有退出的 Container docker container ls -f &quot;status=exited&quot; 列出所有退出 Container 的標頭 docker container ls -f &quot;status=exited&quot; -q 刪除所有退出的 Container docker rm $(docker container ls -f &quot;status=exited&quot; -q) 建立自己的 Docker Image 用 Container 建立 Docker Image 運行 centos image docker run -it centos 在 container 裡面安裝 vim yum install -y vim 列出所有 container，要找到 container 的名字 docker container ls -a 把 container 轉存成 image docker commit upbeat_albattani fishboneapps/centos-vim 以上方法是比較不建議的方式 用 Dockerfile 建立 Docker Image 建立一個目錄 mkdir docker-centos-vim 進入目錄並新增 Dockerfile cd docker-centos-vim &amp;&amp; vim Dockerfile 新增 Dockerfile 12FROM centos // 基於 centos 的 DockerRUN yum install -y vim // 運行指令 建立 Image docker build -t fishboneapps/centos-vim-new . 在生成 Image 的時候，最好通過 Dockerfile 一步一步的去生成，這樣我們只需要去分享 Dockerfile 給別人就好了，別人通過分享的 Dockerfile，就可以生成一模一樣的 Image 了。","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://vincent.fishboneapps.com/tags/Docker/"}]},{"title":"Docker 快速學習自我挑戰 II Day1","slug":"Docker-快速學習自我挑戰-II-Day1","date":"2019-05-17T10:06:24.000Z","updated":"2020-06-22T17:12:20.057Z","comments":true,"path":"2019/05/17/Docker-快速學習自我挑戰-II-Day1/","link":"","permalink":"https://vincent.fishboneapps.com/2019/05/17/Docker-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-II-Day1/","excerpt":"","text":"課前準備及目標 \b \b 因為新的專案要使用 CI 和 CD，研究之後，發現應該要先學 Docker，最後的目標希望能在專案實現自動化的部署。預計使用工具為 Drone 和 Gogs 來實現 Laravel 專案的自動部署。最終的目標，當然是希望透過 Docker 讓 DevOps 更有系統性，拋開以往的手動化操作可能發生的錯誤，讓程式碼發佈更為嚴謹且穩定。 Docker 簡介 Docker 比起虛擬機更加輕巧，不需要虛擬化技術。 Docker 的好處 簡化配置 程式碼流水線管理 提高開發效率 隔離應用 整合伺服器 調試能力 多用戶 快速部署 容器需要知道的兩樣工具：Docker 和 Kubernetes (k8s) Kubernetes 是容器編排工具，對容器創建、管理、調度、運維 DevOps = 文化 + 過程 + 工具 容器技術概述 虛擬化的優點 資源池：物理機器的資源分配到不同的虛擬機器裡面 很容易擴展：加物理機器或是虛擬機器 很容易雲化：亞馬遜 AWS，阿里雲…等 虛擬化的侷限性 每一個虛擬機都是一個完整的操作系統，要分配資源給它。當虛擬機的數量增多時，操作系統消耗的資源會變多。 容器解決的問題 解決了開發和運維之間的矛盾 在開發和運維之間建立了一個橋樑，實現 DevOps 的最佳解決方案 容器是什麼？ 軟體和依賴套件的標準化打包 應用之間的隔離 共享同一個 OS Kernal 可以運行在很多主流的作業系統上 容器和虛擬機的區別 容器是 APP 層面的隔離、虛擬化是物理資源層面的隔離 虛擬機和容器可以合在一起，可以在虛擬機器裡面創建容器，這是沒有衝突的。 環境部署 使用 VirtualBox + Vagrant 為什麼不用 VMware? 因為 VMware 本身要錢，而且 Vagrant 搭配 VMware 也是要額外收錢的。 安裝 VirtualBox 當作虛擬化工具 安裝 Vagrant 新增目錄 Ubuntu mkdir Ubuntu 初始化 Vagrant 檔案 (可以在 Vagrant 官網找到需要的映像檔) vagrant init ubuntu/xenial64 啟動虛擬機 vagrant up 檢查虛擬機狀態 vagrant status 停止虛擬機 vagrant halt 刪除虛擬機 vagrant destroy 連線到虛擬機 vagrant ssh Ubuntu 上安裝 Docker Ubuntu 上安裝 Docker 文檔 如果有舊版的 Docker 透過以下指令移除 sudo apt-get remove docker docker-engine docker.io containerd runc 更新套件 sudo apt-get update 安裝 Docker 所需套件 123456sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common 新增 Docker 金鑰 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 確認金鑰 sudo apt-key fingerprint 0EBFCD88 綁定遠端 Docker Repository 1234sudo add-apt-repository \\ &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot; 安裝最新版本的 Docker CE sudo apt-get install docker-ce docker-ce-cli containerd.io 確定 Docker 安裝完成 sudo docker run hello-world 檢查 Docker 版本 sudo docker version","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://vincent.fishboneapps.com/tags/Docker/"}]},{"title":"React Native 快速學習自我挑戰 Day10","slug":"React-Native-快速學習自我挑戰-Day10","date":"2018-06-21T04:01:08.000Z","updated":"2020-06-22T17:22:58.891Z","comments":true,"path":"2018/06/21/React-Native-快速學習自我挑戰-Day10/","link":"","permalink":"https://vincent.fishboneapps.com/2018/06/21/React-Native-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day10/","excerpt":"","text":"程式碼再利用 - 編輯和建立 重複使用 Employee Form 修改 src/components/ListItem.js，點擊 row 就會導向新增的頁面 123456789101112131415161718192021222324import &#123; Text, TouchableWithoutFeedback, View &#125; from &#x27;react-native&#x27;;import &#123; Actions &#125; from &#x27;react-native-router-flux&#x27;;class ListItem extends Component &#123; onRowPress() &#123; Actions.employeeCreate(&#123; employee: this.props.employee &#125;); &#125; render() &#123; const &#123; name &#125; = this.props.employee; return ( &lt;TouchableWithoutFeedback onPress=&#123;this.onRowPress.bind(this)&#125;&gt; &lt;View&gt; &lt;CardSection&gt; &lt;Text style=&#123;styles.titleStyle&#125;&gt; &#123;name&#125; &lt;/Text&gt; &lt;/CardSection&gt; &lt;/View&gt; &lt;/TouchableWithoutFeedback&gt; ); &#125;&#125; 建立表單 v.s. 編輯表單 編輯表單的方式 使用者導向編輯表單 EmployeeFormReducer 是空的 表單是空的 我們必須要在 FormReducer 預載入 state 使用者編輯表單 - 我們不改變任何 employee 的 model 使用者送出表單 我們從 reducer 儲存資料 可重複使用的表單 新增 src/components/EmployeeForm.js，將本來在 EmployeeCreate.js 的三個 cardSection 分離到 EmployeeForm.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123; View, Text, Picker &#125; from &#x27;react-native&#x27;;import &#123; connect &#125; from &#x27;react-redux&#x27;;import &#123; employeeUpdate &#125; from &quot;../actions&quot;;import &#123; CardSection, Input &#125; from &quot;./common&quot;;class EmployeeForm extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;CardSection&gt; &lt;Input label=&quot;Name&quot; placeholder=&quot;Jane&quot; value=&#123;this.props.name&#125; onChangeText=&#123;value =&gt; this.props.employeeUpdate(&#123; prop: &#x27;name&#x27;, value &#125;)&#125; /&gt; &lt;/CardSection&gt; &lt;CardSection&gt; &lt;Input label=&quot;Phone&quot; placeholder=&quot;555-555-5555&quot; value=&#123;this.props.phone&#125; onChangeText=&#123;value =&gt; this.props.employeeUpdate(&#123; prop: &#x27;phone&#x27;, value &#125;)&#125; /&gt; &lt;/CardSection&gt; &lt;CardSection style=&#123;&#123; flexDirection: &#x27;column&#x27; &#125;&#125;&gt; &lt;Text style=&#123;styles.pickerTextStyle&#125;&gt;Shift&lt;/Text&gt; &lt;Picker selectedValue=&#123;this.props.shift&#125; onValueChange=&#123;value =&gt; this.props.employeeUpdate(&#123; prop: &#x27;shift&#x27;, value &#125;)&#125; &gt; &lt;Picker.Item label=&quot;Monday&quot; value=&quot;Monday&quot; /&gt; &lt;Picker.Item label=&quot;Tuesday&quot; value=&quot;Tuesday&quot; /&gt; &lt;Picker.Item label=&quot;Wednesday&quot; value=&quot;Wednesday&quot; /&gt; &lt;Picker.Item label=&quot;Thursday&quot; value=&quot;Thursday&quot; /&gt; &lt;Picker.Item label=&quot;Friday&quot; value=&quot;Friday&quot; /&gt; &lt;Picker.Item label=&quot;Saturday&quot; value=&quot;Saturday&quot; /&gt; &lt;Picker.Item label=&quot;Sunday&quot; value=&quot;Sunday&quot; /&gt; &lt;/Picker&gt; &lt;/CardSection&gt; &lt;/View&gt; ); &#125;&#125;const styles = &#123; pickerTextStyle: &#123; fontSize: 18, paddingLeft: 20 &#125;&#125;;const mapStateToProps = (state) =&gt; &#123; const &#123; name, phone, shift &#125; = state.employeeForm; return &#123; name, phone, shift &#125;;&#125;;export default connect(mapStateToProps, &#123; employeeUpdate &#125;)(EmployeeForm); 修改 src/components/EmployeeCreate.js，引入剛剛分離的 EmployeeForm.js，這邊所使用的 ...this.props 是把在 Create 表單的所有 state 都傳入 EmployeeForm 1234567891011import &#123; Card, CardSection, Button &#125; from &quot;./common&quot;;import EmployeeForm from &#x27;./EmployeeForm&#x27;;&lt;Card&gt; &lt;EmployeeForm &#123;...this.props&#125; /&gt; &lt;CardSection&gt; &lt;Button onPress=&#123;this.onButtonPress.bind(this)&#125;&gt; Create &lt;/Button&gt; &lt;/CardSection&gt;&lt;/Card&gt; 獨立的 Employee 編輯表單 新增 src/components/EmployeeEdit.js 123456789101112131415161718192021import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123; connect &#125; from &#x27;react-redux&#x27;;import EmployeeForm from &#x27;./EmployeeForm&#x27;;import &#123; Card, CardSection, Button &#125; from &quot;./common&quot;;class EmployeeEdit extends Component &#123; render() &#123; return( &lt;Card&gt; &lt;EmployeeForm /&gt; &lt;CardSection&gt; &lt;Button&gt; Save Changes &lt;/Button&gt; &lt;/CardSection&gt; &lt;/Card&gt; ); &#125;&#125;export default connect()(EmployeeEdit); 我們現在要為編輯 Employee 進行客製化，這代表兩件事情 我們必須確定這個表單總是和某一個 Employee 一起導向，然後載入那個 Employee 的資料到 Form Reducer，這就是表單一打開的初始值 我們要新增另外一個 Action Creator 來更新特定 Employee 從 State 初始化表單 修改 src/Router.js 新增 Scene 123import EmployeeEdit from &#x27;./components/EmployeeEdit&#x27;;&lt;Scene key=&quot;employeeEdit&quot; component=&#123;EmployeeEdit&#125; title=&quot;Edit Employee&quot; /&gt; 修改 src/components/ListItem.js 的 Action，點擊 row 之後會導向編輯 Employee 的頁面 Actions.employeeEdit(&#123; employee: this.props.employee &#125;); 修改 src/components/EmployeeEdit.js 將預設值載入，並測試按鈕送出的值是否正確 12345678910111213141516171819202122import _ from &#x27;lodash&#x27;;import &#123; employeeUpdate &#125; from &quot;../actions&quot;;componentWillMount() &#123; _.each(this.props.employee, (value, prop) =&gt; &#123; this.props.employeeUpdate(&#123; prop, value &#125;); &#125;); &#125; onButtonPress() &#123; const &#123; name, phone, shift &#125; = this.props; console.log(name, phone, shift); &#125;&#125;const mapStateToProps = (state) =&gt; &#123; const &#123; name, phone, shift &#125; = state.employeeForm; return &#123; name, phone, shift &#125;;&#125;;export default connect(mapStateToProps, &#123; employeeUpdate &#125;)(EmployeeEdit); 更新 Firebase 的紀錄 在 src/actions/EmployeeActions.js 新增一個新的 Action 123456789export const employeeSave = (&#123; name, phone, shift, uid &#125;) =&gt; &#123; const &#123; currentUser &#125; = firebase.auth(); return () =&gt; &#123; firebase.database().ref(`/users/$&#123;currentUser.uid&#125;/employees/$&#123;uid&#125;`) .set(&#123; name, phone, shift &#125;) .then(() =&gt; console.log(&#x27;saved!&#x27;)); &#125;;&#125;; 修改 src/components/EmployeeEdit.js 讓點擊 Button 之後啟動 employeeSave 的 Action 1234567891011import &#123; employeeUpdate, employeeSave &#125; from &quot;../actions&quot;;onButtonPress() &#123; const &#123; name, phone, shift &#125; = this.props; this.props.employeeSave(&#123;name, phone, shift, uid: this.props.employee.uid &#125;);&#125;export default connect(mapStateToProps, &#123; employeeUpdate, employeeSave&#125;)(EmployeeEdit); 清除表單屬性 在 src/actions/types.js 新增 EMPLOYEE_SAVE_SUCCESS export const EMPLOYEE_SAVE_SUCCESS = 'employee_save_success'; 修改 src/actions/EmployeeActions.js 讓畫面返回並清空資料 12345678910111213import &#123; EMPLOYEES_FETCH_SUCCESS, EMPLOYEE_SAVE_SUCCESS&#125; from &#x27;./types&#x27;return () =&gt; &#123; firebase.database().ref(`/users/$&#123;currentUser.uid&#125;/employees/$&#123;uid&#125;`) .set(&#123; name, phone, shift &#125;) .then(() =&gt; &#123; dispatch( &#123;type: EMPLOYEE_SAVE_SUCCESS&#125;); Actions.pop() &#125;);&#125;; 修改 src/reducers/EmployeeFromReducer.js 讓 Reducer 變回起始值 1234567import &#123; EMPLOYEE_CREATE, EMPLOYEE_SAVE_SUCCESS&#125; from &#x27;../actions/types&#x27;;case EMPLOYEE_SAVE_SUCCESS: return INITIAL_STATE; 在 Employees 傳送訊息 React-Native-Communications 套件 修改 src/components/EmployeeEdit.js，點擊按鈕之後會傳送訊息給該 Employee 12345678910111213import Communications from &#x27;react-native-communications&#x27;;onTextPress() &#123; const &#123; phone, shift &#125; = this.props; Communications.text(phone, `Your upcoming shift is on $&#123;shift&#125;`);&#125;&lt;CardSection&gt; &lt;Button onPress=&#123;this.onTextPress.bind(this)&#125;&gt; Text Schedule &lt;/Button&gt;&lt;/CardSection&gt; Modals 作為可重複使用的元件 Modal 官方文件 新增 src/components/common/Confirm.js 12345678910import React from &#x27;react&#x27;;import &#123; Text, View, Modal &#125; from &#x27;react-native&#x27;;import &#123; CardSection &#125; from &quot;./CardSection&quot;;import &#123; Button &#125; from &quot;./Button&quot;;const Confirm = () =&gt; &#123; &#125;;export &#123; Confirm &#125;; 在 src/components/common/index.js 新增 export * from './Confirm'; 設定 Modal 呈現的資料 1234567891011121314151617181920const Confirm = (&#123; children, visible, onAccept, onDecline &#125;) =&gt; &#123; return ( &lt;Modal visible=&#123;visible&#125; transparent animationType=&quot;slide&quot; onRequestClose=&#123;() =&gt; &#123;&#125;&#125; &gt; &lt;View&gt; &lt;CardSection&gt; &lt;Text&gt;&#123;children&#125;&lt;/Text&gt; &lt;/CardSection&gt; &lt;CardSection&gt; &lt;Button onPress=&#123;onAccept&#125;&gt;Yes&lt;/Button&gt; &lt;Button onPress=&#123;onDecline&#125;&gt;No&lt;/Button&gt; &lt;/CardSection&gt; &lt;/View&gt; &lt;/Modal&gt; );&#125;; Modal 樣式 在 src/components/common/Confirm.js 新增樣式 12345678910111213141516171819202122232425262728293031const Confirm = (&#123; children, visible, onAccept, onDecline &#125;) =&gt; &#123; const &#123; containerStyle, textStyle, cardSectionStyle &#125; = styles; return ( ... &lt;View style=&#123;containerStyle&#125;&gt; &lt;CardSection style=&#123;cardSectionStyle&#125;&gt; &lt;Text style=&#123;textStyle&#125;&gt; &#123;children&#125; ... );&#125;;const styles = &#123; cardSectionStyle: &#123; justifyContent: &#x27;center&#x27;, &#125;, textStyle: &#123; flex: 1, fontSize: 18, textAlign: &#x27;center&#x27;, lineHeight: 40 &#125;, containerStyle: &#123; backgroundColor: &#x27;rgba(0, 0, 0, 0.75)&#x27;, position: &#x27;relative&#x27;, flex: 1, justifyContent: &#x27;center&#x27;, &#125;&#125;; 在 src/components/EmployeeEdit.js 新增元件 1234567891011121314151617import &#123; Card, CardSection, Button, Confirm &#125; from &quot;./common&quot;;class EmployeeEdit extends Component &#123; state = &#123; showModal: false &#125;; &lt;CardSection&gt; &lt;Button onPress=&#123;() =&gt; this.setState(&#123; showModal: !this.state.showModal &#125;)&#125;&gt; Fire Employee &lt;/Button&gt; &lt;/CardSection&gt; &lt;Confirm visible=&#123;this.state.showModal&#125; &gt; Are you sure you want to delete this? &lt;/Confirm&gt;&#125; Employee 刪除的 Action Creator 在 src/components/EmployeeEdit.js 新增 Decline 和 Accept 的 helper 12345678910111213onAccept() &#123;&#125;onDecline() &#123; this.setState(&#123; showModal: false &#125;);&#125;&lt;Confirm visible=&#123;this.state.showModal&#125; onAccept=&#123;this.onAccept.bind(this)&#125; onDecline=&#123;this.onDecline.bind(this)&#125;&gt; 在 src/actions/EmployeeActions.js 新增 delete 的 function 1234567891011export const employeeDelete = (&#123; uid &#125;) =&gt; &#123; const &#123; currentUser &#125; = firebase.auth(); return () =&gt; &#123; firebase.database().ref(`/users/$&#123;currentUser.uid&#125;/employees/$&#123;uid&#125;`) .remove() .then(() =&gt; &#123; Actions.pop() &#125;); &#125;&#125;; 完成 Employee Delete 修改 src/components/EmployeeEdit.js 將 Accept function 完成 1234567891011import &#123; employeeUpdate, employeeSave, employeeDelete &#125; from &quot;../actions&quot;;onAccept() &#123; const &#123; uid &#125; = this.props.employee; this.props.employeeDelete(&#123; uid &#125;);&#125;export default connect(mapStateToProps, &#123; employeeUpdate, employeeSave, employeeDelete&#125;)(EmployeeEdit); 完成課程","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"https://vincent.fishboneapps.com/tags/React-Native/"}]},{"title":"React Native 快速學習自我挑戰 Day9","slug":"React-Native-快速學習自我挑戰-Day9","date":"2018-06-19T09:20:04.000Z","updated":"2020-06-22T17:22:55.771Z","comments":true,"path":"2018/06/19/React-Native-快速學習自我挑戰-Day9/","link":"","permalink":"https://vincent.fishboneapps.com/2018/06/19/React-Native-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day9/","excerpt":"","text":"使用 Firebase 當作資料儲藏庫 Firebase JSON 架構 Firebase 的資料庫會有 Users 的 Collection，然後個別的 User 會有自己的 Employees 的 Collection 在 Authentication 的使用者並不會自己新增到資料庫，需要自己手動新增，它們是兩個分離的系統 Firebase 的資料安全 預設中，只要用戶登入之後，就可以存取所有資料庫的資料，所以我們要修改這個部分 修改 database 中的 rule 12345678910&#123; &quot;rules&quot;: &#123; &quot;users&quot;: &#123; &quot;$uid&quot;: &#123; &quot;.read&quot;: &quot;$uid === auth.uid&quot;, &quot;.write&quot;: &quot;$uid === auth.uid&quot; &#125; &#125; &#125;&#125; 使用 Firebase 建立紀錄 在建立 employees 的頁面，連結按鈕，然後產生 action 來儲存記錄到 Firebase，最後畫面返回到 Employess 列表的頁面，我們新增的 employee 就會出現在列表上 在 src/components/EmployeeCreate.js 的 button 連結 employeeCreate 的事件 123456789101112131415import &#123; employeeUpdate, employeeCreate &#125; from &quot;../actions&quot;;onButtonPress() &#123; const &#123; name, phone, shift &#125; = this.props; this.props.employeeCreate(&#123; name, phone, shift &#125;);&#125;&lt;Button onPress=&#123;this.onButtonPress.bind(this)&#125;&gt; Create&lt;/Button&gt;export default connect(mapStateToProps, &#123; employeeUpdate, employeeCreate&#125;)(EmployeeCreate); 在 src/actions/EmployeeActions.js 新增 employeeCreate 的 action，並用 console.log 讀出三個值，實際在模擬器上面會發現 shift 的值是 empty，沒辦法出現，問題在下一章會解決 123export const employeeCreate = (&#123; name, phone, shift &#125;) =&gt; &#123; console.log(name, phone, shift);&#125;; 預設 Form 值 修改 src/components/employeeCreate.js 如果 shift 為空值則傳回 Monday this.props.employeeCreate(&#123; name, phone, shift: shift || 'Monday' &#125;); 成功地儲存資料到 Firebase 修改 src/actions/EmployeeActions.js 將資料傳送到 Firebase 12345678import firebase from &#x27;firebase&#x27;;export const employeeCreate = (&#123; name, phone, shift &#125;) =&gt; &#123; const &#123; currentUser &#125; = firebase.auth(); firebase.database().ref(`/users/$&#123;currentUser.uid&#125;/employees`) .push(&#123; name, phone, shift &#125;);&#125;; 重設表單屬性 修改 src/actions/EmployeeActions.js 在 Action 儲存完資料之後，返回本來的頁面 123456789import &#123; Actions &#125; from &#x27;react-native-router-flux&#x27;;return () =&gt; &#123; firebase.database().ref(`/users/$&#123;currentUser.uid&#125;/employees`) .push(&#123;name, phone, shift&#125;) .then(() =&gt; &#123; Actions.pop() &#125;);&#125;; 修改 src/actions/EmployeeActions.js 新增 EMPLOYEE_CREATE 讓資料送出之後，預設值變為空值 12345678910111213import &#123; EMPLOYEE_UPDATE, EMPLOYEE_CREATE&#125; from &#x27;./types&#x27;return (dispatch) =&gt; &#123; firebase.database().ref(`/users/$&#123;currentUser.uid&#125;/employees`) .push(&#123;name, phone, shift&#125;) .then(() =&gt; &#123; dispatch( &#123;type: EMPLOYEE_CREATE &#125; ); Actions.pop() &#125;);&#125;; 在 src/actions/types.js 新增 EMPLOYEE_CREATE export const EMPLOYEE_CREATE = 'employee_create'; 修改 \bsrc/reducers/EmployeeFormReducer.js 傳回預設值 1234567import &#123; EMPLOYEE_UPDATE, EMPLOYEE_CREATE&#125; from &#x27;../actions/types&#x27;;case EMPLOYEE_CREATE: return INITIAL_STATE; 從 Firebase 取得資料 修改 src/actions/EmployeeActions.js 新增 employeesFetch 來取得資料 12345678910111213141516import &#123; EMPLOYEE_UPDATE, EMPLOYEE_CREATE, EMPLOYEES_FETCH_SUCCESS&#125; from &#x27;./types&#x27;export const employeesFetch = () =&gt; &#123; const &#123; currentUser &#125; = firebase.auth(); return (dispatch) =&gt; &#123; firebase.database().ref(`/users/$&#123;currentUser.uid&#125;/employees`) .on(&#x27;value&#x27;, snapshot =&gt; &#123; dispatch(&#123; type: EMPLOYEES_FETCH_SUCCESS, payload: snapshot.val()&#125; ); &#125;); &#125;;&#125;; 在 src/actions/types.js 新增 EMPLOYEES_FETCH_SUCCESS export const EMPLOYEES_FETCH_SUCCESS = 'employees_fetch_success'; 藉由 ID 儲存資料 修改 src/components/EmployList.js 在讀取之前，呼叫 employeesFetch 的 action 12345678import &#123; connect &#125; from &#x27;react-redux&#x27;;import &#123; employeesFetch &#125; from &quot;../actions&quot;;componentWillMount() &#123; this.props.employeesFetch();&#125;export default connect(null, &#123; employeesFetch &#125;)(EmployeeList); 新增 src/reducers/EmployeeReducer.js 123456789101112131415import &#123; EMPLOYEES_FETCH_SUCCESS&#125; from &quot;../actions/types&quot;;const INITIAL_STATE = &#123;&#125;;export default (state = INITIAL_STATE, action) =&gt; &#123; switch (action.type) &#123; case EMPLOYEES_FETCH_SUCCESS: // return &#123; ...state, [id]: action.payload &#125;; (用 id 的方式處理) return action.payload; default: return state; &#125;&#125;; 在 src/reducers/index.js 新增 EmployeeReducer 123import EmployeeReducer from &#x27;./EmployeeReducer&#x27;;employees: EmployeeReducer 建立動態 DataSource 修改 src/components/EmployeeList.js，新增一個 createDataSource 的 function，如果使用把 dataSoure 的 function 放在 componentWillMount，在翻頁的時候，東西就會不見，所以新增一個 function 來處理它 1234567891011121314151617181920212223import &#123; ListView, View, Text &#125; from &#x27;react-native&#x27;;componentWillMount() &#123; this.props.employeesFetch(); this.createDataSource(this.props);&#125;componentWillReceiveProps(nextProps) &#123; // nextProps are the next set of props that this component // will be rendered with // this.props is still the old set of props this.createDataSource(nextProps);&#125;createDataSource(&#123; employees &#125;) &#123; const ds = new ListView.DataSource(&#123; rowHasChanged: (r1, r2) =&gt; r1 !== r2 &#125;); this.dataSource = ds.cloneWithRows(employees);&#125; 把物件轉成陣列 安裝 lodash npm install --save lodash 修改 src/components/EmployeeList.js 用 lodash 將物件轉成陣列 1234567891011import _ from &#x27;lodash&#x27;;const mapStateToProps = state =&gt; &#123; const employees = _.map(state.employees, (val, uid) =&gt; &#123; return &#123; ...val, uid &#125;; // &#123; shift: &#x27;Monday&#x27;, name: &#x27;S&#x27;, id&quot; &#x27;1j2j34&#x27; &#125;; &#125;); return &#123; employees &#125;;&#125;;export default connect(mapStateToProps, &#123; employeesFetch &#125;)(EmployeeList); 在 Employee List 建立 List 修改 src/components/EmployeeList.js 把資料讀出來 1234567891011121314151617import &#123; ListView &#125; from &#x27;react-native&#x27;;import ListItem from &#x27;./ListItem&#x27;;renderRow(employee) &#123; return &lt;ListItem employee=&#123;employee&#125; /&gt;;&#125;render() &#123; console.log(this.props); return ( &lt;ListView enableEmptySections dataSource=&#123;this.dataSource&#125; renderRow=&#123;this.renderRow&#125; /&gt; );&#125; 新增 src/components/ListItem.js 1234567891011121314151617181920212223242526import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123; Text &#125; from &#x27;react-native&#x27;;import &#123; CardSection &#125; from &#x27;./common&#x27;;class ListItem extends Component &#123; render() &#123; const &#123; name &#125; = this.props.employee; return ( &lt;CardSection&gt; &lt;Text style=&#123;styles.titleStyle&#125;&gt; &#123;name&#125; &lt;/Text&gt; &lt;/CardSection&gt; ); &#125;&#125;const styles = &#123; titleStyle: &#123; fontSize: 18, paddingLeft: 15 &#125;&#125;;export default ListItem;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"https://vincent.fishboneapps.com/tags/React-Native/"}]},{"title":"React Native 快速學習自我挑戰 Day8","slug":"React-Native-快速學習自我挑戰-Day8","date":"2018-06-15T08:37:05.000Z","updated":"2020-06-22T17:22:52.598Z","comments":true,"path":"2018/06/15/React-Native-快速學習自我挑戰-Day8/","link":"","permalink":"https://vincent.fishboneapps.com/2018/06/15/React-Native-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day8/","excerpt":"","text":"讓使用者到處導航 處理導航列 安裝套件 npm i --save react-native-router-flux Router 裡面的導覽列 新增 src/Router.js 123456789101112131415import React from &#x27;react&#x27;;import &#123; Scene, Router &#125; from &#x27;react-native-router-flux&#x27;;import LoginForm from &#x27;./components/LoginForm&#x27;;const RouterComponent = () =&gt; &#123; return ( &lt;Router&gt; &lt;Scene key=&quot;root&quot;&gt; &lt;Scene key=&quot;login&quot; component=&#123;LoginForm&#125; title=&quot;Please Login&quot; /&gt; &lt;/Scene&gt; &lt;/Router&gt; );&#125;;export default RouterComponent; 在 src/App.js 將 Router 引入並使用 12345import Router from &#x27;./Router&#x27;;&lt;Provider store=&#123;store&#125;&gt; &lt;Router /&gt;&lt;/Provider&gt; 顯示多個 Scenes 新增 src/components/EmployeeList.js 123456789101112131415161718import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123; View, Text &#125; from &#x27;react-native&#x27;;class EmployeeList extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;Text&gt;EmployList&lt;/Text&gt; &lt;Text&gt;EmployList&lt;/Text&gt; &lt;Text&gt;EmployList&lt;/Text&gt; &lt;Text&gt;EmployList&lt;/Text&gt; &lt;Text&gt;EmployList&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;export default EmployeeList; 在 src/Router.js 新增 EmployeeList 的 Scene 1234import EmployeeList from &#x27;./components/EmployeeList&#x27;;&lt;Scene key=&quot;logoin&quot; component=&#123;LoginForm&#125; title=&quot;Please Login&quot; initial/&gt;&lt;Scene key=&quot;employeeList&quot; component=&#123;EmployeeList&#125; title=&quot;Employees&quot; /&gt; 在路由之間移動導覽列 在 src/Actions/index.js 使用 Router 的 Actions 功能 12345678910import &#123; Actions &#125; from &#x27;react-native-router-flux&#x27;;const loginUserSuccess = (dispatch, user) =&gt; &#123; dispatch(&#123; type: LOGIN_USER_SUCCESS, payload: user &#125;); Actions.employeeList();&#125;; 使用 Buckets 分類 Scenes 在 src/Router.js 將路由分類 12345678&lt;Scene key=&quot;root&quot; hideNavBar&gt; &lt;Scene key=&quot;auth&quot;&gt; &lt;Scene key=&quot;logoin&quot; component=&#123;LoginForm&#125; title=&quot;Please Login&quot; initial/&gt; &lt;/Scene&gt; &lt;Scene key=&quot;main&quot;&gt; &lt;Scene key=&quot;employeeList&quot; component=&#123;EmployeeList&#125; title=&quot;Employees&quot; /&gt; &lt;/Scene&gt;&lt;/Scene&gt; 在 src/Actions/index.js 修改 Actions 12345678const loginUserSuccess = (dispatch, user) =&gt; &#123; dispatch(&#123; type: LOGIN_USER_SUCCESS, payload: user &#125;); Actions.main();&#125;; 導覽列按鈕 修改 src/Router.js 123456789&lt;Scene key=&quot;main&quot;&gt; &lt;Scene rightTitle=&quot;Add&quot; onRight=&#123;() =&gt; &#123; console.log(&#x27;right!!!&#x27;) &#125;&#125; key=&quot;employeeList&quot; component=&#123;EmployeeList&#125; title=&quot;Employees&quot; /&gt;&lt;/Scene&gt; 導航至 Employee Creation Form 新增 src/components/EmployeeCreate.js 1234567891011121314import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123; View, Text &#125; from &#x27;react-native&#x27;;class EmployeeCreate extends Component &#123; render() &#123; return( &lt;View&gt; &lt;Text&gt;Employee From&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;export default EmployeeCreate; 在 src/Router.js 新增並連結 employeeCreate Scene 1234567891011121314import &#123; Scene, Router, Actions &#125; from &#x27;react-native-router-flux&#x27;;import EmployeeCreate from &#x27;./components/EmployeeCreate&#x27;;&lt;Scene key=&quot;main&quot;&gt; &lt;Scene rightTitle=&quot;Add&quot; onRight=&#123;() =&gt; Actions.employeeCreate() &#125; key=&quot;employeeList&quot; component=&#123;EmployeeList&#125; title=&quot;Employees&quot; initial /&gt; &lt;Scene key=&quot;employeeCreate&quot; component=&#123;EmployeeCreate&#125; title=&quot;Create Employee&quot; /&gt;&lt;/Scene&gt; 建立 Employee Creation Form 修改 src/components/EmployeeCreate.js 123456789101112131415161718192021222324252627282930313233import &#123; Card, CardSection, Input, Button &#125; from &quot;./common&quot;;class EmployeeCreate extends Component &#123; render() &#123; return( &lt;Card&gt; &lt;CardSection&gt; &lt;Input label=&quot;Name&quot; placeholder=&quot;Jane&quot; /&gt; &lt;/CardSection&gt; &lt;CardSection&gt; &lt;Input label=&quot;Phone&quot; placeholder=&quot;555-555-5555&quot; /&gt; &lt;/CardSection&gt; &lt;CardSection&gt; &lt;/CardSection&gt; &lt;CardSection&gt; &lt;Button&gt; Create &lt;/Button&gt; &lt;/CardSection&gt; &lt;/Card&gt; ); &#125;&#125; Employee Form Actions 在 src/actions/types.js 新增 EMPLOYEE_UPDATE export const EMPLOYEE_UPDATE = 'employee_update'; 新增 src/actions/EmployeeActions.js 12345678910import &#123; EMPLOYEE_UPDATE&#125; from &#x27;./types&#x27;export const employeeUpdate = (&#123; prop, value &#125;) =&gt; &#123; return &#123; type: EMPLOYEE_UPDATE, payload: &#123; prop, value &#125; &#125;;&#125;; 新增 src/reducers/EmployeeFormReducer.js 123456789101112import &#123; EMPLOYEE_UPDATE&#125; from &#x27;../actions/types&#x27;;const INITIAL_STATE = &#123;&#125;;export default (state = INITIAL_STATE, action) =&gt; &#123; switch (action.type) &#123; default: return state; &#125;&#125;; 在 Reducer 的層次來處理 Form Update 修改 src/reducers/EmployeeFormReducer.js 12345678910111213141516const INITIAL_STATE = &#123; name: &#x27;&#x27;, phone: &#x27;&#x27;, shift: &#x27;&#x27;&#125;;export default (state = INITIAL_STATE, action) =&gt; &#123; switch (action.type) &#123; case EMPLOYEE_UPDATE: // action.payload === &#123; prop: &#x27;name&#x27;, value: &#x27;jane&#x27; &#125; return &#123; ...state, [action.payload.prop]: action.payload.value &#125; default: return state; &#125;&#125;; 新增 src/actions/AuthActions.js 並將 index.js 的內容全部剪貼過去 將其它 Actions 在 src/actions/index.js 輸出 12export * from &#x27;./AuthActions&#x27;;export * from &#x27;./EmployeeActions&#x27;; 動態 Property 更新 修改 src/reducers/index.js 12345import EmployeeFromReducer from &#x27;./EmployeeFromReducer&#x27;;export default combineReducers(&#123; employeeForm: EmployeeFromReducer&#125;); 修改 src/components/EmployeeCreate.js 跟 Actions 做連結 12345678910111213141516171819202122232425262728import &#123; connect &#125; from &#x27;react-redux&#x27;;import &#123; employeeUpdate &#125; from &quot;../actions&quot;;&lt;CardSection&gt; &lt;Input label=&quot;Name&quot; placeholder=&quot;Jane&quot; value=&#123;this.props.name&#125; onChangeText=&#123;value =&gt; this.props.employeeUpdate(&#123; prop: &#x27;name&#x27;, value &#125;)&#125; /&gt;&lt;/CardSection&gt;&lt;CardSection&gt; &lt;Input label=&quot;Phone&quot; placeholder=&quot;555-555-5555&quot; value=&#123;this.props.phone&#125; onChangeText=&#123;value =&gt; this.props.employeeUpdate(&#123; prop: &#x27;phone&#x27;, value &#125;)&#125; /&gt;&lt;/CardSection&gt;const mapStateToProps = (state) =&gt; &#123; const &#123; name, phone, shift &#125; = state.employeeForm; return &#123; name, phone, shift &#125;;&#125;;export default connect(mapStateToProps, &#123; employeeUpdate &#125;)(EmployeeCreate); Picker 元件 修改 src/components/EmployeeCreate.js 引入 Picker 元件 1234567891011121314151617import &#123; Picker &#125; from &#x27;react-native&#x27;;&lt;CardSection&gt; &lt;Picker style=&#123;&#123; flex: 1 &#125;&#125; selectedValue=&#123;this.props.shift&#125; onValueChange=&#123;value =&gt; this.props.employeeUpdate(&#123; prop: &#x27;shift&#x27;, value &#125;)&#125; &gt; &lt;Picker.Item label=&quot;Monday&quot; value=&quot;Monday&quot; /&gt; &lt;Picker.Item label=&quot;Tuesday&quot; value=&quot;Tuesday&quot; /&gt; &lt;Picker.Item label=&quot;Wednesday&quot; value=&quot;Wednesday&quot; /&gt; &lt;Picker.Item label=&quot;Thursday&quot; value=&quot;Thursday&quot; /&gt; &lt;Picker.Item label=&quot;Friday&quot; value=&quot;Friday&quot; /&gt; &lt;Picker.Item label=&quot;Saturday&quot; value=&quot;Saturday&quot; /&gt; &lt;Picker.Item label=&quot;Sunday&quot; value=&quot;Sunday&quot; /&gt; &lt;/Picker&gt;&lt;/CardSection&gt; Pickers 和樣式覆蓋 修改 src/components/EmployeeCreate.js 新增樣式 123456789101112import &#123; Picker, Text &#125; from &#x27;react-native&#x27;;&lt;CardSection style=&#123;&#123; flexDirection: &#x27;column&#x27; &#125;&#125;&gt; &lt;Text style=&#123;styles.pickerTextStyle&#125;&gt;Shift&lt;/Text&gt;&lt;/CardSection&gt;const styles = &#123; pickerTextStyle: &#123; fontSize: 18, paddingLeft: 20 &#125;&#125;; 修改 src/components/common/CardSection.js，讓它從上一層取得樣式，陣列裡面的樣式，右邊的會覆蓋左邊的 123&lt;View style=&#123;[styles.containerStyle, props.style]&#125;&gt; &#123;props.children&#125;&lt;/View&gt;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"https://vincent.fishboneapps.com/tags/React-Native/"}]},{"title":"React Native 快速學習自我挑戰 Day7","slug":"React-Native-快速學習自我挑戰-Day7","date":"2018-06-12T01:51:47.000Z","updated":"2020-06-22T17:22:49.850Z","comments":true,"path":"2018/06/11/React-Native-快速學習自我挑戰-Day7/","link":"","permalink":"https://vincent.fishboneapps.com/2018/06/11/React-Native-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day7/","excerpt":"","text":"還沒完成 下一個 App 的概覽 這個篇章要講 Navigation，開啟一個新專案 react-native init manager 這個 App 的挑戰 需要使用在登入畫面使用 Redux-ify Header 的內容需要隨著螢幕去改變 每一個使用者都應該要有自己的內容 需要能夠打入文字 需要全螢幕的 overlay 再稍微做一下設定 安裝 react-redux 和 redux 套件，記得 react-redux 是用來串聯 react 和 redux 的套件 npm install --save react-redux redux 修改根目錄的 index.js 1234import &#123; AppRegistry &#125; from &#x27;react-native&#x27;;import App from &#x27;./src/App&#x27;;AppRegistry.registerComponent(&#x27;manager&#x27;, () =&gt; App); 新增 src/App.js 1234567891011121314151617181920import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123; View, Text &#125; from &#x27;react-native&#x27;;import &#123; Provider &#125; from &#x27;react-redux&#x27;;import &#123; createStore &#125; from &#x27;redux&#x27;;class App extends Component &#123; render() &#123; return ( &lt;Provider store=&#123;createStore()&#125;&gt; &lt;View&gt; &lt;Text&gt; Hello! &lt;/Text&gt; &lt;/View&gt; &lt;/Provider&gt; ); &#125;&#125;export default App; 更多模板設定 新增預設的 reducer，新增 src/reducers/index.js 12345import &#123; combineReducers &#125; from &#x27;redux&#x27;;export default combineReducers(&#123; banana: () =&gt; []&#125;); 在 src/App.js 引入 reducer 並使用它 123import reducers from &#x27;./reducers&#x27;;&lt;Provider store=&#123;createStore(reducers)&#125;&gt; 安裝 Firebase npm install --save firebase 在 src/App.js 引入 firebase 並載入設定檔案 1234567891011121314import firebase from &#x27;firebase&#x27;;componentWillMount() &#123; const config = &#123; apiKey: &#x27;&#x27;, authDomain: &#x27;&#x27;, databaseURL: &#x27;&#x27;, projectId: &#x27;&#x27;, storageBucket:&#x27;&#x27;, messagingSenderId: &#x27;&#x27; &#125;; firebase.initializeApp(config);&#125; 處理資料 React 和 Redux 做比較 在 Redux 世界的登入表單 登入表單的四個 component state email password loading error state 的傳遞方式，「email」、「password」=&gt; 登入確認 =&gt; 「loading」、「error」 重建登入表單 複製上一個專案的 src/components/common 到 src/components/common 新增 src/components/LoginForm.js 123456789101112131415161718192021222324252627282930import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123; Card, CardSection, Input, Button &#125; from &#x27;./common&#x27;;class LoginForm extends Component &#123; render() &#123; return ( &lt;Card&gt; &lt;CardSection&gt; &lt;Input label=&quot;Email&quot; placeholder=&quot;email@gmail.com&quot; /&gt; &lt;/CardSection&gt; &lt;CardSection&gt; &lt;Input label=&quot;Password&quot; placeholder=&quot;password&quot; /&gt; &lt;/CardSection&gt; &lt;CardSection&gt; &lt;Button&gt; Login &lt;/Button&gt; &lt;/CardSection&gt; &lt;/Card&gt; ); &#125;&#125;export default LoginForm; 在 App.js 引入 LoginForm，然後使用 LoginForm 123456789import LoginForm from &#x27;./components/LoginForm&#x27;;render() &#123; return ( &lt;Provider store=&#123;createStore(reducers)&#125;&gt; &lt;LoginForm/&gt; &lt;/Provider&gt; );&#125; 使用 Action Creators 來處理表單更新 Redux 運作的邏輯 使用者輸入內容 使用新文字來呼叫 Action Creator Action Creator 回傳一個 Action Action 傳送給所有 Reducers Reducers 計算新的 State State 傳送給所有 Componenets Components 重新渲染新的畫面 等待新的改變…回到第一個動作 在 src/components/LoginForm.js 的 Email Input 新增 onChange 事件 12345&lt;Input label=&quot;Email&quot; placeholder=&quot;email@gmail.com&quot; onChangeText=&#123;this.onEmailChange.bind(this)&#125;/&gt; 在 src/components/LoginForm.js 將 onChange 事件獨立 123onEmailChange(text) &#123;&#125; 新增 src/actions/index.js 新增 emailChanged 的 Action Creator 123456export const emailChanged = (text) =&gt; &#123; return &#123; type: &#x27;email_changed&#x27;, payload: text &#125;;&#125;; 完成 Action Creator 在 src/components/LoginForm.js 跟 Action Creator 做連結 12345678import &#123; connect &#125; from &#x27;react-redux&#x27;;import &#123; emailChanged &#125; from &quot;../actions&quot;;onEmailChange(text) &#123; this.props.emailChanged(text)&#125;export default connect(null, &#123; emailChanged &#125;)(LoginForm); 修改 src/reducers/index.js 123456import &#123; combineReducers &#125; from &#x27;redux&#x27;;import AuthReducer from &#x27;./AuthReducer&#x27;;export default combineReducers(&#123; auth: AuthReducer&#125;); 新增 src/reducers/AuthReducer.js 12345678const INITIAL_STATE = &#123; email: &#x27;&#x27; &#125;;export default (state = INITIAL_STATE, action) =&gt; &#123; switch (action.type) &#123; default: return state; &#125;&#125; Typed Actions Typed Actions 主要是為了避免寫程式上輸入的錯誤，所以特別把它獨立出來 新增 src/actions/types，用 const 的方式輸出 export const EMAIL_CHANGED = 'email_changed'; 在 src/actions/index.js 引入 types.js，將變數改為 EMAIL_CHANGED 12345678import &#123; EMAIL_CHANGED &#125; from &quot;./types&quot;;export const emailChanged = (text) =&gt; &#123; return &#123; type: EMAIL_CHANGED, payload: text &#125;;&#125;; 在 src/reducers/AuthReducer.js 的地方也引入 EMAIL_CHANGED 12345678910import &#123; EMAIL_CHANGED &#125; from &quot;../actions/types&quot;;export default (state = INITIAL_STATE, action) =&gt; &#123; switch (action.type) &#123; case EMAIL_CHANGED: default: return state; &#125;&#125; 不要讓 State 異變 一成不變的 State 觀察以下程式碼，最後會發現 newState === state，原因就是 state 會連結物件，在以下範例中，state 和 newState 連結的會是一樣的物件，最後就會得到 newState === state 的結果 const state = &#123;&#125; const newState = state newState.color = 'red'; 建立一成不變的 State 在 src/reducers/AuthReducer.js 的 case EMAIL_CHANGED 回傳物件 {}，這邊的意思是說把所有的 state 讀回來，然後把 email 這個變數放到所有的 state，如果所有的 state 有 email 的話，則會用新的覆蓋 12case EMAIL_CHANGED: return &#123; ...state, email: action.payload &#125;; mapStateToProps function 用來取得某個部份的 state 到我們的 components 裡面 更多關於建立一成不變的 State 在 src/components/LoginForm.js 新增 onPasswordChange 的 function，然後跟資料流連結 123456789101112131415161718import &#123; emailChanged, passwordChanged &#125; from &quot;../actions&quot;;onPasswordChange(text) &#123; this.props.passwordChanged(text);&#125;// 修改 Password Input 的值onChangeText=&#123;this.onPasswordChange.bind(this)&#125;value=&#123;this.props.password&#125;const mapStateToProps = state =&gt; &#123; return &#123; email: state.auth.email, password: state.auth.password &#125;;&#125;;export default connect(mapStateToProps, &#123; emailChanged, passwordChanged &#125;)(LoginForm); 修改 src/actions/index.js 新增 passwordChanged 的 Action 123456789101112import &#123; EMAIL_CHANGED, PASSWORD_CHANGED&#125; from &quot;./types&quot;;export const passwordChanged = (text) =&gt; &#123; return &#123; type: PASSWORD_CHANGED, payload: text &#125;&#125;; 在 src/actions/types.js 新增 PASSWORD_CHANGED export const PASSWORD_CHANGED = 'password_changed'; 在 AuthReducer 新增 PASSWORD 的 case 1234567891011121314151617181920import &#123; EMAIL_CHANGED, PASSWORD_CHANGED&#125; from &quot;../actions/types&quot;;const INITIAL_STATE = &#123; email: &#x27;&#x27;, password: &#x27;&#x27;&#125;;export default (state = INITIAL_STATE, action) =&gt; &#123; switch (action.type) &#123; case EMAIL_CHANGED: return &#123; ...state, email: action.payload &#125;; case PASSWORD_CHANGED: return &#123; ...state, password: action.payload &#125;; default: return state; &#125;&#125; 同步和異步的 Action Creators 預計使用的 State email：當使用者在 email 欄位輸入文字的時候要改變 password：當使用者在 password 欄位輸入文字的時候要改變 loading：當開始傳送認證請求的時候為 True，當完成的時候則為 False error：預設是 empty string，當我們在認證請求失敗的時候，就要將 error 訊息傳到這個欄位 user：預設是 null，當成功認證的時候，放到 user model 在 js 裡面，執行一個 function 最後都要 return 東西回來，如果有 Ajax 請求的話，就要用特別的方式處理。 介紹 Redux Thunk 安裝 redux-thunk npm install --save redux-thunk 預設 Action Creator 規則 Action Creator 都是 functions 一定要 return action Action 是一個有 ‘type’ 值的 object 使用 Thunk 的 Action Creator 規則 (本來上面的規則一樣可用) Action Creator 都是 functions 一定要 return function function 會使用 dispatch 來呼叫 Thunk 的方式就可以允許我們用手動的方式去 dispatch 一個 action 來呼叫所有不同的 reducers 新增一個 action 到 src/actions/index.js 123456import firebase from &#x27;firebase&#x27;;export const loginUser = (&#123; email, password &#125;) =&gt; &#123; firebase.auth().signInWithEmailAndPassword(email, password) .then(user =&gt; console.log(user));&#125;; 運用 Redux Thunk 修改 src/App.js 把 redux-thunk 呼叫進來 1234567891011import ReduxThunk from &#x27;redux-thunk&#x27;;render() &#123; const store = createStore(reducers, &#123;&#125;, applyMiddleware(ReduxThunk)); return ( &lt;Provider store=&#123;store&#125;&gt; &lt;LoginForm/&gt; &lt;/Provider&gt; );&#125; Redux Thunk 的流程 Action Creator 被呼叫 Action Creator 回傳一個 function Redux Thunk 看我們回傳了一個 function 並且使用 dispatch 呼叫他 我們進行登入的請求 等待… 等待… 請求完成，使用者已登入 .then 運作 Dispatch 我們的 action 修改 src/actions/index.js 的 loginUser，用 dispatch 的方式回傳 12345678export const loginUser = (&#123; email, password &#125;) =&gt; &#123; return (dispatch) =&gt; &#123; firebase.auth().signInWithEmailAndPassword(email, password) .then(user =&gt; &#123; dispatch(&#123; type: &#x27;LOGIN_USER_SUCCESS&#x27;, payload: user &#125;); &#125;); &#125;;&#125;; 修改 src/components/LoginForm.js，讓 LoginUser 的 action 可以使用 123456789101112131415import &#123; emailChanged, passwordChanged, loginUser &#125; from &quot;../actions&quot;;onButtonPress() &#123; const &#123; email, password &#125; = this.props; this.props.loginUser(&#123; email, password &#125;);&#125;&lt;Button onPress=&#123;this.onButtonPress.bind(this)&#125;&gt; Login&lt;/Button&gt;export default connect(mapStateToProps, &#123; emailChanged, passwordChanged, loginUser&#125;)(LoginForm); 讓 LoginUser 更穩固 在 src/actions/types.js 新增 LOGIN_USER_SUCCESS export const LOGIN_USER_SUCCESS = 'login_user_success'; 在 src/actions/index.js 新增 LOGIN_USER_SUCCESS，並放到 dispatch 裡面 123456789101112import &#123; EMAIL_CHANGED, PASSWORD_CHANGED, LOGIN_USER_SUCCESS&#125; from &quot;./types&quot;;return (dispatch) =&gt; &#123; firebase.auth().signInWithEmailAndPassword(email, password) .then(user =&gt; &#123; dispatch(&#123; type: LOGIN_USER_SUCCESS, payload: user &#125;); &#125;);&#125;; 在 src/reducers/AuthReducer.js 新增 LOGIN_USER_SUCCESS 並回傳 state 1234567891011121314import &#123; EMAIL_CHANGED, PASSWORD_CHANGED, LOGIN_USER_SUCCESS&#125; from &quot;../actions/types&quot;;const INITIAL_STATE = &#123; email: &#x27;&#x27;, password: &#x27;&#x27;, user: null&#125;;case LOGIN_USER_SUCCESS: return &#123; ...state, user: action.payload &#125;; 建立使用者帳戶 在 src/actions/types.js 新增 LOGIN_USER_FAIL export const LOGIN_USER_FAIL = 'login_user_fail'; 在 src/actions/index.js 將 LOGIN_USER_FAIL 加入，如果無法登入則創建帳戶，再無法創建帳戶，則彈出錯誤訊息 1234567891011121314151617181920212223242526272829import &#123; EMAIL_CHANGED, PASSWORD_CHANGED, LOGIN_USER_SUCCESS, LOGIN_USER_FAIL&#125; from &quot;./types&quot;;export const loginUser = (&#123; email, password &#125;) =&gt; &#123; return (dispatch) =&gt; &#123; firebase.auth().signInWithEmailAndPassword(email, password) .then(user =&gt; loginUserSuccess(dispatch, user)) .catch(() =&gt; &#123; firebase.auth().createUserWithEmailAndPassword(email, password) .then(user =&gt; loginUserSuccess(dispatch, user)) .catch(() =&gt; loginUserFail(dispatch)); &#125;); &#125;;&#125;;const loginUserFail = (dispatch) =&gt; &#123; dispatch(&#123; type: LOGIN_USER_FAIL &#125;);&#125;;const loginUserSuccess = (dispatch, user) =&gt; &#123; dispatch(&#123; type: LOGIN_USER_SUCCESS, payload: user &#125;);&#125;; 顯示錯誤訊息 在 src/reducers/AuthReduer.js 將 LOGIN_USER_FAIL 引入，然後新增 error 的 state 1234567891011import &#123; LOGIN_USER_FAIL&#125; from &quot;../actions/types&quot;;const INITIAL_STATE = &#123; user: null, error: &#x27;&#x27;&#125;;case LOGIN_USER_FAIL: return &#123; ...state, error: &#x27;Authentication Failed!&#x27;&#125;; 在 src/components/LoginForm.js 新增 renderError 的 function，然後把 error 讀出 1234567891011121314151617181920212223242526272829import &#123; View, Text &#125; from &#x27;react-native&#x27;;renderError() &#123; if (this.props.error) &#123; return ( &lt;View style=&#123;&#123; background: &#x27;white&#x27; &#125;&#125;&gt; &lt;Text style=&#123;styles.errorTextStyle&#125;&gt; &#123;this.props.error&#125; &lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;&#123;this.renderError()&#125;const styles = &#123; errorTextStyle: &#123; fontSize: 20, alignSelf: &#x27;center&#x27;, color: &#x27;red&#x27; &#125;&#125;;const mapStateToProps = state =&gt; &#123; return &#123; error: state.auth.error &#125;;&#125;; Firebase 疑難雜症 如果在 src/reducers/AuthReducer.js 的 case LOGIN_USER_SUCCESS: 新增一個 banana;，實際執行之後就會發現，出現 Authentication Failed 的錯誤訊息，而不是紅色的錯誤畫面，原因在於 firebase 如果執行失敗，就會直接跳到 catch 的語法，導致沒有出現錯誤，而是出現 Authentication Failed 在載入時顯示 Spinner 在 src/actions/type.js 加上 LOGIN_USER export const LOGIN_USER = 'login_user'; 在 src/actions/index.js dispatch LOGIN_USER 12345678910import &#123; LOGIN_USER&#125; from &quot;./types&quot;;return (dispatch) =&gt; &#123; dispatch(&#123; type: LOGIN_USER &#125;); firebase.auth().signInWithEmailAndPassword(email, password) ... &#125;; 在 src/reducers/AuthReduer.js，新增 loading 的 case，如果登入成功的話，則把所有值清除，回到預設值 ...INITIAL_STATE 1234567891011121314import &#123; LOGIN_USER&#125; from &quot;../actions/types&quot;;const INITIAL_STATE = &#123; loading: false&#125;;case LOGIN_USER: return &#123; ...state, loading: true, error: &#x27;&#x27; &#125;;case LOGIN_USER_SUCCESS: return &#123; ...state, ...INITIAL_STATE, user: action.payload&#125;;case LOGIN_USER_FAIL: return &#123; ...state, error: &#x27;Authentication Failed!&#x27;, password: &#x27;&#x27;, loading: false &#125;; 在 src/components/LoginForm.js 引入 Spinner，並新增 renderButton 事件 1234567891011121314151617import &#123; Card, CardSection, Input, Button, Spinner &#125; from &#x27;./common&#x27;;renderButton() &#123; if (this.props.loading) &#123; return &lt;Spinner size=&quot;large&quot; /&gt; &#125; return ( &lt;Button onPress=&#123;this.onButtonPress.bind(this)&#125;&gt; Login &lt;/Button&gt; );&#125;&lt;CardSection&gt; &#123;this.renderButton()&#125;&lt;/CardSection&gt;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"https://vincent.fishboneapps.com/tags/React-Native/"}]},{"title":"減重和營養快速學習自我挑戰 Day4","slug":"減重和營養快速學習自我挑戰-Day4","date":"2018-05-01T03:55:18.000Z","updated":"2020-06-22T17:16:57.057Z","comments":true,"path":"2018/04/30/減重和營養快速學習自我挑戰-Day4/","link":"","permalink":"https://vincent.fishboneapps.com/2018/04/30/%E6%B8%9B%E9%87%8D%E5%92%8C%E7%87%9F%E9%A4%8A%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day4/","excerpt":"","text":"減重動機 如何設定聰明的減重目標？ 沒有目標就沒有結果：如果你不能量測某樣東西，代表它不存在。 如果設定可以激勵你的目標 設定聰明(SMART 原則)的目標 寫下它們並分享給其它人 建立一個行動計畫並付諸行動 追蹤你的進度 SMART 原則： S(Specific)：你有很大的機會完成「特定」目標，在這個階段，很重要的是把你想要達成的想法轉換成更細節的東西 M(Measurable)：建立成功的標準，例如：你想要減少多少重量，或是你想要做多少伏地挺身，試著把你的目標轉換成更具體的數字，會讓你更容易追蹤你的成果 A(Achievable)：你應該要選擇你可以達到的目標，這個部分有點玄機，因為一方面你要選擇更抽象的目標，這樣才能激勵你，但是另一方面，你要應該建立更小的里程碑，例如：每週的標準幫助你追蹤且提醒你正在進步， R(Realistic)：你要回答為什麼要做這些事情？有些人為了看起來更好看，有些人則為了更健康，沒有任何對或錯的原因，只要你確定你自己的是什麼就好了 T(Timely)：你應該要適時的設定目標，代表你要選擇一個時間軸，並為時間軸設定結束日期，我建議你應該要為長期選擇一個大目標，為短期選擇一個小里程碑 要常常檢查你是否達到那些小里程碑，如果你的目標太簡單或是太困難，你可以改變它們，但是問問你自己是不是你真的想要的 如何追蹤你的進度 定期追蹤你的體重：我通常每週在空腹的早晨、不穿任何衣服量測兩次，但是如果你覺得你應該要有更準確的值，你可以每天早上起床後量測，然後你可以以每週為單位進行比較，不要以每天為單位，只要看每週的平均值即可，這樣才可以給你更準確的結果，每天量測的唯一缺點且我不使用它的原因，是因為多人當每天量測的時候，會對他們的體重很執著，這個你可以自己做決定 不要太依賴鏡子：我已經講過很多身體儲水問題和它可以改變你的外表和重量，它真的可以讓昨天的你和今天的你看起來截然不同，所以不要花太多時間在上面，但是不要誤解我的意思，最後算的不是你多重，而是你覺得怎麼樣和看起來怎麼樣，所以長期來看，你還是要依賴鏡子，但是最好的方法還是每週拍照，然後在一到兩個月後比較它們 測量腰圍(選擇性的)：可以用量尺每週量測一次，然後記錄你的測量結果 追蹤主觀的感覺 (0 = 沒問題，5 = 很有問題)：你可以每週評估狀況，這些可以幫忙你早期發現你的問題並快速解決它們 睡覺問題：當在 Calorie Deficit 的情況下，睡覺品質會影響健身成效、恢復和肌肉維持，睡覺品質還會影響飢餓感和能量水平，所以如果你很餓，最近你的健身比最佳情況還差，你發現你的睡眠品質很差，那麼你的睡眠品質可能就是主因，所以你要解決這個問題 壓力水平：如果你的體重最近幾週都沒有下降，但是你的壓力水平特別高，那麼你可以要注意某些東西，或許高的皮質醇水平會避免你減少更多重量，又或者你可能在減重飲食中一次做太多改變 飢餓問題 疲勞/想睡(lethargy) 如果你有在健身，你應該追蹤你的舉重，減重飲食會讓你的舉重更弱，這是很正常的，但是它應該是會慢慢發生，而且大概只花 10%，如果你看到你的你的力量快速下降，你應該破壞你的減重飲食會，或是修改你的 Calorie Deficit 追蹤你的每日步數對你的整體減重飲食是一個好方法，但是有時候很多數據對初學者來說會難以負荷，所以追蹤你的體重對初學者也足夠了，如果你遇到問題，就再追蹤主觀的感覺，如果你有健身，追蹤你的舉重是必要的 減脂最理想的速率 沒有任何一個理想的減脂速率可以用在每一個人身上，但是我們還是可以根據研究結果和現實中一般人的狀況把範圍縮小，第一件事情你要知道的就是體脂肪不會在一夜之間改變，脂肪不只很不容易減掉，它也很不容易得到，研究顯示大部分的美國人每年大約胖 2 磅，意思就是如果你胖了 10 磅，你很有可能在過去五年變胖了，你要瘦回來，不會花到五年，但是你要了解事情的真相就是極少減肥法是可以保證你在數週之內瘦數 10 磅 一磅的脂肪大約等於 3500 卡路里，想要一週減掉 1 磅，你就需要每天有 500 卡路里的 Calorie Deficit (這絕對是做得到的)，但是你想要一週減掉 2 磅，你就需要每天有 1000 卡路里的 Calorie Deficit (而這個就很難達成)，唯一可能做到快速減重或較高的 Deficit 就是你從非常胖的體重開始減重 在這樣的情況下，你的動力就是看到結果有多快，也就是越大的 Deficit 越能達到你的期望，但是還是可以試著每週減掉 2 磅(最多)，然後確定你可以應付得了每日的 Deficit，如果太難以負荷也沒有關係，記得，這不是競賽，最好就是花多一點時間來達到你的目標，或是維持體重都比快速達到來得好，因為快速減重最後就會變成溜溜球回到本來的體重 如何想像你的理想體重 好的心態就是你動力的最重要部分，有很多方法可以幫助你提升你的動機且想像你在減重之後會有多棒，我個人有些懷疑正向思考理論，但是有確實的證據指出他的有效性 不要做的事情 不要只想像你自己減重和看起來多棒：賓州大學的研究發現，只會想像未來有多棒的人，是很難以應付無法避免的挫折，然後就在第一個障礙就放棄了，所以想像自己的想法可能會破壞你減肥的動力 要做的事情 最有效的辦法就是知道為了達到目標，會有樂觀的結果，同時也會伴隨著現實中可能發生的挫折 想像獲得你的理想體重，寫下你會從中得到的最重要的兩個利益，然後想像你在追求的過程中可能出現的兩個最大的障礙 總是想到減重的好處和可能遇到的困難 停止使用意志力來減重 研究顯示，人們常常使用意志力，最後都會枯竭殆盡，舉例來說：吸菸者 24 小時不抽菸，就會像吃很多冰淇淋或是酗酒者，變成身體虛弱者且不能通過忍耐力測試，一旦意志力肌肉枯竭，你似乎對於誘惑的抵抗力會變得脆弱，這會對剛入門的人是很大的問題，因為改變飲食必須要努力且不能耗盡你的意志力 要怎麼做才不會失去意志力？你必須要忽略對結果很重要的基本動力-意志力，這邊舉一個非常戲劇化的例子，如果一個家庭成員不減重的話，就會被殺掉，你可能就會立刻開始且絕對能達到目標，這很明顯很緊急，然而幸運地，這種情況並不會發生，但是你可以利用同樣的邏輯來忽略你對意志力的依賴，最好的辦法就是你用你的目標對大家做一個承諾，然後設定一些結果機制，有一個顯著的證據表明，人們像例子一樣對家人或朋友做了公開的承諾之後，他們最後最有可能達到目標，朋友的支持很重要，但是同樣地，在他們面前失敗也很丟臉，開始告訴你的朋友你開始減重了，然後在 Facebook 和 Twitter 上面寫下你的目標！如果以上說的太多了，你可以簡單地告訴你的配偶或是非常親近的朋友來提醒你自己你的目標 另外一個好方法就是你放一些錢到虛擬帳戶，如果你成功減掉重量或是維持在某個體重，就可以繼續把錢放在裡面，這肯定會對你造成壓力，或許有些人覺得比較極端，但是這就是人們所需要可以達到目標的方法 使用減重動機的榜樣 英國心理學家在數年前有一個非常有趣的研究，是關於動機心理學且特別和減重有關，他追蹤了超過 5000 位想要達到特定目標的人，像是減重、戒菸、拿到新的資格或是開始一段感情，他追蹤這些參與者超過一年，最後研究結束之後，僅僅只有 10% 的人最後達成他一開始所設定的目標 研究發現名人和好榜樣會傷害你的動機，當我看到身材很好的人我會覺得有動力，但是根據科學家所述，它正是問題，我們時常對於短期內什麼東西讓我們感覺很好和長期下來什麼會激勵我們感到困惑，簡單地挑選你認為完美的圖片並放在冰箱門上面對長期來說並沒有幫助，一旦你開始在飲食遇到問題，你就會開始討厭圖片，而且告訴自己那一切都是基因造成的 但是有一個方式可以讓好榜樣幫助你減重成功，所以這邊提供一個方法正確使用好榜樣 好的榜樣應該是一個有故事的人，且你跟你有關聯的 了解他們的背景，如果可能的話，你應該親自詢問問題且與他們交流 你選擇一個好榜樣應該是根據他們在人生的選擇，而不是基因的問題，任何一張他們的圖片只是用來提醒你他們的決定，即使他們真的有非常優越的基因，他們還是花了時間去健身房且堅持他們的飲食，這個就是你英該注意的，而不是最後的結果 有些人會覺得失敗的例子比成功的例子更能啟發他，舉例來說：如果你被你增重的恐懼激勵到了，你應該想要追隨或是跟用同樣方法失敗的人聊天，然後看你可以怎麼樣做得更好，這個叫做負面榜樣，且你可以用這樣的方式在未來真正地找到自我 當然，那些會製造藉口和保持放棄狀態的人，在你還沒有提供幫助來改變他們的生活之前，你就不應該把他們當作負向榜樣，就像你知道的，有一些指導和支持才能走得長久，另外一方面，對於那些對自己身體並不是不滿意，也沒有任何大的健康問題，只希望夏天的時候看起來更棒的人，這些人需要正向榜樣，但是還是要是現實中可以看齊的人，朋友和家人曾經減重的人就很適合當作正向榜樣，而世界級的榜樣則不是那麼適合，但是最後還是取決於你自己在減重旅程中的哪個地方了 如何避免「搞什麼鬼效應」 我們都知道搞什麼鬼效應發生在我們完美的做減重飲食的時候，但是不知道什麼原因，我們放縱了一件錯誤的事情，下一件我們知道的事情就是我們吃了冰箱一半的食物，這是很多人都會做的，這很正常，但在長期下來並不會對你有益 為了避免這樣的效應，我們可以做一件違背常理的事情，下次你放縱的時候，盡量吃、盡量享受，跟感覺很不好比起來，你應該要對食物感覺不錯，然後要再回到正軌，這個方法比起討厭自己或忽略所有承諾還要健康 罪惡代表暴飲暴食，而暴飲暴食也等於罪惡，試著不要暴飲暴食，但是如果你做了也不要討厭你自己，這也是為什麼要在減重飲食裡面有作弊餐，因為非常重要，我們都需要在時間的間隔中重新對意志力充電，就像之前所說的，慢慢地達到目標比起堅持很久、然後破壞飲食、最後什麼都變回原樣是更重要的 成功的飲食包含認知到我們都是人類，我們都會犯錯，我在減重的路途上需要靠犯錯來幫助我，但是我還是達到我大部分的目標 一步步減重配方 當選擇一個健美計畫，很多人的目標都是不只增肌還要減重，不幸地，現在很多關於減重的錯誤資訊和觀念，很容易讓你使用新的減重飲食方法，或是用服用營養素可以幫助你達到成果，然而，很多在整體體重上都沒有得到任何效果，有些極端的減重飲食甚至會傷害你的健康，與其相信一些只想賣你減重飲食產品的健美領袖，倒不如你好好瞭解從身體機制觀點來看，什麼會讓你減重 就像你知道的，減重的科學機制是很簡單的，如果我們想要減重，我們只要吃比你身體燃燒的還要少的卡路里就可以了，而卡路里是用在計算在食物裡面儲藏的能量，現在，如果你提供你的身體較少能量，然後這些能量都花在你身上，這樣就會開始減少囤積卡路里，這個法則是全世界通用的，很多人不能了解，因為這有一些違背常理，這些卡路里會來自各種地方，你可以只吃披薩，但是只要你的全部卡路里比你身體所需要的更少，你一樣可以減重，所以這樣就代表只要不要超過身體所需的卡路里，吃健康或不健康的食物都沒有差？在減重和健康減重有一個很大差異點，如果你希望你的減重更加有效，你就不能只看總量卡路里，你還要看 Macronutrients 的比例，最後一件最重要的就是訓練，即使有 Calorie Deficit 和吃健康的食物已經是減重的好開始，如果你不運動，你的身體就會流失肌肉 Calorie Deficit + Marconutrients 組成 + 訓練 = 健康減重 我們都希望身體可以少一些脂肪，然後保持力量，這邊有三件事情你要做的 你必須要吃比你身體消耗的更少卡路里 你的飲食必須包含特定成分的碳水化合物、蛋白質和脂肪 記得要運動才不會流失肌肉 減重和增肌可同時嗎？ 理論上不可能 大部分運動選手會分兩個層面：膨化(bulking)和切割(cutting)，當他們 Calorie Surplus 的時候，他們就會加強訓練的強度，然後他們就會再換成 Calorie Deficit，然後盡可能的話維持肌肉且只減脂，這就叫做切割 但是大部分的新手可以同時做到這兩件事情，因為他們身體增肌非常快 減重迷思 部位減重：一切都是基因決定的，有些人瘦腿比較快，有些人瘦手比較快 心肺運動永遠可以讓你減重：心肺運動可以讓你燃燒更多卡路里，但是還是要看你吃多少卡路里 更高的組數 = 撕裂肌肉：這個並沒有被科學證實，肌肉跟重複做幾組動作沒有關係，只跟你體脂肪有關係，你想要看起來很壯，你就要減脂 一步步增肌配方 配方包含三個變數會影響你的成功：訓練 + 足夠的(健康的)卡路里 + 休息 = 成功 訓練不要太過強烈，你的肌肉會不習慣，也就代表他們不會成長 飲食部分，你必須要提供你的身體足夠的卡路里，讓它可以建立更多肌肉組織 一定要給你身體足夠的休息，否則你的肌肉沒有辦法從健身中逐漸增壓的情況下恢復 訓練：最終鍛鍊 正確的運動：你要記得你的目標是增加整體的肌肉，這裡有一些比起來更適合這樣目標的運動 複合運動：跟只針對一個地方訓練肌肉比起來，複合運動使用多關節，可以一次動到很多肌肉，舉例來說：伏地挺身，包含胸、三頭、背部和腹肌，在做複合運動的時候，你要知道如何正確的做那個動作，否則你不只會建立較少的肌肉，還會導致關節問題或是傷害 漸進式超載法：你想要增加更多肌肉，你需要逐漸增加重量 忘記更多組數的原則，重量才是關鍵：科學證據顯示做越多組數，你就會訓練你的肌肉有更大的忍耐度，但是更少的力量，這樣的訓練不是不好，而是你想要增肌大重量才是有效率的，就像你會發現快跑選手的肌肉比較大塊，而慢跑的選手的肌肉比較小 你如何更有效率地增加你的肌肉張力？在單一運動中，用更多重量改變取代更多組數，舉例來說：有些新手做伏地挺身對他們來說太困難，可以做跪地伏地挺身，當你可以達到 15 到 20 下，就回到正常的伏地挺身，再當你可以做到 15 到 20 下，就可以試試看管式俯地挺身(pipe pushup)，跟普通的伏地挺身比起來會更佳困難 其它可以增加阻力的方式：如果你已經沒有辦法做動作的變化，可以背包包、加水瓶在身上，或是有重量的書本 心肺運動：心肺運動是一個燃燒更多卡路里的好方法，但是身體需要更多卡路里來建立肌肉，所以如果你有很好的新陳代謝，請限制你的心肺運動量，心肺運動對你想要減重非常有幫助，但是對於想要增加肌肉就沒有那麼有幫助了，記得，想要建立肌肉，更少的卡路里燃燒其實是好事情，但是也不是說你完全不要做心肺運動，它是幫助你訓練心肺的好方法且可以增加你的健美水平 足夠的(健康的) 確保在 Caloric Surplus 的狀態：卡路里就等於能量，沒有能量你的肌肉組織不會成長，就會讓你的運動變成毫無意義， 好的 VS. 不好的卡路里：盡量不要從速食裡面攝取 Macronutrients 休息 肌肉不會再你訓練的時候成長，而是在訓練後：如果你在訓練後提供正確的營養，且有足夠的休息時間，它們會為了應付更強的重量而變得更加強壯 最少要有 7 小時的睡眠時間：只要低於 7 小時，就會犧牲掉可能的增肌，還有甚至你的整體健康，如果你處於很大的壓力或是沒辦法睡覺的情況下，你可以試著在固定每天小睡片刻 其它可以幫助你恢復的方法：冥想、按摩或是一些處方藥 完成課程","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Weight Loss","slug":"Weight-Loss","permalink":"https://vincent.fishboneapps.com/tags/Weight-Loss/"},{"name":"Nutrition","slug":"Nutrition","permalink":"https://vincent.fishboneapps.com/tags/Nutrition/"}]},{"title":"Git & Github 快速學習自我挑戰","slug":"Git-Github-快速學習自我挑戰","date":"2018-04-21T07:18:51.000Z","updated":"2020-06-22T17:12:55.843Z","comments":true,"path":"2018/04/21/Git-Github-快速學習自我挑戰/","link":"","permalink":"https://vincent.fishboneapps.com/2018/04/21/Git-Github-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0/","excerpt":"","text":"Git 環境設定 設定 email 和 username 12git config --global user.email &quot;Email&quot;git config --global user.name &quot;Name&quot; 檢視是否設定正確 git config --list Git 基礎操作 Git 操作流程 Git Init 安裝數據庫 新增資料夾，用 cd 進入資料夾，使用 git init 開啟新的 git 新增完成之後，出現 master，就是現在在 master 分支 基礎指令 加入索引 git add . 檢查狀態 git status 提交更新 git commit -m '修改記錄' 查詢紀錄 git log gitignore 忽略檔案 新增 .gitignore 檔案 直接加上你要忽略的檔案 *.html：忽略全部的 html 檔案 forder/：忽略整個資料夾 工作還原技巧 取消索引 全部檔案取消索引 git reset HEAD 單一檔案取消索引 git reset HEAD 檔案名稱 還原檔案 恢復單一檔案到最新的 commit 狀態 git checkout 檔案名稱 還原工作目錄與索引，會跟最後一次 commit 保持一樣 git reset --hard 指令大全 基礎設定 12345678查詢版本git version查詢設定列表git config --list輸入姓名git config --global user.name &quot;你的名字&quot;輸入emailgit config --global user.email &quot;你的email&quot; 新增本地/遠端數據庫 1234在本地資料夾新增數據庫git init複製遠端數據庫git clone 遠端數據庫網址 增加/刪除檔案 12345678910增加檔案進入索引git add 檔案名稱增加全部檔案進入索引git add .查詢狀態git status顯示歷史紀錄git log將索引提交到數據庫git commit -m &#x27;更新訊息&#x27; 還原指令 12345678910111213141516還原工作目錄與索引，會跟最後一次 commit 保持一樣git reset --hard全部檔案取消索引git reset HEAD單一檔案取消索引git reset HEAD 檔案名稱恢復單一檔案到最新 commit 狀態git checkout 檔案名稱刪除最近一次 commitgit reset --hard &quot;HEAD^&quot; 上面語法如果刪除錯了可以再用此語法還原git reset --hard ORIG_HEAD 刪除最近一次 commit，但保留異動內容git reset --soft &quot;HEAD^&quot; commit 後發現有幾個檔案忘了加入進去，想要補內容進去時git commit --amend 分支 12345678910顯示所有本地分支git branch新增分支git branch 分支名稱切換分支git checkout 分支名稱合併指定分支到目前的分支git merge 分支名稱刪除分支git branch -d 分支名稱 遠端數據庫操作 12345678複製遠端數據庫git clone 遠端數據庫網址查詢遠端數據庫git remote將本地分支推送到遠端分支git push 遠端數據庫名稱 遠端分支名稱將遠端分支拉下來與本地分支進行合併git pull 標籤 12345678910查詢標籤git tag查詢詳細標籤git tag -n刪除標籤git tag -d 標籤名稱新增輕量標籤git tag 標籤名稱新增標示標籤git tag -am &quot;備註內容&quot; 標籤名稱 暫存 12345678910暫時儲存當前目錄git stash瀏覽 stash 列表git stash list 還原暫存git stash pop清除最新暫存git stash drop清除全部暫存git stash clear 分支 好的分支範例 HEAD 了解目前所在的位置 git branch 瀏覽目前分支 git checkout HEAD 前四碼 git checkout master 復原到 master 分支 分支建立 git branch '分支名稱' 建立分支 git checkout '分支名稱' 切換分支 合併分支 git merge '分支名稱' 合併分支 標籤 切換到標籤的 commit：git checkout '標籤名稱' 團隊協作 遠端數據庫 git remote 查詢遠端數據庫 git remote rename '原名稱' '修改名稱' 修改遠端主機名稱 git push origin(預設遠端主機名稱) master(分支名稱) 推送分支 下載遠端數據庫 git pull 把檔案下載下來 Github Pages 進入 Repo 之後，選擇 Setting，選擇 Branch，然後發佈就可以看到網頁了 小型團隊分支協作篇 git pull = git fetch + git merge 如果怕 pull 下來導致數據庫太亂又擔心有衝突的時候，可以先使用 git fetch origin(遠端數據庫) branch1(遠端分支)，下完指令之後，會出現一個 FETCH_HEAD 的分支，可以等確定沒有問題之後再跟現有的分支合併 學習資源 連猴子都能懂得 Git 入門指南 保哥 30 天 Git 教學 Git 官方繁體教學","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://vincent.fishboneapps.com/tags/Git/"}]},{"title":"減重和營養快速學習自我挑戰 Day3","slug":"減重和營養快速學習自我挑戰-Day3","date":"2018-04-07T04:12:23.000Z","updated":"2020-06-22T17:16:54.100Z","comments":true,"path":"2018/04/07/減重和營養快速學習自我挑戰-Day3/","link":"","permalink":"https://vincent.fishboneapps.com/2018/04/07/%E6%B8%9B%E9%87%8D%E5%92%8C%E7%87%9F%E9%A4%8A%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day3/","excerpt":"","text":"如何解決常見的飲食問題 正確的作弊餐不會破壞你的飲食 作弊餐就是為了獎勵每週努力節食而吃一些垃圾食物，那麼作弊餐會不會對整體減重飲食過程帶來負面的影響？並不會，只要你保持檢查卡路里和 Macronutrients，這個課程裡面講的，在減肥飲食中，最重要的就是卡路里平衡和 Macronutrients，你的身體並不會只看你特定飲食而改變身材，一湯匙的魚、一個馬鈴薯和一杯花椰菜和一個巧克力棒沒有什麼太大差別 適當的營養才是全局的關鍵，如果你平常大部分都吃健康乾淨的食物，然後偶爾吃一片披薩，你的身體也不會因此閃紅燈，脂肪不會過度儲存，而且你的健康和能量水平也不會快速下降 關鍵就是適當的追蹤飲食 作弊餐 80-90% 的飲食需要是「乾淨」且健康的 10-20% 的飲食可以是任何你喜歡的食物，只要它符合每日卡路里、蛋白質、碳水化合物和脂肪 依照正確的減重飲食基礎，「作弊餐」並不會很神奇地讓你變胖或是減少肌肉 記得，這並不是讓你開始吃大量的冰淇淋和比薩，彈性的飲食還是要有理由地遵守整體飲食的規則，就是卡路里、蛋白質、碳水化合物和脂肪 還有一個問題就是，作弊日取代作弊餐，作弊日就是一整天不管卡路里的吃任何你喜歡的東西，如果你沒有適量的 Calorie Deficit，那你不會減掉任何肥肉，作弊餐並不會顯著地影響結果，但是作弊日會大幅影響整體的飲食減重成效，舉例：500 Calorie Deficit * 6 天 = 低於標準值的 3000 Calories Deficit =&gt; 在作弊日吃下的任何卡路里高於 3000 卡路里就會抵銷你的每週的 Deficit 每個人都不一樣，而且有不一樣的胃口，但是你絕對可以在作弊日吃下高於你的標準值 1500 卡路里，那也會直接減掉你一半的 Deficit，現在想像如果吃超過標準值 2000-3000 卡路里的東西，這樣一來，你基本上就失去這週所努力的成果，而且只要到高卡路里餐廳，還搭配像是蛋糕、冰淇淋等甜點，總結來說，要常常關注你的每日和每週的卡路里，要減重就要保持在 Deficit 的狀態，只要你考慮到正確的蛋白質、碳水化合物和脂肪，那麼你就沒問題，作弊餐或許不會影響，但是作弊日絕對可以！最好的方法就是總是發展出一個彈性飲食符合你個人的生活模式和喜好 如何正確地做飲食休息 飲食休息就是有計畫且有目的的從飲食中休息，這樣的休息可以從數日到數週，就像是作弊餐，飲食休息也是一個爭議性的話題，因為只要你做錯方式，它就可以很容易的消除你努力所得的 Calorie Deficit 和減重過程 正確地做飲食休息，可以幫助你準備好下一次的減重飲食，且對你長期的成功是重要的 在說細節之前，要先解釋為什麼你應該要有規律的飲食休息，心理和生理上的效益都同樣重要 生理利益 減重飲食 = 更多壓力和血液中含有更高的皮質醇(Cortisol)水平，短期來說不會有太大的影響，但是長期來看，它會影響你的減重飲食成效，研究顯示，長期的 Calorie Deficit 會增加皮質醇水平，且會導致一些非預期的影響，例如：高含水量會讓你的皮膚看起來蓬鬆，當你飲食休息之後，皮質醇水平和整體壓力水平就會回到正常，這也表示你會更少飢餓、更多能量且更少想吃食物的慾望 心理利益 減重飲食事實上很艱難，儘管一開始很容易，長期累積下來，如果我說我喜歡它肯定是在說謊，唯一讓事情變簡單的方法就是你知道你一步一步來，知道你將要在未來的特定時間休息比想到看不到結束還要好 從減重飲食中計畫休息，會消除掉很多壓力，且給你一些東西讓你繼續前進，這也幫助你維持你的動機，且達到長期目標 正確的飲食休息長什麼樣子？ 提高你的卡路里到維持的水平 在正常的時間吃下食物，且不用太擔心 Macronutrients (不要太擔心是說顯然地，健康飲食包含糖果和比薩並不是一個好主意) 建議維持未加工得食物，但不要太擔心蛋白質攝取量沒有達到所需 選擇性的：減少心肺和健身重量在飲食休息的時候 (不要維持超過一週以上) 休息飲食應該要多久？ 這是一個困難的問題，因為這取決於你的新陳代謝和動機，根據我的經驗，休息飲食的心理利益發生得非常快，幾乎跟你離開你的 Calorie Deficit 和飲食在維持的水平一樣快，如此一來，如果你感覺到你只需要一些心理加速到下一個減重飲食層次，那麼短暫的休息大約是 2-7 天就可以達到效果，現在遇到的問題是真實的生理變化，短暫的休息不足以讓你的新陳代謝和激素水平恢復到正常，那麼兩週到更多週的休息是需要的，然而，當休息那麼久，你一定要非常確定你保持在維持的水平，而且不能進入 Calorie Surplus 的狀態，否則你就會把過去幾週減掉的體重補回來了 多長要做休息飲食？你的身體脂肪越少，你就需要休息更多，不要讓你的身體產生過度的壓力 身體脂肪低於 10% =&gt; 每 4-6 週 身體脂肪介於 10% 到 15% 之間 =&gt; 每 6-8 週 身體脂肪介於 15% 到 25% 之間 =&gt; 每 10-12 週 身體脂肪大於 25% =&gt; 盡量少頻率休息 女生要加 5% 到 7% 到這些區間 記得這些只是概略的教學，正確的時機會因人而異，你應該要了解身體的感覺，且當你覺得過度工作或壓力太大要聽從他的感受 在減肥停滯期(Fat Loss Plateaus)中如何休息？ 身體重量的改變並不代表身體脂肪的改變，很多人認為，在體重計上面看到體重變得比上禮拜少，那正是體脂肪減少，但是事情不是這樣的，就像之前說的，減重會發生可以是因為任何數字的東西改變，並不單單只有體脂肪，可能還有肌肉質量、糖原水平、停在你胃的食物或是可以改變最快的東西-水，沒有任何東西比水分對體重的改變最快，例如：如果你之下的餐點含有高碳水化合物和鹽分，那麼你的身體會比平常保留更多得水分，而女性比男性影響更多，因為經期(menstruation)的原因 如何擺脫不想要的水分保持？ 大部分來說，吃少點鹽巴和喝多一點水，就可以達到這樣的效果，為什麼要喝更多水？因為你的身體保有更多水份，是因為沒有比平常更足夠的水分，身體就會儲存一些水分留給之後使用 減肥停滯期(Fat Loss Plateaus)常見的問題 你必須記得，你失去更多脂肪，就會更不容易得到脂肪，你越瘦，就要花越多時間用健康的方式來減肥且不減少肌肉質量，例如：如果你有 25-30% 的身體脂肪，你可以很容易地每週減重 2-3 磅，首先，你的身體還有足夠的卡路里提供整體健康和肌肉維持，但是如果男性如果低於 10% 且女性介於 15-20% 之間，事情就會變得很複雜，所以減重率變慢是很正常的 你越變越瘦，你的身體需要的卡路里就越少，這意味著，每日用來創造 Calorie Deficit 的卡路里量只能剛好維持你的體重，這也是你為什麼需要時常重新計算你每日所需的卡路里 如果你要減重來維持能量，你的新陳代謝也會變慢，這絕對很困擾，因為這意味著意味著你必須要吃越來越少卡路里來抵銷它，然而，減少卡路里的攝入並不是長久之計，這也是你為什麼要定期飲食休息 隱藏卡路里，人們總是消耗比他們想像更多的卡路里，你可能會想你已經正確追蹤，但是如果你的體重開始停滯數週，請一定要再次檢查，卡路里可以隱藏在很多地方，吃小點心或是外出吃餐廳就是兩個例子，不追蹤奶油、醬料是另外一個常見的錯誤，還有就是檢查你的酒精攝入，這些都可以累積一些卡路里，事實上，每天額外的 200 到 300 卡路里可以破壞你的減重飲食並完全停止你的減重，200 卡路里不過就是一些橄欖油和一些果仁，所以也要記得追蹤這兩個，不幸地，減重飲食有時候很狡猾，但是如果你正確追蹤，那麼你一定會看到成果 如何解釋突然的體重改變？ 有些體重改變和減肥停滯期的原因類似，但是有些額外的不一樣 最常見的就是水分保持 喝更多水且減少你的鈉攝入量 壓力激素皮質醇也會影響你的水分保持 最棒的解決方法就是飲食休息，但是千萬不要用這個當作你逃離減重飲食的藉口 一些藥物和營養品，像是肌酸，會讓你的皮膚變得蓬鬆 碳水化合物的攝入 碳水化合物會以糖原的形式儲存在你的肝臟和肌肉 每 1 公克的糖原會伴隨 3 公克的水份儲存，所以如果你換到高碳減重法，這很有可能是可以解釋你體重改變的原因 這並不是很嚴重的問題，因為碳水化合物並不邪惡，而且額外的水分重量也不會讓健康產生問題 只要確定你的碳水化合物來源都是來自好的來源，像是米飯、馬鈴薯或是全麥產品 食物 不要再吃飯完秤重量 建議每週在起床後和吃早餐前的早上秤重兩次 其它原因 女性的月經 消化問題 最後討論一個可能的問題，這個原因可能不會導致突然的體重改變，但是會造成長期的停滯或是體重增加，這個原因就是低估你的每日卡路里攝取，長期的減重飲食問題常常都是來自於不適當的 Calorie Deficit，你必須要確定給你身體比消耗更少的能量，否則不會減少任何體重，請務必記在心上，且定期檢查正確的卡路里需求 飢餓模式是真的嗎？ 人們大部分相信 要減重，要攝入更少卡路里，但是如果你攝入太少卡路里，你的新陳代謝會變慢，你的身體會進入一個減重完全停止的狀態 在吃不足夠的卡路里的情況下，比起不減重有更劇烈的效果 這些事實上，會讓你攝入更多卡路里，但是為了要離開那種情況，想要減重更多，你必須要攝入更多卡路里而不是更少，所以人們相信的這些都是正確的，但是有另外一個謊言隱藏在背後 長期的減重飲食會降低新陳代謝，這是對的，這就是著名的適應性產熱(adaptive thermogenesis)，越多激烈的 Deficit，就會產生越快越顯著的效果，但是對減重並不足夠，而且它絕對不夠顯著且會導致體重增加，適應性產熱發生的很慢，會在數週或數月之後產生 明尼蘇達(Minnesota)的研究 24 週長時間「飢餓飲食」，每天吃兩小餐，總共大約 1500 大卡 當參與者達到 5% 體脂肪時，減少每日卡路里 研究結束時，男性的新陳代謝率減低約 40% 看起來新陳代謝率減少很多，但是記得，因為整體的減重而且 40% 並不靠近 100%，100% 就會會完全停止你的新陳代謝，而且這些還是低於最大可能的 Calorie Deficit，底線就是，如果飢餓模式是真的，那麼它就會起作用且可以避免減重產生的壓力 如果你覺得這個研究是捏造的，有一個相似的現象也會發生在長期的 Calorie Deficit，這個現象包含微量的降低新陳代謝，且會增加飲食的慾望和疲勞，這是因為透過大量減少飲食會增加你的壓力，並間接增加皮質醇水平，這也是我建議我的學生用適量的，而不是大量的 Calorie Deficit，而且要定期做飲食休息 把這些加在一起，會讓你的減重飲食體驗更加可以忍受，且可以增強你的動機和能量，總結來說，飢餓模式有一些是正確的，但是大部分都是誇大了 如何建立好的飲食習慣 健康飲食的飲食的基礎 有效的四種改變 從完整的食物或是補充蛋白取得大部分的蛋白質 從全麥榖物、水果和蔬菜取得大部分的碳水化合物 從不飽和脂肪的來源取得大部分的脂肪 攝取大量維他命和礦物質的食物 把四樣法則變成一樣 未加工的食物，像是蔬菜、水果、堅果或是雞蛋都遵從這四樣原則，還有一些微量加工的食物，也符合這些法則，像是瘦肉和特定的乳製產品 蛋白質解釋 如同妳知道的，在減重飲食和健身中，蛋白質是最重要的 Macronutrients，因為我們的身體不會自己產生蛋白質或是蛋白質的基礎要件-氨基酸，我們需要從飲食中攝取，當我們吃高蛋白食物的時候，蛋白質會分解到消化系統裡面，然後形成氨基酸並供給我們生存和健康 在特定的蛋白質形式間有一個不同，它們的不同來自於兩種主要因素 第一：消化，蛋白質可以完全消化可能是錯誤的，當你吃下任何蛋白質食物，部分的蛋白質會被消化，而另外一部份會消失或是被身體排出體外，如果我們用多高蛋白質比例被消化來整理所有常見的蛋白質食物來源，我們可以知道： 幾乎所有的動物蛋白質都有相當高的消化性(接近 100%) 一些植物性蛋白只有稍微低於動物性蛋白，例如：大豆，但是其它植物性基礎來源的蛋白質都只能少部分消化，也就是說，跟動物性蛋白相比，從植物性基礎來源取得同量的蛋白質，你需要攝入更多水果，因為很多蛋白會在消化過程中消失 第二：氨基酸分佈，現在有兩種蛋白，一種是完全蛋白，就是包含所有基礎氨基酸，另外一種是不完全蛋白，就是沒有包含所有基礎氨基酸，動物性蛋白最後在蛋白質名單中會是高量的，它們全部都是完全蛋白，而大部分的植物來源蛋白質是不完全的，但是它們可以形成補助攝入鍵結(complementary intake pairs)，然後讓這些不完全蛋白變完全，像是大豆和米飯在一起 如果我們綜合以上資訊來重新檢視蛋白質，我們可以提出一個高質量蛋白質來源名單，蛋白質質量(從高到低) 牛奶蛋白(Casein、Whey) 雞蛋蛋白 牛肉 鷹嘴豆(chickpea) 黑豆 花生 米飯 全麥 對大部分的素食者來說，蛋白質質量不是問題，因為如果用一些額外的步驟，他們也可以得到相當好的蛋白質，所以如果你是素食者，你可以這麼做： 專注於完全植物來源，像是菜籽油(Canola)和大豆都是補助蛋白，像是米飯和大豆，在平常外食時攝入更多蛋白質來補償不好消化和植物性蛋白的氨基酸數量 考慮到補充一些微養分，很多素食者會攝入維他命 B 和鐵質 碳水化合物解釋 比較不同的碳水化合物來源，可以使用三個層面來比較： 微營養素和纖維，這個層次是在看食物含有多少維他命、礦物質和纖維，纖維是碳水化合物的一種，身體不能夠完全消化，但是它有很多健康效益，像是補助其它食物消化和降低膽固醇水平 血糖指數(glycemic index)，這個層次是在看碳水化合物多快可以提升身體血糖和胰島素水平，所有的碳水化合物來源都可以用這個比較，從純葡萄糖(glucose)為 100% 到純纖維為 0%，但是血糖指數有一些缺陷，而且並不是衡量碳水化合物最好的指標 飽足感(satiety)，所有的碳水化合物都可以根據提升多少飽足感來做比較，食物讓你持續越久的飽足感，你就不太會吃太多 綜合以上，我們可以整理出品質高到低的碳水化合物清單，大部分都是穀物、水果和蔬菜，它們全部都帶有維他命、礦物質和纖維，它們還可以提升飽足感且在血糖指數也都較低，也就是說，健康基礎的飲食，這些碳水化合物應該就是你需要注意的地方 非常高 大部分的蔬菜 大部分的水果 馬鈴薯 燕麥粥或其他全麥食物 高 豆子 全麥麵包 通心麵 米飯 低 薯條 白麵包 冰淇淋 非常低 薯片 餅乾、蛋糕、糖果棒 膳食脂肪解釋 除了蛋白質和碳水化合物，脂肪是三樣主要 Macronutrients 裡面的其中一樣，意思是，你的身體需要一些脂肪酸來生存，而且不能夠藉由其它食物來產生 脂肪被需要用來調節激素生產，保持你的頭髮和皮膚健康，而且能夠吸收維他命 A、D、E和K(脂溶性脂肪) 脂肪細胞隔絕你的身體且幫助你保持溫暖 1 公克脂肪 =&gt; 9 卡路里 (蛋白質和碳水化合物的兩倍) 兩種脂肪型態：飽和脂肪和非飽和脂肪 飽和脂肪(像是奶油、起司、全脂牛奶)：飽和脂肪都長期被相信是不好的脂肪，且可以提升低密度脂蛋白(low-density lipoprotein，簡稱LDL)膽固醇水平，而膽固醇是一樣柔軟的蠟質物質會導致動脈堵塞，然而，大量的低密度脂蛋白(LDL)理論上可以讓你心臟病發作、中風和其它健康問題，到現在，飽和脂肪酸和低密度脂蛋白問題比以前認為的少很多，在辯論中，飽和脂肪可以直接增加心臟問題仍然是未知數，但是直到我們知道更多之前，我們最好還是限制大量吃含飽和脂肪食物，食物含有大量包和脂肪或是動物脂肪，像是起司、冰淇淋、奶油和肥肉，一些植物油像是椰子、棕櫚和棕櫚籽油都含有飽和脂肪，你可以輕易辨識飽和脂肪，它們在常溫底下通常都是固體的 不飽和脂肪：幫助降低你的低密度脂蛋白，大部分的植物油在常溫底下通常都是液體的，而不飽和脂肪油又可以分為兩類： 多飽和脂肪：橄欖油、菜籽油 多不飽和脂肪：紅花油、葵花油、粟米油(corn oil)、大豆油 反式脂肪(Trans fats)：當蔬菜被灌入氫氣時形成 =&gt; 避免，灌入氫氣是為了要讓食物保鮮更久，問題是研究指出這些相對較少數量的脂肪會提高不同健康問題的風險，包含心臟疾病、老年癡呆症(Alzheimer’s)、乳癌、憂鬱症和更多疾病，請盡量避免食物有氫化或是部分氫化油，像是熱奶油和人造奶油(Margarine) 健康的脂肪食物 攝入有質量的食物其實很簡單，而且很美味，高脂肪食物也很神奇地健康且營養 不飽和脂肪的來源： 鱷梨(Avocados) 鮭魚 橄欖和橄欖油 堅果和堅果油 =&gt; 不要被處理過的 亞麻籽(flaxseed) 鮪魚 黑巧克力 葵花籽 健康的飽和脂肪來源 全蛋 高質量的肉 全脂牛奶 雞胸肉 反式脂肪來源 =&gt; 你應該要避開且限制的 披薩 熱狗 漢堡 任何速食 任何炸物 如何對一個較健康的飲食做正確的改變？ 改變飲食來改善健康和減重通常是密不可分的，像是蔬菜、穀物和水果通常都被認定為健康的而且低卡路里，可以改善飽足度且對減重很好，根據你現在的飲食，包含這些食物，還要應用以前所學的減重法則，就可以改變非常多 這邊提供一個「遊戲計畫」，這樣才不會覺得要一次做很多事情 如果沒有什麼經驗，只要一次改變一件事情就好，直到你習慣第一個改變之前，不要做太多改變或直接跳到下面一個步驟，太多人想要一次改變每一件事情，最後一事無成，更多人認為健康飲食對他們忙碌的人生太困難，然後很快就放棄，但是你只要做小改變，然後慢慢習慣它，到下一個步驟以前，你不會覺得太多，那對長期來說，就是非常棒的 步驟一：Calorie Deficit 計算你的每日卡路里且從裡面減少 20% 確定透過吃大部分健康的食物達到卡路里量，意思是你必須要盡可能地吃健康的食物，像是瘦蛋白、水果、蔬菜、全麥和健康的脂肪來源，可以吃一些垃圾食物嗎？可以，但是不要常常吃，而且要保持和檢查卡路里是否超標，如果你可以這樣做，你將會看到很好的結果，因為你已經有 Calorie Deficit，而且還為身體健康攝取到足夠的維他命、礦物質 步驟二：Macronutrients 一旦你實踐了步驟一，你就可以開始下一個步驟了，開始追蹤你每日的 Macronutrients，特別是蛋白質，確保你攝取足夠的量供給給肌肉維護，最好的主意就是每一餐和點心都吃下蛋白質，可以是雞胸肉、魚或是如果你是素食者，可以吃一些豆子和堅果，一旦你有了蛋白質，你可以加一些蔬菜和水果，這樣就是很滿足的一餐了，但是如果你需要額外的能量來健身，吃下有質量的碳水化合物像是米飯、馬鈴薯或是油菜(canola)，你可以不用在每一餐都加入膳食脂肪，但是請確定要達到一天所需的量 步驟三：飲食計畫 現在我們有 Calorie Deficit，且大部分都吃健康的食物，還達到你每日所需的 Macronutrients，你就差不多設置好了，還有一個就是幫助你維持減重飲食，就是飲食計畫 嘗試每天讓你的早餐、午餐、晚餐和點心維持相同的份量和時間 雖然設置吃飯時間沒關係，但是這是一個很好的心理作用，讓你總是在同樣的時間吃同樣份量的食物，只要你依照你的計畫進行這些就會更容易，如果你達到這一個步驟，而且對改變覺得很輕鬆，那麼你就成功達成減重飲食，這基本上對長期成功是很完美的設置 如何正確地閱讀營養標籤？ 檢查成分：越少越好，成分是用容量去排列的，也就是說，排列在越前面的成分，你可以在你的產品裡面找到越多，例如：如果你看到你的產品上面第一個是糖、玉米糖漿或是任何非常甜的東西，那你最好要避開這個產品，而且限制攝入量 從上面開始檢查一份的大小，以 100g 為基礎比較食物 檢查卡路里總量：這只有告訴我們食物有多少能量，但是沒有說能量從哪裡來 檢查脂肪：大部分熱量應該都是從不飽和脂肪來的，還有一些是從反式脂肪來的，所以越高的反式脂肪就是一個要避免的指標 檢查膽固醇和鈉：可以看右側的每日建議食用量，如果低於 5% 就是低，高於 20% 就被視為是高 檢查碳水化合物：糖的數量應該要低，而且纖維要高，例如：如果你看到食物有 30g 的碳水化合物，但是 10g 是來自糖，那就不是一個好現象 檢查蛋白質：越高越好 檢查 Micronutrients：一般來說，越多維他命和礦物質越好，唯一的例外就是鈉，但是它已經在標籤的上面了","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Weight Loss","slug":"Weight-Loss","permalink":"https://vincent.fishboneapps.com/tags/Weight-Loss/"},{"name":"Nutrition","slug":"Nutrition","permalink":"https://vincent.fishboneapps.com/tags/Nutrition/"}]},{"title":"減重和營養快速學習自我挑戰 Day2","slug":"減重和營養快速學習自我挑戰-Day2","date":"2018-01-27T12:58:25.000Z","updated":"2020-06-22T17:16:51.324Z","comments":true,"path":"2018/01/27/減重和營養快速學習自我挑戰-Day2/","link":"","permalink":"https://vincent.fishboneapps.com/2018/01/27/%E6%B8%9B%E9%87%8D%E5%92%8C%E7%87%9F%E9%A4%8A%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day2/","excerpt":"","text":"設定減重配方 確定你需要的卡路里 TDEE = Total daily energy expenditure (每日能量支出) BMR = Basic Metabolic Rate (基礎代謝率) 計算 TDEE 線上計算器 或是 第一步：使用估計的 TDEE 值且每天攝取這個量的卡路里 第二步：監控你的體重改變 第三步：重量不改變的地方來找到卡路里，如果體重減少，代表 TDEE 估計值太高，應該要減少 100 卡路里，反之亦然。 範例 182 公分、81 公斤且 25 歲的男生 如果我們假設他每週高強度訓練三到四次，他的每天的 TDEE 就會落在 2500 到 2700 卡路里 使用 2500 或 2700 進行減重飲食，根據大約十天到兩週的時間觀察，如果你開始增重，就要減少 TDEE 的估計值了，不過需要注意的就是，如果你不運動或是很少運動，這個值就會低很多，如果同樣的人不運動，TDEE 就會落在 2000 到 2200 卡路里。 為減重調整你的飲食 182 公分、81 公斤的男性 (不運動) TDEE 約在 2000 到 2200 卡路里 一般來說，有三種 Calorie Deficit，最小的約 10-15% 的 TDEE、適量的約 15-20% 的 TDEE、而最大的就是比你 TDEE 低 25% 的值 小量的 Calorie Deficit 會讓肌肉流失最低，然而研究卻顯示最大的 Calorie Deficit 並不代表肌肉會流失比較多，如果你保持一個嚴格的健身方案 除此之外，如果你的目標是要減少身體脂肪更低的情況，低於 20% 的 TDEE 的值是最好的選擇 然而，如果有人新陳代謝快速且用小量 deficit 也會達到類似的效果，同時可以在你減重飲食的時候吃更多食物且使用更少的力量減肥 從 2000 減少 20% =&gt; 1600 卡路里 182 公分、81 公斤的男性 (運動) TDEE 約 2500 卡路里 適量 Deficit - 低於 TDEE 20% 從 2500 減少 20% =&gt; 2000 卡路里 從以上的例子可以知道運動可以造成巨量的改變，且允許你每天攝取更多的食物 如何正確的監控卡路里 研究顯示追蹤卡路里的人可以減掉更多體重 你需要三樣東西：食物、卡路里監控軟體(Fitatu)、廚房秤 如何使用磅秤 確保你的卡路里和 Macronutrients 的值足夠正確 確保整個流程更加簡單，而且耗費更少時間 秘訣 不需要擔心小事情 (像是咖啡或是食物上的番茄醬、芥末醬等等)，但是記得像是橄欖油是高卡路里，只要一湯匙就會帶給你很多卡路里 有時候你只需要秤重一次，如果你規律地吃特定食物，你只需要秤重一次，這時候你其實已經知道視覺上的量大概是多少，你就更容易用眼睛準確地看出數量 生的或是煮過的？確保你監控的食物是煮過的還是生的，像是米飯再煮熟的過程中會有很多水，就會讓你的卡路里計算產生誤差，有時候甚至會破壞你的減重飲食，還是像是雞肉，有皮和沒有皮的也有差別 在追蹤 App 中檢查卡路里和 Macronutrients 的值，因為有時候很多值是錯誤的，所以你要上網搜尋可信任來源，如果你覺得某些值可能是錯誤的 你真的只需要使用食物秤一次，如果你可以使用重複的飲食計畫，也正是我最建議的，因為這是到目前爲止最簡單也最容易做卡路里和 Macronutrients 的計算，這樣一來，飲食就會變成例行性且自動的 減重需要多少蛋白質 如果在減重飲食的過程中，不攝取足夠的蛋白質，你的身體不只不會燃燒脂肪，你還會很難得到肌肉。 最佳化蛋白質攝取 體重每一磅攝取 0.8 公克到 1.0 公克的蛋白質(這是用在你規律運動且做高強度訓練的狀況下) 如果你不做運動，或是只做心肺運動，你可以降低範圍，因為你並沒有給你的肌肉足夠的壓力 舉例：180 磅的男生應該要每天攝取 145 公克到 180 公克的蛋白質 在範圍內，我應該選擇什麼樣的攝取量？ 有兩樣要素：體脂肪率和活動等級 如果你越瘦，代表的就是你肌肉比你的脂肪多，那麼你的身體就需要更多的蛋白質；如果男生的體脂肪低於 10%、女生體脂肪低於 20%，代表就是你高度活動且有高強度運動，那麼你就需要每磅的體重攝取到 1 公克的蛋白質 但是，大部分的人通常只需要每天每磅的體重攝取 0.8 公克的蛋白質就已經足夠了 減重需要多少脂肪 每磅去脂體重需要約 0.3 公克的脂肪，去脂體重就是身體不是脂肪的重量，例如：肌肉、水和骨頭，因為不知道如何計算去脂體重，所以用 TDEE 來算，去脂體重會轉換成約 15%-20% 的 TDEE 最佳化脂肪攝取 180 磅的男生 (TDEE 為 2000 卡路里)：2000 * 0.2 = 400 卡路里 有運動的 180 磅的男生 (TDEE 為 2500 卡路里)：2500 * 0.2 = 500 卡路里 1 公克的脂肪等於 9 卡路里 400 卡路里 / 9 = 45 公克/天 500 卡路里 / 9 = 55 公克/天 減重需要多少碳水化合物 減重飲食中，碳水化合物的角色是最有爭議性的且最常被熱烈辯論的，但是我提供最簡單且科學的方式來計算需要多少碳水化合物 最佳化碳水化合物攝取 如果你不運動，那麼碳水化合物是選擇性的 但是如果你規律運動，那麼基本上碳水化合物是必須的 我建議你用碳水化合物來填滿剩下每天可攝取的卡路里量 結合你的 Macronutrients 簡單減重 (常運動的男性) 每天會減重的可攝取卡路里：2000 卡路里 蛋白質：145 卡路里 (=&gt; 600 卡路里) 脂肪：500 卡路里或 55 公克 沒計算到的：900 卡路里 =&gt; 碳水化合物 (=&gt; 225 公克) 簡單減重 (不常運動的男性) 每天會減重的可攝取卡路里：1600 卡路里 蛋白質：145 卡路里 (=&gt; 600 卡路里) 脂肪：400 卡路里或 45 公克 沒計算到的：600 卡路里 =&gt; 更多蛋白質、更多脂肪或碳水化合物，或三種的結合 我建議他用碳水化合物或蛋白質填滿剩下的卡路里，因為每公克的脂肪就會等於 9 卡路里，從卡路里的角度來看，你可能很容易就吃過量的食物，另外一個問題就是這些食物跟蛋白質和碳水化合物比起來更沒有飽足感 綜合來說，不運動的人，飲食中還是需要碳水化合物，然後剩餘量的卡路里用來攝取更多蛋白質，這個方法比起你攝取很多脂肪，可以讓你減少飢餓感 合適的飲食時機和飲食頻率 吃幾餐並沒有關係，所有的研究顯示不同的頻率基本上都會有相同的結果 少量多餐並不會增強你的新陳代謝到任何有意義的層次 吃六餐在實際上，你並沒有足夠的時間一直準備餐點，而吃一餐，並不能夠攝取到足量的卡路里，而且你的身體會一次消化所有食物，讓你沒有辦法儲存蛋白質供給你之後所需 不要過度複雜化事情，每天適合的飲食最好一天三次到六次 飲食的時機 需要在特定時間攝入特定的食物嗎？這要看狀況，基本上只要你的身體覺得足夠就好，只要你提供穩定的蛋白質維持肌肉質量即可 如果你運動的話，那麼理所當然地，你需要在你健身前後攝入特定食物 這些食物稱為運動前餐(pre-workout meals)和運動後餐(post-workout meals)，這代表做以下事情 減少肌肉糖原(glycogen)耗盡 減少肌肉蛋白質分解 減少運動後皮質醇(cortisol)水平 確保最佳化的恢復 在運動前後，吃下蛋白質和碳水化合物，就是這麼簡單，太多人過度複雜化這件事情了 飲食綱領：在運動前後一小時吃下一個均衡餐點，每一磅目標體重吃下 0.2 - 0.25 g (碳水化合物和蛋白質都要) 如果沒有時間在運動前後吃下食物，或是距離你的上一餐不到兩小時，你就在運動前 30 分鐘吃一些容易消化的蛋白質或是碳水化合物，像是蛋白質棒或是香蕉，我個人喜歡在運動前一小時吃下糙米雞肉飯和蔬菜，看起來沒有什麼特別的，就只是在運動前 1~2 小時由正常食物所得到蛋白質和碳水化合物 不需要比這個更複雜，也不用執著於特定餐點 飲食建議 在運動前 1 小時用餐： Whey 蛋白和燕麥粥混合 全麥麵包的大雞腿三明治 兩顆或是更多水煮蛋放在鱷梨吐司(Avocodo Toasts)上 全麥麵食加上一些蛋白質 運動前 30 分鐘的點心： 香蕉和蛋白棒 蘋果切片和花生醬 蛋白棒 如何設計你的理想餐點計畫 當你想要減重的時候，你吃多少比你吃什麼更加重要 只要你堅持你的每日卡路里量和 Macronutrients，就已經足夠了 你的身體需要維他命和礦物質來保持健康，而且需要足夠的能量來運動 當你在做飲食計畫的時候，用 80% 到 90% 的卡路里來計算未加工的好食物，留下 10% 到 20% 給壞食物 吃太多高熱量的加工食物就代表食物的質量越少，飽足感也會更少，這樣會導致更多飢餓感的產生，所以如果你遵從簡單的 80/20 法則，這樣會更容易堅持你的飲食計畫，而且你也能夠吃到你喜歡的食物 男生的減重飲食計畫 183 公分且體重 180 磅的男生且每週訓練 3 次 (TDEE = 2500 大卡) 餐點 1 兩顆蛋：156 大卡 (14.1g 蛋白質、11g 脂肪、0g 碳水化合物) 一根香蕉：118 大卡 (1.4g 蛋白質、0.4g 脂肪、27g 碳水化合物) 50g 的燕麥粥：201 大卡 (6.2g 蛋白質、4.3g 脂肪、36.4g 碳水化合物) 餐點 2 25g 混合堅果：145 大卡 (5.9g 蛋白質、12.3g 脂肪、2.9g 碳水化合物) 30g Whey 蛋白分離乳清：111 大卡 (25.8g 蛋白質、0g 脂肪、1.6g 碳水化合物) 餐點 3 100g 糙米飯(煮過的)：139 大卡 (2.6g 蛋白質、1.1g 脂肪、29.2g 碳水化合物) 100g 雞胸肉(去皮)：160 大卡 (31g 蛋白質、3g 脂肪、0g 碳水化合物) 150g 混合沙拉(無調味醬)：43 大卡 (2.7g 蛋白質、0.7g 脂肪、6.6g 碳水化合物) 餐點 4 200g 糙米飯(煮過的)：279 大卡 (5.2g 蛋白質、2.2g 脂肪、58.4g 碳水化合物) 150g 鮭魚：270 大卡 (31g 蛋白質、16.5g 脂肪、0g 碳水化合物) 150g 混合沙拉(無調味醬)：43 大卡 (2.7g 蛋白質、0.7g 脂肪、6.6g 碳水化合物) 餐點 5 30g Whey 蛋白分離乳清：111 大卡 (25.8g 蛋白質、0g 脂肪、1.6g 碳水化合物) 一根香蕉：118 大卡 (1.4g 蛋白質、0.4g 脂肪、27g 碳水化合物) 一顆蘋果：75 大卡 (0.6g 蛋白質、0.2g 脂肪、17.4g 碳水化合物) 全部：1969 卡路里、155g 蛋白質、52.8g 脂肪、214.8g 碳水化合物 183 公分且體重 180 磅的男生每週訓練少於 3 次(TDEE 約在 2200 大卡) 餐點 1 兩顆蛋：156 大卡 (14.1g 蛋白質、11g 脂肪、0g 碳水化合物) 一根香蕉：118 大卡 (1.4g 蛋白質、0.4g 脂肪、27g 碳水化合物) 30g 的燕麥粥：120 大卡 (3.7g 蛋白質、2.6g 脂肪、21.8g 碳水化合物) 餐點 2 25g 混合堅果：145 大卡 (5.9g 蛋白質、12.3g 脂肪、2.9g 碳水化合物) 30g Whey 蛋白分離乳清：111 大卡 (25.8g 蛋白質、0g 脂肪、1.6g 碳水化合物) 餐點 3 100g 糙米飯(煮過的)：139 大卡 (2.6g 蛋白質、1.1g 脂肪、29.2g 碳水化合物) 100g 雞胸肉(去皮)：160 大卡 (31g 蛋白質、3g 脂肪、0g 碳水化合物) 150g 混合沙拉(無調味醬)：43 大卡 (2.7g 蛋白質、0.7g 脂肪、6.6g 碳水化合物) 餐點 4 100g 糙米飯(煮過的)：140 大卡 (2.6g 蛋白質、1.1g 脂肪、29.2g 碳水化合物) 150g 鮭魚：270 大卡 (31g 蛋白質、16.5g 脂肪、0g 碳水化合物) 150g 混合沙拉(無調味醬)：43 大卡 (2.7g 蛋白質、0.7g 脂肪、6.6g 碳水化合物) 餐點 5 30g Whey 蛋白分離乳清：111 大卡 (25.8g 蛋白質、0g 脂肪、1.6g 碳水化合物) 一根香蕉：118 大卡 (1.4g 蛋白質、0.4g 脂肪、27g 碳水化合物) 一顆蘋果：75 大卡 (0.6g 蛋白質、0.2g 脂肪、17.4g 碳水化合物) 全部：1749 卡路里、151.3g 蛋白質、50g 脂肪、171g 碳水化合物 女生的減重飲食計畫 162 公分 135 磅的女生且每週訓練 3 次 (TDEE 約在 2000 大卡) 餐點 1 一顆蛋：78 大卡 (7g 蛋白質、5.5g 脂肪、0g 碳水化合物) 一根香蕉：118 大卡 (1.4g 蛋白質、0.4g 脂肪、27g 碳水化合物) 50g 的燕麥粥：201 大卡 (6.2g 蛋白質、4.3g 脂肪、36.4g 碳水化合物) 餐點 2 20g 混合堅果：116 大卡 (4.7g 蛋白質、9.8g 脂肪、2.3g 碳水化合物) 20g Whey 蛋白分離乳清：74 大卡 (17.2g 蛋白質、0g 脂肪、1.1g 碳水化合物) 餐點 3 100g 糙米飯(煮過的)：139 大卡 (2.6g 蛋白質、1.1g 脂肪、29.2g 碳水化合物) 100g 雞胸肉(去皮)：160 大卡 (31g 蛋白質、3g 脂肪、0g 碳水化合物) 150g 混合沙拉(無調味醬)：43 大卡 (2.7g 蛋白質、0.7g 脂肪、6.6g 碳水化合物) 餐點 4 100g 糙米飯(煮過的)：139 大卡 (2.6g 蛋白質、1.1g 脂肪、29.2g 碳水化合物) 100g 鮭魚：225 大卡 (25.3g 蛋白質、13.8g 脂肪、0g 碳水化合物) 150g 混合沙拉(無調味醬)：43 大卡 (2.7g 蛋白質、0.7g 脂肪、6.6g 碳水化合物) 餐點 5 20g Whey 蛋白分離乳清：74 大卡 (17.2g 蛋白質、0g 脂肪、1.1g 碳水化合物) 一根香蕉：118 大卡 (1.4g 蛋白質、0.4g 脂肪、27g 碳水化合物) 全部：1528 卡路里、122g 蛋白質、40.8g 脂肪、166.5g 碳水化合物 162 公分 135 磅的女生且每週訓練少於 3 次 (TDEE 約在 1700 大卡) 餐點 1 一顆蛋：78 大卡 (7g 蛋白質、5.5g 脂肪、0g 碳水化合物) 一根香蕉：118 大卡 (1.4g 蛋白質、0.4g 脂肪、27g 碳水化合物) 30g 的燕麥粥：120 大卡 (3.7g 蛋白質、2.6g 脂肪、21.8g 碳水化合物) 餐點 2 20g 混合堅果：116 大卡 (4.7g 蛋白質、9.8g 脂肪、2.3g 碳水化合物) 20g Whey 蛋白分離乳清：74 大卡 (17.2g 蛋白質、0g 脂肪、1.1g 碳水化合物) 餐點 3 100g 糙米飯(煮過的)：139 大卡 (2.6g 蛋白質、1.1g 脂肪、29.2g 碳水化合物) 100g 雞胸肉(去皮)：160 大卡 (31g 蛋白質、3g 脂肪、0g 碳水化合物) 150g 混合沙拉(無調味醬)：43 大卡 (2.7g 蛋白質、0.7g 脂肪、6.6g 碳水化合物) 餐點 4 100g 糙米飯(煮過的)：139 大卡 (2.6g 蛋白質、1.1g 脂肪、29.2g 碳水化合物) 100g 鮭魚：225 大卡 (25.3g 蛋白質、13.8g 脂肪、0g 碳水化合物) 150g 混合沙拉(無調味醬)：43 大卡 (2.7g 蛋白質、0.7g 脂肪、6.6g 碳水化合物) 餐點 5 20g Whey 蛋白分離乳清：74 大卡 (17.2g 蛋白質、0g 脂肪、1.1g 碳水化合物) 半根香蕉：59 大卡 (0.7g 蛋白質、0.2g 脂肪、13.5g 碳水化合物) 全部：1388 卡路里、118.8g 蛋白質、38.9g 脂肪、138.4g 碳水化合物 減重營養品 在減重金字塔中，營養品只會少部分影響你的飲食，大約整體結果的 5%-10%，我只推薦兩種東西：蛋白粉和肌酸，這兩樣東西被證實是有效的，而且沒有任何副作用，但是蛋白粉有一個問題-液體卡路里，液體卡路里比起固體卡路里沒有不健康，但是他們會快速被消化且讓你覺得更不滿意，這讓你更容易多吃超過你的每日卡路里量 如果你被飢餓所困擾，蛋白質或代餐並不是很好的主意，取而代之的，煮一些蛋白加上蔬菜或是吃雞柳條都可以提供你足夠的蛋白質且讓你不會太快飢餓，但是如果你沒有飢餓的問題，而且你很難達到每日蛋白質量，那麼蛋白粉對你的減重飲食來說就是很好的補充物 燃脂補充物？燃脂物可以： 增強新陳代謝 從破壞你的飲食計畫來減少飢餓感 讓整體飲食計畫的感受更愉悅 確保燃脂補充物有以下成分： 咖啡因 - 幫助你輕微地增加新陳代謝，還可以讓你重訓的時候更加有力量 辛弗林(Synephrine) - 化學合成物從柑橘類(Citrus)水果提煉而來，特別是苦的水果，研究顯示，辛弗林可以增強新陳代謝，而且與咖啡因一起食用的時候效果更佳 綠茶萃取物 - 輕微地加速運動時減脂效果 Naringenin &amp; Hesperidin - 在葡萄柚、橘子和番茄表皮的分子，可以增強血液流動 為什麼我不食用燃脂補充物？ 即使特定燃脂補充物是純的配方，也沒有超量服用，對整體來說也沒有太大的影響，最最最重要影響你減重結果的就是適量的 Calorie Deficit，還有有效的運動 運動和減重 額外的運動可以幫助你生成肌肉和增加精力，還有，運動會增加每日能量支出 如何創造 Calorie Deficit 藉由飲食創造 Calorie Deficit 藉由運動創造 Calorie Deficit 藉由以上兩者創造 Calorie Deficit 第三項是我最喜歡的，因為我想要確保當我減重飲食時，我不會流失肌肉，而且跟不運動比起來，它可以允許我稍微吃多一點 基本上，你需要找到你的甜蜜點可以達到你的理想 Calorie Deficit，假設你要吃低於 TDEE 500 卡路里，你可以少吃 500 卡路里的食物，或是透過運動來燃燒 500 卡路里，大概等於 1 小時 15 分鐘的慢跑，或是把兩個混合起來，例如：少吃 250 卡路里，且用運動燃燒 250 卡路里，理論上，最後的結果都會一樣，但是個人還是比較推薦兩項並行，因為這對你的肌肉和整體健康很好 可以同時增肌和減脂嗎？ 這是一個很困難的問題，因為沒有任何一個答案可以符合所有的解答 不同能量需求 減脂：需要 Calorie Deficit 增肌：需要 Calorie Surplus 所以可以達成嗎？可以！但是只有在特定條件下 如果排除類固醇使用和遺傳學的影響，可以減脂和增肌的唯一時機就是你是新手且有點超重，因為未訓練的新手對刺激和肌肉訓練會非常有反應，肌肉成長會比有經驗的舉重選手更快，如果你快速肌肉的生長，且你保持 Calorie Deficit，你的身體會提供額外的能量來增肌 如何達成？ 創造適量的 Calorie Deficit 攝取足夠的蛋白質 遵守好的健身計畫 不幸地，你越瘦就越難達到這件事情","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Weight Loss","slug":"Weight-Loss","permalink":"https://vincent.fishboneapps.com/tags/Weight-Loss/"},{"name":"Nutrition","slug":"Nutrition","permalink":"https://vincent.fishboneapps.com/tags/Nutrition/"}]},{"title":"減重和營養快速學習自我挑戰 Day1","slug":"減重和營養快速學習自我挑戰-Day1","date":"2017-12-21T13:53:06.000Z","updated":"2020-06-22T17:16:47.376Z","comments":true,"path":"2017/12/21/減重和營養快速學習自我挑戰-Day1/","link":"","permalink":"https://vincent.fishboneapps.com/2017/12/21/%E6%B8%9B%E9%87%8D%E5%92%8C%E7%87%9F%E9%A4%8A%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day1/","excerpt":"","text":"介紹 會學到什麼？ 減重的科學 減重迷思揭穿 減重金字塔 減重和減脂的不同 正確減脂的食物 設計減重飲食 在飲食中卡路里的角色 如何建構微營養素(蛋白質、碳水化合物和脂肪) 如何在一天中的哪個時刻吃飯 需要進食多少餐 普遍的飲食問題解決 如何突破減脂停滯期 (Fat Loss Plateaus) 如何解釋非預期的重量改變 如何建構完美的作弊餐，而且不會破壞你的減重飲食 建立健康的飲食習慣 做正確的食物選擇 最好的蛋白質、碳水化合物和膳食脂肪 (Dietary Fat) 的來源 如何做飲食小改變來達到長久的影響 (一步一步教學) 減重的動機 如何適當的追蹤進度 如何設定聰明的運動目標 如何讓意志力運作，且當你喘不過氣時，要怎麼做？ 使用對減重動機的 Role Models 的正確方式 什麼是脂肪？ 形成身體脂肪的最基本方式就是儲存能量 身體最在乎的就是生存，當人沒有持續攝入食物，飢餓就會成為最大部分的影響生存的危機 身體脂肪允許你可以儲存過量的能量，換句話說，它就是預備食物的儲存容器；然而，現在有大量的食物，身體機制仍然想要儲存任何多餘的能量，因為它想要最大化生存的機會 燃燒脂肪的方式很簡單，就像以前古人用脂肪來儲存能量，我們要創造一種可以燃燒脂肪的環境 在減重後面的理論和科學 減重迷思揭穿 (錯誤的觀念釐清) 部位減重迷思 錯誤：想要減特地部位的脂肪儲存，只要瞄準該部位運動即可 正確：特定運動只會強化部分肌肉，但是他們不會減少那個部位的脂肪儲存；脂肪減少發生在整個身體，而不是區域部位 排毒會幫助減重 = 短期飲食注重在果汁，且限制較不健康的食物和飲料，用來排除體內毒素 沒有任何證據支持排毒飲食可以幫助減少身體毒素，因為身體需要長期改變飲食和運動，而不是只有喝一些排毒的飲料，事實上，突然的改變飲食會剝奪身體的適量卡路里和營養，讓情況更加惡劣 如果你限制每日卡路里，然後建立飢餓飲食，這樣會讓你失去前幾天大部分的水分和糖分 (glycogen)，當你開始正常飲食之後，你的體重又回到跟以前一樣，而且，嚴厲的卡路里限制會導致你失去肌肉，目標是減脂而不是失去肌肉，當你限制太多卡路里攝入，你就不能達到這樣的目標，除此之外，讓你的身體飢餓越久，你會覺得越來越差，你的能量階層 (Energy Level) 會崩潰，而且你會掙扎於飢餓的渴望和憂鬱等等…，所以，取而代之的，你應該建立長期改變整體飲食和生活方式 碳水化合物會讓你變胖 通常有些人會說攝入碳水化合物會增加胰島素 (insulin) 且導致更多的脂肪儲存，有部分科學證據支持這種說法，然而，有部分證據支持碳水化合物會導致胰島素 (insulin) 變得遲鈍，但是這是對那些糖尿病前期食用過多高糖碳水化合物的人的特定案例；所以這是第一點是對的，如果你不運動，而且每天持續的吃大量的糖果棒和巧克力等碳水化合物，就會負面影響你的健康和重量 然而，如果你遵從均衡飲食和定期運動，那麼好的碳水化合物對強化健身是必要的；大部分的人應該要攝入好的碳水化合物，就是有大量纖維素的碳水化合物可以幫助你感覺更有飽足感 從飲食中減少碳水化合物也代表限制你的能量來源，且限制你肌肉成長的潛力 飲食油脂讓你變胖 攝入脂肪並不會讓你變胖，除非你長期的卡路里過多 事實上，減少脂肪攝入會非常危險，因為你的身體需要消耗脂肪酸來產生賀爾蒙，低脂減肥法會減少你的睪固酮 (testosterone) 產量，所以要確定取得適量的 Omega-3 和 Omega-6 脂肪酸 事實上，很多低脂肪產品跟正常的相同產品相比，含有更多卡路里 還有另外一個迷思就是飽和脂肪酸會導致健康問題，這有部分正確，因為根據我們今天所知道的，大量的飽合脂肪酸可能會讓心臟有問題，然而，目前還沒有任何證據說飽和脂肪酸會直接導致心臟問題，所以，限制飽和脂肪酸的攝入量是合理的，而且要攝入好的飽和脂肪酸，像是椰子油或高質量的草餵肉(吃草的動物所做成的肉品) 唯一一種你應該避免他們轉換成脂肪的脂肪-這種脂肪可以在高度處理和油炸食品裡看到 低脂食物可以減重 低脂食品都被標記為低脂低碳水化合物且有人工的甜味，低脂和低碳水化合物並不代表低卡路里，如果你想要減重，去買這些低脂產品，可能會破壞你的努力，研究顯示參與者吃了 50% 以上被研究員錯誤標記為「低脂」的食物，然後他們對相同的食物貼上正確的營養標籤，因為多數人都假定低脂食物跟一般食物比少有 20% 以上的卡路里，而且不會去檢查營養標籤並確認是否正確，結果是很多人吃了更多，因為他們相信產品的標示是正確的 如果你想要買一個點心，標記是低脂的，檢查營養標籤，檢查一個份量有多少卡路里，且和正常的產品做比較，大部分都是相同的，或甚至正常的產品卡路里更少，千萬不要告訴自己吃更多 Pizza 是可以的，因為你選擇了低脂可樂而不是正常可樂 減重一定要吃清淡的食物 建議吃未加工的食物，大部分的人都攝取太少蔬菜水果，且吃太多速食和糖果，話雖如此，即使你攝入大量的垃圾食物，你還是可以減重 減重其實最終是卡路里攝入和卡路里消耗的比較 如果你都吃 Pizza，但是它的卡路里低於你的身體所需，你還是會減重，反之亦然，如果你吃很多健康食物，但是整體的卡路里還是比你的身體所需更多，你還是會變重 甜蜜點還是專注在健康食物且保持卡路里不足，但是了解減重背後機制更為重要，並不是你吃了什麼重要，而是你吃了多少 減重金字塔 減重金字塔提供不同層次的飲食並根據重要性排列，Calorie Deficit 在最下面，代表所有為減重設計的飲食必須要包含它，跟你吃得多健康或多特別的補品沒有關係，如果沒有 Calorie Deficit，那麼就不會有任何改變 第二個最重要的是 Macronutrients，它就是每日的蛋白質、碳水化合物和膳食脂肪，這些大量營養素隨著你的運動方案會決定你如何減重，是減脂肪、肌肉還是水？當然大家都想減掉純脂肪，所以優化大量營養素是非常重要的，而蛋白質是最重要的營養素，因為他幫助你成長和維持肌肉組織，大量營養素雖然不像卡路里那麼重要，但是它還是可以帶來改變，而且對減重飲食占相當重要的角色 第三個是 Food Composition，食物成份是相當棘手的主題，為什麼他不是最重要的？你需要記在心裡的就是當跟你的健康有關時，食物成分絕對是一個很重要的東西，食物的質量直接影響你的維他命和礦物質的攝入，而且可以大幅改善整個身體狀態，但是當我們只看減重，而且只設計飲食，它就變得相對不重要了，有些案例指出人們即使飲食很糟糕，但是只要確保卡路里不足和攝入足量的蛋白質，仍然可以達到減重的效果 永遠從上面三點開始執行，並不是接下來的不重要，而是確定前面三項都做到了，再繼續執行接下來的，此外，如果生活方式比較忙碌的話，也想要有一套簡單的飲食，只要確定你專注在前兩個或前三個項，這些為你的飲食成功佔有 85% 到 90% 的重要性，足夠對你有很好的結果，人們放棄減重的一個原因就是過度複雜化事情，最後導致混亂 但是如果你想要完善你的飲食且達到 100%，你就要考慮到減重金字塔的最後兩項，就是 Meal Frequency &amp; Meal Timing 和 Supplements，飲食頻率和時間基本上就是多常和一天中什麼時候要吃飯，而補充品則是不被視為普通的或天然的食物，大部分的補充品都是炒作且少數可以長期達到幫助 成功減重的科學 最重要的永遠是 Calorie Deficit，從科學的角度來看，不管你增重或是減重都是由熱力學第一定律來決定，熱力學第一定律就是能量不能被創造或是摧毀，它只能從一種形式轉換成另外一種形式 你的身體重量是依賴於消耗卡路里和燃燒的卡路里相比的不同，也就是卡路里平衡 卡路里 = 食物儲存的能量，一卡路里就是讓一公升的水上升 1°C 的能量，也就是說卡路里就是能量測量的形式，當你吃進食物時，你就會消耗儲存在食物裡的能量，身體接下來使用能量產生動能來保持身體機能，取而代之的，如果所有能量不是這樣被使用，它就會儲存給之後使用，有些能量會儲存在肌肉或是腎臟，但是這些地方儲存的方長快，所以你的身體接下來會以身體脂肪的形式儲存剩餘的卡路里 卡路里平衡 負向卡路里平衡：跟消耗比起來，燃燒過多的卡路里。跟從食物攝取的相比，身體需要更多卡路里來產生每日機能的能量，也就是說，它會燃燒儲存的能量，而且你會減重，因為必要的能量會從身體組織分解，而負向卡路里平衡永遠會減重，減重的效果有時候會被改變和保水所掩蓋，但是如果我們去除這樣的因素，那麼在被發現的醫療史上目前零例外 中性卡路里平衡：跟消耗比起來，燃燒相同的卡路里。一個人攝入的卡路里和他活動身體所消耗的一樣，也就是說，所有你消耗的卡路里都會以某種形式被用在身體中，而你的體重會保持穩定，當然攝入的卡路里和活動所消耗的並不會 100% 完全一樣，但是如果你的體重過去幾個月沒有改變，那麼卡路里平衡是可能的，也就是你的卡路里平衡很可能就是中性的 正向卡路里平衡：跟消耗比起來，燃燒較少的卡路里。透過食物攝入能量，且比運動所燃燒的能量多，額外的卡路里被儲存為在平紋細布肝 (muslin liver) 裡的糖原 (glycogen) 或是脂肪 你可以發現只有負向卡路里平衡可以達到減重的效果，Deficit 有多少也決定了你在特定時間內所能減少的重量，明顯地，越大的 Deficit，越多的減重效果，但是不代表你應該要停止吃東西來創造最大的 Deficit，請不要讓飲食消失 當我們看向科學事實，我們可以得到一個非常簡單的方程式，攝入卡路里 VS. 消耗卡路里，攝入卡路里代表你一天可以攝入的卡路里量，而消耗卡路里則有幾項因素控制，最主要的是新陳代謝、年齡、基因和運動方案，運動方案是你可以做的最有意義的改變 範例：Calorie Deficit 不運動且依賴新陳代謝燃燒 2500 卡路里，而只攝入 2000 卡路里 藉由運動增加卡路里消耗額外的 500 卡路里，且加到你本來的正常 2500 卡路里 (總計 3000 卡路里) =&gt; 這樣可以讓你攝入 2500 卡路里，且還是處理 Deficit 的狀態 在這兩個案例中，你都可以保持每日的 Deficit 在 500 卡路里上下，但是不管你選擇任何一種，最重要的就是為了減重，你一定要建立一個 Calorie Deficit，其它都不會成功 減重 VS. 減脂 減重可能只是減掉水分或是肌肉質量，所以首要目標要是減脂 如何減脂 (而不只有重量) 每日攝入：每磅身體重量攝入 0.8 - 1 g 的蛋白質 很多研究顯示減脂而不減肌肉的方式就是攝入足夠的蛋白質 確定吃到質量好且富含蛋白質的食物，像是：魚肉、雞胸肉或豆子 補充品可以讓你的生活更簡單，但是不應該把補充品當成蛋白質的唯一來源 不要減少太多卡路里 (不能多於 25%，會低於維持機能所需) 太多 Carolie Deficit 會讓你感覺疲憊且飢餓，而且會影響激素水平、睡覺品質 如果你在做重量訓練，他也會減少你的肌肉恢復能力和力量維持 當需要的時候，做飲食休息 休息可以幫助你生理上和心理上準備到下個階段的減重飲食 它可以讓整體減重飲食體驗更簡單且更有效 做阻力訓練 在減重飲食的過程中，不要流失力量，不管你要做重量訓練或是其他類型的運動 減脂食物如何呢？ 減脂食物常常被提出，很多品牌和商店都宣稱他們的食物可以幫助燃燒身體脂肪，大部分這些宣稱都是單純的行銷手法 沒有任何『減重食物』，食物不會燃燒脂肪，能量消耗才會！ 食物裡的卡路里和這些卡路里如何分解成蛋白質、碳水化合物和脂肪才是決定食物對減重有幫助或是沒幫助 如果你知道如何調節卡路里平衡，你就可以吃任何你想吃的且減重 The Twinkie Diet 是一個很有名的例子，Kansas 的教授只吃 Twinkies Doritos 和高蛋白飲品減了 27 磅，他只確定他的每日全部卡路里低於身體定期消耗的 當你的目標是減脂，垃圾食物不會削減脂肪，還要監控你的 Macronutrient Macronutrients 蛋白質：在任何減脂飲食中最重要的 Macronutrient，還是建立肌肉的最重要因素，很多減脂的研究都顯示高蛋白飲食對減少身體之方、保存肌肉質量和增加飽足感都很有效，如果規律運動，高蛋白飲食更加重要，因為它會進一步增加身體所需的氨基酸 (Amino Acids) 碳水化合物：碳水化合物不邪惡，它不會讓你肥胖或不健康，事實上，保持攝入它可以有很多助益，包含更好的健身表現、改善瘦肌肉 (Lean Muscle) 質量保存和更好的能量層次 (Energy Level) 膳食脂肪：膳食脂肪是身體所必須的，因為身體需要一些脂肪酸來生存，而且它不能由其它食物來產生，你還需要脂肪來調節激素產生，且保持你的皮膚和頭髮健康，還有幫助你吸收維他命 A D E - 也被稱為脂溶性維他命 (Fat Soluble Vitamins)，最後脂肪細胞隔離你的身體且維持你的狀態 真實的減脂食物 提供大量的維他命和礦物質 且充滿相對較少的卡路里 蛋白質：瘦肉、少脂肪的乳製品、蛋白、穀物和蔬菜；蛋白粉混合包，因為它方便且可以幫助你遠離飢餓 碳水化合物： 全麥食品：小麥糙米、燕麥、大麥 蔬菜：紅蘿蔔、花椰菜 (Broccoli)、朝鮮薊 (Artichokes) 豆科植物 (Legumes)：綠豆、黃豆、馬鈴薯 避免攝入的食物 高度處理的垃圾食物：洋芋片、糖果、餅乾、其它好吃的東西、還有卡路里飲料 像是油脂和奶油對身體很好，但是應該要限制攝入量，因為它們有巨量卡路里和膳食脂肪，基本上沒有任何作用且會讓你變胖，還有像是堅果、乾果、巧克力、鰐梨 (Avocado) 和全脂牛奶","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Weight Loss","slug":"Weight-Loss","permalink":"https://vincent.fishboneapps.com/tags/Weight-Loss/"},{"name":"Nutrition","slug":"Nutrition","permalink":"https://vincent.fishboneapps.com/tags/Nutrition/"}]},{"title":"HTML5+CSS3 快速學習自我挑戰 Day6","slug":"HTML5-CSS3-快速學習自我挑戰-Day6","date":"2017-12-20T11:53:29.000Z","updated":"2020-06-22T17:13:20.411Z","comments":true,"path":"2017/12/20/HTML5-CSS3-快速學習自我挑戰-Day6/","link":"","permalink":"https://vincent.fishboneapps.com/2017/12/20/HTML5-CSS3-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day6/","excerpt":"","text":"BONUS 使用 PHP 完成表單 新增 index.php，把原本的 index.html 複製過去，新增 id，在 form 的地方加入 action，並新增 mail 完成傳送的訊息 1234567891011121314151617&lt;div class=&quot;form-box&quot; id=&quot;form&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;h2&gt;We&#x27;re happy to hear from you&lt;/h2&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;form method=&quot;post&quot; action=&quot;mailer.php&quot; class=&quot;contact-form&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;?php if($_GET[&#x27;success&#x27;] == 1) &#123; echo &quot;&lt;div class=\\&quot;form-messages success\\&quot;&gt;Thank you! Your message has been sent.&lt;/div&gt;&quot;; &#125; if($_GET[&#x27;success&#x27;] == -1) &#123; echo &quot;&lt;div class=\\&quot;form-messages error\\&quot;&gt;Oops! Something went wrong. Please try again!&lt;/div&gt;&quot;; &#125; ?&gt; &lt;/div&gt; 在 resource/css/style.css 新增表單樣式 1234567891011.form-messages &#123; width: 70%; padding: 10px; border-radius: 3px; margin: 0 auto 30px; color: #333;&#125;.success &#123; background-color: rgba(38, 191, 68, 0.8); &#125;.error &#123; background-color: rgba(209, 46, 46, 0.8); &#125; 在 resource/css/style.css 將高度調整為 630px 1234567891011.map-box &#123; height: 630px;&#125;.map &#123; height: 630px;&#125;.form-box &#123; height: 630px;&#125; 在根目錄新增 mailer.php 123456789101112131415161718192021222324252627282930313233&lt;?php // Get the form fields, removes html tags and whitespace. $name = strip_tags(trim($_POST[&quot;name&quot;])); $name = str_replace(array(&quot;\\r&quot;,&quot;\\n&quot;), array(&quot; &quot;, &quot; &quot;), $name); $email = filter_var(trim($_POST[&quot;email&quot;]), FILTER_SANITIZE_EMAIL); $message = trim($_POST[&quot;message&quot;]); //Check the data if (empty($name) OR empty($message) OR !filter_var($email, FILTER_SANITIZE_EMAIL)) &#123; header(&quot;Location: https://omnifood.fishboneapps.com/index.php?success=-1#form&quot;); exit; &#125; // Set the recipient email address. Update this to YOUR desired email address. $recipient = &quot;dtvgood202@gmail.com&quot;; // Set the email subject. $subject = &quot;New contact from $name&quot;; // Build the email content $email_content = &quot;Name: $name\\n&quot;; $email_content .= &quot;Email: $email\\n\\n&quot;; $email_content .= &quot;Message:\\n$message\\n&quot;; // Build the email headers. $email_headers = &quot;From: $name &lt;$email&gt;&quot;; // Send the email. mail($recipient, $subject, $email_content, $email_headers); // Redirect to the index.html page with success code header(&quot;Location: https://omnifood.fishboneapps.com/index.php?success=1#form&quot;);?&gt; 別停止學習 建議學習 JavaScript JavaScript 讓網站更生動 JavaScript 也可以在後端使用 JavaScript 很快可以開始 JavaScript 被高度需求且薪資高 JavaScript 是網路的未來 完成課程","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://vincent.fishboneapps.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://vincent.fishboneapps.com/tags/CSS/"}]},{"title":"HTML5+CSS3 快速學習自我挑戰 Day5","slug":"HTML5-CSS3-快速學習自我挑戰-Day5","date":"2017-12-03T07:11:22.000Z","updated":"2020-06-22T17:13:20.411Z","comments":true,"path":"2017/12/03/HTML5-CSS3-快速學習自我挑戰-Day5/","link":"","permalink":"https://vincent.fishboneapps.com/2017/12/03/HTML5-CSS3-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day5/","excerpt":"","text":"增加一些特效吧！ jQuery 簡介 jQuery 是世界上最熱門的 JavaScript 函式庫 完全免費 jQuery 很容易 選擇和控制 HTML 元素 創建動畫 開發 Ajax 應用 Magnific Popup：響應式 lightbox TooltipSter：建立 ToolTip Mapplace.js：在網站內插入 google map Typer.js：顯示打字特效 One Page Scroll：滑動特效，一次只顯示一個區塊 jQuery 函式庫 cdn 在 index.html 引入 jQuery 函式庫 &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt; 新增 resources/js/script.js 12345$(document).ready(function() &#123; $(&#x27;h1&#x27;).click(function() &#123; $(this).css(&#x27;background-color&#x27;, &#x27;#ff0000&#x27;) &#125;);&#125;); 在 index.html 把 script.js 引入 &lt;script src=&quot;resources/js/script.js&quot;&gt;&lt;/script&gt; 建立 sticky navigation 在 index.html 的 nav 新增 .sticky class &lt;nav class=&quot;sticky&quot;&gt;，並在本來的 logo 下面放入黑色的 logo &lt;img src=&quot;resources/img/logo.png&quot; alt=&quot;Omnifood logo&quot; class=&quot;logo-black&quot;&gt; 在 style.css 新增 logo-black 和 sticky header 的 CSS 12345678910111213141516171819202122232425262728.logo-black &#123; display: none; height: 50px; width: auto; float: left; margin: 5px 0;&#125;/* sticky navi*/.sticky &#123; position: fixed; top: 0; left: 0; width: 100%; background: rgba(255, 255, 255, 0.98); box-shadow: 0 2px 2px #efefef;&#125;.sticky .main-nav &#123; margin-top: 18px; &#125;.sticky .main-nav li a:link,.sticky .main-nav li a:visited &#123; padding: 16px 0; color: #555;&#125;.sticky .logo &#123; display: none; &#125;.sticky .logo-black &#123; display: block; &#125; 下載 webpoints，用來幫助滾動到 html element 的 function 將下載好的檔案，儲存到 vendors/js/jquery.waypoints.min.js 並在 index.html 引入 &lt;script src=&quot;vendors/js/jquery.waypoints.min.js&quot;&gt;&lt;/script&gt; 在 script.js 控制如果超過 hero box 就顯示 sticky navigation 12345678910111213$(document).ready(function() &#123; $(&#x27;.js--section-features&#x27;).waypoint(function(direction) &#123; if (direction === &quot;down&quot;) &#123; $(&#x27;nav&#x27;).addClass(&#x27;sticky&#x27;); &#125; else &#123; $(&#x27;nav&#x27;).removeClass(&#x27;sticky&#x27;); &#125; &#125;, &#123; offset: &#x27;60px;&#x27; &#125;);&#125;); 滾動到元素 Smooth Scrolling 在 index.html 的主頁的兩個 buttons 新增兩個 class js--scroll-to-plans js--scroll-to-start 12&lt;a class=&quot;btn btn-full js--scroll-to-plans&quot; href=&quot;#&quot;&gt;I&#x27;m hungry&lt;/a&gt;&lt;a class=&quot;btn btn-ghost js--scroll-to-start&quot; href=&quot;#&quot;&gt;Show me more&lt;/a&gt; 在 index.html 的個別區塊新增專屬 js 的 class 和 id 1234&lt;section class=&quot;section-features js--section-features&quot; id=&quot;features&quot;&gt;&lt;section class=&quot;section-meals&quot; id=&quot;works&quot;&gt;&lt;section class=&quot;section-cities&quot; id=&quot;cities&quot;&gt;&lt;section class=&quot;section-plans js--section-plans&quot; id=&quot;plans&quot;&gt; 在選單新增 id 的連結 1234&lt;li&gt;&lt;a href=&quot;#features&quot;&gt;Food delivery&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#works&quot;&gt;How it works&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#cities&quot;&gt;Our cities&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#plans&quot;&gt;Sign up&lt;/a&gt;&lt;/li&gt; 在 index.html 新增事件當點擊按鈕時，移動到某個位置 123456$(&#x27;.js--scroll-to-plans&#x27;).click(function() &#123; $(&#x27;html, body&#x27;).animate(&#123;scrollTop: $(&#x27;.js--section-plans&#x27;).offset().top&#125;, 1000);&#125;);$(&#x27;.js--scroll-to-start&#x27;).click(function() &#123; $(&#x27;html, body&#x27;).animate(&#123;scrollTop: $(&#x27;.js--section-features&#x27;).offset().top&#125;, 1000);&#125;); 從 Smooth Scrolling 的網站複製 js 到 script.js 123456789101112131415161718192021222324252627282930313233343536// Select all links with hashes$(&#x27;a[href*=&quot;#&quot;]&#x27;)// Remove links that don&#x27;t actually link to anything .not(&#x27;[href=&quot;#&quot;]&#x27;) .not(&#x27;[href=&quot;#0&quot;]&#x27;) .click(function(event) &#123; // On-page links if ( location.pathname.replace(/^\\//, &#x27;&#x27;) == this.pathname.replace(/^\\//, &#x27;&#x27;) &amp;&amp; location.hostname == this.hostname ) &#123; // Figure out element to scroll to var target = $(this.hash); target = target.length ? target : $(&#x27;[name=&#x27; + this.hash.slice(1) + &#x27;]&#x27;); // Does a scroll target exist? if (target.length) &#123; // Only prevent default if animation is actually gonna happen event.preventDefault(); $(&#x27;html, body&#x27;).animate(&#123; scrollTop: target.offset().top &#125;, 1000, function() &#123; // Callback after animation // Must change focus! var $target = $(target); $target.focus(); if ($target.is(&quot;:focus&quot;)) &#123; // Checking if the target was focused return false; &#125; else &#123; $target.attr(&#x27;tabindex&#x27;,&#x27;-1&#x27;); // Adding tabindex for elements not focusable $target.focus(); // Set focus again &#125;; &#125;); &#125; &#125; &#125;); 在滾動的過程中增加動畫 Animate.css，將檔案下載放置到 vendors/css/animate.css 在 index.html 引入 Animate.css &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;vendors/css/animate.css&quot;&gt; 在 index.html 要放置動畫區塊，新增 class 123456// \bfeatures 區塊&lt;div class=&quot;row js--wp-1&quot;&gt;&lt;img src=&quot;resources/img/app-iPhone.png&quot; alt=&quot;Omnifood app on iPhone&quot; class=&quot;app-screen js--wp-2&quot;&gt;// cities 區塊&lt;div class=&quot;row js--wp-3&quot;&gt;&lt;div class=&quot;plan-box js--wp-4&quot;&gt; 在 style.css 的 ANIMATION 新增 123456789101112131415161718.js--wp-1,.js--wp-2,.js--wp-3 &#123; opacity: 0; -webkit-animation-duration: 1s; animation-duration: 1s;&#125;.js--wp-4 &#123; -webkit-animation-duration: 1s; animation-duration: 1s;&#125;.js--wp-1.animated,.js--wp-2.animated,.js--wp-3.animated &#123; opacity: 1;&#125; 在 script.js 新增動畫 12345678910111213141516171819202122$(&#x27;.js--wp-1&#x27;).waypoint(function(direction) &#123; $(&#x27;.js--wp-1&#x27;).addClass(&#x27;animated fadeIn&#x27;);&#125;, &#123; offset: &#x27;50%&#x27;&#125;);$(&#x27;.js--wp-2&#x27;).waypoint(function(direction) &#123; $(&#x27;.js--wp-2&#x27;).addClass(&#x27;animated fadeInUp&#x27;);&#125;, &#123; offset: &#x27;50%&#x27;&#125;);$(&#x27;.js--wp-3&#x27;).waypoint(function(direction) &#123; $(&#x27;.js--wp-3&#x27;).addClass(&#x27;animated fadeInUp&#x27;);&#125;, &#123; offset: &#x27;50%&#x27;&#125;);$(&#x27;.js--wp-4&#x27;).waypoint(function(direction) &#123; $(&#x27;.js--wp-4&#x27;).addClass(&#x27;animated pulse&#x27;);&#125;, &#123; offset: &#x27;50%&#x27;&#125;); 讓 navigation 變成響應式 在 index.html 新增專屬 js 的 class 123&lt;ul class=&quot;main-nav js--main-nav&quot;&gt;// 新增手機版 hamburger bar&lt;a class=&quot;mobile-nav-icon js--nav-icon&quot;&gt;&lt;i class=&quot;ion-navicon-round&quot;&gt;&lt;/i&gt;&lt;/a&gt; 在 style.css 新增手機版按鈕樣式 1234567891011.mobile-nav-icon &#123; float: right; margin-top: 30px; cursor: pointer; display: none;&#125;.mobile-nav-icon i &#123; font-size: 200%; color: #fff;&#125; 在 queries.css 新增選單響應式樣式 1234567891011121314151617181920212223242526.mobile-nav-icon &#123; display: inline-block; &#125;.main-nav &#123; float: left; margin-top: 35px; margin-left: 25px;&#125;.main-nav li &#123; display: block;&#125;.main-nav li a:link,.main-nav li a:visited &#123; display: block; border: 0; padding: 10px 0; font-size: 100%;&#125;.sticky .main-nav &#123; margin-top: 10px; &#125;.sticky .main-nav li a:link,.sticky .main-nav li a:visited &#123; padding: 10px 0; &#125;.sticky .mobile-nav-icon &#123; margin-top: 10px; &#125;.sticky .mobile-nav-icon i &#123; color: #555; &#125; 在 script.js 新增選單打開關閉效果 12345678910111213$(&#x27;.js--nav-icon&#x27;).click(function() &#123; var nav = $(&#x27;.js--main-nav&#x27;); var icon = $(&#x27;.js--nav-icon i&#x27;); nav.slideToggle(200); if (icon.hasClass(&#x27;ion-navicon-round&#x27;)) &#123; icon.addClass(&#x27;ion-close-round&#x27;); icon.removeClass(&#x27;ion-navicon-round&#x27;); &#125; else &#123; icon.addClass(&#x27;ion-navicon-round&#x27;); icon.removeClass(&#x27;ion-close-round&#x27;); &#125;&#125;); 優化和發佈網站 最後的調整：建立 favicon favicon 產生器 用產生器產生之後，將檔案放在 resources/favicons，然後在 index.html 引入 12345678&lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;180x180&quot; href=&quot;resources/favicons/apple-touch-icon.png&quot;&gt;&lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;32x32&quot; href=&quot;resources/favicons/favicon-32x32.png&quot;&gt;&lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;16x16&quot; href=&quot;resources/favicons/favicon-16x16.png&quot;&gt;&lt;link rel=&quot;manifest&quot; href=&quot;resources/favicons/manifest.json&quot;&gt;&lt;link rel=&quot;mask-icon&quot; href=&quot;resources/favicons/safari-pinned-tab.svg&quot; color=&quot;#5bbad5&quot;&gt;&lt;link rel=&quot;shortcut icon&quot; href=&quot;resources/favicons/favicon.ico&quot;&gt;&lt;meta name=&quot;msapplication-config&quot; content=&quot;resources/favicons/browserconfig.xml&quot;&gt;&lt;meta name=&quot;theme-color&quot; content=&quot;#ffffff&quot;&gt; 效能優化：網站速度 優化容量很大圖片 壓縮 CSS 和 jQuery code optimizilla：壓縮圖片工具 壓縮完之後，在 style.css 更改圖片路徑 123456789101112131415header &#123; background: -webkit-gradient(linear, left top, left bottom, from(rgba(0, 0, 0, 0.7)), to(rgba(0, 0, 0, 0.7))), url(img/hero-min.jpg) center; background: linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), url(img/hero-min.jpg) center; background-size: cover; height: 100vh; background-attachment: fixed;&#125;.section-testimonials &#123; background-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0, 0, 0, 0.8)), to(rgba(0, 0, 0, 0.8))), url(&#x27;img/back-customers-min.jpg&#x27;); background-image: linear-gradient(rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.8)), url(&#x27;img/back-customers-min.jpg&#x27;); background-size: cover; color: #fff; background-attachment: fixed;&#125; CSS 壓縮工具 基礎 Search Engine Optimization (SEO) Search Engine Optimization (SEO)：改善且提升網站訪問量的技術，讓網頁可以被搜尋引擎搜尋到 META DESCRIPTION TAG：在 index.html 新增 Description meta &lt;meta name=&quot;description&quot; content=&quot;Omnifood is a premium food delivery service with the mission to bring affordable and healthy meals to as many people as possible&quot;&gt; HTML VALIDATION CONTENT IS KING：網頁內容很重要，即使網站在搜尋的最上面，內容不好\b，你的使用者就會不想讀，另外，保持更新網站內容，如此一來，你的使用者就會更常回來觀看你的網站。 KEYWORDS：不要過度使用關鍵字，搜尋引擎會認為是垃圾網站且封鎖你的網站 BACKLINKS：讓其它網站引用你的網站，搜尋引擎會把這個項目列入計分項目 發佈我們的網站 三個簡單的步驟 選擇且買網域 購買網站代管 上傳我們的網站 Google Analytics 網站維護 保持追蹤網站 監控使用者行為 如何：使用 Google Analytics! 做調整，讓網站越來越好 將追蹤碼放置在 index.html 的所有 scripts 下方 完成課程 現在呢？ 重新設計已經完成但是設計很差的網站， 免費為當地慈善機構設計網站 參加設計競賽 開始作一些自由業工作，像是 freelancer.ocm、odesh 或 elance 別停止學習 BONUS 有效提升網站轉換率 對未來客戶建立信任感：可以提供免費的禮物給訪問者 重複你的主要行動：可以在網站上面放置強烈的 call to action 按鈕，讓使用者想點擊 抓住使用者的注意力：使用彈跳式視窗 告訴使用者效益 不要要求太多訊息 使用社交證明：使用像是 testimonial 的區塊 使用迫切性的效果：使用一些像是 now、hurry、instant 和 immediately 等字眼，讓使用者來點擊按鈕 使用稀有性：告訴使用者產品已經缺貨或是要賣光了 新增地圖到 Omnifood 網站 gmaps.js 在 index.html 引入 gmaps.js 12&lt;script src=&quot;http://maps.google.com/maps/api/js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;resources/js/gmaps.js&quot;&gt;&lt;/script&gt; 在 index.html 的 form seciton 修改為兩個區塊，加入 google map 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;div class=&quot;map-box&quot;&gt; &lt;div class=&quot;map&quot;&gt;&lt;/div&gt; &lt;div class=&quot;form-box&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;h2&gt;We&#x27;re happy to hear from you&lt;/h2&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;form method=&quot;post&quot; action=&quot;#&quot; class=&quot;contact-form&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col span-1-of-3&quot;&gt; &lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col span-2-of-3&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;Your name&quot; required&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col span-1-of-3&quot;&gt; &lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col span-2-of-3&quot;&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;Your email&quot; required&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col span-1-of-3&quot;&gt; &lt;label for=&quot;find-us&quot;&gt;How did you find us?&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col span-2-of-3&quot;&gt; &lt;select name=&quot;find-us&quot; id=&quot;find-us&quot;&gt; &lt;option value=&quot;friends&quot;&gt;Friends&lt;/option&gt; &lt;option value=&quot;search&quot;&gt;Search Engine&lt;/option&gt; &lt;option value=&quot;ad&quot;&gt;Advertisement&lt;/option&gt; &lt;option value=&quot;other&quot;&gt;Other&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col span-1-of-3&quot;&gt; &lt;label for=&quot;news&quot;&gt;Newsletter&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col span-2-of-3&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;news&quot; id=&quot;news&quot; checked&gt; Yes, Please &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col span-1-of-3&quot;&gt; &lt;label for=&quot;message&quot;&gt;Drop us a line&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col span-2-of-3&quot;&gt; &lt;textarea name=&quot;message&quot; id=&quot;message&quot; placeholder=&quot;Your message&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col span-1-of-3&quot;&gt; &lt;label&gt;&amp;nbsp;&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col span-2-of-3&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Send it!&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 在 script.js 新增 google map 位置 123456789101112131415var map = new GMaps(&#123; div: &#x27;.map&#x27;, lat: 38.7436883, lng: -9.05, zoom: 12&#125;);map.addMarker(&#123; lat: 38.7436883, lng: -9.1952226, title: &#x27;Lisbon&#x27;, infoWindow: &#123; content: &#x27;&lt;p&gt;Our Lisbon HQ&lt;/p&gt;&#x27; &#125;&#125;); 在 style.css 新增 form + google map 樣式 1234567891011121314151617181920212223.map-box &#123; width: 100%; height: 560px; position: relative;&#125;.map &#123; width: 100%; height: 560px; position: relative; z-index: 0;&#125;.form-box &#123; position: absolute; width: 50%; top: 0; right: 0; background-color: rgba(255, 255, 255, 0.8); z-index: 10; height: 560px; padding-top: 40px;&#125; 在 queries.css 的 max-width: 767px 的區塊新增 12345678910111213141516171819.map-box &#123; width: 100%; height: auto; position: relative;&#125;.map &#123; width: 100%; height: 300px; position: relative; z-index: 0;&#125;.form-box &#123; position: relative; width: 100%; height: auto; padding: 30px 0;&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://vincent.fishboneapps.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://vincent.fishboneapps.com/tags/CSS/"}]},{"title":"HTML5+CSS3 快速學習自我挑戰 Day4","slug":"HTML5-CSS3-快速學習自我挑戰-Day4","date":"2017-12-01T10:13:49.000Z","updated":"2020-06-22T17:13:20.411Z","comments":true,"path":"2017/12/01/HTML5-CSS3-快速學習自我挑戰-Day4/","link":"","permalink":"https://vincent.fishboneapps.com/2017/12/01/HTML5-CSS3-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day4/","excerpt":"","text":"殺手級的網站 建立 Sign-up Section 在 index.html 新增 Sign-up Section 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;section class=&quot;section-plans&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;h2&gt;Start eating healthy today&lt;/h2&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col span-1-of-3&quot;&gt; &lt;div class=&quot;plan-box&quot;&gt; &lt;div&gt; &lt;h3&gt;Premium&lt;/h3&gt; &lt;p class=&quot;plan-price&quot;&gt;$399 &lt;span&gt;/ month&lt;/span&gt;&lt;/p&gt; &lt;p class=&quot;plan-price-meal&quot;&gt;That&#x27;s only 13.30$ per meal&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;i class=&quot;ion-ios-checkmark-empty icon-small&quot;&gt;&lt;/i&gt;1 meal every day&lt;/li&gt; &lt;li&gt;&lt;i class=&quot;ion-ios-checkmark-empty icon-small&quot;&gt;&lt;/i&gt;Order 24/7&lt;/li&gt; &lt;li&gt;&lt;i class=&quot;ion-ios-checkmark-empty icon-small&quot;&gt;&lt;/i&gt;Access to newest creations&lt;/li&gt; &lt;li&gt;&lt;i class=&quot;ion-ios-checkmark-empty icon-small&quot;&gt;&lt;/i&gt;Free delivery&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-full&quot;&gt;Sign up now&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col span-1-of-3&quot;&gt; &lt;div class=&quot;plan-box&quot;&gt; &lt;div&gt; &lt;h3&gt;Pro&lt;/h3&gt; &lt;p class=&quot;plan-price&quot;&gt;$149 &lt;span&gt;/ month&lt;/span&gt;&lt;/p&gt; &lt;p class=&quot;plan-price-meal&quot;&gt;That&#x27;s only 14.90$ per meal&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;i class=&quot;ion-ios-checkmark-empty icon-small&quot;&gt;&lt;/i&gt;1 meal 10 days/month&lt;/li&gt; &lt;li&gt;&lt;i class=&quot;ion-ios-checkmark-empty icon-small&quot;&gt;&lt;/i&gt;Order 24/7&lt;/li&gt; &lt;li&gt;&lt;i class=&quot;ion-ios-checkmark-empty icon-small&quot;&gt;&lt;/i&gt;Access to newest creations&lt;/li&gt; &lt;li&gt;&lt;i class=&quot;ion-ios-checkmark-empty icon-small&quot;&gt;&lt;/i&gt;Free delivery&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-ghost&quot;&gt;Sign up now&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col span-1-of-3&quot;&gt; &lt;div class=&quot;plan-box&quot;&gt; &lt;div&gt; &lt;h3&gt;Starter&lt;/h3&gt; &lt;p class=&quot;plan-price&quot;&gt;$19 &lt;span&gt;/ meal&lt;/span&gt;&lt;/p&gt; &lt;p class=&quot;plan-price-meal&quot;&gt;&amp;nbsp;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;i class=&quot;ion-ios-checkmark-empty icon-small&quot;&gt;&lt;/i&gt;1 meal&lt;/li&gt; &lt;li&gt;&lt;i class=&quot;ion-ios-checkmark-empty icon-small&quot;&gt;&lt;/i&gt;Order from 8 am to 12 pm&lt;/li&gt; &lt;li&gt;&lt;i class=&quot;ion-ios-close-empty icon-small&quot;&gt;&lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;i class=&quot;ion-ios-checkmark-empty icon-small&quot;&gt;&lt;/i&gt;Free delivery&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-ghost&quot;&gt;Sign up now&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 在 style.css 的 SIGN UP 新增樣式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849.section-plans &#123; background-color: #f4f4f4;&#125;.plan-box &#123; background-color: #fff; border-radius: 5px; width: 90%; margin-left: 5%; box-shadow: 0 2px 2px #efefef;&#125;.plan-box div &#123; padding: 15px; border-bottom: 1px solid #e8e8e8;&#125;.plan-box div:first-child &#123; background-color: #fcfcfc; border-top-left-radius: 5px; border-top-right-radius: 5px;&#125;.plan-box div:last-child &#123; text-align: center;&#125;.plan-price &#123; font-size: 300%; margin-bottom: 10px; font-weight: 100; color: #e67e22;&#125;.plan-price span &#123; font-size: 30%;&#125;.plan-price-meal &#123; font-size: 80%;&#125;.plan-box ul &#123; list-style: none;&#125;.plan-box ul li &#123; padding: 5px 0;&#125; 建立 Contact Form 在 index.html 新增 Contact Form 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;section class=&quot;section-form&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;h2&gt;We&#x27;re happy to hear from you&lt;/h2&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;form method=&quot;post&quot; action=&quot;#&quot; class=&quot;contact-form&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col span-1-of-3&quot;&gt; &lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col span-2-of-3&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;Your name&quot; required&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col span-1-of-3&quot;&gt; &lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col span-2-of-3&quot;&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;Your email&quot; required&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col span-1-of-3&quot;&gt; &lt;label for=&quot;find-us&quot;&gt;How did you find us?&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col span-2-of-3&quot;&gt; &lt;select name=&quot;find-us&quot; id=&quot;find-us&quot;&gt; &lt;option value=&quot;friends&quot;&gt;Friends&lt;/option&gt; &lt;option value=&quot;search&quot;&gt;Search Engine&lt;/option&gt; &lt;option value=&quot;ad&quot;&gt;Advertisement&lt;/option&gt; &lt;option value=&quot;other&quot;&gt;Other&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col span-1-of-3&quot;&gt; &lt;label for=&quot;news&quot;&gt;Newsletter&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col span-2-of-3&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;news&quot; id=&quot;news&quot; checked&gt; Yes, Please &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col span-1-of-3&quot;&gt; &lt;label for=&quot;&quot;&gt;Drop us a line&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col span-2-of-3&quot;&gt; &lt;textarea name=&quot;message&quot; placeholder=&quot;Your message&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col span-1-of-3&quot;&gt; &lt;label&gt;&amp;nbsp;&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;col span-2-of-3&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Send it!&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/section&gt; 在 style.css 的 FORM 新增樣式 1234567891011121314151617181920212223242526.contact-form &#123; width: 60%; margin: 0 auto;&#125;input[type=text],input[type=email],select,textarea &#123; width: 100%; padding: 7px; border-radius: 3px; border: 1px solid #ccc;&#125;textarea &#123; height: 100px;&#125;input[type=checkbox] &#123; margin: 10px 5px 10px 0;&#125;*:focus &#123; outline:none;&#125; 在 style.css 的 button 加上 input 的 submit botton 123456789101112.btn:link,.btn:visited,input[type=submit].btn-full:link,.btn-full:visited,input[type=submit].btn:hover,.btn:active,input[type=submit]:hover,input[type=submit]:active 建立 Footer 在 index.html 新增 Footer 1234567891011121314151617181920212223242526&lt;footer&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col span-1-of-2&quot;&gt; &lt;ul class=&quot;footer-nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;About us&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Blog&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Press&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;iOS App&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Android App&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;col span-1-of-2&quot;&gt; &lt;ul class=&quot;social-links&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;ion-social-facebook&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;ion-social-twitter&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;ion-social-googleplus&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;ion-social-instagram&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;p&gt; Copyright &amp;copy; 2015 by Omnifood. All rights reserved. &lt;/p&gt; &lt;/div&gt;&lt;/footer&gt; 在 style.css 的 FOOTER 新增樣式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475footer &#123; background-color: #333; padding: 60px; font-size: 80;&#125;.footer-nav &#123; list-style: none; float: left;&#125;.social-links &#123; list-style: none; float: right;&#125;.footer-nav li,.social-links li &#123; display: inline-block; margin-right: 40px;&#125;.footer-nav li:last-child,.social-links li:last-child &#123; margin-right: 0;&#125;.footer-nav li a:link,.footer-nav li a:visited,.social-links li a:link,.social-links li a:visited &#123; text-decoration: none; border: 0; color: #888;&#125;.footer-nav li a:hover,.footer-nav li a:active &#123; color: #ddd;&#125;.social-links li a:link,.social-links li a:visited &#123; font-size: 160%;&#125;.ion-social-facebook,.ion-social-twitter,.ion-social-googleplus,.ion-social-instagram &#123; transition: color 0.2s;&#125;.ion-social-facebook:hover &#123; color: #3b5998;&#125;.ion-social-twitter:hover &#123; color: #00aced;&#125;.ion-social-googleplus:hover &#123; color: #dd4b39;&#125;.ion-social-instagram:hover &#123; color: #517fa4;&#125;footer p &#123; color: #888; text-align: center; font-size: 90%; margin-top: 20px;&#125; 使用 Media Queries 來做響應式設計 讓網頁變成響應式 新增 resources/css/queries.css 在 index.html 引入新增的 queries.css &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;resources/css/queries.css&quot;&gt; 在 index.html 引入 meta 讓 html 變成響應式 &lt;meta name=&quot;viewpoint&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; 在 resources/css/queries.css 新增 media query 讓網頁變成響應式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/*Big tablets to 1200px (widths smaller than 1140px row)*/@media only screen and (max-width: 1200px) &#123; .hero-text-box &#123; width: 100%; padding: 0 2%; &#125; .row &#123; padding: 0 2%; &#125;&#125;/*Small tablets to big tablet: from 768px to 1023px*/@media only screen and (max-width: 1023px) &#123; body &#123; font-size: 18px; &#125; section &#123; padding: 60px 0;&#125; .long-copy &#123; width: 80%; margin-left: 10%; &#125; .steps-box &#123; margin-top: 10px; &#125; .steps-box:last-child &#123; margin-top: 10px; &#125; .works-step &#123; margin-bottom: 40px; &#125; .works-step:last-of-type &#123; margin-bottom: 60px; &#125; .app-screen &#123; width: 50%; &#125; .icon-small &#123; width: 20px; margin-right: 5px; &#125; .city-feature &#123; font-size: 90%; &#125; .plan-box &#123; width: 100%; margin-left: 0; &#125; .plan-price &#123; font-size: 250%; &#125; .contact-form &#123; width: 80%; &#125;&#125;/*Small phones to small tablets: from 481px to 767px*/@media only screen and (max-width: 767px) &#123; body &#123; font-size: 16px; &#125; section &#123; padding: 30px 0; &#125; .row, .hero-text-box &#123; padding: 0 4%; &#125; .col &#123; width: 100%; margin: 0 0 4% 0; &#125; .main-nav &#123; display: none; &#125; h1 &#123; font-size: 180%; &#125; h2 &#123; font-size: 150%; &#125; .long-copy &#123; width: 100%; margin-left: 0; &#125; .steps-box:first-child &#123; text-align: center; &#125; .works-step div &#123; height: 40px; width: 40px; margin-right: 15px; padding: 4px; font-size: 120%; &#125; .works-step &#123; margin-bottom: 20px; &#125; .works-step:last-of-type &#123; margin-bottom: 20px; &#125;&#125;/*Small phones: from 0 to 480px*/@media only screen and (max-width: 480px) &#123; section &#123; padding: 25px 0; &#125; .contact-form &#123; width: 100%; &#125;&#125; 在 style.css 新增 overflow-x: hidden 12345html,body &#123; ... overflow-x: hidden;&#125; 關於瀏覽器的筆記 CSS Browser prefixes 1234567Android: -webkit-Chrome: -webkit-Firefox: -moz-Internet Explorer: -ms-ios: -webkit-Opera: -o-Safari: -webkit- CDN 網站 找到以下套件並放在網 index.html 的最下方 123&lt;script src=&quot;https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/selectivizr@1.0.3/selectivizr.min.js&quot;&gt;&lt;/script&gt; CSS 語法瀏覽器支援度查詢","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://vincent.fishboneapps.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://vincent.fishboneapps.com/tags/CSS/"}]},{"title":"HTML5+CSS3 快速學習自我挑戰 Day3","slug":"HTML5-CSS3-快速學習自我挑戰-Day3","date":"2017-11-30T08:55:34.000Z","updated":"2020-06-22T17:13:20.411Z","comments":true,"path":"2017/11/30/HTML5-CSS3-快速學習自我挑戰-Day3/","link":"","permalink":"https://vincent.fishboneapps.com/2017/11/30/HTML5-CSS3-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day3/","excerpt":"","text":"殺手級的網站 製作 Features Section 下載 icons，然後將 css 複製到 vendors/css、fonts 複製到 vendors/fonts 在 index.html 引入 ionicons &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;vendors/css/ionicons.min.css&quot;&gt; 在 header 下方加入 Feature Section 123456789101112131415161718192021222324252627282930313233343536373839&lt;section class=&quot;section-features&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;h2&gt;Get food fast &amp;mdash; not fast food.&lt;/h2&gt; &lt;p class=&quot;long-copy&quot;&gt; Hello, we&#x27;re Omnifood, your new premium food delivery service. We know you&#x27;re always busy. No time for cooking. So let us take care of that, we&#x27;re really good at it, we promise! &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col span-1-of-4&quot;&gt; &lt;i class=&quot;ion-ios-infinite-outline&quot;&gt;&lt;/i&gt; &lt;h3&gt;Up to 365 days/year&lt;/h3&gt; &lt;p&gt; Never cook again! We really mean that. Our subscription plans include up to 365 days/year coverage. You can also choose to order more flexibly if that&#x27;s your style. &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col span-1-of-4&quot;&gt; &lt;i class=&quot;ion-ios-stopwatch-outline&quot;&gt;&lt;/i&gt; &lt;h3&gt;Ready in 20 minutes&lt;/h3&gt; &lt;p&gt; You&#x27;re only twenty minutes away from your delicious and super healthy meals delivered right to your home. We work with the best chefs in each town to ensure that you&#x27;re 100% happy. &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col span-1-of-4&quot;&gt; &lt;i class=&quot;ion-ios-nutrition-outline&quot;&gt;&lt;/i&gt; &lt;h3&gt;100% organic&lt;/h3&gt; &lt;p&gt; All our vegetables are fresh, organic and local. Animals are raised without added hormones or antibiotics. Good for your health, the environment, and it also tastes better! &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col span-1-of-4&quot;&gt; &lt;i class=&quot;ion-ios-cart-outline&quot;&gt;&lt;/i&gt; &lt;h3&gt;Order anything&lt;/h3&gt; &lt;p&gt; We don&#x27;t limit your creativity, which means you can order whatever you feel like. You can also choose from our menu containing over 100 delicious meals. It&#x27;s up to you! &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 在 index.html 的 col 部份新增 box 和 icon 部分新增 icon-big 的 class 123&lt;div class=&quot;col span-1-of-4 box&quot;&gt; &lt;i class=&quot;ion-ios-infinite-outline icon-big&quot;&gt;&lt;/i&gt;&lt;/div&gt; 在 style.css 的 REUSABLE COMPONENT 新增 section 和 box 1234567section &#123; padding: 80px 0;&#125;.box &#123; padding: 1%;&#125; 在 style.css 的 HEADINGS 將共同的 css 取出來，並新增 h1 h2 h3 1234567891011121314151617181920212223242526272829303132333435h1, h2, h3 &#123; font-weight: 300; text-transform: uppercase;&#125;h1 &#123; margin-top: 0; margin-bottom: 20px; color: #fff; font-size: 240%; word-spacing: 4px; letter-spacing: 1px;&#125;h2 &#123; font-size: 180%; word-spacing: 2px; text-align: center; margin-bottom: 30px; letter-spacing: 1px;&#125;h3 &#123; font-size: 110%; margin-bottom: 15px;&#125;h2:after &#123; display: block; height: 2px; background-color: #e67e22; content: &quot; &quot;; width: 100px; margin: 30px auto 0;&#125; 在 style.css 的 PARAGRAPHS 將共同的 css 取出來 12345678910.long-copy &#123; line-height: 145%; width: 70%; margin-left: 15%;&#125;.box p &#123; font-size: 90%; line-height: 145%;&#125; 在 style.css 的 ICONS 新增 icon-big 1234567/* -------- ICONS -------- */.icon-big &#123; font-size: 350%; display: block; color: #e67e22; margin-bottom: 10px;&#125; 建立 Favorite Meals Section 在 index.html 新增一個 Favorite Meals Section 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;section class=&quot;section-meals&quot;&gt; &lt;ul class=&quot;meals-showcase&quot;&gt; &lt;li&gt; &lt;figure class=&quot;meal-photo&quot;&gt; &lt;img src=&quot;resources/img/1.jpg&quot; alt=&quot;Korean bibimbap with egg and vegetables&quot;&gt; &lt;/figure&gt; &lt;/li&gt; &lt;li&gt; &lt;figure class=&quot;meal-photo&quot;&gt; &lt;img src=&quot;resources/img/2.jpg&quot; alt=&quot;Simple italian pizza with cherry tomatoes&quot;&gt; &lt;/figure&gt; &lt;/li&gt; &lt;li&gt; &lt;figure class=&quot;meal-photo&quot;&gt; &lt;img src=&quot;resources/img/3.jpg&quot; alt=&quot;Chicken breast steak with vegetables&quot;&gt; &lt;/figure&gt; &lt;/li&gt; &lt;li&gt; &lt;figure class=&quot;meal-photo&quot;&gt; &lt;img src=&quot;resources/img/4.jpg&quot; alt=&quot;Autumn pumpkin soup&quot;&gt; &lt;/figure&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;meals-showcase&quot;&gt; &lt;li&gt; &lt;figure class=&quot;meal-photo&quot;&gt; &lt;img src=&quot;resources/img/5.jpg&quot; alt=&quot;Paleo beef steak with vegetables&quot;&gt; &lt;/figure&gt; &lt;/li&gt; &lt;li&gt; &lt;figure class=&quot;meal-photo&quot;&gt; &lt;img src=&quot;resources/img/6.jpg&quot; alt=&quot;Healthy baguette with egg and vegetables&quot;&gt; &lt;/figure&gt; &lt;/li&gt; &lt;li&gt; &lt;figure class=&quot;meal-photo&quot;&gt; &lt;img src=&quot;resources/img/7.jpg&quot; alt=&quot;Burger with cheddar and bacon&quot;&gt; &lt;/figure&gt; &lt;/li&gt; &lt;li&gt; &lt;figure class=&quot;meal-photo&quot;&gt; &lt;img src=&quot;resources/img/8.jpg&quot; alt=&quot;Granola with cherries and strawberries&quot;&gt; &lt;/figure&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/section&gt; 在 style.css 的 MEALS 新增樣式 12345678910111213141516171819202122232425262728293031323334.section-meals &#123; padding: 0;&#125;.meals-showcase &#123; list-style: none; width: 100%;&#125;.meals-showcase li &#123; display: block; float: left; width: 25%;&#125;.meal-photo &#123; width: 100%; margin: 0; overflow: hidden; background-color: #000;&#125;.meal-photo img &#123; opacity: 0.7; width: 100%; height: auto; transform: scale(1.15); transition: transform 0.5s, opacity 0.5s;&#125;.meal-photo img:hover &#123; opacity: 1; transform: scale(1.03);&#125; 在 style.css 的 MEALS 讓中間文字說明和下方段落有間距 123.section-features .long-copy &#123; margin-bottom: 40px;&#125; 建立 How-it-works Section 在 index.html 新增 How-it-works Section 123456789101112131415161718192021222324252627&lt;section class=&quot;section-steps&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;h2&gt;How it works - Simple as 1, 2, 3&lt;/h2&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col span-1-of-2 steps-box&quot;&gt; &lt;img src=&quot;resources/img/app-iPhone.png&quot; alt=&quot;Omnifood app on iPhone&quot; class=&quot;app-screen&quot;&gt; &lt;/div&gt; &lt;div class=&quot;col span-1-of-2 steps-box&quot;&gt; &lt;div class=&quot;works-step&quot;&gt; &lt;div&gt;1&lt;/div&gt; &lt;p&gt;Choose the subscription plan that best fits your needs and sign up today.&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;works-step&quot;&gt; &lt;div&gt;2&lt;/div&gt; &lt;p&gt;Order your delicious meal using our mobile app or website. Or you can even call us!&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;works-step&quot;&gt; &lt;div&gt;3&lt;/div&gt; &lt;p&gt;Enjoy your meal after less than 20 minutes. See you the next time!&lt;/p&gt; &lt;/div&gt; &lt;a href=&quot;#&quot; class=&quot;btn-app&quot;&gt;&lt;img src=&quot;resources/img/download-app.svg&quot; alt=&quot;App Store Button&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;btn-app&quot;&gt;&lt;img src=&quot;resources/img/google-play-badge.svg&quot; alt=&quot;Play Store Button&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 在 style.css 的 HOW IT WORKS 新增樣式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546.section-steps &#123; background-color: #f4f4f4;&#125;.steps-box:first-child &#123; text-align: right; padding-right: 3%; margin-top: 30px;&#125;.steps-box:last-child &#123; padding-left: 3%; margin-top: 70px;&#125;.app-screen &#123; width: 40%;&#125;.works-step &#123; margin-bottom: 50px;&#125;.works-step:last-of-type &#123; margin-bottom: 80px;&#125;.works-step div &#123; color: #e67e22; border: 2px solid #e67e22; display: inline-block; border-radius: 50%; height: 50px; width: 50px; text-align: center; padding: 5px; float: left; font-size: 150%; margin-right: 25px;&#125;.btn-app img &#123; height: 50px; width: auto; margin-right: 10px;&#125; 在 style.css 的 BASIC SETUP 新增 clearfix 12345678.clearfix &#123;zoom: 1;&#125;.clearfix:after &#123; content: &#x27;.&#x27;; clear: both; display: block; height: 0; visibility: hidden;&#125; 在 index.html 的 meals-showcase 後面加上 clearfix meals-showcase clearfix 建立 Cities Section 在 index.html 新增 Cities Section 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;section class=&quot;section-cities&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;h2&gt;We&#x27;re currently in these cities&lt;/h2&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col span-1-of-4 box&quot;&gt; &lt;img src=&quot;resources/img/lisbon-3.jpg&quot; alt=&quot;lisbon&quot;&gt; &lt;h3&gt;Lisbon&lt;/h3&gt; &lt;div class=&quot;city-feature&quot;&gt; &lt;i class=&quot;ion-ios-person icon-small&quot;&gt;&lt;/i&gt; 1600+ happy eaters &lt;/div&gt; &lt;div class=&quot;city-feature&quot;&gt; &lt;i class=&quot;ion-ios-star icon-small&quot;&gt;&lt;/i&gt; 60+ top chefs &lt;/div&gt; &lt;div class=&quot;city-feature&quot;&gt; &lt;i class=&quot;ion-social-twitter icon-small&quot;&gt;&lt;/i&gt; &lt;a href=&quot;#&quot;&gt;@omnifood_lx&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col span-1-of-4 box&quot;&gt; &lt;img src=&quot;resources/img/san-francisco.jpg&quot; alt=&quot;lisbon&quot;&gt; &lt;h3&gt;San Francisco&lt;/h3&gt; &lt;div class=&quot;city-feature&quot;&gt; &lt;i class=&quot;ion-ios-person icon-small&quot;&gt;&lt;/i&gt; 3700+ happy eaters &lt;/div&gt; &lt;div class=&quot;city-feature&quot;&gt; &lt;i class=&quot;ion-ios-star icon-small&quot;&gt;&lt;/i&gt; 160+ top chefs &lt;/div&gt; &lt;div class=&quot;city-feature&quot;&gt; &lt;i class=&quot;ion-social-twitter icon-small&quot;&gt;&lt;/i&gt; &lt;a href=&quot;#&quot;&gt;@omnifood_sf&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col span-1-of-4 box&quot;&gt; &lt;img src=&quot;resources/img/berlin.jpg&quot; alt=&quot;lisbon&quot;&gt; &lt;h3&gt;Berlin&lt;/h3&gt; &lt;div class=&quot;city-feature&quot;&gt; &lt;i class=&quot;ion-ios-person icon-small&quot;&gt;&lt;/i&gt; 2300+ happy eaters &lt;/div&gt; &lt;div class=&quot;city-feature&quot;&gt; &lt;i class=&quot;ion-ios-star icon-small&quot;&gt;&lt;/i&gt; 110+ top chefs &lt;/div&gt; &lt;div class=&quot;city-feature&quot;&gt; &lt;i class=&quot;ion-social-twitter icon-small&quot;&gt;&lt;/i&gt; &lt;a href=&quot;#&quot;&gt;@omnifood_berlin&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col span-1-of-4 box&quot;&gt; &lt;img src=&quot;resources/img/london.jpg&quot; alt=&quot;lisbon&quot;&gt; &lt;h3&gt;London&lt;/h3&gt; &lt;div class=&quot;city-feature&quot;&gt; &lt;i class=&quot;ion-ios-person icon-small&quot;&gt;&lt;/i&gt; 1200+ happy eaters &lt;/div&gt; &lt;div class=&quot;city-feature&quot;&gt; &lt;i class=&quot;ion-ios-star icon-small&quot;&gt;&lt;/i&gt; 50+ top chefs &lt;/div&gt; &lt;div class=&quot;city-feature&quot;&gt; &lt;i class=&quot;ion-social-twitter icon-small&quot;&gt;&lt;/i&gt; &lt;a href=&quot;#&quot;&gt;@omnifood_london&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 在 style.css 的 CITIES 新增樣式 123456789.box img &#123; width: 100%; height: auto; margin-bottom: 15px;&#125;.city-feature &#123; margin-bottom: 5px;&#125; 在 style.css 的 ICONS 新增樣式 12345678910111213.icon-small &#123; display: inline-block; width: 30px; text-align: center; color: #e67e22; font-size: 120%; margin-right: 10px; /*secrets to align text and icons*/ line-height: 120%; vertical-align: middle; margin-top: -5px;&#125; 在 style.css 的 LINKS 新增樣式 1234567891011121314a:link,a:visited &#123; color: #e67e22; text-decoration: none; padding-bottom: 1px; border-bottom: 1px solid #e67e22; transition: border-bottom 0.2s, color 0.2s&#125;a:hover,a:active &#123; color: #555; border-bottom: 1px solid transparent;&#125; 在 style.css 的 HOW IT WORKS 把 LINKS 底線移除 1234.btn-app:link,.btn-app:visited &#123; border: 0;&#125; 建立 Customer Testimonials Section 把 resources/img/back-customers.jpg 放到 resources/css/img/back-customers.jpg 在 index.html 新增 Customer Testimonials Section 12345678910111213141516171819202122232425&lt;section class=&quot;section-testimonials&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;h2&gt;Our customers can&#x27;t live without us&lt;/h2&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col span-1-of-3&quot;&gt; &lt;blockquote&gt; Omnifood is just awesome! I just launched a startup which leaves me with no time for cooking, so Omnifood is a life-saver. Now that I got used to it, I couldn&#x27;t live without my daily meals! &lt;cite&gt;&lt;img src=&quot;resources/img/customer-1.jpg&quot; alt=&quot;&quot;&gt;Alberto Duncan&lt;/cite&gt; &lt;/blockquote&gt; &lt;/div&gt; &lt;div class=&quot;col span-1-of-3&quot;&gt; &lt;blockquote&gt; Inexpensive, healthy and great-tasting meals, delivered right to my home. We have lots of food delivery here in Lisbon, but no one comes even close to Omifood. Me and my family are so in love! &lt;cite&gt;&lt;img src=&quot;resources/img/customer-2.jpg&quot; alt=&quot;&quot;&gt;Joana Silva&lt;/cite&gt; &lt;/blockquote&gt; &lt;/div&gt; &lt;div class=&quot;col span-1-of-3&quot;&gt; &lt;blockquote&gt; I was looking for a quick and easy food delivery service in San Franciso. I tried a lot of them and ended up with Omnifood. Best food delivery service in the Bay Area. Keep up the great work! &lt;cite&gt;&lt;img src=&quot;resources/img/customer-3.jpg&quot; alt=&quot;&quot;&gt;Milton Chapman&lt;/cite&gt; &lt;/blockquote&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 在 style.css 的 TESTIMONIALS 新增樣式 123456789101112131415161718192021222324252627282930313233343536.section-testimonials &#123; background-image: linear-gradient(rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.8)), url(&#x27;img/back-customers.jpg&#x27;); background-size: cover; color: #fff; background-attachment: fixed;&#125;blockquote &#123; padding: 2%; font-style: italic; line-height: 145%; position: relative; margin-top: 40px;&#125;blockquote:before &#123; content: &quot;\\201C&quot;; font-size: 500%; display: block; position: absolute; top: -5px; left: -3px;&#125;cite &#123; font-size: 90%; margin-top: 25px; display: block;&#125;cite img &#123; height: 50px; border-radius: 50%; margin-right: 10px; vertical-align: middle;&#125; 在 style.css 的 header 新增 background-attachment: fixed;，讓圖片在背景部分靜止不動，做成視差捲軸","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://vincent.fishboneapps.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://vincent.fishboneapps.com/tags/CSS/"}]},{"title":"HTML5+CSS3 快速學習自我挑戰 Day2","slug":"HTML5-CSS3-快速學習自我挑戰-Day2","date":"2017-11-19T03:59:13.000Z","updated":"2020-06-22T17:13:20.411Z","comments":true,"path":"2017/11/18/HTML5-CSS3-快速學習自我挑戰-Day2/","link":"","permalink":"https://vincent.fishboneapps.com/2017/11/18/HTML5-CSS3-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day2/","excerpt":"","text":"網站設計基礎 網站設計介紹 設計師創造網頁的樣式和感覺，開發者則根據設計師的樣稿使用 HTML、CSS、JavaScript 建立網頁 字體 字體是一種藝術和排列技術，讓書面語言可閱讀且美觀 對 body text 使用 15px - 20px 的字體大小 對 Headlines 使用大的字體 使用 120% - 150% 的行距 (Line Spacing) 每行 45 到 90 字 使用正確的字體 Sans-serif：中立、乾淨、簡單、現代化網站 Serif：傳統目的、說故事、長篇幅的閱讀 Google Fonts 在 Google Fonts 裡面很棒的 Sans-serif 字體：Open Sans、Lato、Raleway、Monsterrat、PT Sans 在 Google Fonts 裡面很棒的 Serif 字體：Cardo、Merriweather、PT Serif 如何選擇字體？ 對網站選擇一個反映你想要得視覺和感覺的字體 決定：Sans-serif 或 Serif？ 使用好字體 只使用那一種 typeface 像專家一樣使用顏色 只使用一種基底顏色 (Base Color)，Base Color 就是除了黑色、白色和灰色階的顏色 如果想要使用更多顏色，請使用工具 Flat UI colors 是一種幫助選擇 Base Color 的好工具 Color Wheel Tool 可以幫助混合多種顏色，可以使用 Adobe Color CC 使用顏色來吸引注意力 絕不要在設計使用黑色 明智地選擇顏色 紅色：力量、熱情、力氣、興奮，亮色系更有活力、暗色系更有力量且優雅 橘色：可以吸引注意力但不會壓過紅色，它代表鼓舞和創意，橘色還跟友善、信心和勇氣有關聯 黃色：是一種有活力且給予一種快樂和生動活潑的感覺，它還跟好奇心、智慧和明亮…等等有關聯 綠色：是一種和諧、自然、生活和健康的顏色，它還時常跟錢有關聯，在設計裡面，綠色還可以有平衡和協調的效果 藍色：代表耐心、和平、信任和穩定，它是特別有吸引力的顏色，尤其是對男生，它跟專業、信任和榮譽，這也是為什麼大型的 Socail Media 都使用藍色 紫色：傳統上跟權力、高貴和富有有關連，在設計裡面，紫色可以給予一種智慧、高貴、奢華和神秘的感覺 粉紅色：表達浪漫、主動、關心、和平和感情…等等 咖啡色：代表放鬆和信心，它本身表示質樸、自然、持久、舒適和依賴感 使用圖片 在圖片上直接放置文字 這種做法只有在圖片很黑且文字是白色的時候有用，否則在圖片和文字之間會沒有足夠的對比 覆蓋圖片 (Overlay the Image) 使用顏色漸層也可以達到驚人的效果 把文字放在 Box 裡面 白色加上一些透明度可以做到，也可以把 Box 弄成黑色或是其它顏色 只要保持創意就可以了 模糊圖片 (Blur the Image) 文字要在所有螢幕解析度底下，保持在圖片模糊的部分 The Floor Fade 從上到下的漸層褪色的技術，幾乎沒有注意到，但是仍然可以改善閱讀性 如果想要在圖片下方放置文字，這是一種很好的方法 使用 Icon 如果正確使用的話，可以提供非常好的使用者體驗；反之，如果用不好的話，會造成使用者的困惑 使用 Icon 來做條列式的功能/步驟 對動作和連結使用 Icons Icons 應該要可辨識 Label Your Icons (就是在圖標後方放置文字) Icons 不應該成為焦點 盡可能使用 ICON FONTS Spacing 和版面編排 White Space 就是創建乾淨和簡單的關鍵 使用 White Space 在元素之間放置 White Space 在元素群組之間放置 White Space 在網站區塊之間放置 White Space 但是不要太誇張 定義階層 White Space 描述了在網頁元素之間的隱形關係 定義你想要讓觀眾先看到哪個部分 建立一個對應內容訊息的 Flow，它導引使用者從一個元素到下一個元素 使用 White Space 來建立 Flow 使用者體驗介紹 使用者體驗是一個產品的介紹，看起來如何和感覺 使用者體驗是和這一個產品的整體經驗，它包含使用者介面，但是也要有整個產品的全面觀 引用賈伯斯，功能是最重要的 It’s not just what it looks like and feels like. Design is how it works - Steve Jobs 可以把使用者體驗想成使用者目標和商業目標，使用者體驗設計師需要整理這些目標，當使用者達到他們的目的之後，商業也會受益，舉例來說，一個網站如果提供免費的電子書來交換使用者的 Email，使用者的目標就是學習電子書的內容，而你的目標就是取得使用者的 Email，所以你就可以在之後賣東西給他們，最後，你要確定你的設計可以做最好的工作來達到這兩個目標 獲取靈感：令人驚嘆的網站設計的秘密材料 使用其它網站當作靈感，來看其他領導設計師們怎麼做正確的事情 收集你喜歡的設計 試圖了解關於它們的每一樣東西 為什麼它們看起來很好？ 這些網站有什麼共通點？ 如何使用 HTML 和 CSS 來建立？ 像藝術家一般的竊取 殺手級的網站 七步驟完成完整有功能的網站 定義你的專案 確認專案目標 確認你的客群 在心裡用你的目標和客群來設計 規劃全部 規劃內容：文字、圖片、影片、Icons…等等 開始思考視覺分層結構 (Visail Hierarchy) 定義導覽列 (Navigation) 如果是比較大型的專案，要定義網站架構 在設計之前，畫出 Ideas 的草稿 獲得靈感和思考你的設計 把 ideas 從腦中拿出來：在設計之前，畫出 Ideas 的草稿 盡可能的畫出更多草稿，但是不要把花太多時間把它弄得太完美 在沒有任何想要建立的 ideas 之前，不要開始設計 設計和開發你的網站 使用 Guidelines 和 Tips 設計你的網站 使用 HTML 和 CSS：在瀏覽器設計 使用草稿、內容和從 123 步驟做的計畫性的決定 這一步驟是建立網站最大的一步驟，但是：所有的步驟都很重要 還沒完成 - 優化 優化表現：網站速度 搜尋引擎優化 (SEO) 發佈你得傑作 所有你需要的就是開啟一個網站伺服器，它可以 host 你的網站且傳送到全世界 網站維護 發佈不是最後的事情 觀察你的使用者表現和在必要的情況下修改你的網站 定期更新你的內容：blog 讓七步驟付諸行動 步驟一： 專案目標：顯示 Omnifood 做的事情，如何運作和他們所營業的地點，然後讓人註冊申請訂閱項目 客群：沒有時間煮飯或不喜歡煮飯的忙碌人 步驟二： 單頁網頁內容包含 Omnifood 提供的資訊和簡單的 navigation (導覽列) 內容：Omnifood 提供的文字文件和套圖 Navigation (導覽列)：也是由 Omnifood 提供的文字文件 步驟三：畫草稿 步驟四： 顏色：橘色 字體：LATO，字體有半圓角，給這個字型溫暖的感覺，當使用強壯的結構會提供穩定和嚴謹，根據這個字體的設計師，這個字體是男性也是女性，嚴謹但友善，且有夏天的感覺 第一個開發步驟 新增以下目錄結構 12345678910111213- resources - CSStoc: true -img - js - img - data- vendors - CSStoc: true - js - fonts- index.html 下載 Normalize.css，放到 vendors/css 修改 index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;resources/css/normalize.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;resources/css/style.css&quot;&gt; &lt;link href=&quot;https://fonts.googleapis.com/css?family=Lato:100,300,300i,400&quot; rel=&quot;stylesheet&quot;&gt; &lt;title&gt;Omnifood&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Omnifood&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 修改 resources/css/style.css，text-rendering 用最完美的方式讓字體載入 1234567891011121314* &#123; margin: 0; padding: 0; box-sizing: border-box;&#125;html &#123; background-color: #fff; color: #555; font-family: &#x27;Lato&#x27;, &#x27;Arial&#x27;, sans-serif; font-weight: 300; font-size: 20px; text-rendering: optimizeLegibility;&#125; 為響應式設計設置 fluid grid 三個響應式的方法 Fluid Grid：所有的版面編排元素都使用相對單位，像是百分比而不是像是像素這種絕對單位 Flexible Images：也是使用相對單位 Media Queries：允許我們在不同瀏覽器寬度選擇不同的 CSS 樣式規格 把 grid.css 放到 vendors/css 響應式設計官方網站 在 index.html 引入 grid.css &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;vendors/css/grid.css&quot;&gt; 在 style.css 新增 row 1234.row &#123; max-width: 1140px; margin: 0 auto;&#125; 在 index.html 最外層包上 row 123&lt;div class=&quot;row&quot;&gt; &lt;h1&gt;Omnifood&lt;/h1&gt;&lt;/div&gt; 建立 header 在 index.html 新增 header 1234567&lt;header&gt; &lt;div class=&quot;hero-text-box&quot;&gt; &lt;h1&gt;Goodbye junk food. Hello super healthy meals.&lt;/h1&gt; &lt;a href=&quot;#&quot;&gt;I&#x27;m hungry&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;Show me more&lt;/a&gt; &lt;/div&gt;&lt;/header&gt; 在 style.css 加入以下 1234567891011121314151617header &#123; background: linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), url(img/hero.jpg) center; background-size: cover; height: 100vh;&#125;.hero-text-box &#123; position: absolute; width: 1140px; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125;h1 &#123; margin: 0;&#125; 選擇相近顏色的工具 在 style.css 的 h1 做修改 12345678910h1 &#123; margin-top: 0; margin-bottom: 20px; color: #fff; font-size: 240%; font-weight: 300; text-transform: uppercase; letter-spacing: 1px; word-spacing: 4px;&#125; 在 index.html 的 h1 加 &lt;br&gt; 斷行，且在 button 加上兩個 attribute 12345&lt;div class=&quot;hero-text-box&quot;&gt; &lt;h1&gt;Goodbye junk food.&lt;br&gt;Hello super healthy meals.&lt;/h1&gt; &lt;a class=&quot;btn btn-full&quot; href=&quot;#&quot;&gt;I&#x27;m hungry&lt;/a&gt; &lt;a class=&quot;btn btn-ghost&quot; href=&quot;#&quot;&gt;Show me more&lt;/a&gt;&lt;/div&gt; 在 style.css 新增 button 樣式，link 是連結，visited 是被點擊過的連結，hover 是滑鼠放到該元素上的動作，active 則是點擊該元素的動作 123456789101112131415161718192021222324252627282930313233343536373839.btn:link,.btn:visited &#123; display: inline-block; padding: 10px 30px; font-weight: 300; text-decoration: none; border-radius: 200px; transition: background-color 0.2s, border 0.2s, color 0.2s;&#125;.btn-full:link,.btn-full:visited &#123; background-color: #e67e22; border: 1px solid #e67e22; color: #fff; margin-right: 15px;&#125;.btn-ghost:link,.btn-ghost:visited &#123; border: 1px solid #e67e22; color: #e67e22;&#125;.btn:hover,.btn:active &#123; background-color: #cf6d17;&#125;.btn-full:hover,.btn-full:active &#123; border: 1px solid #cf6d17;&#125;.btn-ghost:hover,.btn-ghost:active &#123; border: 1px solid #cf6d17; color: #fff;&#125; 在 index.html 的 body 下面新增 navigation 1234567891011&lt;nav&gt; &lt;div class=&quot;row&quot;&gt; &lt;img src=&quot;resources/img/logo-white.png&quot; alt=&quot;Omnifood logo&quot; class=&quot;logo&quot;&gt; &lt;ul class=&quot;main-nav&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Food delivery&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;How it works&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Our cities&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Sign up&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/nav&gt; 在 style.css 新增 navigation 樣式 123456789101112131415161718192021222324252627282930313233.logo &#123; height: 100px; width: auto; float: left; margin-top: 20px;&#125;.main-nav &#123; float: right; list-style: none; margin-top: 55px;&#125;.main-nav li &#123; display: inline-block; margin-left: 40px;&#125;.main-nav li a:link,.main-nav li a:visited &#123; padding: 8px 0; color: #fff; text-decoration: none; text-transform: uppercase; font-size: 90%; border-bottom: 2px solid transparent; transition: border-bottom 0.2s;&#125;.main-nav li a:hover,.main-nav li a:active &#123; border-bottom: 2px solid #e67e22;&#125; 在 style.css 加上一些註解，註解的樣式如下 123/* ----------------------------------------------------- *//* BASIC SETUP *//* ----------------------------------------------------- */","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://vincent.fishboneapps.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://vincent.fishboneapps.com/tags/CSS/"}]},{"title":"Nodejs II 快速學習自我挑戰 Day2","slug":"Nodejs-II-快速學習自我挑戰-Day2","date":"2017-11-10T09:32:45.000Z","updated":"2020-06-22T17:15:24.880Z","comments":true,"path":"2017/11/10/Nodejs-II-快速學習自我挑戰-Day2/","link":"","permalink":"https://vincent.fishboneapps.com/2017/11/10/Nodejs-II-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day2/","excerpt":"","text":"Mongoose 和本地端 MongoDB 安裝 Mongoose 和連接 安裝 Mongoose npm install --save mongoose Mongoose 官方網站 在 app.js 新增 mongoose connect 連接到本地端伺服器，記得要使用 useMongoClient，不然會出現奇怪的錯誤，如果連接成功，顯示 MongoDB connected，失敗則出現錯誤 12345mongoose.connect(&#x27;mongodb://localhost/vidjot-dev&#x27;, &#123; useMongoClient: true&#125;) .then(() =&gt; console.log(&#x27;MongoDB connected...&#x27;)) .catch(err =&gt; console.log(err)); 加入這一行避免 deprecation 警告出現，把預設已經 deprecated 的 library 用 global promise 取代 mongoose.Promise = global.Promise; 建立理想的 Model 新增 models/Idea.js，新增 ideas 的 model 1234567891011121314151617181920const mongoose = require(&#x27;mongoose&#x27;);const Schema = mongoose.Schema;// Create Schemaconst IdeaSchema = new Schema(&#123; title: &#123; type: String, required: true, &#125;, details: &#123; type: String, required: true &#125;, data: &#123; type: Date, default: Date.now &#125;&#125;);mongoose.model(&#x27;ideas&#x27;, IdeaSchema); 在 app.js 讀取 models 12require(&#x27;./models/Idea&#x27;);const Idea = mongoose.model(&#x27;ideas&#x27;); 新增 Idea Form 在 views/partials/_navbar.handlebars 加入右側選單，直接加在左側選單的 ul 下面 123456789&lt;ul class=&quot;navbar-nav ml-auto&quot;&gt; &lt;li class=&quot;nav-item dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;nav-link dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; id=&quot;navbarDropdownMenuLink&quot;&gt;Video Ideas&lt;/a&gt; &lt;div class=&quot;dropdown-menu&quot;&gt; &lt;a href=&quot;/ideas&quot; class=&quot;dropdown-item&quot;&gt;Ideas&lt;/a&gt; &lt;a href=&quot;/ideas/add&quot; class=&quot;dropdown-item&quot;&gt;Add Ideas&lt;/a&gt; &lt;/div&gt; &lt;/li&gt;&lt;/ul&gt; 在 app.js 新增 ideas/add 的路由 123app.get(&#x27;/ideas/add&#x27;, (req, res) =&gt; &#123; res.render(&#x27;ideas/add&#x27;);&#125;); 新增 views/ideas/add.handlebars 1234567891011121314&lt;div class=&quot;card card-body&quot;&gt; &lt;h3&gt;Video Idea&lt;/h3&gt; &lt;form action=&quot;/ideas&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;title&quot;&gt;Title&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;title&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;details&quot;&gt;Details&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; name=&quot;details&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt;&lt;/div&gt; 伺服端的 Form Validation Body-Parser 外掛 安裝 body-parser npm install body-parser --save 在 app.js 引入 body-parser const bodyParser = require('body-parser'); 在 app.js 呼叫 Body parser middleware 123// Body parser middlewareapp.use(bodyParser.urlencoded(&#123; extended: false &#125;))app.use(bodyParser.json()) Server Side 處理表單，如果沒有資料，回傳 text，並且將本來有輸入的值放回去，最後，如果全部都有資料則 passed 123456789101112131415161718192021// Process Formapp.post(&#x27;/ideas&#x27;, (req, res) =&gt; &#123; let errors = []; if(!req.body.title) &#123; errors.push(&#123;text:&#x27;Please add a title&#x27;&#125;); &#125; if(!req.body.details) &#123; errors.push(&#123;text:&#x27;Please add some details&#x27;&#125;); &#125; if(errors.length &gt; 0)&#123; res.render(&#x27;ideas/add&#x27;, &#123; errors: errors, title: req.body.title, details: req.body.details &#125;) &#125; else &#123; res.send(&#x27;passed&#x27;); &#125;&#125;); 在 views/ideas/add.handlebars 新增錯誤訊息，將剛剛回傳的 errors 放進來 12345&#123;&#123;#each errors&#125;&#125; &lt;div class=&quot;alert alert-danger&quot;&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;&#123;&#123;else&#125;&#125;&#123;&#123;/each&#125;&#125; 在 views/ideas/add.handlebars 的表單輸入加入 required，可使用前端認證 12&lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;title&quot; required&gt;&lt;textarea class=&quot;form-control&quot; name=&quot;details&quot; required&gt;&lt;/textarea&gt; 將 Idea 存到 MongoDB 在 app.js 確認沒有錯誤的話則寫入資料庫 1234567891011&#125; else &#123; const newUser = &#123; title: req.body.title, details: req.body.details, &#125; new Idea(newUser) .save() .then(idea =&gt; &#123; res.redirect(&#x27;/ideas&#x27;); &#125;)&#125; 進入 mongo 模式 mongo 查詢資料庫 顯示資料庫 show dbs 進入資料庫 use vidjot-dev 顯示資料庫內的 collections show collections 讀取指定 collection 的內容 db.ideas.find(); 從 MongoDB 讀取 Ideas 在 app.js 新增 ideas 的路由，然後傳送資料過去，且排列順序按照 date 降冪排列 123456789app.get(&#x27;/ideas&#x27;, (req, res) =&gt; &#123; Idea.find(&#123;&#125;) .sort(&#123;date: &#x27;desc&#x27;&#125;) .then(ideas =&gt; &#123; res.render(&#x27;ideas/index&#x27;, &#123; ideas: ideas &#125;); &#125;);&#125;); 新增 views/ideas/index.handlebars 並用 each 讀出資料 12345678&#123;&#123;#each ideas&#125;&#125; &lt;div class=&quot;card card-body mb-2&quot;&gt; &lt;h4&gt;&#123;&#123;title&#125;&#125;&lt;/h4&gt; &lt;p&gt;&#123;&#123;details&#125;&#125;&lt;/p&gt; &lt;/div&gt;&#123;&#123;else&#125;&#125; &lt;p&gt;No video ideas listed&lt;/p&gt;&#123;&#123;/each&#125;&#125; 編輯 Idea Form 在 app.js 新增編輯 Idea Form 的路由，只找尋一個然後傳過去下個頁面 1234567891011// Edit Idea Formapp.get(&#x27;/ideas/edit/:id&#x27;, (req, res) =&gt; &#123; Idea.findOne(&#123; _id: req.params.id, &#125;) .then(idea =&gt; &#123; res.render(&#x27;ideas/edit&#x27;, &#123; idea: idea &#125;); &#125;);&#125;); 在 views/ideas/index.handlebars 新增一個 Edit 的連結 &lt;a class=&quot;btn btn-dark btn-block&quot; href=&quot;/ideas/edit/&#123;&#123;id&#125;&#125;&quot;&gt;Edit&lt;/a&gt; 從 views/ideas/add.handlebars 複製新增到 views/ideas/edit.handlebars，且將值放進去 1234567891011121314151617181920&#123;&#123;#each errors&#125;&#125; &lt;div class=&quot;alert alert-danger&quot;&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;&#123;&#123;else&#125;&#125;&#123;&#123;/each&#125;&#125;&lt;div class=&quot;card card-body&quot;&gt; &lt;h3&gt;Edit Video Idea&lt;/h3&gt; &lt;form action=&quot;/ideas&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;title&quot;&gt;Title&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;title&quot; value=&quot;&#123;&#123;idea.title&#125;&#125;&quot; required&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;details&quot;&gt;Details&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; name=&quot;details&quot; required&gt;&#123;&#123;idea.details&#125;&#125;&lt;/textarea&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt;&lt;/div&gt; 更新 Idea Data Method Override 安裝 method-override npm install method-override --save 在 app.js 引入 const methodOverride = require('method-override'); 在 app.js 新增 method-override 的 middleware app.use(methodOverride('_method')); 修改 views/ideas/edit.handlebars 的表單 action 且新增 hidden input 12&lt;form action=&quot;/ideas/&#123;&#123;idea.id&#125;&#125;?_method=PUT&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt; 在 app.js 更新表單，然後將值存到資料庫 12345678910111213141516// Edit Form processapp.put(&#x27;/ideas/:id&#x27;, (req, res) =&gt; &#123; Idea.findOne(&#123; _id: req.params.id &#125;) .then(idea =&gt; &#123; // new values idea.title = req.body.title; idea.details = req.body.details; idea.save() .then(idea =&gt; &#123; res.redirect(&#x27;/ideas&#x27;); &#125;) &#125;);&#125;); 移除 Idea Data 在 views/ideas/index.handlebars 新增 Delete 按鈕 1234&lt;form action=&quot;/ideas/&#123;&#123;id&#125;&#125;?_method=DELETE&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot;&gt; &lt;input type=&quot;submit&quot; class=&quot;btn btn-danger btn-block&quot; value=&quot;Delete&quot;&gt;&lt;/form&gt; 在 app.js 新增刪除路由，用 remove 直接把檔案從資料庫刪除 1234567// Delete Ideaapp.delete(&#x27;/ideas/:id&#x27;, (req, res) =&gt; &#123; Idea.remove(&#123;_id: req.params.id&#125;) .then(() =&gt; &#123; res.redirect(&#x27;/ideas&#x27;); &#125;);&#125;); Flashing Messaging Express Session Connect Flash 安裝 Express Session 和 Connect Flash npm install express-session connect-flash --save 在 app.js 引入 Express Session 和 Connect Flash 12const flash = require(&#x27;connect-flash&#x27;);const session = require(&#x27;express-session&#x27;); 在 app.js 把 Express Session 和 Connect Flash 的 middleware 12345678// Express session middlewareapp.use(session(&#123; secret: &#x27;secret&#x27;, resave: true, saveUninitialized: true&#125;));app.use(flash()); 在 app.js 把區域變數變成全域變數，這樣訊息就可以在 handlebars 的頁面顯示 1234567// Global variablesapp.use(function(req, res, next) &#123; res.locals.success_msg = req.flash(&#x27;success_msg&#x27;); res.locals.error_msg = req.flash(&#x27;error_msg&#x27;); res.locals.error = req.flash(&#x27;error&#x27;); next();&#125;); app.js 在所有路由跳轉之前，送出 flash 訊息 req.flash('success_msg', 'Video Idea added'); req.flash('success_msg', 'Video Idea updated'); req.flash('success_msg', 'Video Idea removed'); 新增 views/partials/_msg.handlebars 1234567&#123;&#123;#if success_msg&#125;&#125; &lt;div class=&quot;alert alert-success&quot;&gt;&#123;&#123;success_msg&#125;&#125;&lt;/div&gt;&#123;&#123;/if&#125;&#125;&#123;&#123;#if error_msg&#125;&#125; &lt;div class=&quot;alert alert-danger&quot;&gt;&#123;&#123;error_msg&#125;&#125;&lt;/div&gt;&#123;&#123;/if&#125;&#125; 在 views/layouts/main.handlebars 的 &#123;&#123;\"&#123;&#123;body\"&#125;&#125;&#125;&#125; 上方引入 &#123;&#123;\"&#123;&#123;> _msg\"&#125;&#125;&#125;&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://vincent.fishboneapps.com/tags/Nodejs/"}]},{"title":"UI 網頁設計快速學習自我挑戰 Day1","slug":"UI-網頁設計快速學習自我挑戰-Day1","date":"2017-11-09T09:30:02.000Z","updated":"2020-06-22T17:16:33.016Z","comments":true,"path":"2017/11/09/UI-網頁設計快速學習自我挑戰-Day1/","link":"","permalink":"https://vincent.fishboneapps.com/2017/11/09/UI-%E7%B6%B2%E9%A0%81%E8%A8%AD%E8%A8%88%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day1/","excerpt":"","text":"修改 Illustrator 環境 Illustrator CC =&gt; Preferences =&gt; Units，把 General、Stroke 和 Type 改為 Pixels Window =&gt; Workspace，選擇 Web，如果有問題，選擇 Reset Web 在 Illustrator 新增 sitemap New =&gt; 選擇 A4 打開 Adobe Muse =&gt; New =&gt; 直接新增 修改 Muse 背景：Preferences =&gt; Color theme 挑一個 用 Command + Shift + 4 截圖，把檔案貼到 Illustrator Desktop、Tablet、Mobile 網頁設計用什麼螢幕尺寸 了解裝置大小 New =&gt; 選擇 Web =&gt; Common size =&gt; 將 width 改為 1200 =&gt; 新增 開啟左邊選單列的 artboard tool =&gt; 選擇 New Artboard =&gt; 將寬度調為 768 px 按住 Option 鍵 =&gt; 按鈕會變成有陰影的箭頭 =&gt; 拖移也可以產生新的 Artboard Window =&gt; Artboard =&gt; Artboard 出現在右邊選單，將 Artboard 改為以下 Desktop 1200px Tablet 768px Mobile 400px Save =&gt; 按照預設值即可 什麼是 Grid System 和 Responsive Mobile &amp; Tablet Design？ 12 個 column，不能用 13，因為難以切割 如何在 Illustrator 製作 12 個 column 的 responsive grid？ 先選擇 Rectangle Tool =&gt; 內部選擇 None =&gt; 外部選擇黑色 =&gt; 把 Desktop 部分框起來 選擇 Object =&gt; Path =&gt; Split Into Grid =&gt; Column number 選擇 12 =&gt; Gutter 選擇 30px =&gt; Add Guides 要打勾 =&gt; 點選 OK 選擇出現的 object =&gt; 按滑鼠右鍵 ungroup =&gt; 把畫面往下移動 View =&gt; Make Guides =&gt; View =&gt; Lock Guides，然後線條就鎖住了 把所有的線框起來 =&gt; 刪掉 點選左邊選單的 Artboard，把左右兩邊邊界拉大 Tablet 和 Mobile 步驟都跟上面一樣，但是 Tablet Column number 選擇 6，Mobile Column 選擇 2 建立 Wireframe Command + ; 可以關閉和開啟 Guides 新增 Logo，左上角佔用 4 個 column 新增 Navigation，右上角佔用 6 個 column 新增 Hero box，放到 Logo 下方，佔用 12 個 column 在 Hero box 裡面的第二個 column 新增佔用 5 個 column 的文字 Command + Shift + . 放大字體，Command + Shift + , 縮小字體 全選文字 =&gt; 點選右方段落 =&gt; 取消勾選 Hyphenate 在文字下方新增佔用 3 個 column 的 button，文字打入 AMAZING CALL TO ACTION 在 Hero box 下方新增 4 個 column 的區塊，裡面要打上叉叉，先用 Line Segment Tool 新增一條斜線，再用 Object =&gt; Transform =&gt; Reflect，產生相反的線，用 Transform 對齊，最後把區塊和叉叉組合在一起 =&gt; Object =&gt; Group 最後複製三個 4 column 區塊，然後對齊，並間隔一個位置。 建立 Tablet 和 Mobile Wireframe 把 Guides 延長的方法：View =&gt; Guides =&gt; Unlock Guides =&gt; 把下面的線框起來 =&gt; 選擇 Direct Selection Tool =&gt; 把線拉長並按住 Shift (可以保持直線) =&gt; View =&gt; Guides =&gt; Lock Guides Mobile Hamburger Bar：用 Line Segment Tool 拉出直線 =&gt; 設定 Stroke 線為黑色且寬度設為 4px =&gt; 複製三個 =&gt; 用 transform 的 Vertical Distribute Center 剩下的按照位置移動，並調整大小即可。 網頁設計的靈感 AWWWARDS 使用 Illustrator 模板開始網頁設計 New =&gt; Web =&gt; TEMPLATES =&gt; 選擇需要的下載 打開 Creative Cloud =&gt; Assets =&gt; Market =&gt; 選擇需要的 =&gt; Add to Library 將 Vector Logo 放到版面編排 使用 svg 再放大也不會失真，所以最好使用 svg 用 Rectangle Tool 拉出背景，選擇黑色，透明度選擇 81%，把位置放到最後面 =&gt; 按滑鼠右鍵 =&gt; Arrange =&gt; Send to Back 放上 Navigation 文字 =&gt; ABOUT ME、CONTACT ME 使用 Adobe 顏色 Adobe 顏色選擇器 進去網頁之後 =&gt; 選擇 Explore =&gt; 選擇喜歡的色盤 =&gt; 按下 Save =&gt; 選擇要存入的 Library =&gt; 就可以在 Illustrator 看到了 使用 Adobe Illustrator 來對應品牌顏色 把 Google Logo 放到頁面裡面 =&gt; 使用 Eyedropper Tool 點需要的顏色 =&gt; 在畫面左上方顏色選擇器的地方選擇 New Swatch =&gt; 輸入名稱 =&gt; 儲存到 Library","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"UI","slug":"UI","permalink":"https://vincent.fishboneapps.com/tags/UI/"},{"name":"Illustrator","slug":"Illustrator","permalink":"https://vincent.fishboneapps.com/tags/Illustrator/"}]},{"title":"HTML5+CSS3 快速學習自我挑戰 Day1","slug":"HTML5-CSS3-快速學習自我挑戰-Day1","date":"2017-11-03T21:39:50.000Z","updated":"2020-06-22T17:13:20.411Z","comments":true,"path":"2017/11/03/HTML5-CSS3-快速學習自我挑戰-Day1/","link":"","permalink":"https://vincent.fishboneapps.com/2017/11/03/HTML5-CSS3-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day1/","excerpt":"","text":"課程介紹 學習內容 動手做 HTML5、CSS3 和 jQuery 製作七步驟，從草稿到完整的有功能且優化的網站 簡單使用網站設計原則和訣竅 如何取得且使用很棒的圖片、文字和圖標，全部免費 Responsive 網頁設計，讓不同的大小畫面都漂亮 如何使用 jQuery 製作非常酷的動畫 如何優化網站 課程主要分為四部分 網站設計基礎 基礎 HTML 和 CSS 用被應用在真實世界的七步驟完成很酷的網站 優化網站 開始使用 HTML 什麼是 HTML HTML = Hyper Text Markup Language HTML 檔案用 HTML 標籤來寫 &lt;h1&gt; &lt;p&gt; &lt;a&gt; 標籤用來包裝元素的開始和結束 &lt;tagname&gt;content&lt;/tagname&gt; HTML 架構 HTML 裡面由 head 和 body 組成，在檔案開頭要宣告檔案類型 12345678&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 填滿架構 Lorem Ipsum 產生器 常用 HTML 標籤 &lt;p&gt;&lt;/p&gt; 段落 &lt;strong&gt;&lt;/strong&gt; 粗體 &lt;em&gt;&lt;/em&gt; 斜體 &lt;u&gt;&lt;/u&gt; 底線 &lt;br&gt; 換行 圖片和屬性 隨機產生人像 引入圖片 &lt;img src=&quot;logo.jpg&quot; alt=&quot;The HTML5 logo&quot;&gt; 超連結 超連結文字 &lt;a href=&quot;https://www.udemy.com&quot; target=&quot;_blank&quot;&gt;Link to Udemy&lt;/a&gt; 超連結圖片 &lt;a href=&quot;logo.jpg&quot; target=&quot;_blank&quot;&gt;HTML logo&lt;/a&gt; CSS 格式 開始使用 CSS CSS = Cascading Style Sheets CSS 定義 HTML 要長什麼樣子 HTML 是內容，CSS 是樣式 CSS 可以寫的地方 加在 HTML tag 裡面 加在 HTML 檔案裡面 把 CSS code 放在外部檔案 新增 style.css，然後在 index.html 引入 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;&gt; 開始讓網頁變漂亮 修改 style.css 檔案 12345678910111213141516171819202122body &#123; font-family: Helvetica Neue, Arial; font-size: 18px;&#125;h1, h2 &#123; color: green;&#125;h1 &#123; font-size: 40px;&#125;h2 &#123; font-size: 25px;&#125;p &#123; font-size: 18px; text-align: justify;&#125; 顏色 RGB #RRGGBB 每個顏色最小 0，最大 ff 要有透明度，則採用 rgba Classes 和 IDs id 只能用一次，用 # 表示 在 sytle.css 新增 class 1234567.main-text &#123; text-align: justify;&#125;.author-text &#123; font-size: 22px;&#125; 把前段的的 &lt;p&gt; 改成 &lt;p class=&quot;main-text&quot;&gt;，作者的 &lt;p&gt; 改成 &lt;p class=&quot;author-text&quot;&gt; CSS box model Box model 分為四部分 Content：文字，圖片…等等 Padding：在 Content 內部的透明區域，在 box 裡面 Border：在 Padding 和 Content 的外面 Margin：Boxes 之間的距離 Box-sizing：CSS 同樣也可以定義整個 box width 和 Height，而不只有 Content 在 HTML，有 block 元素和 inline 元素，包含 Heading 和 Paragraph 都是 block 元素，而圖片，粗體和連結都屬於 inline 元素，inline 元素你只能設定它的 height 或是它的 width 在 style.css 設定元素 12345* &#123; margin: 0; padding: 0; box-sizing: border-box;&#125; 設定 h1 margin-bottom: 20px; h2 margin-bottom: 10px; .main-text margin-bottom: 20px; 建立一個簡單的版面編排 新增網頁架構 123456789101112131415&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;blog-post&quot;&gt; 內文 &lt;/div&gt; &lt;div class=&quot;other-posts&quot;&gt; 右邊選單欄 &lt;/div&gt; &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt; &lt;div class=&quot;author-box&quot;&gt; 作者欄 &lt;/div&gt;&lt;/div&gt; clearfix 處理換 row 的問題，margin 的值是 top right bottom left，float 是強制靠左，讓元素整合在一起 1234567891011121314151617181920212223242526.clearfix:after &#123; content: &quot;&quot;; display: table; clear: both;&#125;.container &#123; width: 1140px; margin: 20px auto 0 auto;&#125;.blog-post &#123; width: 75%; float: left; padding-right: 30px;&#125;.other-posts &#123; width: 25%; float: left;&#125;.author-box &#123; padding-top: 20px; border-top: 1px solid #333;&#125; 擦亮我們的 blog post 把 html logo 放到內文第二部分，然後側邊選單欄新增內容 1234567891011&lt;div class=&quot;other-posts&quot;&gt; &lt;div class=&quot;other&quot;&gt; The first other blog post &lt;/div&gt; &lt;div class=&quot;other&quot;&gt; Yet another blog post &lt;/div&gt; &lt;div class=&quot;other&quot;&gt; The best blog post ever: read this! &lt;/div&gt;&lt;/div&gt; 調整側邊欄的間距，作者欄的圖片大小且變成圓形，然後讓作者區塊的文字平行對齊 1234567891011121314151617181920212223.author-text &#123; font-size: 22px; float: left; margin-top: 30px; margin-left: 10px;&#125;.other &#123; margin-bottom: 40px;&#125;.author-box img &#123; height: 100px; width: 100px; border-radius: 50%; float: left;&#125;.blog-post img &#123; height: 150px; width: auto;&#125; Relative 和 Absolute 在 blog post 內文第一部分標題後面新增日期 &lt;p class=&quot;date&quot;&gt;Nov 11th, 2017&lt;/p&gt; 在 .blog-post 的 class 下的 position 設為 relative 1234.blog-post &#123; ... position: relative;&#125; 在 .date 的 position 設為 absolute 並調整間距 12345.date &#123; position: absolute; top: 10px; right: 30px;&#125; 開始使用 Chrome Developer Tools Windows F12 開啟，Mac Command + Option + I","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://vincent.fishboneapps.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://vincent.fishboneapps.com/tags/CSS/"}]},{"title":"Nodejs II 快速學習自我挑戰 Day1","slug":"Nodejs-II-快速學習自我挑戰-Day1","date":"2017-11-02T08:36:32.000Z","updated":"2020-06-22T17:15:24.880Z","comments":true,"path":"2017/11/02/Nodejs-II-快速學習自我挑戰-Day1/","link":"","permalink":"https://vincent.fishboneapps.com/2017/11/02/Nodejs-II-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day1/","excerpt":"","text":"課程簡介 課程內容 使用 Node/Express/Mongo 創建 Server Side Application 很多 node modules/packages 從手稿到專案部署 2 個有一步步解說的深度專案 課程內容沒有的 沒有 Nodejs 簡介 沒有簡單的 todo List 或 REST API 不會只告訴你讓你自己線上部署你自己的應用 課程的先備知識 HTML/CSS/JavaScript 基礎的 Node.js/Express 知識 如果沒有 Node/Express/MongoDB 的知識，我會解說 課程可以學到的東西 如何從無到有包含部署製作一個 server-side 應用 都是關於 Express 框架 在本地工作和遠端 MongoDB 部署 處理本地和 Google OAuth 認證 在 Server 處理畫面和編排 ES6 JavaScript 觀念 專案一：VidJot - 可以讓創作者註冊且寫下他們對下一個影片的想法 使用 Express、Mongoose、Passport、Bcrypt、Express-Session、Handlebars.js、Bootstrap 4 beta 專案二：StoryBooks - 社交網路，用來創建公開和私有的故事，使用者可以使用 Google OAuth 選擇允許或關閉留言 使用 Express、Mongoose、Passport、Google OAuth、Private/Public Stories、Helper Functions、Moment.js、Materialize CSS 環境設定 開發環境設定 VS code 設定檔案 1234567&#123; &quot;editor.fontSize&quot;: 26, &quot;terminal.integrated.fontSize&quot;: 26, &quot;terminal.integrated.shell.windows&quot;: &quot;C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe&quot; &quot;editor.wordWrap&quot;: &quot;on&quot; &quot;editor.tabSize&quot;: 2,&#125; 什麼是 Node.js 什麼是 Node.js? JavaScript runtime 使用 V8 JavaScript Engine，正是 Google 瀏覽器所使用的 Engine V8 Engine 用 C++ 寫的，用來幫助 JavaScript 編譯到非常快的機器 允許我們在 Server 上面運行 JS (像是 PHP、Rails、Java…等等) 跨平台執行 (Windows、Linux、MacOS) 用來建立非常快速且可規模化的 Real-time Application，因為他有非同步式的特色 使用事件驅動，非阻塞式 I/O model 可以用 Node 做什麼？ 用 filesystem 操作檔案 建立網頁伺服器，處理進來的 Http 請求和回傳回應，可以使用像是 express 的框架讓這件事情更簡單 與資料庫連線 (MongoDB、MySQL、Postgres、Redis… 等等) 強大的 APIs 和後端介面 強大的 Server side apps 且可以讀取 views Blocking Model vs. Non-Blocking Blocking 要等事件完成才進行下一件事情，Non-Blocking 在事情完成前，先繼續做其它事情，等到事情完成會有 callback，然後回去執行 callback 的動作 安裝和探索 Node.js chrome 可以使用的語法 document Node server 可以用的語法 global process.env.USER 安裝本地 MongoDB 下載 MongoDB 安裝在 C 槽，在 mongodb 根目錄新增 data 的資料夾，在 data 的資料夾再新增 db 的資料夾。在 mongodb 根目錄新增 log，在 log 的資料夾新增檔案 mongo.log 用系統管理員打開 cmd，跳到 mongodb bin 目錄，cd c:/mongodb/bin mongod --directoryperdb --dbpath C:\\mongodb\\data\\db --logpath C:\\mongodb\\log\\mongo.log --logappend --rest --install net start MongoDB mongo show databases 註冊 mlab mLab 註冊 Heroku Heroku VidJot Project 介紹 VidJot 安裝和啟動 Express Express 官方網站 設定 npm 預設值 npm set init-author-name=&quot;Vincent Adler&quot; npm set init-license=&quot;MIT&quot; 開新專案 npm init description: App to create video ideas entry point: (index.js) app.js 安裝 express npm install express --save 在根目錄新增 app.js 123456789const express = require(&#x27;express&#x27;);const app = express();const port = 5000;app.listen(port, () =&gt; &#123; console.log(`Server started on Port $&#123;port&#125;`);&#125;); 基礎路由和 Nodemon 在 app.js 新增路由 123456789// Index Routeapp.get(&#x27;/&#x27;, (req, res) =&gt; &#123; res.send(&#x27;INDEX&#x27;);&#125;);// About Routeapp.get(&#x27;/about&#x27;, (req, res) =&gt; &#123; res.send(&#x27;ABOUT&#x27;)&#125;); 安裝 nodemon npm install -g nodemon 檢查 npm 套件安裝位置 npm root -g 使用 nodemon nodemon Express Middleware Middleware 簡介 在 app.js 新增 middleware 1234app.use(function(req, res, next) &#123; console.log(Date.now()); next();&#125;); 在 middleware 放入 req.name 可以在 app.get 取得 1234app.use(function(req, res, next) &#123; req.name = &#x27;Vincent Adler&#x27;; next();&#125;); 123app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; res.send(req.name);&#125;); 使用模板 handlebars.js 官方網站 在 express 使用 handlebars EJS 安裝 express-handlebars npm install express-handlebars --save 引入 express-handlebars const exphbs = require('express-handlebars'); 新增 handlebars middleware 1234app.engine(&#x27;handlebars&#x27;, exphbs(&#123; defaultLayout: &#x27;main&#x27;&#125;));app.set(&#x27;view engine&#x27;, &#x27;handlebars&#x27;); 新增 views/index.handlebars &lt;h1&gt;Welcome&lt;/h1&gt; 新增 views/layouts/main.handlebars，{{{body}}} 會讀出被 render 的 view 12345678910111213&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;VidJot&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;&#123;&#123;body&#125;&#125;&#125;&lt;/body&gt;&lt;/html&gt; 把 app.js route 的 send 都改成 render 1234567app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; res.render(&#x27;index&#x27;);&#125;);app.get(&#x27;/about&#x27;, (req, res) =&gt; &#123; res.render(&#x27;about&#x27;)&#125;); 新增 views/about.handlebars &lt;h1&gt;About&lt;/h1&gt; 讓讀取的資料變成動態 123456app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; const title = &#x27;Welcome&#x27;; res.render(&#x27;index&#x27;, &#123; title: title &#125;);&#125;); 修改 views/index.handlebars &lt;h1&gt;&#123;&#123;\"&#123;&#123;title\"&#125;&#125;&#125;&#125;&lt;/h1&gt; Bootstrap 和 Partials 取得 Bootstrap 的 CDN 在 views/layouts/main.handlebars 引入 CDN 1234567// CSS&lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css&quot; integrity=&quot;sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb&quot; crossorigin=&quot;anonymous&quot;&gt;// JS&lt;script src=&quot;https://code.jquery.com/jquery-3.2.1.slim.min.js&quot; integrity=&quot;sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.3/umd/popper.min.js&quot; integrity=&quot;sha384-vFJXuSJphROIrBnz7yo7oB41mKfc8JzQZiCq4NCceLEaO4IHwicKwpJf9c9IpFgh&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/js/bootstrap.min.js&quot; integrity=&quot;sha384-alpBpkh1PFOepccYVYDB4do5UnbKysX5WZXm3XxPqe5iKTfUKjNkCk9SaVuEZflJ&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; 在 views/layouts/main.handlebars，body 用 container 包住 123&lt;div class=&quot;container&quot;&gt; &#123;&#123;&#123;body&#125;&#125;&#125;&lt;/div&gt; 新增 views/partials/_navbar.handlebars 123456789101112131415161718&lt;nav class=&quot;navbar navbar-expand-sm navbar-dark bg-primary&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;VidJot&lt;/a&gt; &lt;button class=&quot;navbar-toggler&quot; type=&quot;button&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#navbarNav&quot; aria-controls=&quot;navbarNav&quot; aria-expanded=&quot;false&quot; aria-label=&quot;Toggle navigation&quot;&gt; &lt;span class=&quot;navbar-toggler-icon&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;navbarNav&quot;&gt; &lt;ul class=&quot;navbar-nav&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/&quot;&gt;Home&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;/about&quot;&gt;About&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt; 在 views/layouts/main.handlebars 引入 navbar partial &#123;&#123;\"&#123;&#123;> _navbar\"&#125;&#125;&#125;&#125; 包裝一下 views/index.handlebars 12345&lt;div class=&quot;jumbotron text-center&quot;&gt; &lt;h1 class=&quot;display-3&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;p class=&quot;lead&quot;&gt;Jot down ideas for your next YouTube Videos&lt;/p&gt; &lt;a href=&quot;/ideas/add&quot; class=&quot;btn btn-dark btn-lg&quot;&gt;Add Video Idea&lt;/a&gt;&lt;/div&gt; 包裝一下 views/about.handlebars 123&lt;h1&gt;About&lt;/h1&gt;&lt;p&gt;This is a Node/Express app for jotting down ideas for future Youtube videos&lt;/p&gt;&lt;p&gt;Version: 1.0.0&lt;/p&gt;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://vincent.fishboneapps.com/tags/Nodejs/"}]},{"title":"Nodejs 快速學習自我挑戰 Day12","slug":"Nodejs-快速學習自我挑戰-Day12","date":"2017-10-14T00:51:23.000Z","updated":"2020-06-22T17:15:24.880Z","comments":true,"path":"2017/10/13/Nodejs-快速學習自我挑戰-Day12/","link":"","permalink":"https://vincent.fishboneapps.com/2017/10/13/Nodejs-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day12/","excerpt":"","text":"使用 Socket.io 的即時 Web Apps Mustache.js 下載 Mustache 最新版，儲存到 public/js/libs/mustache.js 在 public/index.html 引入 &lt;script src=&quot;js/libs/mustache.js&quot;&gt;&lt;/script&gt; 在 public/index.html 加入 template 12345678910111213141516171819202122232425&lt;script id=&quot;message-template&quot; type=&quot;text/template&quot;&gt; &lt;li class=&quot;message&quot;&gt; &lt;div class=&quot;message__title&quot;&gt; &lt;h4&gt;&#123;&#123;from&#125;&#125;&lt;/h4&gt; &lt;span&gt;&#123;&#123;createdAt&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;message__body&quot;&gt; &lt;p&gt;&#123;&#123;text&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/li&gt;&lt;/script&gt;&lt;script id=&quot;location-message-template&quot; type=&quot;text/template&quot;&gt; &lt;li class=&quot;message&quot;&gt; &lt;div class=&quot;message__title&quot;&gt; &lt;h4&gt;&#123;&#123;from&#125;&#125;&lt;/h4&gt; &lt;span&gt;&#123;&#123;createdAt&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;message__body&quot;&gt; &lt;p&gt; &lt;a href=&quot;&#123;&#123;url&#125;&#125;&quot; target=&quot;_blank&quot;&gt;My current location&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/li&gt;&lt;/script&gt; 在 public/js/index.js 使用 Mustache 來顯示 template 1234567891011121314151617181920212223socket.on(&#x27;newMessage&#x27;, function (message) &#123; var formattedTime = moment(message.createdAt).format(&#x27;h:mm a&#x27;); var template = jQuery(&#x27;#message-template&#x27;).html(); var html = Mustache.render(template, &#123; text: message.text, from: message.from, createdAt: formattedTime &#125;); jQuery(&#x27;#messages&#x27;).append(html);&#125;);socket.on(&#x27;newLocationMessage&#x27;, function (message) &#123; var formattedTime = moment(message.createdAt).format(&#x27;h:mm a&#x27;); var template = jQuery(&#x27;#location-message-template&#x27;).html(); var html = Mustache.render(template, &#123; from: message.from, url: message.url, createdAt: formattedTime &#125;); jQuery(&#x27;#messages&#x27;).append(html);&#125;); git push heroku master Autoscrolling 在 public/js/index.js 新增 scrollToBottom function 123456789101112131415function scrollToBottom () &#123; // Selectors var messages = jQuery(&#x27;#messages&#x27;); var newMessage = messages.children(&#x27;li:last-child&#x27;); // Height var clientHeight = messages.prop(&#x27;clientHeight&#x27;); var scrollTop = messages.prop(&#x27;scrollTop&#x27;); var scrollHeight = messages.prop(&#x27;scrollHeight&#x27;); var newMessageHeight = newMessage.innerHeight(); var lastMessageHeight = newMessage.prev().innerHeight(); if (clientHeight + scrollTop + newMessageHeight + lastMessageHeight &gt;= scrollHeight) &#123; messages.scrollTop(scrollHeight); &#125;&#125; 在 public/js/index.js 的 newMessage 和 newLocationMessage 新增 scrollToBottom scrollToBottom(); 新增一個 join page 將本來的 index.html 和 index.js 改為 chat.html 和 chat.js 新增 public/index.html 1234567891011121314151617181920212223242526272829303132&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scale=1, user-scalable=no&quot;&gt; &lt;title&gt;Join | ChatApp&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/styles.css&quot;&gt;&lt;/head&gt;&lt;body class=&quot;centered-form&quot;&gt; &lt;div class=&quot;centered-form__form&quot;&gt; &lt;form action=&quot;chat.html&quot;&gt; &lt;div class=&quot;form-field&quot;&gt; &lt;h3&gt;Join a Chat&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;form-field&quot;&gt; &lt;label&gt;Display name&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; autofocus /&gt; &lt;/div&gt; &lt;div class=&quot;form-field&quot;&gt; &lt;label&gt;Room name&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;room&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;form-field&quot;&gt; &lt;button&gt;Join&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 傳送 Room 資訊 deparam function 把檔案下載到 public/js/libs/deparam.js 在 public/chat.html 引入 &lt;script src=&quot;js/libs/deparam.js&quot;&gt;&lt;/script&gt; 在 public/js/chat.js 新增 emit 123456789101112socket.on(&#x27;connect&#x27;, function () &#123; var params = jQuery.deparam(window.location.search); socket.emit(&#x27;join&#x27;, params, function (err) &#123; if (err) &#123; alert(err); window.location.href = &#x27;/&#x27;; &#125; else &#123; console.log(&#x27;No error&#x27;); &#125; &#125;);&#125;); 新增 server/utils/validation.js 12345var isRealString = (str) =&gt; &#123; return typeof str === &#x27;string&#x27; &amp;&amp; str.trim().length &gt; 0;&#125;;module.exports = &#123;isRealString&#125;; 在 server/server.js 引入 const &#123;isRealString&#125; = require('./utils/validation'); 在 server/server.js 新增 socket.on 取得資訊，並做驗證 1234567socket.on(&#x27;join&#x27;, (params, callback) =&gt; &#123; if (!isRealString(params.name) || !isRealString(params.room)) &#123; callback(&#x27;Name and room name are required.&#x27;); &#125; callback();&#125;); 新增 server/utils/validation.test.js 引入 isRealString 測試一：拒絕不是 string 的值 測試二：拒絕只有空白的 string 測試三：接受沒有空格的 string 新增 server/utils/validation.test.js 1234567891011121314151617181920const expect = require(&#x27;expect&#x27;);const &#123;isRealString&#125; = require(&#x27;./validation&#x27;);describe(&#x27;isRealString&#x27;, () =&gt; &#123; it(&#x27;should reject non-string values&#x27;, () =&gt; &#123; var res = isRealString(98); expect(res).toBe(false); &#125;); it(&#x27;should reject string with only spaces&#x27;, () =&gt; &#123; var res = isRealString(&#x27; &#x27;); expect(res).toBe(false); &#125;); it(&#x27;should allow string with non-space characters&#x27;, () =&gt; &#123; var res = isRealString(&#x27; Andrew &#x27;); expect(res).toBe(true); &#125;);&#125;); Socket.io Rooms 在 server/server.js 新增 socket.join，然後把上面的 newMessage 放到下面，動態產生使用者加入的訊息 1234567891011socket.on(&#x27;join&#x27;, (params, callback) =&gt; &#123; if (!isRealString(params.name) || !isRealString(params.room)) &#123; callback(&#x27;Name and room name are required.&#x27;); &#125; socket.join(params.room); socket.emit(&#x27;newMessage&#x27;, generateMessage(&#x27;Admin&#x27;, &#x27;Welcome to the chat app&#x27;)); socket.broadcast.to(params.room).emit(&#x27;newMessage&#x27;, generateMessage(&#x27;Admin&#x27;, `$&#123;params.name&#125; has joined`)); callback();&#125;); 使用 ES6 classes 來儲存用戶 新增 server/utils/users.js 1234567class Person &#123; constructor (name, age) &#123; console.log(name, age); &#125;&#125;var me = new Person(&#x27;Andrew&#x27;, 25); node server/utils/users.js 就會出現 Andrew 25 在 class 新增 getUserDescription 123getUserDescription () &#123; return `$&#123;this.name&#125; is $&#123;this.age&#125; year(s) old.`;&#125; 新增變數，然後讀出變數 12var description = me.getUserDescription();console.log(description); console.log(description); 就會顯示出 Andrew is 25 year(s) old. 在 server/utils/users.js 新增 Users class 123456789101112class Users &#123; constructor () &#123; this.users = []; &#125; addUser (id, name, room) &#123; var user = &#123;id, name, room&#125;; this.users.push(user); return user; &#125;&#125;module.exports = &#123;Users&#125;; 新增 server/utils/users.test.js 1234567891011121314151617const expect = require(&#x27;expect&#x27;);const &#123;Users&#125; = require(&#x27;./users&#x27;);describe(&#x27;Users&#x27;, () =&gt; &#123; it(&#x27;should add new user&#x27;, () =&gt; &#123; var users = new Users(); var user = &#123; id: &#x27;123&#x27;, name: &#x27;Andrew&#x27;, room: &#x27;The Office Fans&#x27; &#125;; var resUser = users.addUser(user.id, user.name, user.room); expect(users.users).toEqual([user]); &#125;);&#125;); npm test 在 server/utils/users.test.js 丟 data 進去 123456789101112131415161718var users;beforeEach(() =&gt; &#123; users = new Users(); users.users = [&#123; id: &#x27;1&#x27;, name: &#x27;Mike&#x27;, room: &#x27;Node Course&#x27; &#125;,&#123; id: &#x27;2&#x27;, name: &#x27;Jen&#x27;, room: &#x27;React Course&#x27; &#125;,&#123; id: &#x27;3&#x27;, name: &#x27;Julie&#x27;, room: &#x27;Node Course&#x27; &#125;];&#125;); npm run test-watch 在 server/utils/user.js 新增 getUserList 123456getUserList (room) &#123; var users = this.users.filter((user) =&gt; user.room === room); var namesArray = users.map((user) =&gt; user.name); return namesArray;&#125; 在 server/utils/user.test.js 新增 getUserList 測試 1234567891011it(&#x27;should return names for node course&#x27;, () =&gt; &#123; var userList = users.getUserList(&#x27;Node Course&#x27;); expect(userList).toEqual([&#x27;Mike&#x27;, &#x27;Julie&#x27;]);&#125;);it(&#x27;should return names for react course&#x27;, () =&gt; &#123; var userList = users.getUserList(&#x27;React Course&#x27;); expect(userList).toEqual([&#x27;Jen&#x27;]);&#125;); 在 server/utils/user.js 新增 getUser 123getUser (id) &#123; return this.users.filter((user) =&gt; user.id === id)[0];&#125; 在 server/utils/user.test.js 新增 getUser 測試 12345678910111213it(&#x27;should find user&#x27;, () =&gt; &#123; var userId = &#x27;2&#x27;; var user = users.getUser(userId); expect(user.id).toBe(userId);&#125;);it(&#x27;should not find user&#x27;, () =&gt; &#123; var userId = &#x27;99&#x27;; var user = users.getUser(userId); expect(user).toBeUndefined();&#125;); 在 server/utils/user.js 新增 removeUser 123456789removeUser (id) &#123; var user = this.getUser(id); if (user) &#123; this.users = this.users.filter((user) =&gt; user.id !== id); &#125; return user;&#125; 在 server/utils/user.test.js 新增 removeUser 測試 123456789101112131415it(&#x27;should remove a user&#x27;, () =&gt; &#123; var userId = &#x27;1&#x27;; var user = users.removeUser(userId); expect(user.id).toBe(userId); expect(users.users.length).toBe(2);&#125;);it(&#x27;should not remove user&#x27;, () =&gt; &#123; var userId = &#x27;99&#x27;; var user = users.removeUser(userId); expect(user).toBeUndefined(); expect(users.users.length).toBe(3);&#125;); Wiring up User List 在 public/js/chat.js 新增 updateUserList 123socket.on(&#x27;updateUserList&#x27;, function (users) &#123; console.log(&#x27;Users list&#x27;, users);&#125;); 在 server/server.js 引入 const &#123;Users&#125; = require('./utils/users'); 在 server/server.js 新增 users var users = new Users(); 在 server/server.js 的 connect 部分，當連線時，先 removeUser，然後再重新 addUser，最後將 userList 傳送到前端頁面 1234users.removeUser(socket.id);users.addUser(socket.id, params.name, params.room);io.to(params.room).emit(&#x27;updateUserList&#x27;, users.getUserList(params.room)); 在 server/server.js 的 disconnect 部分，踢除 user，如果 user 存在，就更新 UserList，然後在前端頁面顯示 user 離開的訊息 12345678socket.on(&#x27;disconnect&#x27;, () =&gt; &#123; var user = users.removeUser(socket.id); if (user) &#123; io.to(user.room).emit(&#x27;updateUserList&#x27;, users.getUserList(user.room)); io.to(user.room).emit(&#x27;newMessage&#x27;, generateMessage(&#x27;Admin&#x27;, `$&#123;user.name&#125; has left.`)); &#125;&#125;); 修改 public/js/chat.js 的 updateUserList，把 user 顯示在前端 123456789socket.on(&#x27;updateUserList&#x27;, function (users) &#123; var ol = jQuery(&#x27;&lt;ol&gt;&lt;/ol&gt;&#x27;); users.forEach(function (user) &#123; ol.append(jQuery(&#x27;&lt;li&gt;&lt;/li&gt;&#x27;).text(user)); &#125;); jQuery(&#x27;#users&#x27;).html(ol);&#125;); 只傳送訊息到同一個 Room 在 public/js/chat.js 的 submit 刪掉 from: 'User', 在 server/server.js 修改 createMessage 讓 message 只在指定的 room 發佈訊息 123456789socket.on(&#x27;createMessage&#x27;, (message, callback) =&gt; &#123; var user = users.getUser(socket.id); if (user &amp;&amp; isRealString(message.text)) &#123; io.to(user.room).emit(&#x27;newMessage&#x27;, generateMessage(user.name, message.text)); &#125; callback(&#x27;&#x27;);&#125;); 在 server/server.js 修改 createLocationMessage 如上 12345678socket.on(&#x27;createLocationMessage&#x27;, (coords) =&gt; &#123; var user = users.getUser(socket.id); if (user) &#123; io.to(user.room).emit(&#x27;newLocationMessage&#x27;, generateLocationMessage(user.name, coords.latitude, coords.longitude)); &#125;&#125;); 新功能開發 不管字母大小寫，都是同一個房間 拒絕同樣名稱的用戶 在進去聊天室的時候，列出正在聊天的聊天室名稱 (dropdown)","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://vincent.fishboneapps.com/tags/Nodejs/"}]},{"title":"Nodejs 快速學習自我挑戰 Day11","slug":"Nodejs-快速學習自我挑戰-Day11","date":"2017-10-09T23:12:56.000Z","updated":"2020-06-22T17:15:24.880Z","comments":true,"path":"2017/10/09/Nodejs-快速學習自我挑戰-Day11/","link":"","permalink":"https://vincent.fishboneapps.com/2017/10/09/Nodejs-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day11/","excerpt":"","text":"使用 Socket.io 的即時 Web Apps Broadcasting Events 刪除 server/server.js 和 public/js/index.js 的 socket.emit 在 server/server.js 新增 io.emit 12345678socket.on(&#x27;createMessage&#x27;, (message) =&gt; &#123; console.log(&#x27;createMessage&#x27;, message); io.emit(&#x27;newMessage&#x27;, &#123; from: message.from, text: message.text, CreatedAt: new Date().getTime() &#125;);&#125;); git push heroku master 在 server/server.js 新增兩種 emit，如果 connect 就傳送歡迎，如果有新用戶進來，就 broadcast 新用戶加入 12345678910socket.emit(&#x27;newMessage&#x27;, &#123; from: &#x27;Admin&#x27;, text: &#x27;Welcome to the chat app&#x27;&#125;);socket.broadcast.emit(&#x27;newMessage&#x27;, &#123; from: &#x27;Admin&#x27;, text: &#x27;New user joined&#x27;, createdAt: new Date().getTime()&#125;); 訊息產生器和測試 新增 server/utils/message.js 123456789var generateMessage = (from, text) =&gt; &#123; return &#123; from, text, createdAt: new Date().getTime() &#125;;&#125;;module.exports = &#123;generateMessage&#125;; npm install expect mocha --save-dev 修改 package.json 12&quot;test&quot;: &quot;mocha server/**/*.test.js&quot;,&quot;test-watch&quot;: &quot;nodemon --exec &#x27;npm test&#x27;&quot; 新增 server/utils/message.test.js npm test 修改 server/utils/message.test.js 1234567891011121314var expect = require(&#x27;expect&#x27;);var &#123;generateMessage&#125; = require(&#x27;./message&#x27;);describe(&#x27;generateMessage&#x27;, () =&gt; &#123; it(&#x27;should generate correct message object&#x27;, () =&gt; &#123; var from = &#x27;Jen&#x27;; var text = &#x27;Some message&#x27;; var message = generateMessage(from, text); expect(typeof message.createdAt).toBe(&#x27;number&#x27;); expect(message).toMatchObject(&#123;from, text&#125;); &#125;);&#125;); 在 server/server.js 引入 const &#123;generateMessage&#125; = require('./utils/message'); 將 server/server.js 的 object 換成 function 12345socket.emit(&#x27;newMessage&#x27;, generateMessage(&#x27;Admin&#x27;, &#x27;Welcome to the chat app&#x27;));socket.broadcast.emit(&#x27;newMessage&#x27;, generateMessage(&#x27;Admin&#x27;, &#x27;New user joined&#x27;));io.emit(&#x27;newMessage&#x27;, generateMessage(message.from, message.text)); Event Acknowledgements 在 public/js/index.js 新增 emit 123456socket.emit(&#x27;createMessage&#x27;, &#123; from: &#x27;Frank&#x27;, test: &#x27;Hi&#x27;&#125;, function (data) &#123; console.log(&#x27;Got it&#x27;, data);&#125;); 在 server/server.js 新增 callback function 12345socket.on(&#x27;createMessage&#x27;, (message, callback) =&gt; &#123; console.log(&#x27;createMessage&#x27;, message); io.emit(&#x27;newMessage&#x27;, generateMessage(message.from, message.text)); callback(&#x27;This is from the server&#x27;);&#125;); 訊息表單和 jQuery 下載最新版的 jQuery 放到 public/js/libs/jquery.js 在 public/index.html 引入 &lt;script src=&quot;/js/libs/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt; 在 public/index.html 新增 form 1234&lt;form id=&quot;message-form&quot;&gt; &lt;input name=&quot;message&quot; type=&quot;text&quot; placeholder=&quot;Message&quot; /&gt; &lt;button&gt;Send&lt;/button&gt;&lt;/form&gt; 在 public/js/index.js 新增 jQuery 來取得 form 傳出來的訊息 12345678910jQuery(&#x27;#message-form&#x27;).on(&#x27;submit&#x27;, function (e) &#123; e.preventDefault(); socket.emit(&#x27;createMessage&#x27;, &#123; from: &#x27;User&#x27;, text: jQuery(&#x27;[name=message]&#x27;).val() &#125;, function () &#123; &#125;);&#125;); 在 public/index.html 新增 &lt;ol id=&quot;messages&quot;&gt;&lt;/ol&gt; 讓傳出得的訊息 console 在頁面上 在 public/js/index.js 將取得的文字用 jQuery 創建元素並顯示在前端 1234567socket.on(&#x27;newMessage&#x27;, function (message) &#123; console.log(&#x27;newMessage&#x27;, message); var li = jQuery(&#x27;&lt;li&gt;&lt;/li&gt;&#x27;); li.text(`$&#123;message.from&#125;: $&#123;message.text&#125;`); jQuery(&#x27;#messages&#x27;).append(li);&#125;); git push heroku master Geolocation Geolocation 官方文件 在 public/index.html 新增 button &lt;button id=&quot;send-location&quot;&gt;Send Location&lt;/button&gt; 在 public/js/index.js 新增 click 事件，當點擊時傳送出 location 的資訊 123456789101112131415var locationButton = jQuery(&#x27;#send-location&#x27;);locationButton.on(&#x27;click&#x27;, function () &#123; if (!navigator.geolocation) &#123; return alert(&#x27;Geolocation not supported by your browser&#x27;); &#125; navigator.geolocation.getCurrentPosition(function (position) &#123; socket.emit(&#x27;createLocationMessage&#x27;, &#123; latitude: position.coords.latitude, longitude: position.coords.longitude &#125;); &#125;, function () &#123; alert(&#x27;Unable to fetch location&#x27;); &#125;);&#125;); 在 server/server.js 新增 newMessage 把訊息傳到前端頁面 123socket.on(&#x27;createLocationMessage&#x27;, (coords) =&gt; &#123; io.emit(&#x27;newMessage&#x27;, generateMessage(&#x27;Admin&#x27;, `$&#123;coords.latitude&#125;, $&#123;coords.longitude&#125;`));&#125;); 在 server/server.js 新增新的 message，讓 locaiton 可以超連結 123socket.on(&#x27;createLocationMessage&#x27;, (coords) =&gt; &#123; io.emit(&#x27;newLocationMessage&#x27;, generateLocationMessage(&#x27;Admin&#x27;, coords.latitude, coords.longitude));&#125;); 在 server/utils/message.js 新增 generateLocationMessage 並 export 123456789var generateLocationMessage = (from, latitude, longitude) =&gt; &#123; return &#123; from, url: `https://www.google.com/maps?q=$&#123;latitude&#125;,$&#123;longitude&#125;`, createdAt: new Date().getTime() &#125;;&#125;;module.exports = &#123;generateMessage, generateLocationMessage&#125;; 在 public/js/index.js 將取得的 location 傳送到前端頁面 123456789socket.on(&#x27;newLocationMessage&#x27;, function (message) &#123; var li = jQuery(&#x27;&lt;li&gt;&lt;/li&gt;&#x27;); var a = jQuery(&#x27;&lt;a target=&quot;_blank&quot;&gt;My current location&lt;/a&gt;&#x27;); li.text(`$&#123;message.from&#125;: `); a.attr(&#x27;href&#x27;, message.url); li.append(a); jQuery(&#x27;#messages&#x27;).append(li);&#125;); 在 server/utils/message.test.js 測試 generateLocationMessage 可以運作 123456789101112describe(&#x27;generateLocationMessage&#x27;, () =&gt; &#123; it(&#x27;should generate correct location object&#x27;, () =&gt; &#123; var from = &#x27;Deb&#x27;; var latitude = 15; var longitude = 19; var url = &#x27;https://www.google.com/maps?q=15,19&#x27;; var message = generateLocationMessage(from, latitude, longitude); expect(typeof message.createdAt).toBe(&#x27;number&#x27;); expect(message).toMatchObject(&#123;from, url&#125;); &#125;);&#125;); git push heroku master 裝飾聊天頁面 樣式 新增 public/css/styles.css 1button,button:hover&#123;border:none;color:#fff;padding:10px&#125;.chat__messages,.chat__sidebar ul&#123;list-style-type:none&#125;*&#123;box-sizing:border-box;margin:0;padding:0;font-family:HelveticaNeue-Light,&quot;Helvetica Neue Light&quot;,&quot;Helvetica Neue&quot;,Helvetica,Arial,&quot;Lucida Grande&quot;,sans-serif;font-weight:300;font-size:.95rem&#125;li,ul&#123;list-style-position:inside&#125;h3&#123;font-weight:600;text-align:center;font-size:1.5rem&#125;button&#123;background:#265f82;cursor:pointer;transition:background .3s ease&#125;button:hover&#123;background:#1F4C69&#125;button:disabled&#123;cursor:default;background:#698ea5&#125;.centered-form&#123;display:flex;align-items:center;height:100vh;width:100vw;justify-content:center;background:-moz-linear-gradient(125deg,rgba(39,107,130,1) 0,rgba(49,84,129,1) 100%);background:-webkit-gradient(linear,left top,right bottom,color-stop(0,rgba(49,84,129,1)),color-stop(100%,rgba(39,107,130,1)));background:-webkit-linear-gradient(125deg,rgba(39,107,130,1) 0,rgba(49,84,129,1) 100%);background:-o-linear-gradient(125deg,rgba(39,107,130,1) 0,rgba(49,84,129,1) 100%);background:-ms-linear-gradient(125deg,rgba(39,107,130,1) 0,rgba(49,84,129,1) 100%);background:linear-gradient(325deg,rgba(39,107,130,1) 0,rgba(49,84,129,1) 100%)&#125;.centered-form__form&#123;background:rgba(250,250,250,.9);border:1px solid #e1e1e1;border-radius:5px;padding:0 20px;margin:20px;width:230px&#125;.form-field&#123;margin:20px 0&#125;.form-field&gt;*&#123;width:100%&#125;.form-field label&#123;display:block;margin-bottom:7px&#125;.form-field input,.form-field select&#123;border:1px solid #e1e1e1;padding:10px&#125;.chat&#123;display:flex&#125;.chat__sidebar&#123;overflow-y:scroll;width:260px;height:100vh;background:-moz-linear-gradient(125deg,rgba(39,107,130,1) 0,rgba(49,84,129,1) 100%);background:-webkit-gradient(linear,left top,right bottom,color-stop(0,rgba(49,84,129,1)),color-stop(100%,rgba(39,107,130,1)));background:-webkit-linear-gradient(125deg,rgba(39,107,130,1) 0,rgba(49,84,129,1) 100%);background:-o-linear-gradient(125deg,rgba(39,107,130,1) 0,rgba(49,84,129,1) 100%);background:-ms-linear-gradient(125deg,rgba(39,107,130,1) 0,rgba(49,84,129,1) 100%);background:linear-gradient(325deg,rgba(39,107,130,1) 0,rgba(49,84,129,1) 100%)&#125;.chat__footer,.chat__sidebar li&#123;background:#e6eaee;padding:10px&#125;.chat__sidebar h3&#123;color:#e6eaee;margin:10px 20px;text-align:left&#125;.chat__sidebar li&#123;border:1px solid #e1e1e1;border-radius:5px;margin:10px&#125;.chat__main&#123;display:flex;flex-direction:column;height:100vh;width:100%&#125;.chat__messages&#123;flex-grow:1;overflow-y:scroll;-webkit-overflow-scrolling:touch;padding:10px&#125;.chat__footer&#123;display:flex;flex-shrink:0&#125;.chat__footer form&#123;flex-grow:1;display:flex&#125;.chat__footer form *&#123;margin-right:10px&#125;.chat__footer input&#123;border:none;padding:10px;flex-grow:1&#125;.message&#123;padding:10px&#125;.message__title&#123;display:flex;margin-bottom:5px&#125;.message__title h4&#123;font-weight:600;margin-right:10px&#125;.message__title span&#123;color:#999&#125;@media (max-width:600px)&#123;*&#123;font-size:1rem&#125;.chat__sidebar&#123;display:none&#125;.chat__footer&#123;flex-direction:column&#125;.chat__footer form&#123;margin-bottom:10px&#125;.chat__footer button&#123;margin-right:0&#125;&#125; 在 public/index.html 引入 &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/styles.css&quot;&gt; 在 public/index.html 加入樣式 1234567891011121314151617181920212223&lt;body class=&quot;body&quot;&gt; &lt;div class=&quot;chat__sidebar&quot;&gt; &lt;h3&gt;People&lt;/h3&gt; &lt;div id=&quot;users&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;chat__main&quot;&gt; &lt;ol id=&quot;messages&quot; class=&quot;chat__messages&quot;&gt;&lt;/ol&gt; &lt;div class=&quot;chat__footer&quot;&gt; &lt;form id=&quot;message-form&quot;&gt; &lt;input name=&quot;message&quot; type=&quot;text&quot; placeholder=&quot;Message&quot; autofocus autocomplete=&quot;off&quot; /&gt; &lt;button&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;button id=&quot;send-location&quot;&gt;Send Location&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/libs/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/js/index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 在 server/server.js 把 callback 改為空值 12345socket.on(&#x27;createMessage&#x27;, (message, callback) =&gt; &#123; console.log(&#x27;createMessage&#x27;, message); io.emit(&#x27;newMessage&#x27;, generateMessage(message.from, message.text)); callback(&#x27;&#x27;);&#125;); 修改 public/js/index.js 用 jQuery 取得值，然後送到 server 123456789101112jQuery(&#x27;#message-form&#x27;).on(&#x27;submit&#x27;, function (e) &#123; e.preventDefault(); var messageTextbox = jQuery(&#x27;[name=message]&#x27;); socket.emit(&#x27;createMessage&#x27;, &#123; from: &#x27;User&#x27;, text: messageTextbox.val() &#125;, function () &#123; messageTextbox.val(&#x27;&#x27;) &#125;);&#125;); 修改 public/js/index.js 當送出的時候把按鈕變成無法點擊，完成之後就移除無法點擊的效果 123456789101112131415161718locationButton.on(&#x27;click&#x27;, function () &#123; if (!navigator.geolocation) &#123; return alert(&#x27;Geolocation not supported by your browser&#x27;); &#125; locationButton.attr(&#x27;disabled&#x27;, &#x27;disabled&#x27;).text(&#x27;Sending location...&#x27;); navigator.geolocation.getCurrentPosition(function (position) &#123; locationButton.removeAttr(&#x27;disabled&#x27;).text(&#x27;Send location&#x27;); socket.emit(&#x27;createLocationMessage&#x27;, &#123; latitude: position.coords.latitude, longitude: position.coords.longitude &#125;); &#125;, function () &#123; locationButton.removeAttr(&#x27;disabled&#x27;).text(&#x27;Send location&#x27;); alert(&#x27;Unable to fetch location&#x27;); &#125;);&#125;); Timestamps 和使用 Moment 格式化 npm i moment --save Momentjs 官方網站 新增 playground/time.js 測試 moment.js 123456var moment = require(&#x27;moment&#x27;);var date = moment();date.add(1, &#x27;years&#x27;).subtract(9, &#x27;months&#x27;);console.log(date.format(&#x27;MMM Do, YYYY&#x27;));console.log(date.format(&#x27;h:mm a&#x27;)); Printing Message Timestamps 修改 server/utils/message.js，引入 moment，然後將 createdAt 改為 moment().valueOf(); 123var moment = require(&#x27;moment&#x27;);createdAt: moment().valueOf() npm test，確定測試可以通過 從 node_modules/moment/moment.js 複製檔案到 public/js/libs/moment.js 在 public/index.html 引入 &lt;script src=&quot;/js/libs/moment.js&quot;&gt;&lt;/script&gt; 讓訊息送出時，同時顯示時間 123var formattedTime = moment(message.createdAt).format(&#x27;h:mm a&#x27;);li.text(`$&#123;message.from&#125; $&#123;formattedTime&#125;: $&#123;message.text&#125;`);","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://vincent.fishboneapps.com/tags/Nodejs/"}]},{"title":"Nodejs 快速學習自我挑戰 Day10","slug":"Nodejs-快速學習自我挑戰-Day10","date":"2017-10-07T16:37:59.000Z","updated":"2020-06-22T17:15:24.880Z","comments":true,"path":"2017/10/07/Nodejs-快速學習自我挑戰-Day10/","link":"","permalink":"https://vincent.fishboneapps.com/2017/10/07/Nodejs-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day10/","excerpt":"","text":"安全和認證 讓 Todo Routes Private 修改 server/models/todo.js 新增 _creator 1234_creator: &#123; type: mongoose.Schema.Types.ObjectId, required: true,&#125; 修改 server/tests/seed/seed.js 新增 _creator 1234567891011const todos = [&#123; _id: new ObjectID(), text: &#x27;First test todo&#x27;, _creator: userOneId&#125;, &#123; _id: new ObjectID(), text: &#x27;Second test todo&#x27;, completed: true, completedAt: 333, _creator: userTwoId&#125;]; 修改 server/server.js，加入 authenticate，然後新增 _creator 12345678910111213141516171819202122app.post(&#x27;/todos&#x27;, authenticate, (req, res) =&gt; &#123; var todo = new Todo(&#123; text: req.body.text, _creator: req.user._id &#125;); todo.save().then((doc) =&gt; &#123; res.send(doc); &#125;, (e) =&gt; &#123; res.status(400).send(e); &#125;);&#125;);app.get(&#x27;/todos&#x27;, authenticate, (req, res) =&gt; &#123; Todo.find(&#123; _creator: req.user._id &#125;).then((todos) =&gt; &#123; res.send(&#123;todos&#125;); &#125;, (e) =&gt; &#123; res.status(400).send(e); &#125;);&#125;); 在 server/tests/server.test.js 的 POST 部分設置 x-auth .set('x-auth', users[0].tokens[0].token) 在 server/tests/server.test.js 的 GET 部分設置 x-auth，並在回送時設定長度為 1，因為設置了 creator，只會回傳一個 todo 123456789101112describe(&#x27;GET /todos&#x27;, () =&gt; &#123; it(&#x27;should get all todos&#x27;, (done) =&gt; &#123; request(app) .get(&#x27;/todos&#x27;) .set(&#x27;x-auth&#x27;, users[0].tokens[0].token) .expect(200) .expect((res) =&gt; &#123; expect(res.body.todos.length).toBe(1); &#125;) .end(done); &#125;);&#125;); 在 server/server.js 修改 POST /users/login 的 token 為 1 1234expect(user.tokens[1]).toInclude(&#123; access: &#x27;auth&#x27;, token: res.headers[&#x27;x-auth&#x27;]&#125;); 在 server/server.js 修改 GET /todos/:id’，新增 authenticate middleware，且修改 findById 成 findOne 123456app.get(&#x27;/todos/:id&#x27;, authenticate, (req, res) =&gt; &#123;Todo.findOne(&#123; _id: id, _creator: req.user._id&#125; 在 server/tests/server.test.js 修改 GET /todos 和 GET /todo/:id 都加上 .set('x-auth', users[0].tokens[0].token) 在 server/server.js 修改 DELETE /todos/:id’，新增 authenticate middleware，且修改 findByIdAndRemove 成 findOneAndRemove 123456app.delete(&#x27;/todos/:id&#x27;, authenticate, (req, res) =&gt; &#123;Todo.findOneAndRemove(&#123; _id: id, _creator: req.user._id&#125; 在 server/tests/server.test.js 的 describe(‘GET /todo/:id’) 加上一個測試，如果被其他使用者建立的 todo 則 404 1234567it(&#x27;should not return todo doc created by other user&#x27;, (done) =&gt; &#123; request(app) .get(`/todos/$&#123;todos[1]._id.toHexString()&#125;`) .set(&#x27;x-auth&#x27;, users[0].tokens[0].token) .expect(404) .end(done);&#125;); 在 server/tests/server.test.js 的 DELETE /todos/:id 的每個測試都加上 .set('x-auth', users[1].tokens[0].token) 在新增一個測試，如果 todo 對不上 user 就回傳 404 123456789101112131415161718it(&#x27;should not remove a todo&#x27;, (done) =&gt; &#123; var hexId = todos[0]._id.toHexString(); request(app) .delete(`/todos/$&#123;hexId&#125;`) .set(&#x27;x-auth&#x27;, users[1].tokens[0].token) .expect(404) .end((err, res) =&gt; &#123; if (err) &#123; return done(err); &#125; Todo.findById(hexId).then((todo) =&gt; &#123; expect(todo).toExist(); done(); &#125;).catch((e) =&gt; done(e)); &#125;);&#125;); 在 server/server.js 修改 PATCH /todos/:id’，新增 authenticate middleware，且修改 findByIdAndUpdate 成 findOneAndUpdate 123app.patch(&#x27;/todos/:id&#x27;, authenticate, (req, res) =&gt; &#123;Todo.findOneAndUpdate(&#123;_id: id, _creator: req.user._id&#125;, &#123;$set: body&#125;, &#123;new: true&#125;) 改善 App 組態設定 在 server/config/config.js 修改成用 json 的方式讀取環境變數 12345678910var env = process.env.NODE_ENV || &#x27;development&#x27;;if (env === &#x27;development&#x27; || env === &#x27;test&#x27;) &#123; var config = require(&#x27;./config.json&#x27;); var envConfig = config[env]; Object.keys(envConfig).forEach((key) =&gt; &#123; process.env[key] = envConfig[key]; &#125;);&#125; 新增 server/config/config.json，把組態檔放進去 123456789101112&#123; &quot;test&quot;: &#123; &quot;PORT&quot;: 3000, &quot;MONGODB_URI&quot;: &quot;mongodb://localhost:27017/TodoAppTest&quot;, &quot;JWT_SECRET&quot;: &quot;fadskljfalkfwerlkmvvsfgreio3&quot; &#125;, &quot;development&quot;: &#123; &quot;PORT&quot;: 3000, &quot;MONGODB_URI&quot;: &quot;mongodb://localhost:27017/TodoApp&quot;, &quot;JWT_SECRET&quot;: &quot;fadskljfa3kfwe345mvvsfgreio3&quot; &#125;&#125; 在 server/tests/seed/seed.js 的 jwt.sign 值都改為 process.env.JWT_SECRET 在 server/tests/seed/user.js 的 jwt.sign 和 jwt.verify 值都改為 process.env.JWT_SECRET 在 heroku 設定 JWT_SECRET heroku config:set JWT_SECRET=fadskljfa3kfwe345mvvs2g3eio3 部署到 Heroku 取得 MONGODB_URI heroku config:get MONGODB_URI 取得值 - mongodb://帳號:密碼@連線網址:39994/資料庫名稱 進入 Robo 3T 進行新的連線並測試 git push master heroku 進階的 Postman 在 POST /users 和 /users/login 的 Test 選項寫入下面兩行，在送出時就會設定 x-auth 為全域的變數 12var token = postman.getResponseHeader(&#x27;x-auth&#x27;);postman.setEnvironmentVariable(&#x27;x-auth&#x27;, token); 在其他的 header 加上 {{x-auth}} 取得變數 在 POST /todos 的 Test 選項寫入下面兩行，在送出時就會設定 todoId 為全域的變數 12var body = JSON.parse(responseBody);postman.setEnvironmentVariable(&#x27;todoId&#x27;, body._id); 在其他有 id 的 url 上面加上 {{todoId}} 升級 expect npm install expect@21.2.1 --save-dev 把 server/tests/server.test.js 的 toNotExist 改成 toBeFalsy，把 toExist 改成 toBeTruthy 在 PATCH /todos/:id 的部份把 expect(res.body.todo.completedAt).toBeA('number'); 取代為 expect(typeof res.body.todo.completedAt).toBe('number'); 將 .toNotBe 改為 .not.toBe 將 toInclude 改為 toMatchObject，toObject 會拋回原始的 user 資料 expect(user.toObject().tokens[1]).toMatchObject(&#123; 使用 Socket.io 的即時 Web Apps 創建一個專案 mkdir node-chat-app cd node-chat-app npm init git init 新增 server/server.js 123456789101112const path = require(&#x27;path&#x27;);const express = require(&#x27;express&#x27;);const publicPath = path.join(__dirname, &#x27;../public&#x27;);const port = process.env.PORT || 3000;var app = express();app.use(express.static(publicPath));app.listen(port, () =&gt; &#123; console.log(`Server is up on $&#123;port&#125;`);&#125;); 新增 public/index.html 12345678910111213&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Welcome to the chat app&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; npm i express --save 推到 Github 1234git add .git commit -m &#x27;Init commit&#x27;git remote add origin https://github.com/TingSyuanWang/node-chat-app.gitgit push -u origin master 發佈到 heroku 12heroku creategit push heroku master 增加 Socket.io 到 App npm i socket.io --save 新增 http 和 socketIO 到 server/server.js， 1234567891011121314151617const http = require(&#x27;http&#x27;);const socketIO = require(&#x27;socket.io&#x27;);var server = http.createServer(app);var io = socketIO(server);io.on(&#x27;connection&#x27;, (socket) =&gt; &#123; console.log(&#x27;New user connected&#x27;); socket.on(&#x27;disconnect&#x27;, () =&gt; &#123; console.log(&#x27;User was disconnected&#x27;); &#125;);&#125;);server.listen(port, () =&gt; &#123; console.log(`Server is up on $&#123;port&#125;`);&#125;); 新增 socket.io 到 index.html 123456789101112&lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var socket = io(); socket.on(&#x27;connect&#x27;, () =&gt; &#123; console.log(&#x27;Connected to server&#x27;); &#125;); socket.on(&#x27;disconnect&#x27;, () =&gt; &#123; console.log(&#x27;Disconnected from server&#x27;); &#125;);&lt;/script&gt; Events 的 Emitting 和 Listening 新增 public/js/index.js 123456789101112131415161718var socket = io();socket.on(&#x27;connect&#x27;, function () &#123; console.log(&#x27;Connected to server&#x27;); socket.emit(&#x27;createEmail&#x27;, &#123; to: &#x27;jen@example.com&#x27;, text: &#x27;Hey. This is Andrew.&#x27; &#125;);&#125;);socket.on(&#x27;disconnect&#x27;, function () &#123; console.log(&#x27;Disconnected from server&#x27;);&#125;);socket.on(&#x27;newEmail&#x27;, function (email) &#123; console.log(&#x27;New email&#x27;, email);&#125;); 在 public/index.html 引入 script &lt;script src=&quot;js/index.js&quot;&gt;&lt;/script&gt; 在 server/server.js 在 connect 的時候，傳出 newEmail，然後等待接收 createEmail 123456789socket.emit(&#x27;newEmail&#x27;, &#123; from: &#x27;mike@example.com&#x27;, text: &#x27;Hey. What is going on&#x27;, createdAt: 123&#125;);socket.on(&#x27;createEmail&#x27;, (newEmail) =&gt; &#123; console.log(&#x27;createEmail&#x27;, newEmail);&#125;); 在 public/js/index.js 新增 emit 1234socket.emit(&#x27;createMessage&#x27;, &#123; from: &#x27;Andrew&#x27;, text: &#x27;Yup, that works for me.&#x27;&#125;); 在 server/server.js 接收 client 的 emit 123socket.on(&#x27;createMessage&#x27;, (message) =&gt; &#123; console.log(&#x27;createMessage&#x27;, message);&#125;); 在 server/server.js 新增 emit 12345socket.emit(&#x27;newMessage&#x27;, &#123; from: &#x27;John&#x27;, text: &#x27;See you then&#x27;, createdAt: 123123&#125;); 在 public/js/index.js 把接收的 Message console 出來 123socket.on(&#x27;newMessage&#x27;, function (message) &#123; console.log(&#x27;newMessage&#x27;, message);&#125;);","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://vincent.fishboneapps.com/tags/Nodejs/"}]},{"title":"Nodejs 快速學習自我挑戰 Day9","slug":"Nodejs-快速學習自我挑戰-Day9","date":"2017-09-27T22:14:39.000Z","updated":"2020-06-22T17:15:24.880Z","comments":true,"path":"2017/09/27/Nodejs-快速學習自我挑戰-Day9/","link":"","permalink":"https://vincent.fishboneapps.com/2017/09/27/Nodejs-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day9/","excerpt":"","text":"安全和認證 Private Routes 和 Auth Middleware 在 server/server.js 新增 get 1234567891011app.get(&#x27;/users/me&#x27;, (req, res) =&gt; &#123; var token = req.header(&#x27;x-auth&#x27;); User.findByToken(token).then((user) =&gt; &#123; if (!user) &#123; &#125; res.send(user); &#125;);&#125;); 在 server/models/users.js 新增 findByToken 12345678910111213141516UserSchema.statics.findByToken = function (token) &#123; var User = this; var decoded; try &#123; decoded = jwt.verify(token, &#x27;abc123&#x27;) &#125; catch (e) &#123; &#125; return User.findOne(&#123; &#x27;_id&#x27;: decoded._id, &#x27;tokens.token&#x27;: token, &#x27;tokens.access&#x27;: &#x27;auth&#x27; &#125;);&#125;; 使用 Postman 新增 user 並取得 x-auth，然後新增 GET /users/me，並在 Header 插入剛剛取得的 x-auth，就會順利取得 _id 和 email 將 在 server/models/users.js 的 error 部分處理好 12345try &#123; decoded = jwt.verify(token, &#x27;abc123&#x27;)&#125; catch (e) &#123; return Promise.reject();&#125; 將 server/server.js 的 error 部分處理好 123456789User.findByToken(token).then((user) =&gt; &#123; if (!user) &#123; return Promise.reject(); &#125; res.send(user);&#125;).catch((e) =&gt; &#123; res.status(401).send();&#125;); 新增 server/middleware/authenticate.js 12345678910111213141516171819var &#123;User&#125; = require(&#x27;./../models/user&#x27;);var authenticate = (req, res, next) =&gt; &#123; var token = req.header(&#x27;x-auth&#x27;); User.findByToken(token).then((user) =&gt; &#123; if (!user) &#123; return Promise.reject(); &#125; req.user = user; req.token = token; next(); &#125;).catch((e) =&gt; &#123; res.status(401).send(); &#125;);&#125;;module.exports = &#123;authenticate&#125;; 在 server/server.js 引入 authenticate var &#123;authenticate&#125; = require('./middleware/authenticate'); 在 /users/me 的部分使用 authenticate 123app.get(&#x27;/users/me&#x27;, authenticate, (req, res) =&gt; &#123; res.send(req.user);&#125;); Hashing Passwords 安裝 bcryptjs npm i bcryptjs@2.3.0 --save bcrypt 文件 在 playground/hashing.js 新增 bcrypt function 1234567891011const &#123;SHA256&#125; = require(&#x27;crypto-js&#x27;);const jwt = require(&#x27;jsonwebtoken&#x27;);const bcrypt = require(&#x27;bcryptjs&#x27;);var password = &#x27;123abc!&#x27;;bcrypt.genSalt(10, (err, salt) =&gt; &#123; bcrypt.hash(password, salt, (err, hash) =&gt; &#123; console.log(hash); &#125;);&#125;); node playground/hashing.js 將產出的 hashing 和本來的 password 比較，如果 true 則等於相等 12345var hashedPassword = &#x27;$2a$10$.fiP4qt.xBk3w4CIZB1jN.x.WHFrexbi4Dk3Y/er/0MJASi8S1u1y&#x27;;bcrypt.compare(password, hashedPassword, (err, res) =&gt; &#123; console.log(res);&#125;); 在 server/models/user.js 新增 UserSchema.pre function，如果 password 修改則要重新 hash，如果沒有修改則不 hash，避免重複 hash 的情況發生 1234567891011121314UserSchema.pre(&#x27;save&#x27;, function (next) &#123; var user = this; if (user.isModified(&#x27;password&#x27;)) &#123; bcrypt.genSalt(10, (err, salt) =&gt; &#123; bcrypt.hash(user.password, salt, (err, hash) =&gt; &#123; user.password = hash; next(); &#125;); &#125;); &#125; else &#123; next(); &#125;&#125;); 與 Users 傳送測試資料庫 新增 server/tests/seed/seed.js，把 todos 物件從 server.test.js 移出來，然後新增 populateTodos 123456789101112131415161718192021const &#123;ObjectID&#125; = require(&#x27;mongodb&#x27;);const &#123;Todo&#125; = require(&#x27;./../../models/todo&#x27;);const todos = [&#123; _id: new ObjectID(), text: &#x27;First test todo&#x27;&#125;, &#123; _id: new ObjectID(), text: &#x27;Second test todo&#x27;, completed: true, completedAt: 333&#125;];const populateTodos = (done) =&gt; &#123; Todo.remove(&#123;&#125;).then(() =&gt; &#123; return Todo.insertMany(todos); &#125;).then(() =&gt; done());&#125;;module.exports = &#123;todos, populateTodos&#125;; 在 server/tests/server.test.js 引入 seed 123const &#123;todos, populateTodos&#125; = require(&#x27;./seed/seed&#x27;);beforeEach(populateTodos); 在 server/tests/seed/seed.js 新增 Users 物件 12345678910111213141516171819const jwt = require(&#x27;jsonwebtoken&#x27;);const &#123;User&#125; = require(&#x27;./../../models/user&#x27;);const userOneId = new ObjectID();const userTwoId = new ObjectID();const users = [&#123; _id: userOneId, email: &#x27;andrew@example.com&#x27;, password: &#x27;userOnePass&#x27;, tokens: [&#123; access: &#x27;auth&#x27;, token: jwt.sign(&#123;_id: userOneId, access: &#x27;auth&#x27;&#125;, &#x27;abc123&#x27;).toString() &#125;]&#125;, &#123; _id:userTwoId, email: &#x27;jen@example.com&#x27;, password: &#x27;userTwoPass&#x27;&#125;]; 新增 populateUsers 並匯出 12345678910const populateUsers = (done) =&gt; &#123; User.remove(&#123;&#125;).then(() =&gt; &#123; var userOne = new User(users[0]).save(); var userTwo = new User(users[1]).save(); return Promise.all([userOne, userTwo]) &#125;).then(() =&gt; done());&#125;;module.exports = &#123;todos, populateTodos, users, populateUsers&#125;; 在 在 server/tests/server.test.js 引入 populateUsers 123const &#123;todos, populateTodos, users, populateUsers&#125; = require(&#x27;./seed/seed&#x27;);beforeEach(populateUsers); 測試 POST /users 和 GET /users/me 在 server/tests/server.test.js 新增 1234567891011121314151617181920212223describe(&#x27;GET /users/me&#x27;, () =&gt; &#123; it(&#x27;should return user if authenticated&#x27;, (done) =&gt; &#123; request(app) .get(&#x27;/users/me&#x27;) .set(&#x27;x-auth&#x27;, users[0].tokens[0].token) .expect(200) .expect((res) =&gt; &#123; expect(res.body._id).toBe(users[0]._id.toHexString()); expect(res.body.email).toBe(users[0].email); &#125;) .end(done); &#125;); it(&#x27;should return 401 if not authenticated&#x27;, (done) =&gt; &#123; request(app) .get(&#x27;/users/me&#x27;) .expect(401) .expect((res) =&gt; &#123; expect(res.body).toEqual(&#123;&#125;); &#125;) .end(done); &#125;);&#125;); 新增 POST /users test 123456789101112131415161718192021222324252627describe(&#x27;POST /users&#x27;, () =&gt; &#123; it(&#x27;should create a user&#x27;, (done) =&gt; &#123; var email = &#x27;example@example.com&#x27;; var password = &#x27;123mnb!&#x27;; request(app) .post(&#x27;/users&#x27;) .send(&#123;email, password&#125;) .expect(200) .expect((res) =&gt; &#123; expect(res.header[&#x27;x-auth&#x27;]).toExist(); expect(res.body._id).toExist(); expect(res.body.email).toBe(email); &#125;) .end((err) =&gt; &#123; if (err) &#123; return done(err); &#125; User.findOne(&#123;email&#125;).then((user) =&gt; &#123; expect(user).toExist(); expect(user.password).toNotBe(password); done(); &#125;) &#125;); &#125;);&#125;); 以上 test 會失敗，因為找不到 User，所以在最上面引入 User const &#123;User&#125; = require('./../models/user'); 新增兩種狀況，第一種是 email 和 password 不符合格式，第二種是 email 已經被使用了 123456789101112131415161718192021it(&#x27;should return validation errors if request invalid&#x27;, (done) =&gt; &#123; request(app) .post(&#x27;/users&#x27;) .send(&#123; email: &#x27;and&#x27;, password: &#x27;123&#x27; &#125;) .expect(400) .end(done)&#125;);it(&#x27;should not create user if email in use&#x27;, (done) =&gt; &#123; request(app) .post(&#x27;/users&#x27;) .send(&#123; email: users[0].email, password: &#x27;Password123!&#x27; &#125;) .expect(400) .end(done)&#125;); 登入 - POST /users/login 在 servers/models/user.js 新增 findByCredentials 的 Schema 1234567891011121314151617181920UserSchema.statics.findByCredentials = function (email, password) &#123; var User = this; return User.findOne(&#123;email&#125;).then((user) =&gt; &#123; if (!user) &#123; return Promise.reject(); &#125; return new Promise((resolve, reject) =&gt; &#123; // Use bcrypt.compare to compare password and user.password bcrypt.compare(password, user.password, (err, res) =&gt; &#123; if (res) &#123; resolve(user); &#125; else &#123; reject(); &#125; &#125;) &#125;); &#125;);&#125;; 在 server/server.js 新增 /users/login 123456789101112app.post(&#x27;/users/login&#x27;, (req, res) =&gt; &#123; var body = _.pick(req.body, [&#x27;email&#x27;, &#x27;password&#x27;]); User.findByCredentials(body.email, body.password).then((user) =&gt; &#123; return user.generateAuthToken().then((token) =&gt; &#123; res.header(&#x27;x-auth&#x27;, token).send(user); &#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;); 測試 POST /users/login 新增兩道測試，測試可以登入和不能登入的狀態 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950describe(&#x27;POST /users/login&#x27;, () =&gt; &#123; it(&#x27;should login user and return auth token&#x27;, (done) =&gt; &#123; request(app) .post(&#x27;/users/login&#x27;) .send(&#123; email: users[1].email, password: users[1].password &#125;) .expect(200) .expect((res) =&gt; &#123; expect(res.headers[&#x27;x-auth&#x27;]).toExist(); &#125;) .end((err, res) =&gt; &#123; if (err) &#123; return done(err); &#125; User.findById(users[1]._id).then((user) =&gt; &#123; expect(user.tokens[0]).toInclude(&#123; access: &#x27;auth&#x27;, token: res.headers[&#x27;x-auth&#x27;] &#125;); done(); &#125;).catch((e) =&gt; done(e)); &#125;); &#125;); it(&#x27;should reject invalid login&#x27;, (done) =&gt; &#123; request(app) .post(&#x27;/users/login&#x27;) .send(&#123; email: users[1].email, password: users[1].password + &#x27;1&#x27; &#125;) .expect(400) .expect((res) =&gt; &#123; expect(res.headers[&#x27;x-auth&#x27;]).toNotExist(); &#125;) .end((err, res) =&gt; &#123; if (err) &#123; return done(err); &#125; User.findById(users[1]._id).then((user) =&gt; &#123; expect(user.tokens.length).toBe(0); done(); &#125;).catch((e) =&gt; done(e)); &#125;); &#125;);&#125;); 登出 DELETE /users/me/token 在 server/server.js 新增 delete function 1234567app.delete(&#x27;/users/me/token&#x27;, authenticate, (req, res) =&gt; &#123; req.user.removeToken(req.token).then(() =&gt; &#123; res.status(200).send(); &#125;, () =&gt; &#123; res.status(400).send(); &#125;);&#125;); 在 server/models/user.js 新增 removeToken function 123456789UserSchema.methods.removeToken = function (token) &#123; var user = this; return user.update(&#123; $pull: &#123; tokens: &#123;token&#125; &#125; &#125;)&#125;; 測試 DELETE /users/me/token 在 server/tests/server.test.js 新增測試 123456789101112131415161718describe(&#x27;DELETE /users/me/token&#x27;, () =&gt; &#123; it(&#x27;should remove auth token on logout&#x27;, (done) =&gt; &#123; request(app) .delete(&#x27;/users/me/token&#x27;) .set(&#x27;x-auth&#x27;, users[0].tokens[0].token) .expect(200) .end((err, res) =&gt; &#123; if (err) &#123; return done(err); &#125; User.findById(users[0]._id).then((user) =&gt; &#123; expect(user.tokens.length).toBe(0); done(); &#125;).catch((e) =&gt; done(e)); &#125;) &#125;);&#125;);","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://vincent.fishboneapps.com/tags/Nodejs/"}]},{"title":"Nodejs 快速學習自我挑戰 Day8","slug":"Nodejs-快速學習自我挑戰-Day8","date":"2017-09-18T17:30:30.000Z","updated":"2020-06-22T17:15:24.880Z","comments":true,"path":"2017/09/18/Nodejs-快速學習自我挑戰-Day8/","link":"","permalink":"https://vincent.fishboneapps.com/2017/09/18/Nodejs-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day8/","excerpt":"","text":"MongoDB，Mongoose 和 REST APIs (Todo API) 部署 API 到 Heroku 安裝 Heroku CLI brew install heroku/brew/heroku 在 server/server.js 新增 port 的設定 const port = process.env.PORT || 3000; 修改 app.listen 123app.listen(port, () =&gt; &#123; console.log(`Started up at port $&#123;port&#125;`);&#125;); 在 package.json 新增 start 指令，並新增 engine 12345678&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node server/server.js&quot;, &quot;test&quot;: &quot;mocha server/**/*.test.js&quot;, &quot;test-watch&quot;: &quot;nodemon --exec &#x27;npm test&#x27;&quot; &#125;, &quot;engines&quot;: &#123; &quot;node&quot;: &quot;6.11.3&quot; &#125;, heroku create heroku addons:create mongolab:sandbox 可以取得 MongoDB URI heroku config 修改 server/db/mongoose.js mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/TodoApp'); git push heroku master 如果應用發生問題，可以用以下指令確認 heroku logs Postman 環境 進去 Postman，右上角有 Management Environment，點進去之後，新增 Todo App Local 和 Todo App Heroku，分別設定 url 為 localhost:3000 和 Heroku 的網址 然後將網址都改為 的變數代替 刪除 Resource - DELETE /todos/:id 新增 playground/mongoose-remove.js 1234567891011121314151617181920const &#123;ObjectID&#125; = require(&#x27;mongodb&#x27;);const &#123;mongoose&#125; = require(&#x27;./../server/db/mongoose&#x27;);const &#123;Todo&#125; = require(&#x27;./../server/models/todo&#x27;);const &#123;User&#125; = require(&#x27;./../server/models/user&#x27;);// 移除全部Todo.remove(&#123;&#125;).then((result) =&gt; &#123; console.log(result);&#125;);// Todo.findOneAndRemoveTodo.findOneAndRemove(&#123;_id: &#x27;59c0c37efd4847c2497a12a7&#x27;&#125;).then((todo) =&gt; &#123; console.log(todo);&#125;);// Todo.findByIdAndRemoveTodo.findByIdAndRemove(&#x27;59c0c37efd4847c2497a12a7&#x27;).then((todo) =&gt; &#123; console.log(todo);&#125;); 在 server/server.js 新增 delete route 1234567891011121314151617app.delete(&#x27;/todos/:id&#x27;, (req, res) =&gt; &#123; var id = req.params.id; if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; Todo.findByIdAndRemove(id).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;); 使用 Postman 測試，並儲存 測試 DELETE /todos/:id 新增第一個測試，最後的部分是驗證資料是否被刪除 12345678910111213141516171819202122describe(&#x27;DELETE /todos/:id&#x27;, () =&gt; &#123; it(&#x27;should remove a todo&#x27;, (done) =&gt; &#123; var hexId = todos[1]._id.toHexString(); request(app) .delete(`/todos/$&#123;hexId&#125;`) .expect(200) .expect((res) =&gt; &#123; expect(res.body.todo._id).toBe(hexId) &#125;) .end((err, res) =&gt; &#123; if (err) &#123; return done(err); &#125; Todo.findById(hexId).then((todo) =&gt; &#123; expect(todo).toNotExist(); done(); &#125;).catch((e) =&gt; done(e)); &#125;); &#125;);&#125;); 基本上做法跟 GET 差不多，複製 code，然後把 .get 改成 .delete 即可 123456789101112131415it(&#x27;should return 404 if todo not found&#x27;, (done) =&gt; &#123; var hexId = new ObjectID().toHexString(); request(app) .delete(`/todos/$&#123;hexId&#125;`) .expect(404) .end(done);&#125;);it(&#x27;should return 404 if object id is invalid&#x27;, (done) =&gt; &#123; request(app) .delete(&#x27;/todos/123abc&#x27;) .expect(404) .end(done);&#125;); 更新 Resource - PATCH /todos/:id npm i --save lodash@4.15.0 修改 server/server.js，引入 lodash，將其它引入的資料用 const。 1234const _ = require(&#x27;lodash&#x27;);const express = require(&#x27;express&#x27;);const bodyParser = require(&#x27;body-parser&#x27;);const &#123;ObjectID&#125; = require(&#x27;mongodb&#x27;); 新增 patch，如果 completed = true，寫入日期，如果沒有，把 completed 設為 false 且 completedAt 設為 null 12345678910111213141516171819202122232425app.patch(&#x27;/todos/:id&#x27;, (req, res) =&gt; &#123; var id = req.params.id; var body = _.pick(req.body, [&#x27;text&#x27;, &#x27;completed&#x27;]); if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; if (_.isBoolean(body.completed) &amp;&amp; body.completed ) &#123; body.completedAt = new Date().getTime(); &#125; else &#123; body.completed = false; body.completedAt = null; &#125; Todo.findByIdAndUpdate(id, &#123;$set: body&#125;, &#123;new: true&#125;).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;); 用 Postman 測試，傳入 JSON，本地端測試完，再用 Heroku 1234&#123; &quot;completed&quot;: true, &quot;text&quot;: &quot;update from postman&quot;&#125; 測試 PATCH /todos/:id PATCH test 的設計邏輯 12345678910111213141516describe(&#x27;PATCH /todos/:id&#x27;, () =&gt; &#123; it(&#x27;should update the todo&#x27;, (done) =&gt; &#123; // grab id of first item // update text, set completed true // 200 // text is changed, completed is true, completedAt is a number .toBeA &#125;); it(&#x27;should clear completedAt when todo is not completed&#x27;, (done) =&gt; &#123; // grab id of second todo item // update text, set completed to false // 200 // text is changed, completed is false, completedAt is null .toNotExist &#125;);&#125;); 測試修改 completed 為 true 123456789101112131415161718it(&#x27;should update the todo&#x27;, (done) =&gt; &#123; var hexId = todos[0]._id.toHexString(); var text = &#x27;This should be the new text&#x27;; request(app) .patch(`/todos/$&#123;hexId&#125;`) .send(&#123; completed: true, text &#125;) .expect(200) .expect((res) =&gt; &#123; expect(res.body.todo.text).toBe(text); expect(res.body.todo.completed).toBe(true); expect(res.body.todo.completedAt).toBeA(&#x27;number&#x27;); &#125;) .end(done);&#125;); 測試修改 completed 為 false 123456789101112131415161718it(&#x27;should clear completedAt when todo is not completed&#x27;, (done) =&gt; &#123; var hexId = todos[1]._id.toHexString(); var text = &#x27;This should be the new text!!&#x27;; request(app) .patch(`/todos/$&#123;hexId&#125;`) .send(&#123; completed: false, text &#125;) .expect(200) .expect((res) =&gt; &#123; expect(res.body.todo.text).toBe(text); expect(res.body.todo.completed).toBe(false); expect(res.body.todo.completedAt).toNotExist(); &#125;) .end(done);&#125;); 創建測試 Database 修改 package.json 12345&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node server/server.js&quot;, &quot;test&quot;: &quot;export NODE_ENV=test || \\&quot;SET NODE_ENV=test\\&quot; &amp;&amp; mocha server/**/*.test.js&quot;, &quot;test-watch&quot;: &quot;nodemon --exec &#x27;npm test&#x27;&quot;&#125;, 修改 server/db/mongoose.js mongoose.connect(process.env.MONGODB_URI); 新增 server/config/config.js 123456789var env = process.env.NODE_ENV || &#x27;development&#x27;;if (env === &#x27;development&#x27;) &#123; process.env.PORT = 3000; process.env.MONGODB_URI = &#x27;mongodb://localhost:27017/TodoApp&#x27;;&#125; else if (env === &#x27;test&#x27;) &#123; process.env.PORT = 3000; process.env.MONGODB_URI = &#x27;mongodb://localhost:27017/TodoAppTest&#x27;;&#125; 在 server/server.js 引入 config require('./config/config'); node server/server.js，會進入 development 環境 npm test，會進入 test 環境，會再新建一個資料庫 安全和認證 建立 User Model npm i validator@5.6.0 --save 修改 server/models/user.js 123456789101112131415161718192021222324252627282930313233const mongoose = require(&#x27;mongoose&#x27;);const validator = require(&#x27;validator&#x27;);var User = mongoose.model(&#x27;User&#x27;, &#123; email: &#123; type: String, required: true, trim: true, minlength: 1, unique: true, validate: &#123; validator: validator.isEmail, message: &#x27;&#123;VALUE&#125; is not a valid email&#x27; &#125; &#125;, password: &#123; type: String, require: true, minlength: 6, &#125;, tokens: [&#123; access: &#123; type: String, require: true &#125;, token: &#123; type: String, require: true &#125; &#125;]&#125;);module.exports = &#123;User&#125;; 修改 server/server.js 12345678910app.post(&#x27;/users&#x27;, (req, res) =&gt; &#123; var body = _.pick(req.body, [&#x27;email&#x27;, &#x27;password&#x27;]); var user = new User(body); user.save().then((user) =&gt; &#123; res.send(user); &#125;).catch((e) =&gt; &#123; res.status(400).send(e); &#125;);&#125;); JWTs 和 Hashing npm install crypto-js@3.1.6 --save 新增 playground/hashing.js 1234567891011121314151617181920212223const &#123;SHA256&#125; = require(&#x27;crypto-js&#x27;);var message = &#x27;I am user number 3&#x27;;var hash = SHA256(message).toString();console.log(`Message: $&#123;message&#125;`);console.log(`Hash: $&#123;hash&#125;`);var data = &#123; id: 4&#125;;var token = &#123; data, hash: SHA256(JSON.stringify(data) + &#x27;somesecret&#x27;).toString()&#125;;var resultHash = SHA256(JSON.stringify(token.data) + &#x27;somesecret&#x27;).toString();if (resultHash === token.hash) &#123; console.log(&#x27;Data was not changed&#x27;);&#125; else &#123; console.log(&#x27;Data was changed. Do not trust!&#x27;);&#125; 驗證 data 如果不同會跳出資料改變的訊息 12token.data.id = 5;token.hash = SHA256(JSON.stringify(token.data)).toString(); npm i jsonwebtoken@7.1.9 --save JWT 官方網站 使用 jwt 來進行驗證 1234567891011const jwt = require(&#x27;jsonwebtoken&#x27;);var data = &#123; id: 10&#125;;var token = jwt.sign(data, &#x27;123abc&#x27;);console.log(token);var decoded = jwt.verify(token, &#x27;123abc&#x27;);console.log(&#x27;decoded&#x27;, decoded); 產生 Auth Tokens 和 Setting Headers 修改 server/models/user.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const mongoose = require(&#x27;mongoose&#x27;);const validator = require(&#x27;validator&#x27;);const jwt = require(&#x27;jsonwebtoken&#x27;);const _ = require(&#x27;lodash&#x27;);var UserSchema = new mongoose.Schema(&#123; email: &#123; type: String, required: true, trim: true, minlength: 1, unique: true, validate: &#123; validator: validator.isEmail, message: &#x27;&#123;VALUE&#125; is not a valid email&#x27; &#125; &#125;, password: &#123; type: String, require: true, minlength: 6, &#125;, tokens: [&#123; access: &#123; type: String, require: true &#125;, token: &#123; type: String, require: true &#125; &#125;]&#125;);UserSchema.methods.toJSON = function () &#123; var user = this; var userObject = user.toObject(); return _.pick(userObject, [&#x27;_id&#x27;, &#x27;email&#x27;]);&#125;;UserSchema.methods.generateAuthToken = function () &#123; var user = this; var access = &#x27;auth&#x27;; var token = jwt.sign(&#123;_id: user._id.toHexString(), access&#125;, &#x27;abc123&#x27;).toString(); user.tokens.push(&#123;access, token&#125;); return user.save().then(() =&gt; &#123; return token; &#125;);&#125;;var User = mongoose.model(&#x27;User&#x27;, UserSchema);module.exports = &#123;User&#125;; 修改 server/server.js 12345678910111213// POST /usersapp.post(&#x27;/users&#x27;, (req, res) =&gt; &#123; var body = _.pick(req.body, [&#x27;email&#x27;, &#x27;password&#x27;]); var user = new User(body); user.save().then((user) =&gt; &#123; return user.generateAuthToken(); &#125;).then((token) =&gt; &#123; res.header(&#x27;x-auth&#x27;, token).send(user); &#125;).catch((e) =&gt; &#123; res.status(400).send(e); &#125;);&#125;);","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://vincent.fishboneapps.com/tags/Nodejs/"}]},{"title":"Nodejs 快速學習自我挑戰 Day7","slug":"Nodejs-快速學習自我挑戰-Day7","date":"2017-09-17T11:56:53.000Z","updated":"2020-06-22T17:15:24.880Z","comments":true,"path":"2017/09/17/Nodejs-快速學習自我挑戰-Day7/","link":"","permalink":"https://vincent.fishboneapps.com/2017/09/17/Nodejs-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day7/","excerpt":"","text":"MongoDB，Mongoose 和 REST APIs (Todo API) 安裝 Postman Postman 官網 Resource Creation Endpoint - POST /todos 新增 server/db/mongoose.js 123456var mongoose = require(&#x27;mongoose&#x27;);mongoose.Promise = global.Promise;mongoose.connect(&#x27;mongodb://localhost:27017/TodoApp&#x27;);module.exports = &#123;mongoose&#125;; 新增 server/models/todo.js 1234567891011121314151617181920var mongoose = require(&#x27;mongoose&#x27;);var Todo = mongoose.model(&#x27;Todo&#x27;, &#123; text: &#123; type: String, required: true, minlength: 1, trim: true &#125;, completed: &#123; type: Boolean, default: false &#125;, completedAt: &#123; type: Number, default: null &#125;&#125;);module.exports = &#123;Todo&#125;; 新增 server/models/user.js 123456789101112var mongoose = require(&#x27;mongoose&#x27;);var User = mongoose.model(&#x27;User&#x27;, &#123; email: &#123; type: String, required: true, trim: true, minlength: 1 &#125;&#125;);module.exports = &#123;User&#125;; 剛剛把 server/server.js 的資料都搬到了其它資料夾，所以檔案簡化為 123var &#123;mongoose&#125; = require(&#x27;./db/mongoose&#x27;);var &#123;Todo&#125; = require(&#x27;./models/todo&#x27;);var &#123;User&#125; = require(&#x27;./models/user&#x27;); 安裝 body-parse 可以把 JSON 轉換為 object npm i express@4.14.0 body-parser@1.15.2 --save 在 server/server.js 引入 Library 12var express = require(&#x27;express&#x27;);var bodyParser = require(&#x27;body-parser&#x27;); 使用 express 1234567891011var app = express();app.use(bodyParser.json());app.post(&#x27;/todos&#x27;, (req, res) =&gt; &#123; console.log(req.body);&#125;);app.listen(3000, () =&gt; &#123; console.log(&#x27;Started on port 3000&#x27;);&#125;); 在 Postman 新增 Post http://localhost/todos，選擇 Body，選擇 raw，選擇 JSON，並送出 Post 123&#123; &quot;text&quot;: &quot;This is from postman&quot;&#125; 在 console 就會看到傳進去的資料 HTTP Status Codes：確認 HTTP 狀態碼 修改 app.post，如果 OK 就寫入 MongoDB，並回傳 OK 的訊息，如果有問題就回傳 error。 1234567891011app.post(&#x27;/todos&#x27;, (req, res) =&gt; &#123; var todo = new Todo(&#123; text: req.body.text &#125;); todo.save().then((doc) =&gt; &#123; res.send(doc); &#125;, (e) =&gt; &#123; res.status(400).send(e); &#125;);&#125;); 測試 POST /todos npm i expect@1.20.2 mocha@3.0.2 nodemon@1.10.2 supertest@2.0.0 --save-dev 把 server/server.js 輸出 module.exports = &#123;app&#125;; 新增 server/tests/server.test.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const expect = require(&#x27;expect&#x27;);const request = require(&#x27;supertest&#x27;);const &#123;app&#125; = require(&#x27;./../server&#x27;);const &#123;Todo&#125; = require(&#x27;./../models/todo&#x27;);beforeEach((done) =&gt; &#123; Todo.remove(&#123;&#125;).then(() =&gt; done());&#125;);describe(&#x27;POST /todos&#x27;, () =&gt; &#123; it(&#x27;should create a new todo&#x27;, (done) =&gt; &#123; var text = &#x27;Test todo text&#x27;; request(app) .post(&#x27;/todos&#x27;) .send(&#123;text&#125;) .expect(200) .expect((res) =&gt; &#123; expect(res.body.text).toBe(text); &#125;) .end((err, res) =&gt; &#123; if (err) &#123; return done(err); &#125; Todo.find().then((todos) =&gt; &#123; expect(todos.length).toBe(1); expect(todos[0].text).toBe(text); done(); &#125;).catch((e) =&gt; done(e)); &#125;); &#125;); it(&#x27;should not create todo with invalid body data&#x27;, (done) =&gt; &#123; request(app) .post(&#x27;/todos&#x27;) .send(&#123;&#125;) .expect(400) .end((err, res) =&gt; &#123; if (err) &#123; return done(err); &#125; Todo.find().then((todos) =&gt; &#123; expect(todos.length).toBe(0); done(); &#125;).catch((e) =&gt; done(e)); &#125;); &#125;);&#125;); List Resources - GET /todos 在 server/server.js 新增 GET 1234567app.get(&#x27;/todos&#x27;, (req, res) =&gt; &#123; Todo.find().then((todos) =&gt; &#123; res.send(&#123;todos&#125;); &#125;, (e) =&gt; &#123; res.status(400).send(e); &#125;);&#125;); node server/server.js 去 Postman 測試 新增 GET http://localhost:3000/todos 右方 save as，新增一個新的 collection，Todo App，把指令加進去 再新增 POST http://localhost:3000/todos，選 raw，JSON，並寫入資料 也加入新的 collection 測試 GET /todos 修改 server/tests/server.test.js 1234567891011const todos = [&#123; text: &#x27;First test todo&#x27;&#125;, &#123; text: &#x27;Second test todo&#x27;&#125;];// 在測試每一筆的時候，插入兩筆beforeEach((done) =&gt; &#123; Todo.remove(&#123;&#125;).then(() =&gt; &#123; return Todo.insertMany(todos); &#125;).then(() =&gt; done());&#125;); 第一個測試直接找 {text} Todo.find(&#123;text&#125;).then((todos) =&gt; &#123; 第二個測試改為兩筆 expect(todos.length).toBe(2); 新增 GET 測試 1234567891011describe(&#x27;GET /todos&#x27;, () =&gt; &#123; it(&#x27;should get all todos&#x27;, (done) =&gt; &#123; request(app) .get(&#x27;/todos&#x27;) .expect(200) .expect((res) =&gt; &#123; expect(res.body.todos.length).toBe(2); &#125;) .end(done); &#125;);&#125;); Mongoose Queries 和 ID Validation 新增 playground/mongoose-queries.js 123456789101112131415161718192021222324252627282930const &#123;ObjectID&#125; = require(&#x27;mongodb&#x27;);const &#123;mongoose&#125; = require(&#x27;./../server/db/mongoose&#x27;);const &#123;Todo&#125; = require(&#x27;./../server/models/todo&#x27;);const &#123;User&#125; = require(&#x27;./../server/models/user&#x27;);var id = &#x27;59be9ceb9e82d91c669205a611&#x27;;if (!ObjectID.isValid(id)) &#123; console.log(&#x27;ID not valid&#x27;);&#125;Todo.find(&#123; _id: id&#125;).then((todos) =&gt; &#123; console.log(&#x27;Todos&#x27;, todos);&#125;);Todo.findOne(&#123; _id: id&#125;).then((todo) =&gt; &#123; console.log(&#x27;Todo&#x27;, todo);&#125;);Todo.findById(id).then((todo) =&gt; &#123; if (!todo) &#123; return console.log(&#x27;Id not found&#x27;); &#125; console.log(&#x27;Todo by id&#x27;, todo);&#125;).catch((e) =&gt; console.log(e)); nodemon playground/mongoose-queries.js 新增 query user 123456789User.findById(&#x27;59be61a5c4e4cea95cfe65ea&#x27;).then((user) =&gt; &#123; if (!user) &#123; return console.log(&#x27;Unable to find user&#x27;); &#125; console.log(JSON.stringify(user, undefined, 2));&#125;, (e) =&gt; &#123; console.log(e);&#125;); 取得 individual Resource - GET /todos/:id 取得資料的思路 123456789// Valid id using isValid // 404 - send back empty send// findById // success // if todo - send it back // if no todo - send back 404 with empty body // error // 400 - and send empty body back 引入 ObjectId var &#123;ObjectID&#125; = require('mongodb'); 取得 id 1234567891011121314151617app.get(&#x27;/todos/:id&#x27;, (req, res) =&gt; &#123; var id = req.params.id; if (!ObjectID.isValid(id)) &#123; return res.status(404).send(); &#125; Todo.findById(id).then((todo) =&gt; &#123; if (!todo) &#123; return res.status(404).send(); &#125; res.send(&#123;todo&#125;); &#125;).catch((e) =&gt; &#123; res.status(400).send(); &#125;);&#125;); 測試 GET /todos/:id 在 server/tests/server.test.js 引入 ObjectId const &#123;ObjectID&#125; = require('mongodb'); 在傳入的陣列新增 id 1234567const todos = [&#123; _id: new ObjectID(), text: &#x27;First test todo&#x27;&#125;, &#123; _id: new ObjectID(), text: &#x27;Second test todo&#x27;&#125;]; 寫測試 123456789101112131415161718192021222324252627describe(&#x27;GET /todo/:id&#x27;, () =&gt; &#123; it(&#x27;should return todo doc&#x27;, (done) =&gt; &#123; request(app) .get(`/todos/$&#123;todos[0]._id.toHexString()&#125;`) .expect(200) .expect((res) =&gt; &#123; expect(res.body.todo.text).toBe(todos[0].text); &#125;) .end(done); &#125;); it(&#x27;should return 404 if todo not found&#x27;, (done) =&gt; &#123; var hexId = new ObjectID().toHexString(); request(app) .get(`/todos/$&#123;hexId&#125;`) .expect(404) .end(done); &#125;); it(&#x27;should return 404 for non-object ids&#x27;, (done) =&gt; &#123; request(app) .get(&#x27;/todos/123abc&#x27;) .expect(404) .end(done); &#125;);&#125;);","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://vincent.fishboneapps.com/tags/Nodejs/"}]},{"title":"Nodejs 快速學習自我挑戰 Day6","slug":"Nodejs-快速學習自我挑戰-Day6","date":"2017-09-15T06:01:22.000Z","updated":"2020-06-22T17:15:24.880Z","comments":true,"path":"2017/09/15/Nodejs-快速學習自我挑戰-Day6/","link":"","permalink":"https://vincent.fishboneapps.com/2017/09/15/Nodejs-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day6/","excerpt":"","text":"MongoDB，Mongoose 和 REST APIs (Todo API) 安裝 MongoDB 和 Mongoose 下載 MongoDB 將檔案解壓縮後，修改檔名為 mongo，然後移動到家目錄底下 在家目錄新增 mongo-data 的資料夾 啟動 server 並指定路徑./mongod --dbpath ~/mongo-data 新開分頁，執行 ./mongo 寫入資料庫 db.Todos.insert(&#123;text: 'File new node course'&#125;) db.Todos.find() ，搜尋資料庫會發現剛剛輸入的資料 Robomongo 建立 NoSQL Vocabulary SQL 有 table 結構，NoSQL 則是使用物件的形式 (Collection) SQL 每一筆資料稱為 Row/Record，NoSQL 則稱為 Document SQL 每一個欄位稱為 Column，NoSQL 則稱為 Field 連接 MongoDB 並寫入資料 MongoDB native mkdir node-todo-api npm init npm install mongodb@2.2.5 --save 新增 playground/mongodb-connect.js 12345678910const MongoClient = require(&#x27;mongodb&#x27;).MongoClient;MongoClient.connect(&#x27;mongodb://localhost:27017/TodoApp&#x27;, (err, db) =&gt; &#123; if (err) &#123; return console.log(&#x27;Unable to connect to MongoDB server&#x27;); &#125; console.log(&#x27;Connected to MongoDB server&#x27;); db.close();&#125;); node playground/mongodb-connect.js 在 playground/mongodb-connect.js 插入一行 123456789db.collection(&#x27;Todos&#x27;).insertOne(&#123; text: &#x27;Something to do&#x27;, completed: false &#125;, (err, result) =&gt; &#123; if (err) &#123; return console.log(&#x27;Unable to insert todo&#x27;, err); &#125; console.log(JSON.stringify(result.ops, undefined, 2)); &#125;); node playground/mongodb-connect.js 在 playground/mongodb-connect.js 新增 Users 資料表，且新增 fields (name, age, location) 1234567891011// Insert new doc into Users (name, age, location) db.collection(&#x27;Users&#x27;).insertOne(&#123; name: &#x27;Andrew&#x27;, age: 25, location: &#x27;Philadelphia&#x27; &#125;, (err, result) =&gt; &#123; if (err) &#123; return console.log(&#x27;Unable to insert User&#x27;, err); &#125; console.log(JSON.stringify(result.ops)); &#125;); node playground/mongodb-connect.js ObjectId 將 const MongoClient = require('mongodb').MongoClient; 取代為 const &#123; MongoClient, ObjectID &#125; = require('mongodb'); 取得資料 直接在 Robo 裡面的 Todos 新增 document 1234&#123; text: &quot;Walk the dog&quot;, completed: false&#125; 複製 mongodb-connect.js 並新增為 mongodb-find.js 1234567891011121314151617const &#123; MongoClient, ObjectID &#125; = require(&#x27;mongodb&#x27;);MongoClient.connect(&#x27;mongodb://localhost:27017/TodoApp&#x27;, (err, db) =&gt; &#123; if (err) &#123; return console.log(&#x27;Unable to connect to MongoDB server&#x27;); &#125; console.log(&#x27;Connected to MongoDB server&#x27;); db.collection(&#x27;Todos&#x27;).find().toArray().then((docs) =&gt; &#123; console.log(&#x27;Todos&#x27;); console.log(JSON.stringify(docs, undefined, 2)); &#125;, (err) =&gt; &#123; console.log(&#x27;Unable to fetch todos&#x27;, err); &#125;); // db.close();&#125;); node playground/mongodb-find.js db.collection('Todos').find(&#123;completed: false&#125;).toArray().then((docs) =&gt; &#123; 這樣就只會出現 false 的選項了 node playground/mongodb-find.js db.collection('Todos').find(&#123;_id: new ObjectID('59bb791adf952c24d5ae60b7')&#125;) 也可以用 id 的方式搜尋 node playground/mongodb-find.js 用計數的方式算出東西 12345db.collection(&#x27;Todos&#x27;).find().count().then((count) =&gt; &#123; console.log(`Todos count: $&#123;count&#125;`);&#125;, (err) =&gt; &#123; console.log(&#x27;Unable to fetch todos&#x27;, err);&#125;); Deleting Document 一次刪除很多 deleteMany 123db.collection(&#x27;Todos&#x27;).deleteMany(&#123;text: &#x27;Eat lunch&#x27;&#125;).then((result) =&gt; &#123; console.log(result);&#125;); 一次刪除一個 deleteOne 123db.collection(&#x27;Todos&#x27;).deleteOne(&#123;text: &#x27;Eat lunch&#x27;&#125;).then((result) =&gt; &#123; console.log(result);&#125;); 選擇一個然後刪除，如果有多個一樣的，會自動選擇第一筆找到的 findOneAndDelete 123db.collection(&#x27;Todos&#x27;).findOneAndDelete(&#123;completed: false&#125;).then((result) =&gt; &#123; console.log(result);&#125;); 更新資料 更新 Todos，set 改變值，returnOriginal 設為 false 就是回傳值的時候，傳回更新後的值，預設為 true 1234567891011db.collection(&#x27;Todos&#x27;).findOneAndUpdate(&#123; _id: new ObjectID(&#x27;59bcaa59fd4847c2497a0104&#x27;)&#125;, &#123; $set: &#123; completed: true &#125;&#125;, &#123; returnOriginal: false&#125;).then((result) =&gt; &#123; console.log(result);&#125;); 更新 Users，inc 設為 1 就是把值增加 1 1234567891011121314db.collection(&#x27;Users&#x27;).findOneAndUpdate(&#123; _id: new ObjectID(&#x27;59bb7a6630523c252369e2e4&#x27;)&#125;, &#123; $set: &#123; name: &#x27;Andrew&#x27; &#125;, $inc: &#123; age: 1 &#125;&#125;,&#123; returnOriginal: false&#125;).then((result) =&gt; &#123; console.log(result);&#125;); 設定 Mongoose Mongoose 官方網站 npm i mongoose@4.5.9 --save 使用 Mongoose 寫入資料到 MongoDB 1234567891011121314151617181920212223242526var mongoose = require(&#x27;mongoose&#x27;);mongoose.Promise = global.Promise;mongoose.connect(&#x27;mongodb://localhost:27017/TodoApp&#x27;);var Todo = mongoose.model(&#x27;Todo&#x27;, &#123; text: &#123; type: String &#125;, completed: &#123; type: Boolean &#125;, completedAt: &#123; type: Number &#125;&#125;);var newTodo = new Todo(&#123; text: &#x27;Cook dinner&#x27;&#125;);newTodo.save().then((doc) =&gt; &#123; console.log(&#x27;Save todo&#x27;, doc);&#125;, (e) =&gt; &#123; console.log(&#x27;Unable to save todo&#x27;);&#125;); 再寫入別的資料 1234567891011var otherTodo = new Todo(&#123; text: &#x27;Feed the cat&#x27;, completed: true, completedAt: 123&#125;);otherTodo.save().then((doc) =&gt; &#123; console.log(JSON.stringify(doc, undefined, 2));&#125;, (e) =&gt; &#123; console.log(&#x27;Unable to save&#x27;, e);&#125;); Validators，Types 和 Defaults 修改 server/server.js，新增 model，並設定驗證 12345678var User = mongoose.model(&#x27;User&#x27;, &#123; email: &#123; type: String, required: true, trim: true, minlength: 1 &#125;&#125;); 插入物件並儲存 123456789var user = new User(&#123; email: &#x27;andrew@example.com &#x27;&#125;);user.save().then((doc) =&gt; &#123; console.log(&#x27;User saved&#x27;, doc);&#125;, (e) =&gt; &#123; console.log(&#x27;Unable to save user&#x27;, e);&#125;); 這個部分有一個很特別的地方，如果 type 設為 String，輸入數字或是布林值都會變成 text，並不會出錯。","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://vincent.fishboneapps.com/tags/Nodejs/"}]},{"title":"Nodejs 快速學習自我挑戰 Day5","slug":"Nodejs-快速學習自我挑戰-Day5","date":"2017-09-14T03:24:09.000Z","updated":"2020-06-22T17:15:24.880Z","comments":true,"path":"2017/09/13/Nodejs-快速學習自我挑戰-Day5/","link":"","permalink":"https://vincent.fishboneapps.com/2017/09/13/Nodejs-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day5/","excerpt":"","text":"網頁伺服器及應用程式部署 進階 template 註冊 partials hbs.registerPartials(__dirname + '/views/partials') 將 footer code 移到 views/partials/footer.hbs 123&lt;footer&gt; &lt;p&gt;Copyright &#123;&#123;currentYear&#125;&#125;&lt;/p&gt;&lt;/footer&gt; 本來 footer 的區塊用 &#123;&#123;\" &#123;&#123;> footer\" &#125;&#125;&#125;&#125; 取代 nodemon 監控 js 和 hbs 檔案 nodemon server.js -e js, hbs 將 header code 移到 views/partials/header.hbs 12345&lt;header&gt; &lt;h1&gt;&#123;&#123;pageTitle&#125;&#125;, 123&lt;/h1&gt; &lt;p&gt;&lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;/about&quot;&gt;About&lt;/a&gt;&lt;/p&gt;&lt;/header&gt; 本來 footer 的區塊用 &#123;&#123;\" &#123;&#123;> header\" &#125;&#125;&#125;&#125; 取代 使用 hbs 的 Helper 來取得年份 123hbs.registerHelper(&#x27;getCurrentYear&#x27;, () =&gt; &#123; return new Date().getFullYear();&#125;); 本來 &#123;&#123;\" &#123;&#123;currentYear\"&#125;&#125;&#125;&#125; 用 &#123;&#123;\" &#123;&#123;getCurrentYear\" &#125;&#125;&#125;&#125; 取代 使用 hbs 的 Helper 註冊 screamIt 然後將 text 變數送進去 123hbs.registerHelper(&#x27;screamIt&#x27;, (text) =&gt; &#123; return text.toUpperCase();&#125;); 使用 screamIt，text 變數設為 welcomeMessage&#123;&#123;\" &#123;&#123;screamIt welcomeMessage\" &#125;&#125;&#125;&#125; Express Middleware 註冊一個 middleware，然後 console 時間以及擷取的狀態 123456app.use((req, res, next) =&gt; &#123; var now = new Date().toString(); console.log(`$&#123;now&#125;: $&#123;req.method&#125; $&#123;req.url&#125;`); next();&#125;); 新增 maintenance.hbs 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Some Website&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;We&#x27;ll be right back&lt;/h1&gt; &lt;p&gt; The site is currently being updated. &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 使用 middleware 把頁面通通導向 maintenance 123app.use((req, res ,next) =&gt; &#123; res.render(&#x27;maintenance&#x27;);&#125;); Git 版本控制 Git 官方網站 啟動 git 專案 git init 新增檔案 git add 新增 .gitignore 讓部分檔案不上傳 對新增的檔案做 commit git commit -m 'Commit Content' 設置 ssh key ssh key 目錄 ~/.ssh 產生 ssh key ssh-keygen -t rsa -b 4096 -C 'YOUR@EMAIL' 設定完成會產生出 id_rsa(此為私密金鑰，不能給別人) 和 id_rsa_pub(此為公開金鑰，用於第三方軟件) 開啟 ssh-agent eval &quot;$(ssh-agent -s)&quot; 將 ssh 私鑰加入 ssh-agent ssh-add ~/.ssh/id_rsa 將 ssh key 貼到 Github =&gt; Setting =&gt; SSH and GPG key pbcopy &lt; ~/.ssh/id_rsa.pub 跟 Github 進行連線 ssh -T git@github.com 部署 apps heroku 安裝 heroku cli brew install heroku 在本地端 cli 登入 heroku heroku login 新增 ssh key 到 keroku heroku keys:add 檢查在電腦上的 key heroku keys 跟 heroku 進行連線 ssh -v git@heroku.com 修改 server.js 讓 port 動態調整，先取得 env 的 PORT，如果不存在則使用預設的 3000 Port const port = process.env.PORT || 3000; 修改 server.js 的 app.listen 123app.listen(port, () =&gt; &#123; console.log(`Server is up on port $&#123;port&#125;`);&#125;); 在 package.json 的 script 新增 start，讓 server 知道要執行哪個檔案 1234&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;node server.js&quot; &#125; 開啟 heroku 專案 heroku create 將專案推到 heroku git push heroku 用瀏覽器開啟 keroku 的專案heroku open 測試 Apps Mocha 和基本測試 mkdir node-tests cd node-tests npm init，全部直接使用預設值 新增檔案 utils/utils.js module.exports.add = (a, b) =&gt; a + b; Mocha 官方網站 安裝 mocha 且不在正式上線時使用，僅用於開發用途 npm i mocha@3.0.0 --save-dev 新增 utils/util.test.js 12345const utils = require(&#x27;./utils&#x27;);it(&#x27;should add two numbers&#x27;, () =&gt; &#123; var res = utils.add(33, 11);&#125;); 修改 package.json，**搜尋所有資料夾 123&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;mocha **/*.test.js&quot;&#125;, npm test 執行測試 加一行錯誤 throw new Error('Value not correct!') 再執行 npm test，就會發現錯誤了 加 if statement，回傳得到的錯誤值 123if (res !== 44) &#123; throw new Error(`Expected 44, but got $&#123;res&#125;.`)&#125; 在 utils/utils.js 新增一個 module module.exports.square = (x) =&gt; x * x; 在 utils.utils.test.js 多新增一個 test 1234567it (&#x27;should square a number&#x27;, () =&gt; &#123; var res = utils.square(3); if (res !== 9) &#123; throw new Error(`Expected 9, but got $&#123;res&#125;.`) &#125;&#125;); 監控和自動重啟測試 nodemon --exec 'npm test' 在 package.json 直接新增 command &quot;test-watch&quot;: &quot;nodemon --exec \\&quot;npm test\\&quot;&quot; npm run test-watch 使用 Assertion Library Assertion Library 安裝 expect npm install expect@1.20.2 --save-dev 用 expect 簡化函數 12345678910111213141516171819202122232425262728const expect = require(&#x27;expect&#x27;);const utils = require(&#x27;./utils&#x27;);it(&#x27;should add two numbers&#x27;, () =&gt; &#123; var res = utils.add(33, 11); expect(res).toBe(44).toBeA(&#x27;number&#x27;);&#125;);it (&#x27;should square a number&#x27;, () =&gt; &#123; var res = utils.square(3); expect(res).toBe(9).toBeA(&#x27;number&#x27;);&#125;);it (&#x27;should expect some values&#x27;, () =&gt; &#123; expect(12).toNotBe(12); expect(&#123;name: &#x27;andrew&#x27;&#125;).toNotEqual(&#123;name: &#x27;Andrew&#x27;&#125;); expect([2, 3, 4]).toExclude(1); expect(&#123; name: &#x27;Andrew&#x27;, age: 25, location: &#x27;Philadelphia&#x27; &#125;).toExclude(&#123; age: 23 &#125;)&#125;); 在 utils/utils.js 新增 module 123456module.exports.setName = (user, fullName) =&gt; &#123; var names = fullName.split(&#x27; &#x27;); user.firstName = names[0]; user.lastName = names[1]; return user;&#125;; 用 expect 確認回傳的物件是正確值 123456789101112// should verify first and last names are set// assert it includes firstName and lastName with proper valuesit (&#x27;should set firstName and lastName&#x27;, () =&gt; &#123; var user = &#123;location: &#x27;Philadelphia&#x27;, age: 25&#125;; var res = utils.setName(user, &#x27;Andrew Mead&#x27;); expect(res).toInclude(&#123; firstName: &#x27;Andrew&#x27;, lastName: &#x27;Mead&#x27;, age: 25 &#125;);&#125;); 測試非同步式程式碼 在 utils/utils.js 新增一個 asyncAdd 12345module.exports.asyncAdd = (a, b, callback) =&gt; &#123; setTimeout(() =&gt; &#123; callback(a + b); &#125;, 1000);&#125;; 在 utils/utils.test.js 測試 asyncAdd，這邊一定要使用 done，這樣才知道他是非同步，會等完成再執行 expect 123456it(&#x27;should async add two numbers&#x27;, (done) =&gt; &#123; utils.asyncAdd(4, 3, (sum) =&gt; &#123; expect(sum).toBe(7).toBeA(&#x27;number&#x27;); done(); &#125;);&#125;); 在 utils/utils.js 新增一個 asyncSquare 12345module.exports.asyncSquare = (x, callback) =&gt; &#123; setTimeout(() =&gt; &#123; callback(x * x); &#125;, 1000);&#125;; 在 utils/utils.test.js 測試 asyncSqure 123456it(&#x27;should async square a number&#x27;, (done) =&gt; &#123; utils.asyncSquare(5, (res) =&gt; &#123; expect(res).toBe(25).toBeA(&#x27;number&#x27;); done(); &#125;);&#125;); 測試 Express 應用 安裝 Express npm i express@4.14.0 --save 新增 server/server.js 123456789const express = require(&#x27;express&#x27;);var app = express();app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; res.send(&#x27;Hello world!&#x27;);&#125;);app.listen(3000); 執行 server node server/server.js 去瀏覽器輸入 http://localhost:3000/ 就會看到 Hello world! SuperTest npm i supertest@2.0.0 --save-dev 修改 server/server.js 輸出內容讓其它地方可用 module.exports.app = app; 新增 server/server.test.js 12345678910const request = require(&#x27;supertest&#x27;);var app = require(&#x27;./server&#x27;).app;it(&#x27;should return hello world response&#x27;, (done) =&gt; &#123; request(app) .get(&#x27;/&#x27;) .expect(&#x27;Hello world!&#x27;) .end(done);&#125;); 引入 expect，用 expect 客製化測試 12345678910111213141516const request = require(&#x27;supertest&#x27;);const expect = require(&#x27;expect&#x27;);var app = require(&#x27;./server&#x27;).app;it(&#x27;should return hello world response&#x27;, (done) =&gt; &#123; request(app) .get(&#x27;/&#x27;) .expect(404) .expect((res) =&gt; &#123; expect(res.body).toInclude(&#123; error: &#x27;Page not found.&#x27; &#125;); &#125;) .end(done);&#125;); 在 server/server.js 新增路由 1234567891011121314// GET /users// Give users a name prop and age propapp.get(&#x27;/users&#x27;, (req, res) =&gt; &#123; res.send([&#123; name: &#x27;Mike&#x27;, age: 27 &#125;, &#123; name: &#x27;Andrew&#x27;, age: 25 &#125;, &#123; name: &#x27;Jen&#x27;, age: 26 &#125;]);&#125;); 在 server/server.test.js 新增測試 123456789101112131415// Make a new test// assert 200// Assert that you exist in users arrayit(&#x27;should return my user object&#x27;, (done) =&gt; &#123; request(app) .get(&#x27;/users&#x27;) .expect(200) .expect((res) =&gt; &#123; expect(res.body).toInclude(&#123; name: &#x27;Andrew&#x27;, age: 25 &#125;); &#125;) .end(done);&#125;); 使用 describe() 組織測試 修改 utils/utils.test.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const expect = require(&#x27;expect&#x27;);const utils = require(&#x27;./utils&#x27;);describe(&#x27;Utils&#x27;, () =&gt; &#123; describe(&#x27;#add&#x27;, () =&gt; &#123; it(&#x27;should add two numbers&#x27;, () =&gt; &#123; var res = utils.add(33, 11); expect(res).toBe(44).toBeA(&#x27;number&#x27;); &#125;); it(&#x27;should async add two numbers&#x27;, (done) =&gt; &#123; utils.asyncAdd(4, 3, (sum) =&gt; &#123; expect(sum).toBe(7).toBeA(&#x27;number&#x27;); done(); &#125;); &#125;); &#125;); it (&#x27;should square a number&#x27;, () =&gt; &#123; var res = utils.square(3); expect(res).toBe(9).toBeA(&#x27;number&#x27;); &#125;); it(&#x27;should async square a number&#x27;, (done) =&gt; &#123; utils.asyncSquare(5, (res) =&gt; &#123; expect(res).toBe(25).toBeA(&#x27;number&#x27;); done(); &#125;); &#125;);&#125;);// should verify first and last names are set// assert it includes firstName and lastName with proper valuesit (&#x27;should set firstName and lastName&#x27;, () =&gt; &#123; var user = &#123;location: &#x27;Philadelphia&#x27;, age: 25&#125;; var res = utils.setName(user, &#x27;Andrew Mead&#x27;); expect(res).toInclude(&#123; firstName: &#x27;Andrew&#x27;, lastName: &#x27;Mead&#x27;, age: 25 &#125;);&#125;);// it (&#x27;should expect some values&#x27;, () =&gt; &#123; // expect(12).toNotBe(12); // expect(&#123;name: &#x27;andrew&#x27;&#125;).toNotEqual(&#123;name: &#x27;Andrew&#x27;&#125;); // expect([2, 3, 4]).toExclude(1); // expect(&#123; // name: &#x27;Andrew&#x27;, // age: 25, // location: &#x27;Philadelphia&#x27; // &#125;).toExclude(&#123; // age: 23 // &#125;)// &#125;); 修改 server/server.test.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445const request = require(&#x27;supertest&#x27;);const expect = require(&#x27;expect&#x27;);var app = require(&#x27;./server&#x27;).app;// Server // GET / // some test case // GET /users // some test casedescribe(&#x27;Server&#x27;, () =&gt; &#123; describe(&#x27;GET /&#x27;, () =&gt; &#123; it(&#x27;should return hello world response&#x27;, (done) =&gt; &#123; request(app) .get(&#x27;/&#x27;) .expect(404) .expect((res) =&gt; &#123; expect(res.body).toInclude(&#123; error: &#x27;Page not found.&#x27; &#125;); &#125;) .end(done); &#125;); &#125;); describe(&#x27;GET /users&#x27;, () =&gt; &#123; // Make a new test // assert 200 // Assert that you exist in users array it(&#x27;should return my user object&#x27;, (done) =&gt; &#123; request(app) .get(&#x27;/users&#x27;) .expect(200) .expect((res) =&gt; &#123; expect(res.body).toInclude(&#123; name: &#x27;Andrew&#x27;, age: 25 &#125;); &#125;) .end(done); &#125;); &#125;);&#125;); Test Spies 新增 spies/db.js 123module.exports.saveUser = (user) =&gt; &#123; console.log(&#x27;Saving the user&#x27;, user);&#125;; 新增 spies/app.js 12345678var db = require(&#x27;./db&#x27;);module.exports.handleSignup = (email, password) =&gt; &#123; // Check if email already exists db.saveUser(&#123;email, password&#125;); // Save the user to the database // Send the welcome email&#125;; 新增 spies/app.test.js 1234567891011const expect = require(&#x27;expect&#x27;);describe(&#x27;App&#x27;, () =&gt; &#123; it(&#x27;should call the spy correctly&#x27;, () =&gt; &#123; var spy = expect.createSpy(); spy(&#x27;Andrew&#x27;, 25); expect(spy).toHaveBeenCalledWith(&#x27;Andrew&#x27;, 25); &#125;);&#125;); npm install rewire@2.5.2 --save-dev 在 spies/app.test.js 使用 rewire 引入 app var app = rewire('./app'); 用 describe 將 rewire 單元測試分類在一起 123456789101112131415describe(&#x27;App&#x27;, () =&gt; &#123; var db = &#123; saveUser: expect.createSpy() &#125;; app.__set__(&#x27;db&#x27;, db); it(&#x27;should call saveUser with user object&#x27;, () =&gt; &#123; var email = &#x27;andrew@example.com&#x27;; var password = &#x27;123abc&#x27;; app.handleSignup(email, password); expect(db.saveUser).toHaveBeenCalledWith(&#123;email, password&#125;); &#125;);&#125;);","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://vincent.fishboneapps.com/tags/Nodejs/"}]},{"title":"Mac 開發環境建置","slug":"Mac-開發環境建置","date":"2017-09-13T13:07:44.000Z","updated":"2020-06-22T17:15:06.801Z","comments":true,"path":"2017/09/13/Mac-開發環境建置/","link":"","permalink":"https://vincent.fishboneapps.com/2017/09/13/Mac-%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83%E5%BB%BA%E7%BD%AE/","excerpt":"","text":"內建工具 1. Xcode 到 App Store 下載 記得要打開 Xcode，並且同意服務條款 生產力工具 1. Alfred + Powerbank (付費) 直接從官方網站下載應用 2. iTerm2 直接從官方網站下載應用 設定： 把字體改大 iTerm2 =&gt; Preferences =&gt; Profiles =&gt; Text =&gt; Font =&gt; 20px 讓 iTerm2 可以無限的往回滾動 iTerm2 =&gt; Preferences =&gt; Profiles =&gt; Terminal =&gt; Scrollback Buffer =&gt; Unlimited scrollback 修改主題 - 下載 Dracula 主題 iTerm2 =&gt; Preferences =&gt; Profiles =&gt; Color =&gt; 找到右下角的 Color Presets =&gt; Import =&gt; 選擇 Dracula 3. Wunderlist 直接從官方網站下載應用 4. Dropbox 直接從官方網站下載應用 5. MoneyPro (付費軟體) 直接從官方網站下載應用 6. Filezilla 直接從官方網站下載應用 7. Zoom 直接從官方網站下載應用 8. VirtualBox 直接從官方網站下載應用 9. WebStorm 直接從官方網站下載應用 10. PhpStorm 直接從官方網站下載應用 11. Visual Studio Code 直接從官方網站下載應用 設定： 常用套件 Auto Close Tag Beautify ESLint Git History HTML Snippets Material Icon Theme Material Theme Kit 打開自動存檔 File =&gt; Auto Save 字體放大 Code =&gt; Preferences =&gt; Setting =&gt; “editor.fontSize”: 16 修改佈景主題 Command+Shift+P =&gt; theme =&gt; Solarized Light 12. Enpass (密碼管理工具) 直接從官方網站下載應用 13. Anki 直接從官方網站下載應用 14. Slack 直接從官方網站下載應用 15. Karabiner (修改鍵盤工具) 直接從官方網站下載應用 套件 &amp; 指令 1. zsh 安裝指令 sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 修改佈景主題 vim ~/.zshrc 修改 ZSH_THEME=“cloud” 相關主題參考 2. Homebrew 安裝指令 /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 3. nvm 安裝指令 參考官方網站 curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.4/install.sh | bash 列出所有版本 nvm ls-remote 安裝 TLS 版本 nvm install 6.11.3 4. Git 安裝指令 brew update &amp;&amp; brew install git 設定全域 username 和 email git config --global user.name &quot;tingsyuanwang&quot; git config --global user.email &quot;dtvgood202@gmail.com&quot; 5. Hexo (部落格套件) 安裝指令 npm install -g hexo-cli 6. Composer 進去 Composer 網站按照指令安裝 7. Docker 直接從官方網站下載應用 8. Kubectl (Kubernetes 指令) 安裝指令 1curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/darwin/amd64/kubectl React Native 環境 安裝 node watchman brew install node brew install watchman 安裝 React Native CLI npm install -g react-native-cli Java Development Kit 從官方網站下載 Android Studio 從官方網站下載 加到 .zshrc 123456# JDK configurationexport JAVA_HOME=`/usr/libexec/java_home`export ANDROID_HOME=$HOME/Library/Android/sdkexport PATH=$PATH:$ANDROID_HOME/toolsexport PATH=$PATH:$ANDROID_HOME/platform-tools React Native Debugger brew update &amp;&amp; brew cask install react-native-debugger","categories":[{"name":"Skill Share","slug":"Skill-Share","permalink":"https://vincent.fishboneapps.com/categories/Skill-Share/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://vincent.fishboneapps.com/tags/Mac/"}]},{"title":"Jenkins 快速學習自我挑戰 Day1","slug":"Jenkins-快速學習自我挑戰-Day1","date":"2017-09-02T15:49:25.000Z","updated":"2020-06-22T17:14:24.092Z","comments":true,"path":"2017/09/02/Jenkins-快速學習自我挑戰-Day1/","link":"","permalink":"https://vincent.fishboneapps.com/2017/09/02/Jenkins-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day1/","excerpt":"","text":"介紹 Jenkins 課程介紹 目標 了解關鍵知識 使用 Jenkins 來設置自動建立 熟悉基礎 Jenkins 強烈的起始點 課程簡介 介紹 &amp; 核心觀念 快速安裝 Jenkins UI 概覽 Jenkins 基礎 (自由型式工作) Maven 專案 超越基礎 結論 / Bonus 課程重點和方法 課程重點 Mac OS X 初學者 Java / Maven Git &amp; Github Jenkins 相同的系統 簡單 課程方法 最少量的理論 / 核心觀念 一步一步實際練習範例 補充內容 影片：短且針對重點 暫停和跟隨 加入討論 什麼是 Jenkins？為什麼使用 Jenkins？ 什麼是 Jenkins？ 持續整合 / 建立 Server 自動軟體建立 Orchestration 免費 (開源) 商業支援可用 Powered by Java / Jetty WAR for Java Web Containers (像是 Tomcat) Jenkins.io 為什麼使用 Jenkins？ 剛開始 手動的 每一個開發者 在自己的機器運作 不需要 Scale 非常危險 建立 Servers 監控改變 建立 code 自動地 定期地 Jenkins 非常熱門 強大的 強壯的社群支持 極度有彈性的 Jenkins 架構 Host System 裡面會有用 Jetty (預設) 執行的 Container，Jetty 可以存取 JDK tools 會有一個叫做 service 的程式，他負責啟動、停止和監控 Jetty 而在 Container 裡面會執行 Jenkins，在 Jenkins 裡面則會放置 View (依照分組或目錄分類)，View 裡面會放置 Project，提供如何建立軟體的指引，Project 會把工作放到 View 外面的 Job Queue，最後由 Executor 來協助 Job Queue 完成 快速安裝 快速安裝概覽 安裝流程 支援多個技能等級 快速安裝流程 (這一部分) 完整安裝流程 (Bonus) Mac OS X 或 mac OS 應該支援部多數最新版本 Git Apple - Command Line Tools 任意文字編輯器 TextMate 2 (包含教學) Atom Sublime Java Software Development Kit (JDK) Apache Maven 3 Jenkins 2 Mac OS Launch Daemon Service 啟動 / 暫停 / 重新啟動 Jenkins 安裝流程的文字教程 有些人比較喜歡這個方法 Jenkins 快速安裝 安裝 JDK 在 .zshrc 加上這一行 1export JAVA_HOME=`/usr/libexec/java_home` 下載 Maven，下載 tar.gz 版本 使用 Command Line 解壓縮 tar -xvzf apache-maven-3.5.0-bin.tar.gz 在 .zshrc 加上這兩行 123plugins=(mvn)export MAVEN_HOME=~/Development/mavenexport PATH=&quot;$&#123;PATH&#125;:$&#123;MAVEN_HOME&#125;/bin&quot; 下載 LTS 版本 安裝完成之後，可以在 http://localhost:8080 看到 Service Daemon MacOS 上的 Jenkins 服務 重新啟動 Jenkins http://localhost:8080/restart unload 移除組態設定 sudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist load 會重新載入組態設定 sudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://vincent.fishboneapps.com/tags/Jenkins/"}]},{"title":"提高生產效率：適應、改善、執行","slug":"提高生產效率：適應、改善、執行","date":"2017-08-31T07:39:56.000Z","updated":"2020-06-22T17:16:43.819Z","comments":true,"path":"2017/08/31/提高生產效率：適應、改善、執行/","link":"","permalink":"https://vincent.fishboneapps.com/2017/08/31/%E6%8F%90%E9%AB%98%E7%94%9F%E7%94%A2%E6%95%88%E7%8E%87%EF%BC%9A%E9%81%A9%E6%87%89%E3%80%81%E6%94%B9%E5%96%84%E3%80%81%E5%9F%B7%E8%A1%8C/","excerpt":"","text":"為誰設計的課程？ 從 Planning 到 doing faster 課程有以下特點 根據研究 實際演練 證明結果 什麼都有，就是沒有 generic advice 很簡單易用 帶你從 Where You Are 到 You Want To Be 概觀 意志力 動機 習慣 做決定 設定目標 意志力：你最重要的資源 這邊會談到自我管理的重要性 每天練習，持續三十天，並記錄結果 第一項：意志力 冥想 幫助專注 減輕壓力 增強意志力 對初學者有很好的效果 在 11 小時之後，腦中會產生生理改變 快速開始指南 坐下 清理思緒 注意呼吸 每天至少 10 分鐘，堅持至少三個禮拜 第二項：Pause &amp; Plan Response 大腦在壓力之下，會做不好的決定 You + Stress = Short Term Thinking 讓呼吸變慢 第三項：原諒自己 原諒讓自己回到正軌 PRE-COMMIT：找別人一起做，你就會不得不做 想像未來的自己是真的人，關心他，在做不好的決定的時候想到他 動機：為什麼它很重要但不夠 它很棒，但是它不夠讓你完成事情 思考為什麼：你為什麼想達成這個目標？ 我現在就想要，但是現實不是這樣的 動機讓你開始，但是只有習慣可以讓你持續進行 如果你什麼都有了，你想要做什麼？ 你不會永遠享受它 答案在你自己的心中 習慣：成功的秘密 We first make our habits then our habits make us - John Dryden 他們可以在生理上改變大腦 習慣由什麼組成？ Craving Cue Routine Reward 習慣永遠不會完全消失 壞習慣就養成好習慣來取代它就可以了 工作 -&gt; 覺得無聊 -&gt; 看社交軟體，產生拖延 工作 -&gt; 覺得無聊 -&gt; 回來工作吧！ 針對壞習慣記得： 讓習慣慢下來 然後針對某個環節攻擊 創造動力 建立 checklist 當危機產生的時候就是最好的改變時間 結論 了解習慣 創造動力 讓時機更正確 目標：達成任何事情的框架 一定要知道目標 有效目標設定 6 步驟 1 你想要達成什麼？ 2 你想要付出什麼作為交換？ 3 設定明確的時間 4 有一個清楚的計畫 5 列印出來並簽名 6 每天大聲唸出來兩遍 (起床的時候和要睡覺的時候) S M A R T rule Specific Measurable Attainable Realistic Time Bound：把它分為每週里程碑 做決定：速度、彈性和持續性 準備 =&gt; 決定 =&gt; 溝通 =&gt; 執行 =&gt; 衡量 做決定的四個核心標準 結果 選擇 時間框架 參與的人事物 準備：做好調查，可以減少很多投資，還有更多選擇。但是記得不要真的行動，就做調查就好 決定：最好的做法是 Consensus，但是很難執行，而且很慢。 溝通：使用適合的工具來通知 1 做了什麼決定？ 2 誰做的決定？ 3 為什麼做了這個決定？ 執行：完全取決於你 衡量：分析反應，然後適應！ 3 個做決定的迷思 CEO 決定的 在會議決定 決定一定會是最明智的 最大的問題：認知偏差 我們通常都過分自信 sunk-cost 效應 recency 效應：比較願意相信已經隨時可用的東西 克服做決定的風險 注意 鼓勵回饋 擁抱坦率 記得 專注於改正那些錯誤的決定 改善速度 瞄準 Concensus 的做法 舒適圈：它如何同時是祝福也是詛咒 你的知覺會決定怎麼體驗事情 如何修復有缺陷的知覺 了解 Map 如何形成 Map 的形成 知覺 連結 評估 決定 建構式想像：當覺得有尚未完成的潛力，那是因為有限制的信念(憤怒、噁心、害怕) 完成建構式想像 找到未完成的潛力 了解自己目前的情緒 想像自己要用什麼心情緒來達成尚未完成的潛力 口頭承諾你要改變的事情 重新規劃你自己 10 個承諾設計法則 個人的 正向的 現在式的 包含成果 關於自己的：跟自己比較，不要跟別人比較 行動 興奮的情緒 準確的 現實的 負責任的 承諾就是一種工具，他不關說話，他是關於感覺的 每天重複兩次，不然他不會有效的 帶走生產力關鍵 這些都是關於自我管理 意志力： 冥想 pause &amp; plan 原諒自己 背水一戰 動機： 為什麼？ 習慣： 關鍵 Component：cue、routine、reward、craving 建立動力 在危機時刻改變 目標設定 S.M.A.R.T 做決定 components 類型 陷阱 舒適圈、Reality Map 你的戰鬥計畫 了解為什麼？ 寫下來 有備忘錄 使用意志力創造習慣和動機 慢慢地整合新習慣 重複至少 30 天 選擇一樣東西，然後黏著它 你想要持續的效果 當準備好的時候，增加更多 這是關於你有多難受到打擊，而且持續向前行；你能花費多少，而且持續向前行。這就是成功。 完成課程","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Productivity","slug":"Productivity","permalink":"https://vincent.fishboneapps.com/tags/Productivity/"}]},{"title":"Kubernetes 快速學習自我挑戰 Day6","slug":"Kubernetes-快速學習自我挑戰-Day6","date":"2017-08-29T01:40:46.000Z","updated":"2020-06-22T17:14:44.457Z","comments":true,"path":"2017/08/28/Kubernetes-快速學習自我挑戰-Day6/","link":"","permalink":"https://vincent.fishboneapps.com/2017/08/28/Kubernetes-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day6/","excerpt":"","text":"Kubernetes 管理 Kubernetes 的 Master 服務 Kubectl 要和 REST 介面溝通，在溝通之前，要做 authorization Kubernetes 用 etcd 當作後端 Scheduler 會負責排程 pod，可以使用預設的或是外掛 資源配額 當 Kubernetes cluster 被很多人或團隊使用的時候，資源管理變得非常重要 你想要能夠管理資源，你可以給一個人或一個團隊 你不想要一個人或團隊占用 cluster 的所有資源(例如：CPU 或記憶體) 可以使用 namespaces 來分離 cluster 且在上面啟用資源配額 可以用 ResourceQuota 和 ObjectQuota objects 來實現 每一個 container 都可以指定 request capacity 和 capacity limits Request capacity 對資源來說是一種明確的請求 Scheduler 可以使用 request capacity 來決定要把 pod 放在哪裡 可以看成 pod 需要的最少資源量 Resource limit 是一種對 container 的限制規定 container 沒辦法利用比指定更多的資源 resource quotas 範例 運行一個 CPU resource request 為 200m 的 deployment 在 pod 上面 200m = 200millicpu (或是 200 millicores) 200m = 0.2 也就是運行 node 的 CPU 核心的 20% 如果 node 是雙核心，它還是只有單核心的 20% 也可以限制它，例如：400m Memory quotas 用 MiB 或 GiB 來定義 如果一個 capacity quota (例如：記憶體/cpu) 已經被管理者指定，那麼在創建 pod 的時候一定要指定 capacity quota 管理者可以為 pod 指定預設 request 值，且不需要為 capacity 指定任何值 對 limit quotas 一樣有效 如果資源被請求的次數高於允許的 capacity，伺服器 API 會丟出 403 FORBIDDEN 錯誤，且 kubectl 會顯示錯誤 管理者可以用一個 namespace 設定以下 resource limits Resource Description requests.cpu 全部 pods 的 CPU requests 總和不能超過這個值 requests.mem 全部 pods 的 MEM requests 總和不能超過這個值 requests.storage 全部 persistent volume 的 storage requests 總和不能超過這個值 limits.cpu 全部 pods 的 CPU limits 總和不能超過這個值 limits.memory 全部 pods 的 MEM limits 總和不能超過這個值 管理者可以設定以下 objects limits Resource Description configmaps 可以存在 namespace 的 configmaps 總數 persistentvolumeclaims 可以存在 namespace 的 persistent volume claims 總數 pods 可以存在 namespace 的 pods 總數 replicationcontrollers 可以存在 namespace 的 replicationcontrollers 總數 resourcequotas 可以存在 namespace 的 resource quotas 總數 services 可以存在 namespace 的 services 總數 services.loadbalancer 可以存在 namespace 的 load balancers 總數 services.nodeports 可以存在 namespace 的 nodeports 總數 secrets 可以存在 namespace 的 secrets 總數 Namespaces Namespaces 可以在 phisical cluster 裡面創建 virtual cluster Namespaces 有邏輯的分離 cluster 標準的 namespace 叫做 “default”，而且那是所有資源預設啟動的地方 另外一個為 Kubernetes 特定資源擁有的 namespace，叫做 kube-system Namespaces 是有必要的，當同時有很多團隊/專案使用 kubernetes cluster 資源名稱在一個 namespace 必須要是獨一無二的，而且不能跨越 namespaces 例如：在不同 namespaces 可以擁有叫做 “helloworld” 的 deployment 很多次，但是在一個 namespace 不能有兩次 可以使用 namespaces 來分開一個 Kubernetes cluster 的資源 你可以以每一個單一 namespace 為基礎來限制資源 例如：市場組只能使用最多 10 GiB 的記憶體、2 個 Loadbalancers、2 核心 CPU 首先，你必須要先創建一個 namespace kubectl create namespace myspace 你可以列出所有 namespaces kubectl get namespaces 如果想要設定預設 namespace 來啟動資源 export CONTENT=$(kubectl config view | awk '/current-context/ &#123;print $2&#125;') kubectl config set-context $CONTEXT --namespace=myspace 接下來可以在 namespace 建立 resource limits 1234567891011apiVersion: v1kind: ResourceQuotametadata: name: compute-resources namespace: myspacespec: hard: requests.cpu: &quot;1&quot; requests.memory: 1Gi limits.cpu: &quot;2&quot; limits.memory: 2Gi 也可以建立 object limits： 12345678910111213apiVersion: v1kind: ResourceQuotametadata: name: object-counts namespace: myspacespec: hard: configmaps: &quot;10&quot; persistentvolumeclaims: &quot;4&quot; relicationcontrollers: &quot;20&quot; secrets: &quot;10&quot; services: &quot;10&quot; services.loadbalancers: &quot;2&quot; Demo：Namespace quotas cat resourcequotas/resourcequota.yml kubectl create -f resourcequotas/resourcequota.yml cat resourcequotas/helloworld-no-quotas.yml kubectl create -f resourcequotas/helloworld-no-quotas.yml kubectl get deploy --namespace=myspace kubectl get rs --namespace=myspace kubectl describe rs/helloworld-deployment-4153696333 --namespace=myspace 會發現出現錯誤 failed quota，因為沒有指定限定資源，而本身 namespace 有限定資源 kubectl delete deploy/helloworld-deployment --namespace=myspace cat resourcequotas/helloworld-with-quotas.yml kubectl create -f resourcequotas/helloworld-with-quotas.yml kubectl get pod --namespace=myspace 這邊會發現，我明明要求三個 replicas，可是只出現兩個 kubectl get rs --namespace=myspace kubectl describe rs/helloworld-deployment-1576367412 --namespace=myspace kubectl get quota --namespace=myspace kubectl describe quota/compute-quota --namespace=myspace kubectl delete deploy/helloworld-deployment --namespace=myspace cat resourcequotas/defaults.yml kubectl describe limits limits --namespace=myspace kubectl create -f resourcequotas/helloworld-no-quotas.yml kubectl get pods --namespace=myspace User 管理 有兩種 users 可以創建 Normal user，可以外部存取 user 例如：through kubectl 這個 user 不能使用 object 來管理 Service user，可以在 Kubernetes 用 object 管理的 user 這個類型的 user 只能用在 cluster 裡面 authenticate 例如：從 pod 裡面，或從 kubelet 這些 credentials 被像是 Secrets 管理 對 normal users 有很多 authentication strategies Client Cetificates Bearer Tokens Authentication Proxy HTTP Basic Authentication OpenID Webhooks Service Users 使用 Service Account Tokens 它們被儲存為 credentials 且使用 Secrets 那些 Secrets 被掛接在 pods 裡面來讓服務之間溝通 Service Users 對 namespace 是特定的 它們被用 API 自動建立或使用 objects 手動建立 任何 API 被稱為 not authenticated 被視為 anonymous user 獨立在認證機制之外，normal users 有以下特質： 一個 Username (例如：user123 或 user@email.com) 一個 UID Groups 其它儲存其它資訊的 field 在一個 normal users authenticate 之後，他就可以存取所有東西 為了限制存取，你必須設定 authorization 以下有幾種選項可以選擇： AlwaysAllow / AlwaysDeny ABAC (Attribute-Based Access Control) RBAC (Role Based Access Control) Webhook (從遠端 service 做 authorization) Authorization 還在更新中 The ABAC 必須要手動設定 RBAC 使用 rbac.authorization.k8s.io API group 這允許 admins 可以透過 API 來動態設定權限 在 Kubernetes 1.3 RBAC 還在 alpha 而且甚至被當作實驗性的 RBAC 是很有展望的而且會變成 stable 關於 ABAC/RBAC 的目前狀況，可以參照 Kubernetes Authorization Networking Networking 的方法跟預設 Docker 設定非常不一樣 在這個課程包含： 在 pod 裡面 Container to container 的溝通 透過 localhost 和 port number Pod-To-Service 通訊 使用 NodePort 或 DNS External-To-Service 使用 LoadBalancer、NodePort 在 Kubernetes，pod 本身應該要總是可以 routeable 這是 Pod-to-Pod 通訊 Kubernetes 假設 pods 應該要能夠跟其它 pods 溝通，不論它們運行在哪個 node 上面 每一個 pod 都有它自己的 IP 位址 在不同 nodes 上的 pods 必須要能夠跟其它使用 IP 位址的 pod 溝通 在實作上會根據你的網路設定而有不同 在 AWS：kubernets networking (kops default) 每一個 pod 可以使用 AWS Virtual Private Network (VPC) 得到 routable 的 IP kubernetes master 分配一個 /24 subent 給每一個 node (254 IP 位址) 這個 subnet 會被新增到 VPCs route table 有限制 50 個 entries，也就是說，你不能夠建立超過 50 個 node 在單一 AWS cluster 雖然，AWS 可以把 limit 改到 100，但是可能會影響效能 並不是每個主機商都有 VPC-technology (雖然 GCP 和 Azure 都有) 還有其它替代方案 Container Network Interface (CNI) 軟體會提供在 containers 裡的 network interfaces 的函式庫/外掛 熱門的解決方案包含 Calico、Weave (standalone or with CNI) Overlay Network Flannel 是一個簡單又熱門的方式 Node Maintenance 這是 Node Controller，它負責管理 Node Objects 它分派 IP space 給 node，當新的 node 啟動的時候 它使可用機器的 node list 維持最新 node controller 也監控 node 的健康狀態 如果 node 不健康，它就會被刪除 Pods 運行在不健康的 node 會 rescheduled 當新增新的 node，kubelet 會企圖自行註冊 這個叫做 self-registration，而且是預設的行為 它允許你簡單的新增更多 nodes 到 cluster，且不需要自己修改 API 一個新的 node object 會自動帶有以下內容進行建立 metadata (帶有名稱：IP 或 hostname) Labels (例如：cloud region / availability zone / instance size) 一個 node 也有 node condition (例如：Ready、OutOfDisk) 當你想要 decommission 一個 node，你想要優雅地做 你要 drain 一個 node 在你關閉它或是把它拿移出 cluster 為了 drain 一個 node，可以用以下指令 kubectl drain nodename --grace-period=600 如果 nodes 運行 pods 且不受 controller 控制，那就是一個單一 pod kubectl drain nodename --force Demo：Node Maintenance kubectl create -f deployment/helloworld.yml kubectl get pod kubectl drain minikube --force kubectl get node kubectl get pod High Availability 如果想要運行 cluster 在產品上，你會想要所有的 master services 有 high availability (HA) 設置 設定會像是這樣： Clustering etcd：至少運行三個 etcd nodes 使用一個 LoadBalancer 去複製 API servers 運行很多 scheduler 和 controllers 的 instances 只有其中一個會是 leader，其它的都會 stand-by 像是 minikube 的 cluster 不需要 HA - 它是單一 node cluster 如果要在 AWS 使用產品化 cluster，kops 可以為你做 heavy lifting 如果你運行在其它雲端平台，看看針對那個平台的 kube deployment tools kubeadm 是一個 tool 可以為你設置 cluster 如果你使用某個平台且不使用任何工具，可以看看文件來自行實作 Demo：High Availability kops create cluster --name=kubernetes.appsoliloquy.com --state=s3://kops-state-qq123 --zones=ap-southeast-2a,ap-southeast-2b,ap-southeast-2c --node-count=2 --node-size=t2.micro --master-size=t2.micro --dns-zone=kubernetes.appsoliloquy.com --master-zones=ap-southeast-2a,ap-southeast-2b,ap-southeast-2c kops edit ig --name=kubernetes.appsoliloquy.com nodes --state=s3://kops-state-qq123 kops edit ig --name=kubernetes.appsoliloquy.com master-ap-southeast-2a --state=s3://kops-state-qq123 kops edit ig --name=kubernetes.appsoliloquy.com master-ap-southeast-2b --state=s3://kops-state-qq123 完成課程","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://vincent.fishboneapps.com/tags/Kubernetes/"}]},{"title":"Kubernetes 快速學習自我挑戰 Day5","slug":"Kubernetes-快速學習自我挑戰-Day5","date":"2017-08-21T16:46:53.000Z","updated":"2020-06-22T17:14:41.694Z","comments":true,"path":"2017/08/21/Kubernetes-快速學習自我挑戰-Day5/","link":"","permalink":"https://vincent.fishboneapps.com/2017/08/21/Kubernetes-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day5/","excerpt":"","text":"進階的主題 Volumes Autoprovisioning Kubernetes plugins 可以提供 storage AWS Plugin 可以藉由在 AWS 創建 volumes 來提供 storage，但是要在 volume 連接到 node 之前才能做 這些可以使用 StorageClass object 來完成 Documentation 使用 auto provisioned volumes，可以創建以下 yaml 檔案： storage.yml 12345678kind: StorageClassapiVersion: storage.k8s.io/v1beta1metadata: name: standardprovisioner: kubernetes.io/aws-ebsparameters: type: gp2 zone: us-east-1 這樣可以創建 volume 並宣告使用 aws-ebs provisioner Kubernetes 將會提供 type gp2 的 volume (一般用途 - SSD) 接下來，可以創建 volume 並宣告和指定容量 my-volume.claim.yml 123456789101112kind: PersistentVolumeClaimapiVersion: v1metadata: name: myclaim annotations: volume.beta.kubernetes.io/storage-class: &quot;standard&quot;spec: accessModes: - ReadWriteOnce resources: requests: storage: 8Gi 最後，可以使用 volume 來啟動 pod my-pod.yml 123456789101112131415kind: PodapiVersion: v1metadata: name: mypodspec: containers: - name: myfrontend image: nginx volumeMounts: - mountPath: &quot;/var/www/html&quot; name: mypd volumes: - name: mypd persistentVolumeClaim: claimName: myclaim Demo：使用 Volumes 的 WordPress cd wordpress-volumes cat storage.yml cat pv-claim.yml cat wordpress-db.yml cat wordpress-db-service.yml cat wordpress-secrets.yml cat wordpress-web.yml cat wordpress-web-service.yml 查詢 AWS 服務區域 aws efs create-file-system --creation-token 1 --region ap-southeast-2 找尋 SubnetId 和 SecurityGroups aws ec2 describe-instances --region ap-southeast-2 aws efs create-mount-target --file-system-id fs-518f6c68 --subnet-id subnet-5ed8c73a --security-groups sg-5154a737 --region ap-southeast-2 修改倒數第二行的 server vim wordpress-web.yml kubectl create -f storage.yml kubectl create -f pv-claim.yml kubectl create -f wordpress-secrets.yml kubectl create -f wordpress-db.yml kubectl create -f wordpress-db-service.yml kubectl get pvc kubectl get pod kubectl describe pod wordpress-db-8n665 kubectl create -f wordpress-web.yml kubectl create -f wordpress-web-service.yml 去 Route53 新增一個 DNS record - wordpress.，在 alias 的地方打勾，選擇剛剛建立的 LoadBalancer kubectl edit deployment/wordpress-deployment 把以下五行加到 35 行之後，把後面 env 縮排進去並刪除 -，完成之後就發現 wordpress 可以上傳圖片了 123456- command: - bash - -c - chown www-data:www-data /var/www/html/wp-content/uploads &amp;&amp; docker-entrypoint.sh apache2-foreground env: - name: kubectl get pod 刪除所有的 pod，就會發現會全部自動重啟 kubectl delete pod wordpress-db-5cgvm kubectl delete pod/wordpress-deployment-1534735485-71kjs kubectl delete pod wordpress-deployment-1534735485-j74hb kubectl get pod，再一次 get pod 就會發現 pod 全部重啟了 kubectl logs wordpress-deployment-1534735485-0wtxq kubectl exec wordpress-deployment-1534735485-0wtxq -i -t -- bash ls -ahl -R wp-content/uploads/ 會發現檔案都還在 Pet Sets Pet Sets 是從 Kubernetes 1.3 之後開始的新功能 要執行 stateful application 需要： 一個穩定的 pod hostname(取代 podname-randomstring) 當一個 pod 有很多 instances，podname 需要有索引(例如：podname-1、podname-2、podname-3) 一個 stateful app 需要基於序號數(podname-x)或 hostname 的多個有 volumes 的 pods 目前刪除和/或擴展一個 PetSet down不會刪除跟 PetSet 有關連的 Volume 一個 PetSet 允許 stateful app 使用 DNS 找尋其它同伴 Cassandra clusters、ElasticSearch clusters 使用 DNS 來找到其它 cluster 的 members 在 Pet Set 之中一個運行中的 node 叫做 一個 Pet (例如：Cassandra 中的一個 node) 舉例來說： 在 Kubernetes 上使用 Pet Sets 的五個 cassandra nodes，可以命名為 cassandra-1 到 cassandra-5 如果不使用 Pet Sets，可以用取得一個動態 hostname 的方式，而這個方式不能夠使用在設定檔，因為設定檔可以隨時修改名字 一個 PetSet 也允許 stateful app 排序啟動和關閉的 pets： 取代隨機終止一個 Pet (app 中的一個 instance)，你會知道哪一個會不見 當在可以關閉之前，第一次需要從一個 node 倒出資料的時候，這很有用 在 PetSets 依然還很多未來工作需要完成 Daemon Sets Daemon Sets 確保 Kubernetes cluster 的每一個 node 運行相同的 pod 資源 如果你想要確保特定 pod 運行在每一個 Kubernetes node，這個非常有用 當一個 node 被新增到 cluster，新的 pod 就會自動被啟動 同樣地，當一個 node 被移除，pod 將不會在其它 node 進行再排程 典型的應用例子 Logging aggregators Monitoring Load Balancers / Reverse Proxies / API Gateways 運行一個 daemon 在每一個 physical instance 只需要一個 instance 監控資源用量 Heapster 能夠監控 Container Cluster 和效能分析 它提供了 Kubernetes 的監控平台 它是必要的，如果想要在 Kubernetes 使用 pod auto-scaling Heapster 透過 REST endpoint 輸出 cluster metrics 可以與 Heapster 使用不同的後端 範例會使用 InfluxDB，但是其它像是 Google Cloud Monitoring/Logging 和 Kafka 也是可以的 Visualizations (圖像) 可以使用 Grafana 表現 Kubernetes 儀表板只要 monitoring 啟動就可以顯示圖表 所有的這些技術(Heapster、InfluxDB 和 Grafana)都可以在 pods 裡面啟動 YAML 檔案可以在 Heapster 的 github repository 被找到 在下載完 repository 之後，平台可以使用 addon system 或使用 kubectl create -f directory-with-yaml-files/ 來部署 Demo：監控資源用量 git clone https://github.com/kubernetes/heapster.git 後改用 1.3 版本 cd heapster/deploy/kube-config/influxdb vim grafana.yaml 把這行註解掉 kubernetes.io/cluster-service: 'true' vim heapster.yaml 把這行註解掉 kubernetes.io/cluster-service: 'true' vim influxdb.yaml 把這行註解掉 kubernetes.io/cluster-service: 'true' cd .. kubectl create -f influxdb kubectl create -f kubernetes-course/deployment/helloworld.yml minikube service monitoring-grafana --namespace=kube-system --url 進去 Grafana 之後，選擇左列選單，選擇 Sign In，然後就可以選擇 cluster 或是 pod 觀看目前的狀態 Autoscaling Kubernetes 可以基於 metrics 來自動 scale pods Kubernetes 可以自動 scale 一個 Deployment、Replication Controller 或 ReplicaSet 在 Kubernetes 1.3 版本後，根據 CPU 用量 scaling 是可以使用的 有 alpha 的支持，基於 metrics 的 application 是可用的 (像是每秒取得或平均請求延遲) 要啟動這個，cluster 必須要設 env 變數裡面的 ENABLE_CUSTOM_METRICS 為 true 來啟動 Autoscaling 會對目標 pods 定期取得用量 預設是 30 秒，可以在啟動 controller-manager 使用 --horizontal-pod-autoscaler-sync-period 來修改 Autoscaling 會使用監控工具 heapster 來收集它們的 metrics 和決定如何 scaling Heapster 必須要在 autoscaling work 之前安裝並運行 例子 運行一個 200m 的 CPU 資源請求的 pod 並在 pod 運行一個 deployment 200m = 200 millicpu (或是 200 millicores) 200m = 0.2 也就是運行 node 的 CPU 核心的 20% 如果 node 是雙核心，它還是只有單核心的 20% 可以採用 CPU 用量為 50% 的 autoscaling (也就是 100m) 水平 Pod Autoscaling 可以增加/減少 pods 來維持目標 CPU 用量為 50%(或是 100m/在 pod 裡面一個核心10%) 測試 autoscaling 1234567891011121314151617181920apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: hpa-examplespec: replicas: 3 template: metadata: labels: app: hpa-example spec: containers: - name: hpa-example image: gcr.io/google_containers/hpa-example ports: - name: http-port containerPort: 80 resources: requests: cpu: 200m autoscaling specification 範例 123456789101112apiVersion: autoscaling/v1kind: HorizontalPodAutoscalermetadata: name: hpa-example-autoscalerspec: scaleTargetRef: apiVersion: extensions/v1beta1 kind: Deployment name: hpa-example minReplicas: 1 maxReplicas: 10 targetCPUUtilizationPercentage: 50 Demo：Autoscaling cat autoscaling/hpa-example.yml minikube stop minikube start --extra-config kubelet.EnableCustomMetrics=true kubectl create -f autoscaling/hpa-example.yml kubectl get hpa kubectl run -i --tty load-generator --image=busybox /bin/sh wget http://hpa-example.default.svc.cluster.local:31001 cat index.html rm index.html while true; do wget -q -O- http://hpa-example.default.svc.cluster.local:31001; done kubectl get pod，這時候可以看出他會建立很多個 kubectl get hpa 觀看使用狀態","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://vincent.fishboneapps.com/tags/Kubernetes/"}]},{"title":"Kubernetes 快速學習自我挑戰 Day4","slug":"Kubernetes-快速學習自我挑戰-Day4","date":"2017-08-20T06:27:44.000Z","updated":"2020-06-22T17:14:39.032Z","comments":true,"path":"2017/08/20/Kubernetes-快速學習自我挑戰-Day4/","link":"","permalink":"https://vincent.fishboneapps.com/2017/08/20/Kubernetes-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day4/","excerpt":"","text":"進階的主題 深入 Service 在 Kubernets 1.3，DNS 是一個內建的 service 且會自動使用 addon 管理器啟動 addon 在 master node 的 etc/kubernetes/addons 目錄 DNS 服務可以在 pod 裡面被使用，且找到其它服務運行在相同的 cluster 上 在一個 pod 中的很多 containers 的架構不需要這種 service，因為它們可以直接互相聯繫 在相同 pod 中的 container 可以使用 localhost:port 為了要讓 DNS 可以運作，pod 需要 Service Definition Demo：深入 Service cat service-discovery/secrets.yml kubectl create -f service-discovery/secrets.yml cat service-discovery/database.yml cat service-discovery/database-service.yml kubectl create -f service-discovery/database.yml kubectl create -f service-discovery/database-service.yml cat service-discovery/helloworld-db.yml 這邊會發現 env 下的 value: database-service，因為在創建 database-service.yml 的 metadata name 也是使用這個名稱 kubectl create -f service-discovery/helloworld-db.yml kubectl create -f service-discovery/helloworld-db-service.yml minikube service helloworld-db-service --url kubectl get pods 確認是否連線到資料庫 kubectl logs helloworld-deployment-2141920616-5bzp0 curl 剛剛取得的 ip curl http://192.168.99.100:30888 kubectl exec database -i -t -- mysql -u root -p 密碼是 rootpassword show databases; use helloworld show tables; select * from visits; \\q kubectl run -i --tty busybox --image=busybox --restart=Never -- sh nslookup helloworld-db-service nslookup database-service telnet helloworld-db-service 3000 kubectl delete pod busybox ConfigMap 設定參數不是秘密，可以放在 ConfigMap Input 是重複的 key-value pairs ConfigMap key-value pairs 可以被 app 讀取，使用： 環境變數 在 Pod 設定裡面的 Container commandline arguments 使用 voulmes ConfigMap 也可以包含 full configuration 檔案 例如：網頁伺服器的 config 檔案 這些檔案可以被使用 volumes 的方式掛接，而 volumes 正是 application 放置 config file 的地方 這樣的方法可以輸入配置設置到 containers 裡面，而不需要改變 container 本身 使用檔案產生 ConfigMap 123456driver=jdbcdatabase=postgreslookandfeel=1otherparams=xyzparam.with.hierarchy=xyzEOF kubectl create configmap app-config --from-file=app.properties 8. 可以使用 volume 來 expose ConfigMap 的方式創建 pod 1234567891011121314151617181920apiVersion: v1kind: Podmetadata: name: nodehelloworld.example.com labels: app: helloworldspec: containers: - name: k8s-demo image: wardviaene/k8s-demo ports: - containerPort: 3000 volumeMounts: - name: config-volume // config 檔案會被存在 /ect/config/driver、/etc/config/param/with/hierarchy mountPath: /etc/config volumes: - name: config-volume configMap: name: app-config 可以使用環境變數來 expose ConfigMap 的方式創建 pod 1234567891011121314151617181920apiVersion: v1kind: Podmetadata: name: nodehelloworld.example.com labels: app: helloworldspec: containers: - name: k8s-demo image: wardviaene/k8s-demo ports: - containerPort: 3000 env: - name: DRIVER valueFrom: configMapKeyRef: name: app-config key: driver - name: DATABASE [...] Demo：ConfigMap cat configmap/reverseproxy.conf kubectl create configmap nginx-config --from-file=configmap/reverseproxy.conf kubectl get configmap kubectl get configmap nginx-config -o yaml cat configmap/nginx.yml kubectl create -f configmap/nginx.yml kubectl create -f configmap/nginx-service.yml minikube service helloworld-nginx-service --url curl http://192.168.99.100:31965 -vvv kubectl exec -i -t helloworld-nginx -c nginx -- bash ps x cat /etc/nginx/conf.d/reverseproxy.conf Ingress Controller Ingress 是一個從 Kubernetes 1.1 之後可用的解決方案，用來允許 inbound connections 給 cluster 它是 external Loadbalancer 和 nodePorts 的替代方案 Ingress 允許簡單的 expose services，如果 services 需要從 cluster 外部 存取 如果有 Ingress 就可以在 Kubernetes 運行自己的 ingress controller (基本上就是 loadbalancer) 有預設的 ingress controllers 可以使用，或是也可以寫自己的 ingress controller 可以使用 ingress object 來創建 ingress rules 1234567891011121314151617181920apiVersion: extensions/v1beta1kind: ingressmetadata: name: helloworld-rulesspec: rules: - host: helloworld-v1.example.com http: paths: - path: / backend: serviceName: helloworld-v1 servicePort: 80 - host: hellowrld-v2.example.com http: paths: - path: / backend: serviceName: helloworld-v2 servicePort: 80 Demo：Ingress Controller cat ingress/nginx-ingress-controller.yml cat ingress/ingress.yml kubectl create -f ingress/ingress.yml kubectl create -f ingress/nginx-ingress-controller.yml kubectl create -f ingress/echoservice.yml kubectl create -f ingress/helloworld-v1.yml kubectl create -f ingress/helloworld-v2.yml helloworld-v2 和 v1 的差別在於 image 版本 minikube ip curl 192.168.99.100 curl 192.168.99.100 -H 'Host: helloworld-v1.example.com' curl 192.168.99.100 -H 'Host: helloworld-v2.example.com' kubectl get svc Volumes Kubernetes 裡面的 Volumes 用來儲存 container 之外的 data 當 container 停止，所有在 container 裡面的資料會 不見 這正是為什麼我們一直執行 stateless 的 apps：apps 不會保留 本地 state，但是會儲存它們的 state 到 外部 service 外部 Service 像是 database，快取伺服器 (例如：MySQL、AWS S3) Kubernetes 裡面的 Persistent Volumes 可以 連接一個 volume 到 container，而檔案會繼續存在就算 container 停止 Volumes 可以使用不同的 volume plugins 來連接 本地 Volume AWS Cloud：EBS Storage Google Cloud：Google Disk 網路儲存空間：NFS、Cephfs Microsoft Cloud：Azure Disk 使用 Volumes 可以在 cluster 上部署 application with state 這些應用必須要在本地檔案系統讀/寫檔案，而且需要持續存在 可以運行 MySQL 資料庫且使用 persistent volumes 雖然這還沒準備好產品化 Volumes 是 Kubernetes 在 2016 年 6 月發佈的，所以還很新，關於這個部分還需要多加注意 如果 node 停止運行，pod 會重新排程到另外一個 node，然後 volume 可以被連接到新的 node 使用 volumes 必須要先創建 volume 使用 volumes 必須要創建有 volume definition 的 pod Demo：Volumes aws ec2 create-volume --size 10 --region ap-northeast-1 --availability-zone ap-northeast-1a --volume-type gp2 把剛剛拿到的 VolumeId 貼近去 vim volumes/helloworld-with-volume.yml kubectl create -f volumes/helloworld-with-volume.yml kubectl get pod kubectl describe pod helloworld-deployment-2277790027-3c1q2 kubectl exec helloworld-deployment-2277790027-3c1q2 -i -t -- bash ls -ahl /myvol/ echo 'test' &gt; /myvol/myvol.txt echo 'test2' &gt; /test.txt kubectl drain ip-172-20-49-46.ap-northeast-1.compute.internal --force kubectl get pod kubectl exec helloworld-deployment-2277790027-ll7w0 -i -t -- bash ls -ahl /myvol/myvol.txt ls -ahl /test.txt =&gt; 這會找不到，因為沒有存在 volume，而是存在 container kubectl delete -f volumes/helloworld-with-volume.yml aws ec2 delete-volume --volume-id vol-0ae6788e2541f0252 --region ap-northeast-1","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://vincent.fishboneapps.com/tags/Kubernetes/"}]},{"title":"React Native 快速學習自我挑戰 Day6","slug":"React-Native-快速學習自我挑戰-Day6","date":"2017-08-18T11:54:13.000Z","updated":"2020-06-22T17:22:47.161Z","comments":true,"path":"2017/08/18/React-Native-快速學習自我挑戰-Day6/","link":"","permalink":"https://vincent.fishboneapps.com/2017/08/18/React-Native-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day6/","excerpt":"","text":"深入了解 Redux Redux 的基礎 建立新專案 react-native init tech_stack JSPlaygrounds Reducer：一個可以回傳一些資料的 function Action：一個告訴 reducer 如何改變它的資料的物件 State：給 app 使用的資料 更多 Redux 簡易 Redux 範例 123456789101112131415161718192021222324252627282930const reducer = (state = [], action) =&gt; &#123; if (action.type === &#x27;split_string&#x27;) &#123; return action.payload.split(&#x27;&#x27;); &#125; else if (action.type === &#x27;add_character&#x27;) &#123; return [ ...state, action.payload ]; &#125; return state;&#125;;const store = Redux.createStore(reducer);store.getState();const action = &#123; type: &#x27;split_string&#x27;, payload: &#x27;asdf&#x27;&#125;;store.dispatch(action);store.getState();const action2 = &#123; type: &#x27;add_character&#x27;, payload: &#x27;d&#x27;&#125;;store.dispatch(action2);store.getState(); Application 樣板 安裝 redux npm install --save redux react-redux 新增 src/app.js 12345678910import React from &#x27;react&#x27;;import &#123; View &#125; from &#x27;react-native&#x27;;const App = () =&gt; &#123; return ( &lt;View /&gt; );&#125;;export default App; 刪除 ios.index.js 的所有內容，用以下取代 1234import &#123; AppRegistry &#125; from &#x27;react-native&#x27;;import App from &#x27;./src/app&#x27;;AppRegistry.registerComponent(&#x27;tech_stack&#x27;, () =&gt; App ); 在 app.js 引入函式庫 12import &#123; Provider &#125; from &#x27;react-redux&#x27;;import &#123; createStore &#125; from &#x27;redux&#x27;; 新增 src/reducers/index.js 12345import &#123; combineReducers &#125; from &#x27;redux&#x27;;export default combineReducers(&#123; libraries: () =&gt; []&#125;); 引入 reducers，將 reducers 放到 createStore 裡面 123456789import reducers from &#x27;./reducers&#x27;;const App = () =&gt; &#123; return ( &lt;Provider store=&#123;createStore(reducers)&#125;&gt; &lt;View /&gt; &lt;/Provider&gt; );&#125;; 渲染 Header 新增 src/components/common，把舊檔案複製進去 引入 Header import &#123; Header &#125; from './components/common'; 使用 Header 123456789const App = () =&gt; &#123; return ( &lt;Provider store=&#123;createStore(reducers)&#125;&gt; &lt;View&gt; &lt;Header headerText=&quot;Tech Stack&quot; /&gt; &lt;/View&gt; &lt;/Provider&gt; );&#125;; Data 的 Library List 新增 src/reducers/LibraryReducer.js export default () =&gt; []; 在 reducers/index.js 引入 LibraryReducer.js 123456import &#123; combineReducers &#125; from &#x27;redux&#x27;;import LibraryReducer from &#x27;./LibraryReducer&#x27;;export default combineReducers(&#123; libraries: LibraryReducer&#125;); 新增 src/reducers/LibraryList.json 1234567891011121314151617181920212223242526272829303132333435363738[ &#123;&quot;id&quot;: 0, &quot;title&quot;: &quot;Webpack&quot;, &quot;description&quot;: &quot;Webpack is a module bundler. It packs CommonJs/AMD modules i. e. for the browser. Allows to split your codebase into multiple bundles, which can be loaded on demand.&quot; &#125;, &#123;&quot;id&quot;: 1, &quot;title&quot;: &quot;React&quot;, &quot;description&quot;: &quot;React makes it painless to create interactive UIs. Design simple views for each state in your application, and React will efficiently update and render just the right components when your data changes.&quot; &#125;, &#123;&quot;id&quot;: 2, &quot;title&quot;: &quot;Redux&quot;, &quot;description&quot;: &quot;Redux is a predictable state container for JavaScript apps. It helps you write applications that behave consistently, run in different environments (client, server, and native), and are easy to test.&quot; &#125;, &#123;&quot;id&quot;: 3, &quot;title&quot;: &quot;React-Redux&quot;, &quot;description&quot;: &quot;React-Redux is the official set of bindings between the React and Redux libraries. With this library you can keep your views and data in sync.&quot; &#125;, &#123;&quot;id&quot;: 4, &quot;title&quot;: &quot;Lodash&quot;, &quot;description&quot;: &quot;A modern JavaScript utility library delivering modularity, performance, &amp; extras. Lodash is released under the MIT license &amp; supports modern environments.&quot; &#125;, &#123;&quot;id&quot;: 5, &quot;title&quot;: &quot;Redux-Thunk&quot;, &quot;description&quot;: &quot;Redux Thunk middleware allows you to write action creators that return a function instead of an action. The thunk can be used to delay the dispatch of an action, or to dispatch only if a certain condition is met.&quot; &#125;, &#123;&quot;id&quot;: 6, &quot;title&quot;: &quot;ESLint&quot;, &quot;description&quot;: &quot;ESLint is an open source JavaScript linting utility originally created by Nicholas C. Zakas in June 2013. Code linting is a type of static analysis that is frequently used to find problematic patterns or code that doesn&#x27;t adhere to certain style guidelines.&quot; &#125;, &#123;&quot;id&quot;: 7, &quot;title&quot;: &quot;Babel&quot;, &quot;description&quot;: &quot;Babel has support for the latest version of JavaScript through syntax transformers. These plugins allow you to use new syntax, right now without waiting for browser support.&quot; &#125;, &#123;&quot;id&quot;: 8, &quot;title&quot;: &quot;Axios&quot;, &quot;description&quot;: &quot;Promise based HTTP client for the browser and node.js. With Axios, you can make XMLHttpRequests from the browser or Node with the full Promise Api.&quot; &#125;] The Connect Function 引入 json 的資料，然後輸出 123import data from &#x27;./LibraryList.json&#x27;;export default () =&gt; data; 新增 src/components/LibraryList.js，在這邊有一點要注意，可以直接引入 json 來使用，但是在 redux 不能這樣用 12345678910import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123; connect &#125; from &#x27;react-redux&#x27;;class LibraryList extends Component &#123; render() &#123; return; &#125;&#125;export default connect()(LibraryList); Connect 與 MapStateToProps 在 LibraryList.js 新增 mapStateToProps function 123const mapStateToProps = state =&gt; &#123; return &#123; libraries: state.libraries &#125;;&#125;; 在 LibraryList 裡面 console，會看到物件和 dispatch 123456class LibraryList extends Component &#123; render() &#123; console.log(this.props); return; &#125;&#125; 用正確的方法渲染 List 實作 ListView 引入 ListView，然後用 componentWillMount 來取得值，最後送到 ListView 123456789101112131415161718192021222324import &#123; ListView &#125; from &#x27;react-native&#x27;;class LibraryList extends Component &#123; componentWillMount() &#123; const ds = new ListView.DataSource(&#123; rowHasChanged: (r1, r2) =&gt; r1 !== r2 &#125;); this.dataSource = ds.cloneWithRows(this.props.libraries); &#125; renderRow() &#123; &#125; render() &#123; return ( &lt;ListView dataSource=&#123;this.dataSource&#125; renderRow=&#123;this.renderRow&#125; /&gt; ); &#125;&#125; 渲染單一的列 新增 ListItem.js 123456789import React, &#123; Component &#125; from &#x27;react&#x27;;class ListItem extends Component &#123; render() &#123; &#125;&#125;export default ListItem; 在 LibraryList.js 引入 ListItem，然後放在 renderRow 裡面，並傳入 props 叫做 Library 12345import ListItem from &#x27;./ListItem&#x27;;renderRow(library) &#123; return &lt;ListItem library=&#123;library&#125; /&gt;;&#125; 美化 List 引入 CardSection，然後讓接收上一層傳過來的值並顯示它 123456789101112131415import &#123; CardSection &#125; from &#x27;./common&#x27;;class ListItem extends Component &#123; render() &#123; const &#123; titleStyle &#125; = styles; return ( &lt;CardSection&gt; &lt;Text style=&#123;titleStyle&#125;&gt; &#123;this.props.library.title&#125; &lt;/Text&gt; &lt;/CardSection&gt; ); &#125;&#125; 新增樣式 123456const styles = &#123; titleStyle: &#123; fontSize: 18, paddingLeft: 15 &#125;&#125;; 在 app.js 的 View 新增 flex 1 的樣式，讓 List 可以在整頁滾動 &lt;View style=&#123;&#123;\"&#123;&#123; flex: 1 \"&#125;&#125;&#125;&#125;&gt; 創建 Selection Reducer 新增 src/reducers/SelectionReducer.js，在畫面產生的時候，預設不要選任何東西，所以送出 null 123export default () =&gt; &#123; return null;&#125;; 在 reducer/index.js 把 SelectionReducer 加入 123456import SelectionReducer from &#x27;./SelectionReducer&#x27;;export default combineReducers(&#123; libraries: LibraryReducer, selectedLibraryId: SelectionReducer&#125;); 介紹 Action Creator 在 Component 裡面用 Action Creator 呼叫 Action，Action 會去要求 Reducer 改變值 新增 src/actions/index.js 123456export const selectLibrary = (libraryId) =&gt; &#123; return &#123; type: &#x27;select_library&#x27;, payload: libraryId &#125;;&#125;; 呼叫 Action Creators 在 ListItem.js 引入所有 actions import * as actions from '../actions'; 在 ListItem.js 引入 connect，connect 的第一個參數是傳入的 props 值，目前沒有要傳東西，所以用 null，第二個參數是 actions，最後把 action 傳入 ListItem 的 component 123import &#123; connect &#125; from &#x27;react-redux&#x27;;export default connect(null, actions)(ListItem); 新增 Touchable 元件 在 ListItem.js 引入 TouchableWithoutFeedback 和 View import &#123; Text, TouchableWithoutFeedback, View &#125; from 'react-native'; 把 TouchableWithoutFeedback 和 View 加到元件裡面，onPress 之後，使用 action 1234567891011121314151617181920class ListItem extends Component &#123; render() &#123; const &#123; titleStyle &#125; = styles; const &#123; id, title &#125; = this.props.library; return ( &lt;TouchableWithoutFeedback onPress=&#123;() =&gt; this.props.selectLibrary(id)&#125; &gt; &lt;View&gt; &lt;CardSection&gt; &lt;Text style=&#123;titleStyle&#125;&gt; &#123;title&#125; &lt;/Text&gt; &lt;/CardSection&gt; &lt;/View&gt; &lt;/TouchableWithoutFeedback&gt; ); &#125;&#125; Reducer 的規則 修改 SelectionReducer.js，如果選到東西就回傳 id，如果沒有就回傳現在的 state 12345678export default (state = null, action) =&gt; &#123; switch (action.type) &#123; case &#x27;select_library&#x27;: return action.payload; default: return state; &#125;&#125;; 展開列 新增 mapStateToProps 回傳 object，然後會用 props 的形式放到 component 裡面，state.selectedLibraryId 是從 reducer/index.js 裡面取得的，最後將 mapStateToProps 和 actions 放在一起，就可以比較 selectedLibraryId 和 library.id 是不是一樣，一樣的話就展開 12345const mapStateToProps = state =&gt; &#123; return &#123; selectedLibraryId: state.selectedLibraryId &#125;;&#125;;export default connect(mapStateToProps, actions)(ListItem); 在 ListItem 的元件新增 renderDescription function 比較選擇的和本來的一不一樣，一樣就展開 123456789renderDescription() &#123; const &#123; library, selectedLibraryId &#125; = this.props; if (library.id === selectedLibraryId) &#123; return ( &lt;Text&gt;&#123;library.description&#125;&lt;/Text&gt; ); &#125;&#125; 最後把 renderDescription 放到 Component 裡面 12345678&lt;View&gt; &lt;CardSection&gt; &lt;Text style=&#123;titleStyle&#125;&gt; &#123;title&#125; &lt;/Text&gt; &lt;/CardSection&gt; &#123;this.renderDescription()&#125;&lt;/View&gt; 將邏輯移出 Component mapStateToProps 引入第二個參數 ownProps，它等於 this.props，所以最後可以用 expanded 簡化，它只會回傳 true 或 false 12345const mapStateToProps = (state, ownProps) =&gt; &#123; const expanded = state.selectedLibraryId === ownProps.library.id; return &#123; expanded &#125;;&#125;; 修改 renderDescription 123456789renderDescription() &#123; const &#123; library, expanded &#125; = this.props; if (expanded) &#123; return ( &lt;Text&gt;&#123;library.description&#125;&lt;/Text&gt; ); &#125;&#125; 動畫 在 renderDescription 加入 CardSection 讓版面更漂亮 123&lt;CardSection&gt; &lt;Text&gt;&#123;library.description&#125;&lt;/Text&gt;&lt;/CardSection&gt; 引入 LayoutAnimation 123456import &#123; Text, TouchableWithoutFeedback, View, LayoutAnimation&#125; from &#x27;react-native&#x27;; 在 ListItem 的 Component 加入 componentWillUpdate 123componentWillUpdate() &#123; LayoutAnimation.spring();&#125; 流程：User 點擊 Library =&gt; 呼叫 Action Creator =&gt; Action Creator 回傳 Action，然後傳到 Reducers =&gt; 新狀態會傳到 mapstateToProps =&gt; Components 重新渲染 =&gt; View 就會更新","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"https://vincent.fishboneapps.com/tags/React-Native/"}]},{"title":"React Native 快速學習自我挑戰 Day5","slug":"React-Native-快速學習自我挑戰-Day5","date":"2017-08-17T08:39:32.000Z","updated":"2020-06-22T17:22:44.652Z","comments":true,"path":"2017/08/17/React-Native-快速學習自我挑戰-Day5/","link":"","permalink":"https://vincent.fishboneapps.com/2017/08/17/React-Native-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day5/","excerpt":"","text":"處理 Authentication Credentials 讓 User 登入 在送出 button 地方，要取得值之後，做 callback function 在送出的 button 加上 onPress 來取得值 &lt;Button onPress=&#123;this.onButtonPress.bind(this)&#125;&gt; 在 LoginForm.js 引入 firebase import firebase from 'firebase'; 新增 onButtonPress 的 callback function 12345onButtonPress() &#123; const &#123; email, password &#125; = this.state; firebase.auth().signInWithEmailAndPassword(email, password); &#125; 登入的三種模式 登入 =&gt; 成功 登入 =&gt; 失敗 =&gt; 創建帳號 =&gt; 成功 登入 =&gt; 失敗 =&gt; 創建帳號 =&gt; 失敗 =&gt; 出現錯誤 錯誤處理 點擊之後，用 catch 來處理失敗的 Promise，最後顯示出 error，error 要新增一個空白的 state 讓它去改變 12345678910111213state = &#123; email: &#x27;&#x27;, password: &#x27;&#x27;, error: &#x27;&#x27; &#125;; onButtonPress() &#123; const &#123; email, password &#125; = this.state; firebase.auth().signInWithEmailAndPassword(email, password) .catch(() =&gt; &#123; firebase.auth().createUserWithEmailAndPassword(email, password) .catch(() =&gt; &#123; this.setState(&#123; error: &#x27;Authentication Failed.&#x27;&#125;) &#125;); &#125;); &#125; 把 Text 補回來，因為要讓 error 顯示 import &#123; Text &#125; from 'react-native'; 新增 Text 區塊來顯示 error 123&lt;Text style=&#123;styles.errorTextStyle&#125;&gt; &#123;this.state.error&#125;&lt;/Text&gt; 新增 error Text 的 style 樣式 1234567const styles = &#123; errorTextStyle: &#123; fontSize: 20, alignSelf: &#x27;center&#x27;, color: &#x27;red&#x27; &#125;&#125;; 更多 Authentication Flow 在登入錯誤的密碼之後，如果又正確登入，要把錯誤訊息移除，所以要在 onPress 的 callback function 裡面把 state 設為預設空值 this.setState(&#123;error: ''&#125;); 為了要讓送出的時候，等候存取資料庫回覆前，要做一個旋轉圖示 Spinner 讓用戶知道在等候，新增 src/components/Spinner.js 12345678910import React from &#x27;react&#x27;;import &#123; View &#125; from &#x27;react-native&#x27;;const Spinner = () =&gt; &#123; return ( &lt;View /&gt; );&#125;;export &#123; Spinner &#125;; 在 components/index.js 新增 component export * from './Spinner'; 建立一個活動 Spinner 新增 ActivityIndicator import &#123; View, ActivityIndicator &#125; from 'react-native'; 新增 spinner styles 1234567const styles = &#123; spinnerStyle: &#123; flex: 1, justifyContent: &#x27;center&#x27;, alignItems: &#x27;center&#x27; &#125;&#125;; 將 style 加到 View，然後從上層元件取得 size props，最後用預設的方式，如果沒有 size 的 props，預設 large 1234567const Spinner = (&#123; size &#125;) =&gt; &#123; return ( &lt;View style=&#123;styles.spinnerStyle&#125;&gt; &lt;ActivityIndicator size=&#123;size || &#x27;large&#x27;&#125; /&gt; &lt;/View&gt; );&#125;; JSX 中有條件的渲染 預設不顯示 loading state = &#123; email: '', password: '', error: '', loading: false &#125;; 在 onButtonPress 的 callback function 加上 loading true，做法就是在點選登入時，清掉所有錯誤，然後顯示 Loading this.setState(&#123;error: '', loading: true &#125;); 把 Spinner 的元件也 load 進來 import &#123; Button, Card, CardSection, Input, Spinner &#125; from &quot;./common&quot;; 新增一個 renderButton 的 function，如果 this.state.loading === true，就 return spinner，如果不是，就 return 本來的 Button 1234567891011renderButton() &#123; if (this.state.loading) &#123; return &lt;Spinner size=&quot;small&quot; /&gt;; &#125; return ( &lt;Button onPress=&#123;this.onButtonPress.bind(this)&#125;&gt; 登入 &lt;/Button&gt; )&#125; 最後把本來送出 Button 的地方用 renderButton 的 function 取代 123&lt;CardSection&gt; &#123;this.renderButton()&#125;&lt;/CardSection&gt; 清除表單 Spinner 建立 LoginSuccess function 12345678onLoginSuccess() &#123; this.setState(&#123; email: &#x27;&#x27;, password: &#x27;&#x27;, loading: false, error: &#x27;&#x27; &#125;);&#125; 建立 LoginFail function 123onLoginFail() &#123; this.setState(&#123; error: &#x27;Authentication Failed&#x27;, loading: false &#125;);&#125; 送出表單時候，正確的話，執行 .then 裡面的 function，錯誤的話，執行 .catch 裡面的 function 1234567firebase.auth().signInWithEmailAndPassword(email, password) .then(this.onLoginSuccess.bind(this)) .catch(() =&gt; &#123; firebase.auth().createUserWithEmailAndPassword(email, password) .then(this.onLoginSuccess.bind(this)) .catch(this.onLoginFail.bind(this)); &#125;); 處理 Authentication 事件 新增一個 state 叫做 loggedIn，預設為未登入，然後在 componentWillMount 新增 onAuthStateChanged 的 function，如果是 user 就登入 1234567891011state = &#123; loggedIn: false &#125;;componentWillMount() &#123; firebase.auth().onAuthStateChanged((user) =&gt; &#123; if (user) &#123; this.setState(&#123; loggedIn: true&#125;); &#125; else &#123; this.setState(&#123; loggedIn: false &#125;); &#125; &#125;);&#125; 更多有條件的渲染 把 loggedIn 的 state 改成 null，然後新增 renderContent，登入時在讀取資料會先跑出 Spinner，成功的話就顯示登出的 Button，失敗的話就回到登入表單 123456789101112state = &#123; loggedIn: null &#125;;renderContent() &#123; switch (this.state.loggedIn) &#123; case true: return &lt;Button&gt;登出&lt;/Button&gt;; case false: return &lt;LoginForm /&gt;; default: return &lt;Spinner size=&quot;large&quot;/&gt;; &#125;&#125; 引入 Button 和 Spinner import &#123; Header, Button, Spinner &#125; from './components/common'; 修改 button 樣式，修改 src/component/common/Button.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344import React from &#x27;react&#x27;;import &#123; View, Text, TouchableOpacity &#125; from &#x27;react-native&#x27;;const Button = (&#123; onPress, children &#125;) =&gt; &#123; const &#123; buttonStyle, textStyle, viewStyle &#125; = styles; return ( &lt;View style=&#123;viewStyle&#125;&gt; &lt;TouchableOpacity onPress=&#123;onPress&#125; style=&#123;buttonStyle&#125;&gt; &lt;Text style=&#123;textStyle&#125;&gt; &#123;children&#125; &lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; );&#125;;const styles = &#123; textStyle: &#123; alignSelf: &#x27;center&#x27;, color: &#x27;#007aff&#x27;, fontSize: 16, fontWeight: &#x27;600&#x27;, paddingTop: 10, paddingBottom: 10 &#125;, viewStyle: &#123; flexDirection: &#x27;row&#x27;, &#125;, buttonStyle: &#123; flex: 1, alignSelf: &#x27;stretch&#x27;, justifyContent: &#x27;center&#x27;, height: 45, backgroundColor: &#x27;#fff&#x27;, borderRadius: 5, borderWidth: 1, borderColor: &#x27;#007aff&#x27;, marginLeft: 5, marginRight: 5 &#125;&#125;;export &#123; Button &#125;; 讓 User 登出和結束 用 firebase 的語法讓用戶登出 12345return ( &lt;Button onPress=&#123;() =&gt; firebase.auth().signOut()&#125;&gt; 登出 &lt;/Button&gt;);","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"https://vincent.fishboneapps.com/tags/React-Native/"}]},{"title":"React Native 快速學習自我挑戰 Day4","slug":"React-Native-快速學習自我挑戰-Day4","date":"2017-08-15T21:41:09.000Z","updated":"2020-06-22T17:22:42.124Z","comments":true,"path":"2017/08/15/React-Native-快速學習自我挑戰-Day4/","link":"","permalink":"https://vincent.fishboneapps.com/2017/08/15/React-Native-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day4/","excerpt":"","text":"使用 Firebase 進行認證 前置作業 新增新的專案 react-native init auth 新增 src/app.js 1234567891011121314import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123; View, Text &#125; from &#x27;react-native&#x27;;class App extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;Text&gt;An App!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;export default App; 在 ios.index.js 把 app.js 放進來 1234import &#123; AppRegistry &#125; from &#x27;react-native&#x27;;import App from &#x27;./src/app&#x27;;AppRegistry.registerComponent(&#x27;auth&#x27;, () =&gt; App); 將 Album 專案的 src/components/Button.js Card.js CardSection.js header.js 複製到新專案目錄的 src/components/common/ 底下 在 src/components/common 底下新增 index.js 1234export * from &#x27;./Button&#x27;;export * from &#x27;./Card&#x27;;export * from &#x27;./CardSection&#x27;;export * from &#x27;./Header&#x27;; 在個別檔案用元件的方式輸出 export &#123; Button &#125;; export &#123; Card &#125;; export &#123; CardSection &#125;; export &#123; Header &#125;; Firebase Firebase 在專案目錄下安裝 firebase npm install --save firebase Import firebase，且在 app.js 的 component 下新增 componentWillMount import firebase from 'firebase'; 12345componentWillMount() &#123; firebase.initializeApp(&#123; &#123;CONFIG CODE FROM FIREBASE&#125; &#125;);&#125; 新增 src/components/LoginForm.js 123456789101112131415161718192021import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123; View &#125; from &#x27;react-native&#x27;;import &#123; Button, Card, CardSection &#125; from &quot;./common&quot;;class LoginForm extends Component &#123; render() &#123; return ( &lt;Card&gt; &lt;CardSection /&gt; &lt;CardSection /&gt; &lt;CardSection&gt; &lt;Button&gt; Log in &lt;/Button&gt; &lt;/CardSection&gt; &lt;/Card&gt; ); &#125;&#125;export default LoginForm; 在 app.js 引用 LoginForm 且放到 View 裡面 import LoginForm from './components/LoginForm'; 1234&lt;View&gt; &lt;Header headerText=&quot;Authentication&quot; /&gt; &lt;LoginForm /&gt;&lt;/View&gt; 在 LoginForm.js 新增輸入欄位 import &#123; TextInput &#125; from 'react-native'; 123&lt;CardSection&gt; &lt;TextInput style=&#123;&#123; height: 20, width: 100 &#125;&#125; /&gt;&lt;/CardSection&gt; 產生 state state = &#123; text: '' &#125;; 1234567&lt;CardSection&gt; &lt;TextInput value=&#123;this.state.text&#125; onChangeText=&#123;text =&gt; this.setState(&#123; text &#125;)&#125; style=&#123;&#123; height: 20, width: 100 &#125;&#125; /&gt;&lt;/CardSection&gt; Text input 流程：TextInput =&gt; 使用者輸入 text =&gt; OnChange 事件被呼叫 =&gt; 給新的文字 「setState」=&gt; 元件重新渲染 新增 src/components/common/Input.js 123456789101112import React from &#x27;react&#x27;;import &#123; TextInput, View, Text &#125; from &#x27;react-native&#x27;;const Input = (&#123; label &#125;) =&gt; &#123; return ( &lt;View&gt; &lt;Text&gt;&#123;label&#125;&lt;/Text&gt; &lt;/View&gt; );&#125;;export &#123; Input &#125;; 在 common/index.js 加入 export * from './Input'; 讓 input 可以到處存取 修改 LoginForm.js，把 import react-native 刪除，新增 Input 到 common import 1234&lt;Input value=&#123;this.state.text&#125; onChangeText=&#123;text =&gt; this.setState(&#123; text &#125;)&#125;/&gt; 修改 Input.js 12345678910111213const Input = (&#123; label, value, onChangeText &#125;) =&gt; &#123; return ( &lt;View&gt; &lt;Text&gt;&#123;label&#125;&lt;/Text&gt; &lt;TextInput value=&#123;value&#125; onChangeText=&#123;onChangeText&#125; style=&#123;&#123; height: 20, width: 100 &#125;&#125; /&gt; &lt;/View&gt; );&#125;; 在 Input.js 新增 styles 123456789101112131415161718192021const styles = &#123; inputStyle: &#123; color: &#x27;#000&#x27;, paddingRight: 5, paddingLeft: 5, fontSize: 18, lineHeight: 23, flex: 2 &#125;, labelStyle: &#123; fontSize: 18, paddingLeft: 20, flex: 1 &#125;, containerStyle: &#123; height: 40, flex: 1, flexDirection: &#x27;row&#x27;, alignItems: &#x27;center&#x27; &#125;&#125;; 在元件中加入 styles 1234567891011121314const Input = (&#123; label, value, onChangeText &#125;) =&gt; &#123; const &#123; inputStyle, labelStyle, containerStyle &#125; = styles; return ( &lt;View style=&#123;containerStyle&#125;&gt; &lt;Text style=&#123;labelStyle&#125;&gt;&#123;label&#125;&lt;/Text&gt; &lt;TextInput style=&#123;inputStyle&#125; value=&#123;value&#125; onChangeText=&#123;onChangeText&#125; /&gt; &lt;/View&gt; );&#125;; 在 LoginForm.js 加入 label 12345&lt;Input label=&quot;Email&quot; value=&#123;this.state.text&#125; onChangeText=&#123;text =&gt; this.setState(&#123; text &#125;)&#125;/&gt; 在 Input.js 加入 autoCorrect 且改成 false，讓 apple 不自動選取文字，新增 placeholder 參數 1234567&lt;TextInput placeholder=&#123;placeholder&#125; autoCorrect=&#123;false&#125; style=&#123;inputStyle&#125; value=&#123;value&#125; onChangeText=&#123;onChangeText&#125;/&gt; 取得上一層傳遞的 placeholder const Input = (&#123; label, value, onChangeText, placeholder &#125;) =&gt; &#123; 傳遞 placeholder 參數給 Input 元件 123456&lt;Input placeholder=&quot;user@gmail.com&quot; label=&quot;Email&quot; value=&#123;this.state.text&#125; onChangeText=&#123;text =&gt; this.setState(&#123; text &#125;)&#125;/&gt; 把 state 改為 email，避免重複使用參數 12345678910state = &#123; email: &#x27;&#x27; &#125;;&lt;CardSection&gt; &lt;Input placeholder=&quot;user@gmail.com&quot; label=&quot;Email&quot; value=&#123;this.state.email&#125; onChangeText=&#123;email =&gt; this.setState(&#123; email &#125;)&#125; /&gt;&lt;/CardSection&gt; 新增 password 欄位 12345678910state = &#123; email: &#x27;&#x27;, password: &#x27;&#x27; &#125;;&lt;CardSection&gt; &lt;Input placeholder=&quot;password&quot; label=&quot;Password&quot; value=&#123;this.state.password&#125; onChangeText=&#123;password =&gt; this.setState(&#123; password &#125;)&#125; /&gt;&lt;/CardSection&gt; 在 Input.js 加入 secureTextEntry 1234567891011121314151617const Input = (&#123; label, value, onChangeText, placeholder, secureTextEntry &#125;) =&gt; &#123; const &#123; inputStyle, labelStyle, containerStyle &#125; = styles; return ( &lt;View style=&#123;containerStyle&#125;&gt; &lt;Text style=&#123;labelStyle&#125;&gt;&#123;label&#125;&lt;/Text&gt; &lt;TextInput secureTextEntry=&#123;secureTextEntry&#125; placeholder=&#123;placeholder&#125; autoCorrect=&#123;false&#125; style=&#123;inputStyle&#125; value=&#123;value&#125; onChangeText=&#123;onChangeText&#125; /&gt; &lt;/View&gt; );&#125;; 直接加入 secureTextEntry，它就會知道是 true，如果沒有設定就是 undefined，在這邊跟 false 的意思一樣 123456789&lt;CardSection&gt; &lt;Input secureTextEntry placeholder=&quot;password&quot; label=&quot;Password&quot; value=&#123;this.state.password&#125; onChangeText=&#123;password =&gt; this.setState(&#123; password &#125;)&#125; /&gt;&lt;/CardSection&gt;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"https://vincent.fishboneapps.com/tags/React-Native/"}]},{"title":"Kubernetes 快速學習自我挑戰 Day3","slug":"Kubernetes-快速學習自我挑戰-Day3","date":"2017-08-14T20:47:58.000Z","updated":"2020-06-22T17:14:36.574Z","comments":true,"path":"2017/08/14/Kubernetes-快速學習自我挑戰-Day3/","link":"","permalink":"https://vincent.fishboneapps.com/2017/08/14/Kubernetes-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day3/","excerpt":"","text":"Kubernetes 觀念簡介 Service Pods 是非常動態的，它們在 Kubernetes 上面是來去自如的 當使用 Replication Controller，pods 在擴展的操作時是被終止的且再被創建的 當使用 Deployments，且在更新 image 版本的時候，pods 會被終止且創建一個新的 pods 取代舊的 這就是為什麼 pods 不應該被直接存取，而是透過 Service 一個服務是在 “mortal” pods 和其它 services 或終端使用者之間的邏輯橋樑 當使用 “kubectl expose” 命令，就會為 pod 創建一個新的服務，如此一來它就可以被外部存取 創建一個服務會為 pod(s) 創建一個 endpoint ClusterIP：一個虛擬 ip 位址只能從 cluster 裡面被存取(這是預設) NodePort：在每一個 node 都使用一樣的 port，而且可以被外部存取 LoadBalancer：LoadBalance 是由雲端主機商建立的，它會路由外部網路到每一個在 NodePort 上的 node (AWS 上的 ELB 服務) 以上所提到的選項可以使用的只有創建 虛擬 IPs 或 ports 它還有使用 DNS 名稱的可能性 ExternalName 可以為 service 提供 DNS 名稱 例如：為 service discovery 使用 DNS 它只有在 DNS add-on 啟動的時候可以使用 筆記：預設的服務只能運行在 30000-32767 port 之間，但是可以在 kube-apiserver 的命令 argument 加上 --service-node-port-range= 來改變這種特性 (在 init scripts) Demo：Service kubectl create -f first-app/helloworld.yml kubectl describe pod nodehelloworld.example.com cat first-app/helloworld-nodeport-service.yml kubectl create -f first-app/helloworld-nodeport-service.yml minikube service helloworld-service --url curl http://192.168.99.100:31001 kubectl describe svc helloworld-service kubectl get svc kubectl delete svc helloworld-service kubectl create -f first-app/helloworld-nodeport-service.yml kubectl describe svc helloworld-service，會發現 ip 不一樣了 Labels Labels 是 key/value pairs，而且可以連接到 objects Labels 在 AWS 或其它雲端服務商裡就像 tags ，且用來標籤 resource 可以 label objects，例如 pod，要跟隨以下組織架構 Key：environment - Value：dev/staging/qa/prod Key：department - Value：engineering/finance/marketing 在上一個範例，已經使用 label 來標籤 pods 了 Labels 不是獨一無二且可以增加多重標籤到一個 object 上面 一旦 labels 連結到 objects，就可以使用過濾器來縮小結果 這叫做 Label Selectors 使用 Label Selector 可以使用 matching expressions 來匹配 labels 例如：特定的 pod 只能運行在「environment」標籤上的 node 等同於 「development」 更複雜的匹配：「environment」必須要是「development」或「qa」 也可以用 labels 來標籤 nodes 一旦 nodes 被標籤，就可以使用 label selector 來讓 pods 只能運行在 特定 nodes 在特定設置的 nodes 上運行一個 pod 有必要的兩步驟 第一步驟要標籤 node 第二步驟要新增一個 nodeSelector 到 pod 組態設定 第一步驟：新增一個或是多數 labels 到 nodes 上 kubectl label nodes node1 hardware=high-spec kubectl label nodes node2 hardware=low-spec 第二步驟：新增一個使用這些 labels 的 pod Demo：使用 labels 的 Node Selector cat deployment/helloworld-nodeselector.yml kubectl get nodes --show-labels kubectl create -f deployment/helloworld-nodeselector.yml kubectl get deployments，這邊會發現新增出來的東西沒有 available kubectl get pods，會發現都在 pending kubectl describe pod helloworld-deployment-4129182270-70sdz，隨便選一個在 pending 的看內容，會發現錯誤在 MatchNodeSelector (1). kubectl label nodes minikube hardware=high-spec kubectl get nodes --show-labels，檢查是否有 hight-spec 的標籤 kubectl get pods，就會發現全部啟動了 kubectl describe pod helloworld-deployment-4129182270-70sdz，會看到 log 檔，發現啟動失敗，後來就可以啟動了 Health checks 如果應用壞掉了，pod 和 container 仍然繼續運行，應用可能已經沒有再繼續運作了 如果要偵測和解決應用的問題，可以運行health checks 有以下兩種 health checks 可以執行 在 container 定期執行 command 在 URL (HTTP)上定期檢查 在 Load balancer 後的典型的產品化應用應該要總是有用某種方法執行的 health checks 來確保應用的可用性和彈性 以下為 health checks 的範例 123456livenessProbe: httpGet: paht: / port: 3000 initailDelaySeconds: 15 timeoutSeconds: 30 Demo：Health checks kubectl create -f deployment/helloworld-healthcheck.yml kubectl get pods kubectl describe pod helloworld-deployment-583969349-0m0p8，會發現裡面有一個 Liveness 的選項 kubectl edit deployment/helloworld-deployment，進去會看到 livenessProbe，可以進行編輯 Secrets Secrets 提供一種在 Kubernetes 的方法，可以分配 credentials、keys、passwords 和 “secret” data 給 pods Kubernetes 自己本身也使用 Secrets 機制來提供 credentials 以存取內部 API 也可以使用同樣的機制來提供 secrets 給應用 Secrets 是一種提供 secrets 的方法，Kubernetes 原生的 如果不想使用 Secrets，還是有其它方法可以讓 container 取得它的 secrets(例如：在應用裡使用 external vault services) Secrets 可以使用以下方式來使用 以環境變數的方法使用 Secrets 在 pod 裡以檔案的方式使用 Secrets 這個設定 volumes 一定要被掛接在 container 裡 在這個 volume 有檔案 可以被使用在 dotenv 檔案或應用可以直接閱讀檔案 使用 external image 來 pull secrets (從private image registry) 使用檔案來產生 secrets echo -n &quot;root&quot; &gt; ./username.txt echo -n &quot;password&quot; &gt; ./password.txt kubectl create secret generic db-user-pass --from-file=./usernmae.txt --from-file=./password.txt secreat 可以是 SSH key 或是 SSL 憑證 kubectl create secret generic ssl-certificate --from-file=ssh-privatekey=~/.ssh/id_rsa --ssl-cert=ssl-cert=mysslcert.crt 使用 YAML 產生 secrets 使用 base64 產生 password 和 username echo -n &quot;root&quot; | base64 完成創建 YAML 檔案，可以直接使用 kubectl 創建 kubectl create -f secrets-db-secret.yml 可以創建 pods 並且 expose secrets 為環境變數 name: SECRET_USERNAME 或者，也可以在檔案內提供 secrets 12345678volumeMount:-name: credvolume mountPath: /etc/creds readOnly: truevolumes:-name: credvolumesecret: secretName: db-secrets Demo：使用 Volumes 的 Credentails cat deployment/helloworld-secrets.yml kubectl create -f deployment/helloworld-secrets.yml cat deployment/helloworld-secrets-volumes.yml kubectl create -f deployment/helloworld-secrets-volumes.yml kubectl describe pod helloworld-deployment-292348803-34dq4 kubectl exec helloworld-deployment-292348803-34dq4 -i -t -- /bin/bash cat /etc/creds/username cat /etc/creds/password mount Demo：在 kubernetes 上運行 WordPress cat wordpress/wordpress-secrets.yml cat wordpress/wordpress-single-deployment-no-volumes.yml kubectl create -f wordpress/wordpress-secrets.yml kubectl create -f wordpress/wordpress-single-deployment-no-volumes.yml kubectl get pods kubectl describe pod wordpress-deployment-2401615361-1j6rw cat wordpress/wordpress-service.yml kubectl create -f wordpress/wordpress-service.yml minikube service wordpress-service --url kubectl delete pod/wordpress-deployment-2401615361-1j6rw kubectl get pods，刪除之後會發現 pod 依然還在 Web UI Kubernetes 自帶 Web UI，可以取代 kubectl 指令 它可以用來 cluster 上運行的應用總覽 創建和修改個別 Kubernetes 資源和工作量(像是 kubectl create 和 delete) 取得資源狀態的資訊(像是 kubectl describe pod) 一般來說，可以用 https:///ui 來存取 kubernetes Web UI 如果不能存取(例如：部署類型沒有啟動功能)，可以手動安裝： kubectl create -f https://rawgit.com/kubernetes/dashboard/master/src/deploy/kubernetes-dashboard.yaml 如果被詢問密碼，可以用以下方式取得密碼 kubectl config view 如果使用 minikube 可以使用下列命令啟動 dashboard minikube dashboard 如果想要知道 url minikube dashboard --url Demo：Web UI minikube dashboard --url","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://vincent.fishboneapps.com/tags/Kubernetes/"}]},{"title":"Kubernetes 快速學習自我挑戰 Day2","slug":"Kubernetes-快速學習自我挑戰-Day2","date":"2017-08-10T20:42:43.000Z","updated":"2020-06-22T17:14:33.786Z","comments":true,"path":"2017/08/10/Kubernetes-快速學習自我挑戰-Day2/","link":"","permalink":"https://vincent.fishboneapps.com/2017/08/10/Kubernetes-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day2/","excerpt":"","text":"Kubernetes 觀念簡介 建立 docker containers 建立 container，可以使用 Docker Engine 建立 Dockerfile 來執行就可以快速建立需要的 container Docker build 可以手動執行，也可以透過像是 jenkins 的 CI/CD 軟體 在 Kubernetes 上面運行應用程式 運行新建立的應用在新的 Kubernetes cluster 在我們要運行基於 image 之上的 container，我們需要創建 pod definition 一個 pod 就是一個應用運行在 Kubernetes 上面 一個 pod 包含一個或多個緊密耦合的容器，如此一來可以形成一個應用 這些應用們可以輕易的使用本地 port number 跟其它應用溝通 我們的應用只包含一個 container 創建一個 pod 創建一個 pod-helloworld.yml 的檔案 使用 kubectl 在 kubernetes cluster 上面創建 pod 有用的命令 kubectl get pod：取得所有在運行的 pods 的資訊 kubectl describe pod ：描述一個 pod kubectl expose pod --port=444 --name=fronted：公開一個 pod 的 port (創建一個新服務) kubectl port-forward 8080：Port 傳送公開的 pod port 到自己的本地機器 kubectl attach -i：連接到特定 pod kubectl exec --command：執行一個命令在 pod 上面 kubectl label pods myloable=awesome：新增一個標籤到 pod 上面 kubectl run -i --tty busybox --image=busybox --restart=Never – sh：在 pod 裡面運行一個 sh - 對除錯非常有用 先用 minikube start 運行 minikube，再用 kubectl create -f first-app/helloworld.yml 創建 pod kubectl describe pod nodehelloworld.example.com kubectl port-forward nodehelloworld.example.com 8081:3000 curl localhost:8081 就可以看到服務運行了 kubectl expose pod nodehelloworld.example.com --type=NodePort --name nodehelloworld-service minikube service &lt;Service Name&gt; --url 即可以取得服務的 url 有用的 kubectl commands kubectl attach nodehelloworld.example.com 連接 nodehelloworld.example.com kubectl exec nodehelloworld.example.com -- ls /app 在應用裡面執行命令 kubectl exec nodehelloworld.example.com -- touch /app/test.txt kubectl exec nodehelloworld.example.com -- ls /app kubectl describe service nodehelloworld-service kubectl run -i --tty busybox --image=busybox --restart=Never -- sh 新增一個 box 來和 nodehellowrold-service 進行連線 telnet 172.17.0.4 3000 GET / 負載平衡服務 在真實的世界裡面，必須要可以從 cluster 的外部連線到應用 在 AWS 上面，可以輕鬆的新增 外部負載平衡器(external Load Balancer) 這個 AWS Load Balancer 將會路由到正確的 Kubernetes pod 其它雲端服務商沒有 Load Balancer，但是仍有其它解決方案 擁有 haproxy/nginx load balancer 在 cluster 之前 或是可以直接將 ports 公開 AWS ELB LoadBalancer 服務 kops create cluster --name=kubernetes.appsoliloquy.com --state=s3://kops-state-b429d --zones=ap-northeast-1a --node-count=2 --node-size=t2.micro --master-size=t2.micro --dns-zone=kubernetes.appsoliloquy.com kops update cluster kubernetes.appsoliloquy.com --yes --state=s3://kops-state-b429d kubectl create -f first-app/helloworld.yml kubectl create -f first-app/helloworld-service.yml 進去 EC2 的 Load Balancer，確認資料狀態。 進入 Route 53，新增 record，名稱設為 helloworld，Alias 設為 yes，Alias Target 設為 Loadbalancer，點選 create。 進入 helloworld.kubernetes.appsoliloquy.com. 就可以看到結果了 Kubernetes 基礎 Node 架構 Docker 裡面裝有 Pods，Pods 裡面裝有 containers container 之間可以簡單地互相溝通 kubelet 用來管理 pods，在 container 之外，kube-proxy 負責和 iptable 溝通，如果 pod 有問題，它會更新 iptable 的規則 Replication Controller 如果應用是 stateless，可以橫向的擴展 Stateless 就是應用沒有 state，不需要寫入任何本地檔案/保存本地 sessions 所有傳統的資料庫(MySQL、Postgres)都是 stateful，它們都有資料庫檔案且不能分到多個 instances 大部分的網頁應用可以做成 stateless Session 管理 必須要在 container 之外完成 任何檔案需要被儲存的都不能儲存在 container 的本機 我們的範例應用是 stateless，如果相同的應用執行很多次，也不會改變它的 state 更多關於練習的資訊，請看 12factor.net 或是看 Learn DevOps: Continuously delivering better software/scalig apps on-premise and in the cloud 後面會解釋如何使用 volumes 來運行 stateful 應用 這些 stateful 應用不能橫向擴展，但是可以在單一 container 裡面運行它們且縱向擴展 (分配更多 CPU/記憶體/硬碟) Kubernetes 的擴展可以透過使用 Replication Controller 來完成 Replication Controller 可以確保指定數量的 pod relicas 將會隨時運行 如果被 relica controller 創建出來的 pod 運行失敗、被刪除或是被終止，那麼 pod 就會自動被取代 如果你只想確保一個 pod是永遠運行的，甚至在重新開機之後，那麼使用 Replication Controller 是被推薦的 可以只與一個 replica 運行一個 Replication Controller 這樣可以確保 pod 總是處於運行狀態 在 YAML 裡面設定 kind 為 ReplicationController、spec 裡面的 replicas 設為 2，即可複製應用兩次 Demo：Replication Controller kubectl create -f replication-controller/helloworld-repl-controller.yml kubectl describe pod helloworld-controller-cwbbn 複製其中的 controller 檢查狀態 kubectl scale --replicas=4 -f replication-controller/helloworld-repl-controller.yml 擴展服務 kubectl get rc kubectl scale --replicas=1 rc/helloworld-controller kubectl delete rc/helloworld-controller 部署 Replication Set 是 Replication Controller 的下個世代 它支援一種新的 selector，這個 selector 可以做基於過濾的 selection，而過濾是根據 sets of values 例如：“environment” 不是 “dev” 就是 “qa” 不只根據 equality，就像是 Replication Controlller 例如 “environment” == “dev” 跟 Replication Controller 相比，Replica Set 是使用 Deployment object Kubernetes 裡的部署聲明允許讓應用做部署和更新 當使用 deployment object，你就定義了你的應用的 state Kubernetes 將會確保 clusters 符合你的 desired state 只使用 replication controller 或 replication set 可能會在部署應用的時候很麻煩 Deployment Obeject 比較容易使用且有更多可能性 有 deployment object，你可以： 創建一個 deployment(例如：部署一個應用) 更新一個 deployment(例如：部署一個新版本) 可以做 rolling updates(零停機時間部署) Roll back 到上一版本 停止/恢復一個 deployment(例如：只推出部分比例) 在 YAML 裡面設定 kind 為 Deployment 非常有用的命令： kubectl get deployments：取得現有的 deployments 資訊 kubectl get rs：取得 replica sets 的資訊 kubectl get pods --show-labels：取得 pods 且顯示連結到這些 pods 的 labels kubectl rollout status deployment/helloworld-deployment：取得 deployment 狀態 kubectl set image deployment/helloworld-deployment k8s-demo=k8s-demo:2：運行 image label version 2 的 k8s-demo kubectl edit deployment/helloworld-deployment：編輯 deployment object kubectl rollout status deployment/hellowrold-deployment：取得 rollout 的狀態 kubectl rollout history deployment/helloworld-deployment：取得 rollout 的歷史 kubectl rollout undo deployment/helloworld-deployment：Rollback 到上一版本 kubectl rollout undo deployment/helloworld-deployment --to-revision=n：Rollback 到任何版本 Demo：部署 kubectl create -f deployment/helloworld.yml kubectl get deployments kubectl get rs kubectl get pods kubectl get pods --show-labels kubectl rollout status deployment/helloworld-deployment kubectl expose deployment helloworld-deployment --type=NodePort kubectl describe service helloworld-deployment minikube service helloworld-deployment --url kubectl set image deployment/helloworld-deployment k8s-demo=wardviaene/k8s-demo:2 kubectl rollout status deployment/helloworld-deployment curl http://192.168.99.100:32635 curl 剛剛取得的 ip，就會發現變成 Helloworld v2 kubectl rollout history deployment/helloworld-deployment kubectl rollout undo deployment/helloworld-deployment kubectl rollout status deployment/helloworld-deployment kubectl edit deployment/helloworld-deployment，在 spec 的 replica 下面新增 revisionHistoryLimit: 100 kubectl set image deployment/helloworld-deployment k8s-demo=wardviaene/k8s-demo:2 kubectl rollout history deployment/helloworld-deployment kubectl rollout undo deployment/helloworld-deployment --to-revision=8 kubectl rollout history deployment/helloworld-deployment","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://vincent.fishboneapps.com/tags/Kubernetes/"}]},{"title":"Kubernetes 快速學習自我挑戰 Day1","slug":"Kubernetes-快速學習自我挑戰-Day1","date":"2017-08-10T07:02:09.000Z","updated":"2020-06-22T17:14:30.975Z","comments":true,"path":"2017/08/10/Kubernetes-快速學習自我挑戰-Day1/","link":"","permalink":"https://vincent.fishboneapps.com/2017/08/10/Kubernetes-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day1/","excerpt":"","text":"Kubernetes 觀念簡介 什麼是 Kubernetes Kubernetes 是一個開源的 orchestration system (編排系統)，提供給 Docker containers 做使用 它可以讓你在機器的 cluster 中規劃 containers 你可以在一台機器上面跑很多 containers 你可以運行 long running services (像是網頁應用程式) Kubernetes 會控管這些 container 的狀態 可以在特定 nodes 上啟動 container 當 container 被砍的時候，會再重啟一個 container 可以將 containers 從一個 node 移到另外一個 node 跟只有手動運行一些 docker containers 在一個 host 上不同的是，Kubernetes 是一個將會為你管控 container 的平台 Kubernetes clusters 可以從一個 node 開始到數千個 nodes 其他有名的 docker orchestrators： Docker Swarm Mesos Kubernetes 的優點 你可以在任何地方運行 Kubernetes On-premise (自有資料中心) 公開 (Google cloud, AWS) 混合：公開和私有 高度模組化 開源 非常好的社群 Google 支援 Container 簡介 Docker 是最受歡迎的 container 軟體 Docker 的另外一個方案是 rkt，同樣也可以與 Kubernetes 一同運行 Dokcer Engine The Docker runtime 讓 docker images 運行的軟體 Docker Hub 用來儲存和取得 docker images 的線上服務 同樣也允許你線上建立 docker images Docker 的優點 獨立：使用所有的 dependencies 來 ship binary 不需要運行在自己的機器上，不過不能用在產品化 在 Dev、QA和產品化環境更加接近，因為使用同樣的 binary Docker 讓開發團隊可以更加快速的 ship 你可以運行完全一樣的 docker image 在筆電、資料中心虛擬機和雲端主機供應商 Docker 對作業系統級的分離使用 Linux Containers (一個核心特色) Kubernetes 設定 Kubernetes 應該要可以在任何地方運行 但是，對於雲端供應商，像是 AWS 和 GCE，還是有很多整合要做 像是 Volumes 和 外部 Load Balances 只能運行在被支援的雲端供應商 會先使用 minikube 來快速讓本機單一機器用 Kubernetes cluster 運行起來 接下來會用 kops 在 AWS 上把一個 cluster 運行起來 kops 是可以被用來運行高可用型的 產品化 cluster 使用自己的實驗室是有可能的(而且高度建議) 使用 AWS 免費方案 (給你 t2.micro’s 750 小時/月) https://aws.amazon.com 使用本地機器 使用 minikube 使用 Digital Ocean 使用 minikube 在本地端設定 Minikube 是一個讓 Kubernetes 在本地端運行變簡單的工具 Minikube 運行單一 node Kubernetes cluster 在 Linux VM 裡面 它的目標用戶是那些想要拿來測試或是用它來開發的人 它不能運行在產品化的 cluster，它是一個沒有高可用性的單一 node 機器 它可以運行在 Windows、Linux 和 MacOS 你會需要安裝 虛擬化軟體 才能運行 minikube Virtualbox 是免費的且可以直接下載 下載 minikube 啟動你的 cluster 只要(在 shell/terminal/powershell)輸入 minikube start 安裝 minikube 安裝最新版本的 minikube 安裝完成之後，啟動 minikube minikube start 安裝 kubectl chmod +x kubectl &amp;&amp; sudo mv kubectl /usr/local/bin/ kubectl run hello-minikube --image=gcr.io/google_containers/echoserver:1.4 --port=8080 kubectl expose development hello-minikube --type=NodePort minikube service hello-minikube --url minikube stop Kops 介紹 設置 Kubernetes 在 AWS 上面，可以使用叫做 kops 的工具 kops 代表 Kubernetes Operations 這個工具允許你做產品化等級的 Kubernetes 安裝、升級和管理 另外，還有一個叫做 kube-up sh 的傳統工具 這是一個用來建立 cluster 的簡易工具，但現在已經停止維護，它不能用來建立一個產品化準備的環境 Kops 只能運行在 Mac/Linux 如果你使用 windows，你必須要先啟動虛擬機 可以使用 Vagrant 來快速建立一個 Linux box 下載 Virtualbox 和 Vagrant，兩個都需要 下載完之後，建立一個新的虛擬機，然後直接在 cmd/powershell 新增以下指令 1234mkdir ubuntucd ubuntuvagrant init ubuntu/xenial64vagrant up 準備 Kops 安裝 完成上面的步驟 vagrant ssh-config 檢視 ssh 狀態 vagrant ssh 即可登入虛擬機 puttygen putty 在 windows 上可以使用 putty 來登入 為 Kops 安裝準備 AWS Kops Github brew update &amp;&amp; brew install kops wget https://github.com/kubernetes/kops/releases/download/1.7.0/kops-linux-amd64 chmod +x kops-linux-amd64 新增執行權限 mv kops-linux-amd64 /usr/local/bin/kops 移動 kops apt-get update &amp;&amp; apt-get install python-pip -y pip install awscli MacOS 上的 bug 處理 sudo -H pip install awscli --upgrade --ignore-installed six 進入 AWS，選擇服務 IAM (Identity and Access Management)，選擇左列選單 Users，選擇 Add User，命名為 kops，下面選項 Programmatic access 要打勾，下個步驟選擇 AdministratorAccess，完成設定。 aws configure ls -ahl ~/.aws/ 檢視 aws credentials 設定完 IAM 之後，回到服務，選擇 S3，新增 bucket，名稱設定為 kops-state-b429b，最後一個是亂數，因為名稱要是唯一的，地區的選擇要去 cloudping 看哪個最快，選擇最快的就可以了，接下來直接按到完成。 接下來要設定 DNS，選擇服務 Route53，選擇 DNS management 的 Get Started Now，選擇 Create Hosted Zone，打入自己所擁有的網域，名稱設為 kubernetes，最後到自己的 Domain 主機商那邊設定 DNS。 使用 kops 進行 AWS Cluster 設定 安裝 kubectl curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl 下載最新版的 kubectl chmod +x ./kubectl sudo mv ./kubectl /usr/local/bin/kubectl ssh-keygen -f .ssh/id_rsa 新增 ssh-key kops create cluster --name=kubernetes.appsoliloquy.com --state=s3://kops-state-b429d --zones=ap-northeast-1a --node-count=2 --node-size=t2.micro --master-size=t2.micro --dns-zone=kubernetes.appsoliloquy.com kops update cluster kubernetes.appsoliloquy.com --yes --state=s3://kops-state-b429d cat .kube/config kubectl get node kubectl run hello-minikube --image=gcr.io/google_containers/echoserver:1.4 --port=8080 kubectl expose deployment hello-minikube --type=NodePort kubectl get service，檢查 port 開啟 Services 的 VPC，點選 Security Groups，點選 master.&lt;自己的 domain&gt;，點選 Inbound Rules，新增 Custom TCP rule，將剛剛取得的 port 貼上、source 設定為 0.0.0.0/0。 進去 api.kubernetes.&lt;自己的 domain&gt;：剛剛的 port，就可以看到內容了 如果要刪除 instance kops delete cluster --name kubernetes.appsoliloquy.com --state=s3://kops-state-b429d","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://vincent.fishboneapps.com/tags/Kubernetes/"}]},{"title":"React Native 快速學習自我挑戰 Day3","slug":"React-Native-快速學習自我挑戰-Day3","date":"2017-08-08T09:41:08.000Z","updated":"2020-06-22T17:22:39.239Z","comments":true,"path":"2017/08/08/React-Native-快速學習自我挑戰-Day3/","link":"","permalink":"https://vincent.fishboneapps.com/2017/08/08/React-Native-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day3/","excerpt":"","text":"處理 Component 的排版 Flexbox 排版 justifyContent: ‘space-between’：上下頂到邊，平均分配空間排列 justifyContent: ‘space-around’：上下不頂到邊，平均分配空間排列 flexDirection：‘row’, ‘column’：決定方向 修改版面 修改 AlbumDetail.js，在 react-native 多引用 View import &#123; Text, View &#125; from 'react-native'; 修改 AlbumDetail，將 artist 放進去 12345678910111213const AlbumDetail = (props) =&gt; &#123; return ( &lt;Card&gt; &lt;CardSection&gt; &lt;View&gt;&lt;/View&gt; &lt;View style=&#123;styles.headerContentStyle&#125;&gt; &lt;Text&gt;&#123;props.album.title&#125;&lt;/Text&gt; &lt;Text&gt;&#123;props.album.artist&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/CardSection&gt; &lt;/Card&gt; );&#125;; 新增 styles 123456const styles = &#123; headerContentStyle: &#123; flexDirection: &#x27;column&#x27;, justifyContent: &#x27;space-around&#x27; &#125;&#125;; 在 react-native 多引用 Image import &#123; Text, View, Image &#125; from 'react-native'; 新增 image 123&lt;View&gt; &lt;Image source=&#123;&#123; uri: props.album.thumbnail_image &#125;&#125; /&gt;&lt;/View&gt; 簡化傳遞的參數 1234567891011121314151617const AlbumDetail = (&#123; album &#125;) =&gt; &#123; const &#123; title, artist, thumbnail_image &#125; = album; return ( &lt;Card&gt; &lt;CardSection&gt; &lt;View&gt; &lt;Image source=&#123;&#123; uri: thumbnail_image &#125;&#125; /&gt; &lt;/View&gt; &lt;View style=&#123;styles.headerContentStyle&#125;&gt; &lt;Text&gt;&#123;title&#125;&lt;/Text&gt; &lt;Text&gt;&#123;artist&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/CardSection&gt; &lt;/Card&gt; );&#125;; 新增圖片的 style 1234thumbnailStyle: &#123; height:50, width: 50&#125; 將 sytle 加到圖片的 tag &lt;Image style=&#123;styles.thumbnailStyle&#125; source=&#123;&#123;\"&#123;&#123;uri: thumbnail_image\" &#125;&#125;&#125;&#125; /&gt; 簡化 style 的參數 123456789101112131415161718192021const AlbumDetail = (&#123; album &#125;) =&gt; &#123; const &#123; title, artist, thumbnail_image &#125; = album; const &#123; thumbnailStyle, headerContentStyle&#125; = styles; return ( &lt;Card&gt; &lt;CardSection&gt; &lt;View&gt; &lt;Image style=&#123;thumbnailStyle&#125; source=&#123;&#123; uri: thumbnail_image &#125;&#125; /&gt; &lt;/View&gt; &lt;View style=&#123;headerContentStyle&#125;&gt; &lt;Text&gt;&#123;title&#125;&lt;/Text&gt; &lt;Text&gt;&#123;artist&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/CardSection&gt; &lt;/Card&gt; );&#125;; 新增兩個 styles: headerTextStyle、thumbnailContainerStyle 12345678910111213141516171819const styles = &#123; headerContentStyle: &#123; flexDirection: &#x27;column&#x27;, justifyContent: &#x27;space-around&#x27; &#125;, headerTextStyle: &#123; fontSize: 18 &#125;, thumbnailStyle: &#123; height:50, width: 50 &#125;, thumbnailContainerStyle: &#123; justifyContent: &#x27;center&#x27;, alignItems: &#x27;center&#x27;, marginLeft: 10, marginRight: 10 &#125;&#125;; 加入簡化的常數 123456const &#123; thumbnailStyle, headerTextStyle, headerContentStyle, thumbnailContainerStyle&#125; = styles; 加入 style 123456789101112&lt;CardSection&gt; &lt;View style=&#123;thumbnailContainerStyle&#125;&gt; &lt;Image style=&#123;thumbnailStyle&#125; source=&#123;&#123; uri: thumbnail_image &#125;&#125; /&gt; &lt;/View&gt; &lt;View style=&#123;headerContentStyle&#125;&gt; &lt;Text style=&#123;headerTextStyle&#125;&gt;&#123;title&#125;&lt;/Text&gt; &lt;Text&gt;&#123;artist&#125;&lt;/Text&gt; &lt;/View&gt;&lt;/CardSection&gt; 新增專輯封面 style 12345imageStyle: &#123; height: 300, flex: 1, width: null&#125; 1234567const &#123; thumbnailStyle, headerTextStyle, headerContentStyle, thumbnailContainerStyle, imageStyle&#125; = styles; 123&lt;CardSection&gt; &lt;Image style=&#123;imageStyle&#125; source=&#123;&#123; uri: image &#125;&#125; /&gt;&lt;/CardSection&gt; 讓畫面可以滾動，修改 albumList.js import &#123; ScrollView &#125; from 'react-native'; 123456789render () &#123; console.log(this.state); return ( &lt;ScrollView&gt; &#123;this.renderAlbums()&#125; &lt;/ScrollView&gt; );&#125; 畫面卡住的問題，要修改 index.ios.js 123456const App = () =&gt; ( &lt;View style=&#123;&#123; flex: 1 &#125;&#125;&gt; &lt;Header headerText=&#123;&#x27;Albums&#x27;&#125; /&gt; &lt;AlbumList /&gt; &lt;/View&gt;); 新增 src/components/Button.js 12345678910import React from &#x27;react&#x27;;import &#123; Text &#125; from &#x27;react-native&#x27;;const Button = () =&gt; &#123; return ( &lt;Text&gt;Click me!!!&lt;/Text&gt; );&#125;;export default Button; 在 albumDetail.js 引用 Button import Button from './Button'; 再新增一個 CardSection 123&lt;CardSection&gt; &lt;Button/&gt;&lt;/CardSection&gt; 在 Button.js 新增 TouchableOpacity，讓使用者點擊 button 會有反饋 import &#123; Text, TouchableOpacity &#125; from 'react-native'; 123&lt;TouchableOpacity&gt; &lt;Text&gt;Click me!!!&lt;/Text&gt;&lt;/TouchableOpacity&gt; 新增 Button style 123456789101112const styles = &#123; buttonStyle: &#123; flex: 1, alignSelf: &#x27;stretch&#x27;, backgroundColor: &#x27;#fff&#x27;, borderRadius: 5, borderWidth: 1, borderColor: &#x27;#007aff&#x27;, marginLeft: 5, marginRight: 5 &#125;&#125;; 123456789const Button = () =&gt; &#123; const &#123; buttonStyle &#125; = styles; return ( &lt;TouchableOpacity style=&#123;buttonStyle&#125;&gt; &lt;Text&gt;Click me!!!&lt;/Text&gt; &lt;/TouchableOpacity&gt; );&#125;; 新增 Text style 12345678textStyle: &#123; alignSelf: &#x27;center&#x27;, color: &#x27;#007aff&#x27;, fontSize: 16, fontWeight: &#x27;600&#x27;, paddingTop: 10, paddingBottom: 10&#125;, 1234567891011const Button = () =&gt; &#123; const &#123; buttonStyle, textStyle &#125; = styles; return ( &lt;TouchableOpacity style=&#123;buttonStyle&#125;&gt; &lt;Text style=&#123;textStyle&#125;&gt; Click me!!! &lt;/Text&gt; &lt;/TouchableOpacity&gt; );&#125;; 在 albumDetail.js 加上 onPress function，然後把値傳送到 Button.js 123&lt;CardSection&gt; &lt;Button onPress=&#123;() =&gt; console.log(title)&#125; /&gt;&lt;/CardSection&gt; 1234567891011const Button = (&#123; onPress &#125;) =&gt; &#123; const &#123; buttonStyle, textStyle &#125; = styles; return ( &lt;TouchableOpacity onPress=&#123;onPress&#125; style=&#123;buttonStyle&#125;&gt; &lt;Text style=&#123;textStyle&#125;&gt; Click me!!! &lt;/Text&gt; &lt;/TouchableOpacity&gt; );&#125;; 在 albumDetail.js 新增 button 的超連結 import &#123; Text, View, Image, Linking &#125; from 'react-native'; const &#123; title, artist, thumbnail_image, image, url &#125; = album; 123&lt;CardSection&gt; &lt;Button onPress=&#123;() =&gt; Linking.openURL(url)&#125; /&gt;&lt;/CardSection&gt; 讓 Button 文字元件化 修改 albumDetail.js 12345&lt;CardSection&gt; &lt;Button onPress=&#123;() =&gt; Linking.openURL(url)&#125;&gt; Buy Now &lt;/Button&gt;&lt;/CardSection&gt; 修改 Button.js 1234567891011const Button = (&#123; onPress, children &#125;) =&gt; &#123; const &#123; buttonStyle, textStyle &#125; = styles; return ( &lt;TouchableOpacity onPress=&#123;onPress&#125; style=&#123;buttonStyle&#125;&gt; &lt;Text style=&#123;textStyle&#125;&gt; &#123;children&#125; &lt;/Text&gt; &lt;/TouchableOpacity&gt; );&#125;;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"https://vincent.fishboneapps.com/tags/React-Native/"}]},{"title":"React Native 快速學習自我挑戰 Day2","slug":"React-Native-快速學習自我挑戰-Day2","date":"2017-08-04T16:43:27.000Z","updated":"2020-06-22T17:22:33.597Z","comments":true,"path":"2017/08/04/React-Native-快速學習自我挑戰-Day2/","link":"","permalink":"https://vincent.fishboneapps.com/2017/08/04/React-Native-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day2/","excerpt":"","text":"React Native 上的 HTTP 請求 新增檔案 /src/components/AlbumList.js 123456789101112import React from &#x27;react&#x27;;import &#123; View, Text &#125; from &#x27;react-native&#x27;;const AlbumList = () =&gt; &#123; return ( &lt;View&gt; &lt;Text&gt;Album List!!!&lt;/Text&gt; &lt;/View&gt; );&#125;;export default AlbumList; 在 index.js 引入函式庫 import AlbumList from './src/components/AlbumList'; 用 View 把物件包起來 123456const App = () =&gt; ( &lt;View&gt; &lt;Header headerText=&#123;&#x27;Albums&#x27;&#125; /&gt; &lt;AlbumList /&gt; &lt;/View&gt;); Functional Component vs Class Component Functional Component 用來呈現固定資料 不能處理讀取檔案 很容易寫入 Class Component 用來取得動態資料來源 處理可能會改變的資料 (讀取資料、使用者事件…等等) 知道它什麼時候要渲染到裝置上 (對資料讀取非常有幫助) 要寫更多程式 Functional Component 範例 123const Header = () =&gt; &#123; return &lt;Text&gt;Hi there!&lt;/Text&gt;&#125; Class Component 範例 12345class Header extends Component &#123; render () &#123; return &lt;Text&gt;Hi There!&lt;/Text&gt; &#125;&#125; 接下來要把本來的 Functional Component 換成 Class Component，要先修改引用的函式庫 import React, &#123; Component &#125; from 'react'; 將 AlbumList 換成 Class Component 123456789class AlbumList extends Component &#123; render () &#123; return ( &lt;View&gt; &lt;Text&gt;Album List!!!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; 在 Component 裡面加上 componentWillMount 12345678910111213class AlbumList extends Component &#123; componentWillMount () &#123; console.log(&#x27;componentWillMount in AlbumList&#x27;); &#125; render () &#123; return ( &lt;View&gt; &lt;Text&gt;Album List!!!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; 安裝 axios npm install --save axios 在 componentWillMount 引入 API 1234componentWillMount () &#123; axios.get(&#x27;https://rallycoding.herokuapp.com/api/music_albums&#x27;) .then(response =&gt; console.log(response)); &#125; App 的時間軸 啟動 React Native RN 決定要渲染 “App” 到螢幕上 “App” 決定要渲染它自己、“Header” 和 “AlbumList” “AlbumList” 發覺到有東西要被渲染，呼叫 componentWillMount “AlbumList” 開啟 HTTP 請求 “App”、“AlbumList” 和 “Header” 出現在螢幕上 過好幾毫秒之後，HTTP 請求傳回 JSON data 要處理資料比畫面顯示還晚的問題，要用 state 的方式處理，state 由以下三步驟來完成 設定預設值或是初始值 讀取資料，且要告訴 Component 資料已經更新 最後，要確定 Component 有使用這些資料 設定初始值 state = &#123; albums: [] &#125;; 讀取資料，而且拿那個值來更新 component，修改 componentWillMount 底下的 .then，這邊要用 setState，而不是 state = [{}]，因為這樣跟起始值一樣 .then(response =&gt; this.setState(&#123;albums: response.data &#125;)); 在 render 裡面 console.log 結果 console.log(this.state); 加入 state 後的時間軸 啟動 React Native RN 決定要渲染 “App” 到螢幕上 “App” 決定要渲染它自己、“Header” 和 “AlbumList” “AlbumList” 取得起始值 { albums: [] } “AlbumList” 發覺到有東西要被渲染，呼叫 componentWillMount “AlbumList” 開啟 HTTP 請求 “AlbumList” 的渲染方法被呼叫 “App”、“AlbumList” 和 “Header” 出現在螢幕上 過好幾毫秒之後，HTTP 請求傳回 JSON data 叫做 “setState” 的 request handler 會更新 albums “AlbumList” 的渲染方法被呼叫 State 的規則 State 的定義：一個純 JavaScript 物件，被用來記錄和回應被用戶觸發的事件 當我們需要更新 component 顯示的東西，叫做 “this.setState” 只能用 “setState” 來改變 state，不要用 “this.state = 123” 用 renderAlbums 取得值，map 在這邊是 foreach 的功能 123renderAlbums () &#123; return this.state.albums.map(album =&gt; &lt;Text&gt;&#123;album.title&#125;&lt;/Text&gt;);&#125; 把 renderAlbums 放在 &lt;View&gt;&lt;/View&gt; 裡面 &#123;this.renderAlbums()&#125; 新增 key 12345renderAlbums () &#123; return this.state.albums.map(album =&gt; &lt;Text key=&#123;album.title&#125;&gt;&#123;album.title&#125;&lt;/Text&gt; ); &#125; 新增 AlbumDetail.js 123456789101112import React from &#x27;react&#x27;;import &#123; View, Text &#125; from &#x27;react-native&#x27;;const AlbumDetail = (props) =&gt; &#123; return ( &lt;View&gt; &lt;Text&gt;&#123;props.album.title&#125;&lt;/Text&gt; &lt;/View&gt; );&#125;;export default AlbumDetail; 在 AlbumList 引入 AlbumDetail import AlbumDetail from './AlbumDetail'; 修改 renderAlbums，album={album} 是將 props 命名為 album，並傳給 AlbumList 12345renderAlbums () &#123; return this.state.albums.map(album =&gt; &lt;AlbumDetail key=&#123;album.title&#125; album=&#123;album&#125; /&gt; );&#125; 新增 /src/components/Card.js 12345678910import React from &#x27;react&#x27;;import &#123; View &#125; from &#x27;react-native&#x27;;const Card = () =&gt; &#123; return ( &lt;View&gt;&lt;/View&gt; );&#125;;export default Card; 幫 Card 新增 styles 12345678910111213141516const styles = &#123; containerStyle: &#123; borderWidth: 1, borderRadius: 2, borderColor: &#x27;#ddd&#x27;, borderBottomWidth: 0, shadowColor: &#x27;#000&#x27;, shadowOffset: &#123; width: 0, height: 2 &#125;, shadowOpacity: 0.1, shadowRadius: 2, elevation: 1, marginLeft: 5, marginRight: 5, marginTop: 10 &#125;&#125;; 在 Card 的 View 裡面新增 style &lt;View style=&#123;styles.containerStyle&#125;&gt;&lt;/View&gt; 在 AlbumDetails 引用 Card import Card from './Card'; 把 View 改成 Card 123&lt;Card&gt; &lt;Text&gt;&#123;props.album.title&#125;&lt;/Text&gt;&lt;/Card&gt; 把上層的值傳到這邊使用，用 props.children 就可以直接取得值 1234567const Card = (props) =&gt; &#123; return ( &lt;View style=&#123;styles.containerStyle&#125;&gt; &#123;props.children&#125; &lt;/View&gt; );&#125;; 新增 /src/components/CardSection.js 123456789101112131415161718192021222324import React from &#x27;react&#x27;;import &#123; View &#125; from &#x27;react-native&#x27;;const CardSection = (props) =&gt; &#123; return ( &lt;View style=&#123;styles.containerStyle&#125;&gt; &#123;props.children&#125; &lt;/View&gt; );&#125;;const styles = &#123; containerStyle: &#123; borderBottomWidth: 1, padding: 5, backgroundColor: &#x27;#fff&#x27;, justifyContent: &#x27;flex-start&#x27;, flexDirection: &#x27;row&#x27;, borderColor: &#x27;#ddd&#x27;, position: &#x27;relative&#x27; &#125;&#125;;export default CardSection; 在 AlbumDetail 加入 CardSection 12345&lt;Card&gt; &lt;CardSection&gt; &lt;Text&gt;&#123;props.album.title&#125;&lt;/Text&gt; &lt;/CardSection&gt;&lt;/Card&gt;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"https://vincent.fishboneapps.com/tags/React-Native/"}]},{"title":"React Native 快速學習自我挑戰 Day1","slug":"React-Native-快速學習自我挑戰-Day1","date":"2017-08-03T10:50:32.000Z","updated":"2020-06-22T17:22:26.114Z","comments":true,"path":"2017/08/03/React-Native-快速學習自我挑戰-Day1/","link":"","permalink":"https://vincent.fishboneapps.com/2017/08/03/React-Native-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day1/","excerpt":"","text":"開始課程 第一支程式的 Roadmap 在每個作業系統安裝 dependencires 針對不同編輯器安裝不同的 ESLint 生成 React Native 專案 課程 Repo 在不同的系統部署環境 OSX 安裝流程 了解 Dependency 的用途 XCode：打包程式和 React Natvie Library 到可安裝的 app，然後用 iOS 模擬器運行 HomeBrew：被用來安裝 node Node/NPM：Node 在瀏覽器之外運行 JavaScript，NPM 被用來安裝和管理 dependencies，Node 和 NPM 會在一起 watchman：在硬碟上監控檔案，等待它們被改變 RN CLI：React Native Command Line 界面，用來產生新的 React Native 專案 依序安裝 開啟專案 react-native run-ios Windows 安裝流程 必須安裝的軟體 python 2.7 node JAVA SDK Android Studio npm install -g react-native-cli --no-optional 開啟 Android Studio，修正所有錯誤，開啟 AVD，啟動一個模擬器 設定環境變數，JAVA_HOME，值為 C:\\Program Files\\Java\\jdk_版本號，另外將 C:\\Users\\使用者名稱\\AppData\\Local\\Android\\sdk\\platform-tools 加入 path 環境變數 開啟專案 react-native run-android ESLint 設定 (VS code) npm install eslint -g 全域安裝 ESLint npm install --save-dev eslint-config-standard 在專案根目錄新增檔案 .eslintrc 在 .eslintrc 新增以下內容 123&#123; &quot;extends&quot;: &quot;standard&quot;&#125; 向前進！ React Native 安裝疑難排解 從 ios.index.js 開始，先刪除所有檔案，首先引入函式庫 12import React from &#x27;react&#x27;;import ReactNative from &#x27;react-native&#x27;; React vs React Native React 知道 compoent 該怎麼表現 React 知道如何拿一堆 components 且讓他們一起運作 React Native 知道如何從 component 取得 output 且將它呈現在螢幕上 React Native 提供核心套件 (image, text) 創建一個 Component 12345const App = () =&gt; &#123; return ( &lt;Text&gt;Some Text&lt;/Text&gt; );&#125;; 將套件內容讀取出來 ReactNative.AppRegistry.registerComponent('albums', () =&gt; App); 將 ReactNative 取代為 &#123; Text, AppRegistry &#125;，這樣的做法就是只使用 ReactNative 裡面的 Text 元件 import &#123; Text, AppRegistry &#125; from 'react-native'; AppRegistry.registerComponent('albums', () =&gt; App); 創建 Component 的部分可以簡化 123const App = () =&gt; ( &lt;Text&gt;Some Text&lt;/Text&gt;); 新增一個檔案 src/components/header.js 在 header.js 引入函式庫 12import React from &#x27;react&#x27;;import &#123; Text &#125; from &#x27;react-native&#x27;; 製作 Component 123const Header = () =&gt; &#123; return &lt;Text&gt;Albums!&lt;/Text&gt;;&#125;; 接下來要讓 Component 可以在 app 的其它部分使用，但是只有 root Component 才用 “AppRegistry”，在這邊我們使用export default Header; 在 root 呼叫 Component import Header from './src/components/header'; 再來直接將 Header 放在 Component 裡面 123const App = () =&gt; ( &lt;Header /&gt;); 處理樣式問題 在 header.js 新增樣式 12345const styles = &#123; textStyle: &#123; fontSize: 20 &#125;&#125;; 將樣式加入 component 12345const Header = () =&gt; &#123; const &#123; textStyle &#125; = styles; return &lt;Text style=&#123;textStyle&#125;&gt;Albums!&lt;/Text&gt;;&#125;; 引入 view import &#123; Text, View &#125; from 'react-native'; 新增 viewStyle 12345678const styles = &#123; viewStyle: &#123; backgroundColor: &#x27;#F8F8F8&#x27; &#125;, textStyle: &#123; fontSize: 20 &#125;&#125;; 使用 viewStyle 123456789const Header = () =&gt; &#123; const &#123; textStyle, viewStyle &#125; = styles; return ( &lt;View style=&#123;viewStyle&#125;&gt; &lt;Text style=&#123;textStyle&#125;&gt;Albums!&lt;/Text&gt; &lt;/View&gt; );&#125;; 使用 flexbox justifyContent: ‘flex-end’ 將物件移至垂直最下方 justifyContent: ‘center’ 將物件移至垂直中間 justifyContent: ‘flex-start’ 將物件置於垂直上方，其實就是預設 alignItems: ‘flex-start’ 將物件置於水平上方，其實就是預設 alignItems: ‘center’ 將物件移至水平中間 alignItems: ‘flex-end’ 將物件移至水平最右方 修改 viewStyle 123456789101112viewStyle: &#123; backgroundColor: &#x27;#F8F8F8&#x27;, justifyContent: &#x27;center&#x27;, alignItems: &#x27;center&#x27;, height: 60, paddingTop: 15, shadowColor: &#x27;#000&#x27;, shadowOffset: &#123; width: 0, height: 2 &#125;, shadowOpacity: 0.2, elevation: 2, position: &#x27;relative&#x27; &#125;, 讓 Header 可以再使用 將本來文字的地方用 props 取代 &#123;props.headerText&#125; 另外要將 props 的變數放入 function const Header = (props) =&gt; &#123; 在 index 的 component 裡面放入 props &lt;Header headerText=&#123;'Albums'&#125; /&gt;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"React","slug":"React","permalink":"https://vincent.fishboneapps.com/tags/React/"}]},{"title":"docker 快速學習自我挑戰 Day8","slug":"docker-快速學習自我挑戰-Day8","date":"2017-08-02T05:54:52.000Z","updated":"2020-06-22T17:12:20.057Z","comments":true,"path":"2017/08/02/docker-快速學習自我挑戰-Day8/","link":"","permalink":"https://vincent.fishboneapps.com/2017/08/02/docker-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day8/","excerpt":"","text":"Container Registry：Image Storage and Distribution Docker Hub：探尋的更深入 Container Registries 你的 Container plan 需要有 Image Registry 成為 plan 的一部分 更多 Docker Hub 的細節，包含 auto-build Docker Store 是怎麼樣跟 Hub 不一樣 Docker Cloud 是怎麼樣跟 Hub 不一樣 使用 Cloud 的新 Swarm 功能來讓 Mac/Win 跟 Swarm 連線 安裝和使用 Docker Registry，且當作 private image store 第三方 registry 套件選項 Docker Hub：探尋的更深入 最有名的 public image registry 它是真的 Docker Registry 而且最輕量的 image building 讓我們探索更多 Docker Hub 的功能 連結 GitHub/BitBucket 到 Hub 而且自動建立 images commit 將 image building 串連在一起 Docker Store：它可以做什麼？ 下載 Docker “Editions” 找到認證過的 Docker/Swarm 外掛和商業認證的 images Docker Cloud：CI/CD 和 Server Ops Web based Docker Swarm 創建/管理 使用有名的雲端主機商和自建式伺服器 自動化的 image building、測試和部署 跟 Docker Hub 免費的東西相比更進階 包含 image 安全掃描服務 使用 Docker Cloud 來做簡單的遠端 Swarm 管理 觀看此影片 了解 Docker Registry 一個提供給你的網路的私有 image registry Docker/Distribution Github Repo 的一部分 事實上在私有的 container registry 不像完整功能的 Hub 或其它東西，它沒有完整的網頁介面，只有基本的認證 在核心的部分：一個網頁的 API 和儲存系統，用 Go 語言撰寫 儲存系統支援 local、S3/Azure/Alibaba/Google 雲，還有 OpenStack Swift 查看以下資源： 使用 TLS 加密你的 Registry 透過 Garbage Collection 來進行儲存清理 透過 “–registry-mirror” 開啟 Hub caching 運行一個私有的 Docker Registry 運行 registry image 在預設 port 5000 Re-tag 已存在的 image，且推送它到你的新 registry 從本地端 cache 移除 image，且從新的 registry pull 下來 使用 bind mount 來 Re-create registry，且觀察它如何儲存資料 Registry 和適合的 TLS 「預設加密」：Docker 不會用沒有 HTTPS 的方式跟 registry 溝通，除了 localhost (127.0.0.0/8) 對於遠端自行登入的 TLS，要再引擎啟動 「insecure-registry」 運行私有 registry image docker container run -d -p 5000:5000 --name registry registry docker pull hello-world 下載很輕量的 image 來測試 Re-tag 已存在的 image，且推送它到你的新 registry docker tag hello-world 127.0.0.1:5000/hello-world docker push 127.0.0.1:5000/hello-world 從本地端 cache 移除 image，且從新的 registry pull 下來 docker image remove hello-world docker image remove 127.0.0.1:5000/hello-world docker pull 127.0.0.1:5000/hello-world docker container kill registry docker container rm registry 使用 bind mount 來 Re-create registry，且觀察它如何儲存資料 docker container run -d -p 5000:5000 --name registry -v $(pwd)/registry-data:/var/lib/registry registry docker push 127.0.0.1:5000/hello-world tree registry-data 安裝 Docker 自動完成 Oh-my-zsh docker-zsh-completion 作業：使用 TLS 和認證加密 Docker Registry 透過創建給 HTTPS 的 self-signed 認證和啟動 htpasswd 認證可以學習到基礎 會使用 Play With Docker 來完成這個作業 建議使用 Part 2 and 3 of &quot;Docker Registry for Linux 來完成作業，或是跳回 Part 1 且在他們的 infrastructure 上運行 container，使用他們的實際 Docker Engine 的 web-based 介面學習 PWD 怎麼運作的 更多實驗請參考：點此 跟 Swarm 一起使用 Registry 跟 localhost 用一樣的方式 由於 Routing Mesh，所有的節點可以在 127.0.0.1:5000 被看到 記得決定如何儲存 image (volume driver) 筆記：所有的 nodes 都要可以存取 images 專業的技巧：如果可以的話，使用 hosted SaaS registry 使用 play-with-docker.com docker service create --name registry --publish 5000:5000 registry 在 5000 port 的 console 後面加上 v2/_catalog 可以看到 json 格式的紀錄 docker pull hello-world docker tag hello-world 127.0.0.1:5000/hello-world docker push 127.0.0.1:5000/hello-world 在 5000 port 的 console 後面加上 v2/_catalog 可以看到 &#123;&quot;repositories&quot;:[&quot;hello-world&quot;]&#125; docker pull nginx docker tag nginx 127.0.0.1:5000/nginx docker push 127.0.0.1:5000/nginx docker service create --name nginx -p 80:80 --replicas 5 --detach=false 127.0.0.1:5000/nginx docker service ps nginx 就可以看到它使用的是本機端的 image (127.0.0.1:5000/nginx:latest) Docker 的第三方套件 最流行的是：Quay.io 如果使用 AWS、Azure、Google Cloud，他們都有自己專屬的 registry 如果是自建式主機，Docker EE、Quay Enterprise、GitLab 更多詳細的 registry 清單 額外的課程 Journey to Docker Production: Evolving Your Infrastructure and Processes What host OS should I use? What base FROM images should I use? How should my Swarm node design look? What common issues do people have when starting a production docker project? How to limit the project from trying to change too much at once. How to speed up the project by outsourcing small pieces of solution to existing products. How Docker’s Enterprise/Cloud products can help. Everything You Thought You Already Knew About Orchestration Docker tip: docker system prune and df Docker 17.06 Community Edition 更詳細的 changelog 完成課程","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://vincent.fishboneapps.com/tags/Docker/"}]},{"title":"docker 快速學習自我挑戰 Day7","slug":"docker-快速學習自我挑戰-Day7","date":"2017-08-01T10:38:10.000Z","updated":"2020-06-22T17:12:20.057Z","comments":true,"path":"2017/08/01/docker-快速學習自我挑戰-Day7/","link":"","permalink":"https://vincent.fishboneapps.com/2017/08/01/docker-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day7/","excerpt":"","text":"Docker 服務和 Swarm 的威力： Build-In Orchestration Swarms Stacks 和產品化等級的 Compose 在 1.13 版本，Docker 增加了一個新的抽象層到 Swarm，且命名為 Stacks Stacks 接受的 Compose files 如同他們對 Services、Networks 和 Volumes 的聲明性定義 我們使用 docker stack deploy 而不是 docker service create Stacks 為我們掌管這些 objects，包括每一個 stack 的 overlay network，新增 stack 名稱來開始他們的名稱 新的 deploy：Compose file 裡面的 key，不能用 build Compose 現在省略 deploy，Swarm 省略 build docker-compose cli 在 Swarm server 上面不被需要 docker stack deploy -c example-voting-app-stack.yml voteapp 使用 YAML 檔案開始部署專案 docker stack ps voteapp 檢查運行狀態 docker stack services voteapp 顯示 server 狀態，有點像是 docker service ls 如果檔案有修改，再執行一次 docker stack deploy -c example-voting-app-stack.yml voteapp 就會自動更新了 給 Swarm 使用的 Secrets Storage：保護你的環境變數 給 Swarm 儲存 Secrets 的最簡單的「安全」解決方案 什麼是 Secret？ Usernames and passwords TLS 認證和 keys SSH keys 任何你將不會放在「前端頁面的新聞」的資料 支援 generic strings 或二進位內容，最多不可大於 500kb 不需要要求 apps 可以被覆寫 在 1.13.0 版本後的 Docker，Swarm Raft DB 在硬碟上是被加密的 只儲存在 Manager nodes 的硬碟上 預設 Managers 和 Workers 「控制面板」是 TLS ＋ 雙向認證 Secrets 首先儲存在 Swarm，然後再分派給 Service(s) 只有在被分派的 Service(s) 的 containers 可以看見它們 它們看起來是 container 裡面的檔案，但事實上它們在記憶體上的 fs /run/secrets/&lt;secret_name&gt; 或/run/secrets/&lt;secret_alias&gt; 本地端的 docker-compose 可以使用基於檔案的 secrets，但是不安全 在 Swarm Services 使用 Secrets docker secret create psql_user psql_user.txt echo &quot;myDBpassWORD&quot; | docker secret create psql_pass - docker service create --name psql --secret psql_user --secret psql_pass -e POSTGRES_PASSWORD_FILE=/run/secrets/psql_pass -e POSTGRES_USER_FILE=/run/secrets/psql_user postgres docker service ps psql 觀察在第幾個 node，跳到那個 node docker exec -it &lt;container&gt; bash cat /run/secrets/psql_user 可以直接看到 psql_user 內容 docker service update --secret-rm 可以使用這個語法移除 secrets 與 Swarm Stacks 一起使用 Secrets docker stack deploy -c docker-compose.yml mydb docker stack rm mydb 與本地端 Docker Compose 一起使用 Secrets docker-compose up -d docker-compose exec psql cat /run/secrets/psql_user 作業：創建一個帶有 Secrets 的 Stack 並且 Deploy 使用上一個作業(compose-assignment-2)的 Drupal compose 檔案 重新命名 image 回到官方版本 drupal:8.2 移除 build: 透過 external: 新增 secret 使用環境變數 POSTGRES_PASSWORD_FILE 透過 cli echo “&lt;pw&gt;” | docker secret create psql-pw - 新增 secret 複製 compose 到 Swarm node1 的 新 yml 檔案 答案：創建一個帶有 Secrets 的 Stack 並且 Deploy 新增 docker-compose.yml 123456789101112131415161718192021222324252627282930313233version: &#x27;3.1&#x27;services: drupal: image: drupal:8.3.5 ports: - &quot;80:80&quot; volumes: - drupal-modules:/var/www/html/modules - drupal-profiles:/var/www/html/profiles - drupal-sites:/var/www/html/sites - drupal-themes:/var/www/html/themes postgres: image: postgres:9.6 environment: - POSTGRES_PASSWORD=/run/secrets/psql-pw secrets: - psql-pw volumes: - drupal-data:/var/lib/postgresql/datavolumes: drupal-data: drupal-modules: drupal-profiles: drupal-sites: drupal-themes:secrets: psql-pw: external: true echo &quot;123456&quot; | docker secret create psql-pw - docker stack deploy -c docker-compose.yml drupal docker stack ps drupal 完整的 App 生命週期：與單一 Compose 設計的 Dev、Build 和 Deploy 保持夢想 一組 Compose files 給： 本機端 docker-compose up 開發環境 docker-compose up -d docker-compose down 遠端 docker-compose up CI 環境 docker-compose -f docker-compose.yml -f docker-compose.test.yml up -d 遠端 docker stack deploy 產品化環境 docker-compose -f docker-compose.yml -f docker-compose.prod.yml config &gt; output.yml 筆記：docker-compose -f a.yml -f b.yml config 大部分可以運作 筆記：Compose extends：尚無法再 Stacks 裡運作","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://vincent.fishboneapps.com/tags/Docker/"}]},{"title":"docker 快速學習自我挑戰 Day6","slug":"docker-快速學習自我挑戰-Day6","date":"2017-07-29T20:50:58.000Z","updated":"2020-06-22T17:12:20.057Z","comments":true,"path":"2017/07/29/docker-快速學習自我挑戰-Day6/","link":"","permalink":"https://vincent.fishboneapps.com/2017/07/29/docker-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day6/","excerpt":"","text":"Docker 服務和 Swarm 的威力： Build-In Orchestration Swarm 模式：Build-In Orchestration 到處都有 container = 新問題 我們如何自動化 container 生命週期？ 我們如何簡單的 scale out/in/up/down？ 我們如何確保我們的 container 在失敗的情況下會自動重建？ 我們如何取代 container 且沒有任何停機時間(藍色/綠色部署)？ 我們如何控制/追蹤哪裡的 container 啟動了？ 我們如何創建 cross-node 虛擬網路？ 我們如何確保只有受信任的伺服器可以運行我們的 container？ 我們如何儲存 secrets、keys、passwords 且將它們放到正確的 container (或是只有那個 container)？ Swarm 模式：Build-In Orchestration Swarm 模式是建立在 Docker 裡面的叢集解決方案 跟早於 1.12 版本的 Swarm “classic” 沒有關係 被 SwarmKit toolkit 新增到 1.12 (2016 年夏天) 被 Stacks and Secrets 做改善後新增到 1.13 (2017 年 1 月) 預設並沒有被啟動，一旦啟動會有以下新指令 docker swarm docker node docker service docker stack docker secret Manager Node API：從客戶端接受指令並創建服務 object Orchestrator：協調服務 object 和創建任務間的 loop Allocator：分配 IP 給任務 Scheduler：分配 node 給任務 Dispatcher：在 Worker Node 報到 Worker Node Worker：連接 dispatcher 來檢查被分配的任務 Executor：執行被分派到 Worker Node 的任務 創建第一個服務且在本地端擴展它 docker info 可以檢查 swarm 是否開啟 docker swarm init --advertise-addr &lt;ip&gt; 啟用 swarm docker swarm init：剛剛發生什麼事情了？ 眾多 PKI 和安全自動化 用於 swarm 的 Root 登入認證被建立 用於第一次的 Manager Node 認證被發佈 Join tokens 被創建 Raft 資料庫被建立，並被用來儲存 root CA、config 和 secrets 在硬碟上預設被加密 (1.13+) 不需要為了額外的 key/value 系統來保有 orchestration/secrets 使用 mutual TLS 的 Managers 中的 Replicates logs 在「控制面板」中 docker service create alpine ping 8.8.8.8 docker service update eloquent_ride --replicas 3 升級 replicas docker container rm -f &lt;container name&gt; 刪除其中一個 container，他也會自動再產生，可以用 docker service ps &lt;service name&gt; 檢查紀錄 創建一個 3-Node Swarm 叢集 創建一個 3-Node Swarm：Host 選項 play-with-docker.com 只需要瀏覽器，但是在四小時後會重置 Docker-machine + VirtualBox 本地端可以免費執行和運作，但是需要一台大於 8GB 記憶體的機器 Digital Ocean + Docker install 大部分很像產品化的設置，但是在學習時要花費 $5-10/node/mouth 註冊自己的 docker-machine 可以用在 Amazon、Azure、DO、Google…等等的配置機器 使用 get.docker.com 到處安裝 docker 開始建立 安裝 Docker-machine 下載指令稿 docker swarm init --advertise-addr &lt;ip&gt; 啟動 swarm 啟動後會產生 join 的指令，把指令貼在其他兩台上面 docker swarm join-token manager 取得 manager 的 token 使用 Overlay Network 進行擴展 當創建網路的時候就選擇 --driver overlay 為了在單一 Swarm 裡面的 container-to-container traffic 在網路建立的時候，選擇性使用的 IPSec (AES) 加密法 docker network create --driver overlay mydrupal 建立一個新網路 docker service create --name psql --network mydrupal -e POSTGRES_PASSWORD=mypass postgres docker service create --name drupal --network mydrupal -p 80:80 drupal 在瀏覽器隨便輸入其中一個 node 的 ip 都可以執行 使用 Routing Mesh 進行擴展 為了將服務分配到適當的任務的 Routes ingress(incoming) 封包 在 Swarm 裡面 span 所有 nodes 使用 Linux 核心裡面的 IPVS 在任務間做 Swarm Services 的負載平衡 兩個方法讓這樣的模式可以執行： 在 Overlay network 裡面運行 container-to-container (使用 VIP) 外部 traffic 進入到 published ports (所有的 nodes listen) docker service create --name search --replicas 3 -p 9200:9200 elasticsearch:2 curl localhost:9200 檢查狀態 這是無狀態的負載平衡 這個負載平衡(LB)位在 OSI 第三層 (TCP)，不是第四層 (DNS) 以上兩種限制都可以透過以下來克服： Nginx 或 HAProxy LB proxy Docker Enterprise Edition，它內建 L4 web proxy 作業：建立一個 Multi-Service Multi-Node Web App 使用 Docker 分散式投票 App 使用課程倉庫裡面的 swarm-app-1 目錄來完成需求 需要 1 volumes, 2 networks, 5 services 建立需要的 commands，讓服務跑起來並測試 App 所有的東西都使用 Docker Hub images，所以在 Swarm 上面不需要任何 data 像很多電腦的東西，這是一半藝術一半科學 答案：建立一個 Multi-Service Multi-Node Web App docker network create -d overlay backend docker network create -d overlay frontend Vote App：docker service create --name vote -p 80:80 --network frontend --replicas 2 dockersamples/examplevotingapp_vote:before Redis：docker service create --name redis --network frontend redis:3.2 Worker：docker service create --name worker --network frontend --network backend dockersamples/examplevotingapp_worker Postgres：docker service create --name db --network backend --mount type=volume,source=db-data,target=/var/lib/postgresql/data postgres:9.4 Result：docker service create --name result --network backend -p 5001:80 dockersamples/examplevotingapp_result:before","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://vincent.fishboneapps.com/tags/Docker/"}]},{"title":"docker 快速學習自我挑戰 Day5","slug":"docker-快速學習自我挑戰-Day5","date":"2017-07-29T04:37:49.000Z","updated":"2020-06-22T17:12:20.057Z","comments":true,"path":"2017/07/29/docker-快速學習自我挑戰-Day5/","link":"","permalink":"https://vincent.fishboneapps.com/2017/07/29/docker-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day5/","excerpt":"","text":"讓 Docker Compose 更簡單：Multi-Container 工具 Docker Compose 和 The docker-compose.yml Docker Compose 為什麼：搞清楚 container 之間的關係 為什麼：將 Docker container 的運行設定存成易讀取的檔案 為什麼：一線開發者環境啟動 可以分成兩個相關的事情 YAML 格式描述我們的解決方案選項：containers、networks、volumes CLI 工具 docker-compose 被用在開發/測試自動化且使用 YAML 檔案 docker-compose.yml Compose YAML 格式有自己的版本：1、2、2.1、3、3.1 YAML 檔案可以被用於本地 docker 自動化或…的 docker-compose 命令 docker 已經直接被產品化，叫做 Swarm (從 v.1.13 開始) docker-compose --help docker-compose.yml 是預設名稱，但是docker-compose -f可以任何使用喜歡的名稱 測試基本 Compose 命令 Docker 的 CLI 工具有 Windows/Mac 版本，但是 Linux 需要分開下載 不是一個產品化等級的工具，但是對在本地端開發和測試是理想的 最常使用的兩個命令是 docker-compose up # 設定 volumes/networks 和開啟所有的 containers docker-compose down # 停止所有的 containers 和移除 cont/vol/net 如果你的所有專案都有 Dockerfile 和 docker-compose.yml，那「新的開發者」應該要 git clone github.com/some/software docker-compose up 進入超級管理員模式 sudo -i 安裝 docker-compose 最新版本 curl -L https://github.com/docker/compose/releases/download/1.15.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose 作業：為 Multi-Container 服務建立一個 Compose File 建立一個基本的 compose file 用於 Drupal CMS 網站，Docker Hub 是你的好朋友 使用 Drupal image 並與 postgres imgae 一起使用 使用 ports 使 Drupal 運行在 8080，如此一來可以透過 localhost:8080 來存取網頁 確定有設定 postgres 的 POSTGRES_PASSWORD 用瀏覽器來設定 Drupal 秘訣：Drupal 假定 DB 是 localhost，但是資料庫在另外一個 container，要在 Drupal 設定讓它跟 Docker network 溝通 額外加分：使用 volumes 來儲存 Drupal 的 unique data 答案：為 Multi-Container 服務建立一個 Compose File 建立一個 docker-compose.yml 12345678910111213141516version: &#x27;2&#x27;services: drupal: image: drupal ports: - &quot;8080:80&quot; volumes: - drupal-modules:/var/www/html/modules \\ - drupal-profiles:/var/www/html/profiles \\ - drupal-sites:/var/www/html/sites \\ - drupal-themes:/var/www/html/themes postgres: image: postgres environment: - POSTGRES_PASSWORD=mypassword docker-compose up 啟動專案 docker-compose down -v 刪除專案 新增 Image Building 到 Compose Files 使用 Compose 來 Build Compose 也可以建立你自己的客製化 images 如果在 cache 沒有找到，會在 docker-compose up 的時候建立起來 也可以透過 docker-compose build 或 docker-compose up --build 重建 對複雜的 builds 非常好，因為它會有很多 vars 或 build args 實作 建立一個 docker-compose.yml，如果找不到 nginx-custom 的 image，則會執行 build 裡的 Dockerfile 1234567891011121314151617version: &#x27;2&#x27;# based off compose-sample-2, only we build nginx.conf into image# uses sample site from https://startbootstrap.com/template-overviews/agency/services: proxy: build: context: . dockerfile: nginx.Dockerfile image: nginx-custom ports: - &#x27;80:80&#x27; web: image: httpd volumes: - ./html:/usr/local/apache2/htdocs/ docker-compose up docker-compose down docker-compose down --rmi local 在關閉的時候同時刪除 image 作業：Run-Time Image Building 和 Multi-Container 開發的 Compose 為本地端測試建立一個客製化的 drupal image Compose 並不是只有給開發者使用，測試 apps 是很簡單/有趣的 或許你在學習成為 Drupal 的管理者，或者是軟體測試者 從上一次的作業開始 Compose file 在目錄 compose-assignment-2 建立你自己的 Dockerfile 和 docker-compose.yml 使用 drupal image 並與 postgres image 一起使用，就像之前一樣 使用目錄裡的 README.md 取得更多細節 答案：Run-Time Image Building 和 Multi-Container 開發的 Compose 建立 Dockerfile 1234567891011FROM drupal:8.2RUN apt-get update &amp;&amp; apt-get install -y git \\ &amp;&amp; rm -rf /var/lib/apt/lists/*WORKDIR /var/www/html/themesRUN git clone --branch 8.x-3.x --single-branch --depth 1 https://git.drupal.org/project/bootstrap.git \\ &amp;&amp; chown -R www-data:www-data bootstrapWORKDIR /var/www/html 建立 docker-compose.yml 1234567891011121314151617181920212223242526version: &#x27;2&#x27;services: drupal: image: custom-drupal build: . ports: - &quot;8080:80&quot; volumes: - drupal-modules:/var/www/html/modules \\ - drupal-profiles:/var/www/html/profiles \\ - drupal-sites:/var/www/html/sites \\ - drupal-themes:/var/www/html/themes postgres: image: postgres:9.6 environment: - POSTGRES_PASSWORD=mypassword volumes: - drupal-data:/var/lib/postgresql/datavolumes: drupal-data: drupal-modules: drupal-profiles: drupal-sites: drupal-themes:","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://vincent.fishboneapps.com/tags/Docker/"}]},{"title":"docker 快速學習自我挑戰 Day4","slug":"docker-快速學習自我挑戰-Day4","date":"2017-07-28T07:32:17.000Z","updated":"2020-06-22T17:12:20.057Z","comments":true,"path":"2017/07/28/docker-快速學習自我挑戰-Day4/","link":"","permalink":"https://vincent.fishboneapps.com/2017/07/28/docker-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day4/","excerpt":"","text":"Container 生命週期和持久性數據：Volumes, Volumes, Volumes Container 生命週期和持久性數據 學習重點 定義持久性數據的問題 Container 的關鍵觀念：immutable，ephemeral 學習使用 Data Volumes 學習使用 Bind Mounts 作業 觀念 Container 通常是 immutable 而且 ephemeral 「immutable infrastructure」：只重新部署 container，從來都不改變 這些都是理想的情境，但是 databases 或 unique data 呢？ Docker 給我們一些特色來確保這些「separation of concerns」 這些被稱為「persistent data」 兩種方法：Volumes 和 Bind Mounts Volumes：製作一個特別的地點在 container UFS(Unit File System) 之外 Bind Mounts：連結 container 路徑到 host 路徑 持久性數據：Data Volumes Dockerfile 裡面的 VOLUME 命令 docker volume prune 可以清除未使用的 volume docker container run -d --name mysql -e MYSQL_ALLOW_EMPTY_PASSWORD=True mysql 使用 mysql 的 image 開啟一個 container docker container inspect mysql 查看 mysql 狀態，Mounts 可以看到路徑 docker volume inspect &#123;Volume Name&#125; 可以看到 Mountpoint 路徑 docker container rm &#123;container name&#125; 將 container 都刪除之後，使用 docker volume ls 觀察，會發現 Volume 都還會在 docker container run -d --name mysql -e MYSQL_ALLOW_EMPTY_PASSWORD=True -v mysql-db:/var/lib/mysql mysql -v 的指令在這邊表示外接 volume，volume 的名稱為 mysql-db docker volume create 必須要在 docker container run 之前執行，這樣才能選擇自訂的 drives 和 labels 持久性數據：Bind Mounting Map host 檔案或目錄到 container 的檔案或目錄 基本上只有兩個位址會指定到相同的檔案 省略 UFS 和 host 檔案覆寫任何 container 裡的東西 不能在 Dockerfile 使用，必須在 container run 的時候使用 ... run -v /Users/vincent/stuff:/path/container (Mac/Linux) ... run -v //c/Users/vincent/stuff:/path/container (Windows) docker container run -d --name nginx -p 80:80 -v $(pwd):/usr/share/nginx/html nginx 新增一個 container 並指定 volume 到現在的路徑 $(pwd) docker container run -d --name nginx2 -p 8080:80 nginx 再新增一個 container 做比較 docker container exec -it nginx bash 用 bash 連進去 nginx touch testme.txt 在本來的目錄新增檔案，最後檔案會出現在 container 裡面，因為目錄是共用的 作業：Database 與命名好的 Volume 一起升級 讓 database 跟 container 一起升級 創建一個 postgres container 並將 volume 命名為 psql-data，且使用版本 9.6.1 使用 Docker Hub 學習 VOLUME 必要路徑和版本，然後運行它 檢查 logs 並停止 container 再創建一個 postgres container 並使用同個 volume 名稱，且使用版本 9.6.2 透過檢查 logs 來驗證 (這些只在 patch 版本能運作，大部分 SQL 資料庫需要手動設定指令來升級資料庫到主要/次要版本，換言之，這是資料庫的限制，而非 container 的限制) 答案：Database 與命名好的 Volume 一起升級 docker container run -d --name psql -v psql:/var/lib/postgresql/data postgres:9.6.1 docker container logs -f psql -f 代表持續 follow docker container stop psql docker container run -d --name psql2 -v psql:/var/lib/postgresql/data postgres:9.6.2 docker container logs psql2 作業：編輯與 Bind Mounts 一起運行的 container 的程式碼 使用 Jekyll 「靜態網頁生成器」來啟動本地端的 web server 不一定要成為 web 開發者：這是一個橋接在本地檔案存取和運行在 container 的 apps 間的 gap 的範例 來源程式碼在 bindmount-sample-1 的課程 repo 裡面 我們會用 host 上的原生工具當作編輯器來編輯檔案 Container 偵測到 host 端檔案改變，會到 web server 更新 使用 docker run -p 80:4000 -v $(pwd):/site bretfisher/jekyll-serve 開啟 container 重整瀏覽器來觀察變化 修改 _posts\\ 且重整瀏覽器來觀察變化 答案：編輯與 Bind Mounts 一起運行的 container 的程式碼 使用 docker run -p 80:4000 -v $(pwd):/site bretfisher/jekyll-serve 開啟 container 直接編輯目錄底下的 _posts\\ 並重整瀏覽器，網站就會直接修改 Jekyll 靜態網頁生成器","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://vincent.fishboneapps.com/tags/Docker/"}]},{"title":"docker 快速學習自我挑戰 Day3","slug":"docker-快速學習自我挑戰-Day3","date":"2017-07-26T13:34:35.000Z","updated":"2020-06-22T17:12:20.057Z","comments":true,"path":"2017/07/26/docker-快速學習自我挑戰-Day3/","link":"","permalink":"https://vincent.fishboneapps.com/2017/07/26/docker-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day3/","excerpt":"","text":"如何找到且使用 container images 什麼是 image (什麼不是)？ 章節簡介 關於 images，container 的基礎要件 什麼是 image (什麼不是) 使用 Docker Hub 註冊 管理本地 image cache 建立自己的 image 什麼是 image (什麼不是) App binaries and dependencies image data 的元數據和如何使用 image 官方定義：「image 是根目錄系統變化的有序集合，而且對 container runtime 的使用有相應的執行參數」 不是完整的操作系統，沒有核心、核心模組(例如：drivers) 小的跟一個檔案(app binary)一樣，就像 Go 語言的 static binary 大的跟帶有 apt、Apache、PHP和更多被安裝軟體的 Ubuntu 一樣 強大的 hub：使用 Docker Hub Registry images Docker Hub 的基礎 找到官方和其它很棒的公開 image 下載 images 和 image tags 的基礎 Docker Hub：container 版的 apt 套件系統 官方 image 和如何使用它 如何辨別好的公開 image 使用不同 base 的 image，像是 Debian 或 Alpine Images 和他們的 Layers：找出 Image Cache Image layers Union file system：顯示出一系列 file system 的改變，跟實際的系統一樣 history 和 inspect：了解 image 如何構成 copy on write：container 如何在 image 上執行 Image 是由 file system changes 和 metadata 組成的 每一層都被獨一無二的被辨識而且只存在 host 一次 這樣的模式可以省下 host 的空間和 push/pull 的傳送時間 Container 只是在 image 上層的一個單一 read/write 層 docker image history 和 inspect 可以幫助我們了解這些資訊 Image Tagging 和推送到 Docker Hub 學習前必須要會的： 了解 container 和 image 了解 image layer 的基礎 了解 Docker Hub 的基礎 這個章節要學的 都在講 image tags 如何上傳到 Docker Hub Image ID vs. Tag cat .docker/config.json 確認已認證登入 docker image tag nginx tingsyuanwang/nginx 給 image tag 到 Docker Hub 的帳戶 docker image push tingsyuanwang/nginx 推送到自己的 Docker Hub docker image tag tingsyuanwang/nginx tingsyuanwang/nginx:testing 給定名為 testing 的 tag docker image push tingsyuanwang/nginx:testing 上傳 image，實際上不會全部上傳，只上傳 tag 回顧 適時的 tagging images 給 image tag 是為了要上傳到 Docker Hub Tagging 是如何和 image ID 做關聯的 Latest Tag 只是預設標籤，並不代表最新 從 Docker cli 登入 Docker Hub 如何創建私有的 Docker Hub images 建立 images：Dockerfile 的基礎 docker build -f some-dockerfile 創建 Dockerfile ENV NGINX_VERSION 1.13.1-1~stretch 這邊的 ENV 是用來設定環境變數，這是對建立或運行 container 去設定 key 和 value 的主要方法 &amp;&amp; 是為了確保這些指令可以符合進一個單一 layer RUN ln -sf /dev/stdout /var/log/nginx/access.log \\ 這行是關於 log 記錄檔，container 只要確保所有我們想要抓的資訊都有在 stdout 的 log 記錄檔案裡面，docker engine 本身就有 logging drivers 可以去控制 host 上所有 containers 的 logs EXPOSE 80 443 預設來說，container 裡面沒有 TCP 或 UDP port 是開啟的，除非在這邊定義，EXPOSE 指令並不會讓 host 上的 port 開啟，要在執行 docker run -p 的時候設定 host 的 port CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;] CMD是必填參數，這是最後的指令，且在每次開啟、重啟或暫停新的 container 都會執行的命令 建立 images：運行 Docker Builds 新增一個 Dockerfile 到根目錄 docker image build -t customnginx . 用 dockerfile 新建一個 image 建立 images：擴展官方 image WORKDIR /usr/share/nginx/html 這個就是在跑 cd 的語法 COPY index.html index.html 複製本地檔案到 docker container 裡面 docker image build -t nginx-with-html . 執行檔案 docker container run -p 80:80 --rm nginx-with-html 用剛剛建立出來的 image 來執行 作業：建立自己的 Dockerfile 且使用它運行 container Dockerfiles 是 process workflow 和藝術組合而成的 使用已存在的 Node.js app 並把它 docker 化 製作 Dockerfile，建立它，測試它，上傳它，(刪除它)，並運行它 預期這樣的過程是反覆的，很少能夠一次就完成它的 細節都在 dockerfile-assignment-1/Dockerfile 使用官方 node 6.x image 的 alpine 版本 預期結果會呈現在 http://localhost 的網頁 標籤並推送到自己的 Docker Hub 從本機的 cache 移除 image，並從 Hub 重新運行一次 解答：建立自己的 Dockerfile 且使用它運行 container Dockerfile 1234567891011121314151617181920# Instructions from the app developer# - you should use the &#x27;node&#x27; official image, with the alpine 6.x branchFROM node:6-alpine# - this app listens on port 3000, but the container should launch on port 80# so it will respond to http://localhost:80 on your computerEXPOSE 3000# - then it should use alpine package manager to install tini: &#x27;apk add --update tini&#x27;RUN apk add --update tini# - then it should create directory /usr/src/app for app files with &#x27;mkdir -p /usr/src/app&#x27;RUN mkdir -p /usr/src/app# - Node uses a &quot;package manager&quot;, so it needs to copy in package.json fileCOPY package.json package.json# - then it needs to run &#x27;npm install&#x27; to install dependencies from that fileRUN npm install &amp;&amp; npm cache clean# - to keep it clean and small, run &#x27;npm cache clean --force&#x27; after above# - then it needs to copy in all files from current directorCOPY . .# - then it needs to start container with command &#x27;tini -- node ./bin/www&#x27;CMD [ &quot;tini&quot;, &quot;--&quot;, &quot;node&quot;, &quot;./bin/www&quot;]# - in the end you should be using FROM, RUN, WORKDIR, COPY, EXPOSE, and CMD commands docker build -t testnode . 使用 Dockerfile 建立 image docker container run --rm -p 80:3000 testnode 使用 image 建立 container docker tag testnode tingsyuanwang/testing-node 修改 tag docker push tingsyuanwang/testing-node 將檔案推送到 Docker Hub docker image rm tingsyuanwang/testing-node 將本地端的 node image 移除 docker container run --rm -p 80:3000 tingsyuanwang/testing-node 運行 container 讓 docker 自動從遠端抓回來","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://vincent.fishboneapps.com/tags/Docker/"}]},{"title":"docker 快速學習自我挑戰 Day2","slug":"docker-快速學習自我挑戰-Day2","date":"2017-07-24T07:09:19.000Z","updated":"2020-06-26T15:50:35.711Z","comments":true,"path":"2017/07/24/docker-快速學習自我挑戰-Day2/","link":"","permalink":"https://vincent.fishboneapps.com/2017/07/24/docker-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day2/","excerpt":"","text":"安裝與版本 Windows Container：Docker 不再只能在 Linux 上面執行 目前 17 版已經可以在 windows 上執行 docker，但有些功能不能使用，包括 Swarm Overlay、Secret…等等 可以參考以下影片 Windows Containers and Docker: 101 Beyond - the path to Windows and Linux parity in Docker Docker + Microsoft - Investing in the Future of your Applications 作業 - 管理多個 container Docker 小幫手 (1) 官方文件 (2) --help 運行 nginx、MySQL、httpd(apache) server 運行以上軟體，並使用 --detached (或 -d)，並用 --name 命名 nginx 要使用 80:80，httpd 用 8080:80，MySQL 用 3306:3306 當執行 MySQL，使用 --environment (或 -e) 將 MYSQL_RANDOM_ROOT_PASSWORD=yes 參數傳進去 container 在 MySQL 使用 docker container logs 來找到創建時所產生的隨機密碼 使用 docker container stop 和 docker container rm 將全部的資料清除 在清除之前，使用 docker container ls 確定資料的狀態是否正確 可以使用 curl localhost 會出現網頁 index 的檔案 Container 裡面發生了什麼事情呢？CLI 進程監控 docker container top 某一個 container 的進程清單 docker container inspect 某一個 container 的設定細節 docker container stats 所有 container 的效能統計 在 Container 裡面取得 Shell：不需要使用 SSH docker container run -it 以交互方式開啟新的 container docker container exec -it 在已存在的 container 執行額外的 command 在眾多 container 裡面有不同的 Linux 發行版本 docker container run -it --name proxy nginx bash 進去 container 裡面 docker container run -it --name ubuntu ubuntu 直接執行，不需加 bash 結果會一樣，因為預設就是 bash docker container start -ai ubuntu 如果要重新開機，可以使用這個指令 Alpine Linux：一個小型且以安全為目的的 Linux 分支 docker pull alpine 下載最新的 alpine docker container run -it alpine sh 因為沒有 bash，所以用 sh 套件管理基本 Docker 網路：眾多 Container 裡面的私有和公有網路的溝通觀念 觀念 docker container run -p p 就是你機器上的 port 對於本地端的開發/測試，網路通常『只是堪用』 docker container port &lt;container&gt; 這個指令可以快速輸出哪一個 port 為這個 container 開啟 學習 Docker 網路、虛擬網路和封包如何傳遞 了解網路封包如何在 Docker 之間移動 預設 Docker 網路 每一個 container 都會連接到虛擬網路 「橋(bridge)」 每一個虛擬網路路由都會透過 NAT 防火牆轉址到 host IP 在虛擬網路上所有的 container 都可以互相溝通，而不需要 -p 最好的練習就是對個別的 app 新增虛擬網路 MySQL 和 php/apache 用「my_web_app」網路 Mongo 和 nodejs 用 「my_api」網路 「含電池，但可拆卸 (battery included, But Removable)」 在多數情況下，預設會運行的很好，但很容易換掉客製化的 ports 新建虛擬網路 連結 container 們到大於1(或者沒有)的虛擬網路 省略虛擬網路且使用 host IP (–net=host) 使用不同的 Docker 網路驅動來取得新的能力 錯誤修改：Nginx 官方 image 移除 Ping 功能 因為最新 2017 官方修改 ping 功能，所以把 docker container run &lt;stuff&gt; nginx，要把 nginx 取代為 nginx:alpine，這樣就可以繼續使用 ping 的 command Docker 網路：虛擬網路的 CLI 管理 docker network ls 顯示所有網路 docker network inspect 檢查特定網路 docker network create --driver 創建一個網路 docker network connect 連結一個網路到 container docker network disconnect 從 container 移除一個網路 在同個 Docker 網路創建前端/後端應用，這樣他們之間的溝通就不會留給 host 所有的在外部暴露的 port 預設會關閉，需要手動使用 -p 打開，這樣才有更好的預設安全 接下來後面要提到的 Swarm 和 Overlay 網路更好 Docker 網路：DNS 和 container 如何找到彼此 了解 DNS 是如何成為容易交互溝通的關鍵 觀察客製化的網路預設是如何運作的 學習如何使用 --link 來讓 DNS 在預設橋接網路生效 請遺忘 IP：固定 ip 和使用 ip 來讓 container 之間溝通是一種反面模式，盡可能地避免這樣的事情發生 Docker DNS：Docker daemon 有內建的 DNS server，而Container 會預設使用它 DNS 預設名稱：Docker 預設 hostname 到 container 的名字，但是還是可以設定 aliases 如果使用客製網路，友善的 DNS 名稱是內建的 這些使用 Docker Compose 都會更簡單 作業：使用 container 做 CLI testing 知道如何使用 -it 在 container 裡面使用 shell 了解基本的 linux distribution，像是 Ubuntu 和 CentOS 了解如何執行 container 作業 使用不同的 distro container 來檢查 curl cli 工具版本 使用兩個不同的終端視窗來開啟 bash，使用 -it 來啟動 centos:7 和 ubuntu:14.04 學習 docker container --rm 選項，這樣可以 save cleanup 確定最新版本的 curl 有安裝在相對應的 distro ubuntu: apt-get update &amp;&amp; apt-get install curl centos: yum update curl 檢查 curl --version 作業：DNS Round Robin 測試 了解如何使用 -it 在 container 裡面使用 shell 了解基本的 linux distribution，像是 Ubuntu 和 CentOS 了解如何執行 container 了解 DNS 紀錄的基礎 從 Docker Engine 1.11 之後，我們可以創建很多 container 到一個網路且傳遞到相關的 DNS 位址 創建一個新的虛擬網路(預設 bridge driver) 從 elasticsearch:2 的 image 創建兩個 container 搜尋和使用 --net-alias search，當我們創建 container 的時候，同時給他們額外的 DNS name 去響應 執行 alpine nslookup search 並加上 --net 來觀察兩個使用相同 DNS 名稱的 container 列表 多次執行 centos curl -s search:9200 並加上 --net，直到觀察到名稱欄位出現 完成作業 執行兩次 docker container run -d --net dude --net-alias search elasticsearch:2，開啟兩個 container docker container run --rm --net dude alpine nslookup search 觀察兩個使用相同 DNS 名稱的 container 列表 docker container run --rm --net dude centos curl -s search:9200","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://vincent.fishboneapps.com/tags/Docker/"}]},{"title":"docker 快速學習自我挑戰 Day1","slug":"docker-快速學習自我挑戰-Day1","date":"2017-07-22T18:55:38.000Z","updated":"2020-06-22T17:12:20.057Z","comments":true,"path":"2017/07/22/docker-快速學習自我挑戰-Day1/","link":"","permalink":"https://vincent.fishboneapps.com/2017/07/22/docker-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day1/","excerpt":"","text":"課程 Roadmap Part I Install Docker Terminal/CLI Tools Download the Repo (github) Part II CURD of Containers Just A Process Shell into Container Docker Networking Part III Use Docker Hub Make Dockerfiles Push Custom Images Build Images Part IV Container Lifetime Docker Volumes Build Mounts Part V Do’s and Don’ts docker-compose.yml docker-compose up Part VI (BIG ONE) Build A Cluster Overlay Networks Routing Mesh Swarm Services Stacks Secrets App Deploy Lifecycle 安裝與版本 安裝 Win10 Win8.1 以前的版本 注意：範例所使用的 http://localhost，必須要改為 http://192.168.99.100 Mac，如果使用低於版本 OSX Yosemite 10.10.3，改用 Toolbox 千萬不要使用 apt/yum install docker，請使用自動化安裝 curl -sSL https://get.docker.com/ | sh 版本 Docker Engine 現在改為 Docker CE (Community Edition) Docker Data Center 現在改為 Docker EE (Enterprise Edition) Docker 的版本改為 YY.MM 的命名方式 創建和使用 Container 檢查 Docker 的安裝和設定 docker version 檢查版本 Client 的版本是 Command Line 的版本，Server 則被稱為 docker engine，docker engine 是在背景執行的 daemon，而我們執行的 Command Line 就跟伺服器的 API 來進行溝通， docker info 取得更詳細的資訊 docker 指令格式 docker &lt;command&gt; &lt;sub-command&gt; (options) 開始使用 Nginx Server Image 是我們想要跑的應用程式 Container 是 image 所產生的 instance，並用進程的方式執行 可以使用同個 image 來產生很多 Container docker container run --publish 80:80 nginx 新建 ngix server，執行完成之後可以直接用瀏覽器看到 nginx，語法背後執行的邏輯如下： 從 Docker Hub 下載「nginx」的 image 從這個 image 開始一個新的 container 開啟本機端的 80 port 將 80 port 路由到 container 的 80 port docker container run --publish 80:80 --detach nginx 加上 detach 可以讓 docker 在背景執行，這個指令會 echo 出 container ID docker container ls 列出所有的 container docker container stop 889 停止某個 container，stop 後面加上 id 前三碼 (只要是唯一即可，若三碼非唯一，則用四碼，後面以此類推) docker container ls -a 列出所有(包含關閉的) container 當使用 run 的時候，一定會新增新的 container，但是當使用 start 的時候，則會開啟一個存在但關閉的 container docker container run --publish 80:80 --detach --name webhost nginx 新增客製化名稱的 container docker container logs webhost 檢查 container 名稱為「webhost」的 log 檔 docker container top webhost 檢查 container 名稱為「webhost」的 process docker container rm 2e5 889 dc1 刪除所選的 container 如果有在執行中的 container，則要強制刪除 docker container rm -f 2e5 “docker container run” 做了什麼事情？ 在本地 image cache 搜尋 image 如果找不到，則搜尋遠端的 image repository (預設為 Docker Hub) 下載最新版本 (nginx：預設為最新版，可以使用 nginx:版本號來取得所需版本) 根據拿到的 image 來創建新的 container，並準備開始 在 docker engine 裡面給 container 私有網路上的虛擬 ip 開啟 host 端的 80 port 並轉址到 container 的 80 port，如果沒有使用 --publish 則不會打開任何 port 藉由使用 image Dockerfile 裡的 CMD 開啟 container docker container run --publish 8080:80 --name webhost -d nginx:1.11 nginx -T host port 可以改為 8080 可修改 nginx 的版本為 1.11 nginx -T 修改開啟時的 CMD Container VS. VM Container 不是縮小版的 VM Container 只是 Process Container 能夠存取的資源有限 當 Process 暫停的時候離開 用命令提示字元了解更多 docker run --name mongo -d mongo 新建一個 mongo DB 的 container 並在背景執行 ps aux 檢視所有正在執行的程式，docker top mongo 檢視服務的狀態 ps aux | grep mongo 搜尋 mongo 的服務 docker stop mongo 關閉 mongo，檢視和搜尋都會找不到該服務 docker start mongo 再次打開 mongo，檢視和搜尋都又會再找到該服務","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://vincent.fishboneapps.com/tags/Docker/"}]},{"title":"Nodejs 快速學習自我挑戰 Day4","slug":"Nodejs-快速學習自我挑戰-Day4","date":"2017-06-13T12:46:04.000Z","updated":"2020-06-22T17:15:24.880Z","comments":true,"path":"2017/06/13/Nodejs-快速學習自我挑戰-Day4/","link":"","permalink":"https://vincent.fishboneapps.com/2017/06/13/Nodejs-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day4/","excerpt":"","text":"Weather App 進階 Promise 新增 asyncAdd function，用 new Promise 新增 promise，然後再用 .then 輸出結果，最後用 .catch 把錯誤一次輸出(避免第二次 errorMessage 跑的是 success function) 1234567891011121314151617181920var asyncAdd = (a, b) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; if (typeof a === &#x27;number&#x27; &amp;&amp; typeof b === &#x27;number&#x27;) &#123; resolve(a + b); &#125; else &#123; reject(&#x27;Arguments must be numbers&#x27;); &#125; &#125;, 1500); &#125;);&#125;;asyncAdd(5, &#x27;7&#x27;).then((res) =&gt; &#123; console.log(&#x27;Results: &#x27;, res); return asyncAdd(res, 33);&#125;).then((res) =&gt; &#123; console.log(&#x27;Should be 45&#x27;, res);&#125;).catch((errorMessage) =&gt; &#123; console.log(errorMessage);&#125;); 使用 Promise 取代 callback 整合 geocode 123456789101112131415161718192021222324252627282930const request = require(&#x27;request&#x27;);var geocodeAddress = (address) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; var encodedAddress = encodeURIComponent(address); request (&#123; url: `https://maps.googleapis.com/maps/api/geocode/json?address=$&#123;encodedAddress&#125;`, json: true &#125;, (error, response, body) =&gt; &#123; if (error) &#123; reject(&#x27;Unable to connect to Google servers&#x27;); &#125; else if (body.status === &#x27;ZERO_RESULTS&#x27;) &#123; reject(&#x27;Unable to find that address&#x27;); &#125; else if (body.status === &#x27;OK&#x27;) &#123; resolve(&#123; address: body.results[0].formatted_address, latitude: body.results[0].geometry.location.lat, longitude: body.results[0].geometry.location.lng, &#125;); &#125; &#125;); &#125;);&#125;;geocodeAddress(&#x27;19146&#x27;).then((location) =&gt; &#123; console.log(JSON.stringify(location, undefined, 2));&#125;, (errorMessage) =&gt; &#123; console.log(errorMessage);&#125;); 讓 Weather App 使用 Promise axios 套件 安裝 axios npm install axios@0.13.1 --save 使用 axios，先使用 .then 取得地址，然後再用一次 .then 取得溫度，最後用 .catch 處理錯誤的出現 1234567891011121314151617181920212223var encodedAddress = encodeURIComponent(argv.address);var geocodeUrl = `https://maps.googleapis.com/maps/api/geocode/json?address=$&#123;encodedAddress&#125;`;axios.get(geocodeUrl).then((response) =&gt; &#123; if (response.data.status === &#x27;ZERO_RESULTS&#x27;) &#123; throw new Error(&#x27;Unable to find that address.&#x27;); &#125; var lat = response.data.results[0].geometry.location.lat; var lng = response.data.results[0].geometry.location.lng; var weatherUrl = `https://api.darksky.net/forecast/key/$&#123;lat&#125;, $&#123;lng&#125;`; console.log(response.data.results[0].formatted_address); return axios.get(weatherUrl);&#125;).then((response) =&gt; &#123; var temperature = response.data.currently.temperature; var apparentTemperature = response.data.currently.apparentTemperature; console.log(`It&#x27;s currently $&#123;temperature&#125;, It feels like $&#123;apparentTemperature&#125;.`);&#125;).catch((e) =&gt; &#123; if (e.code === &#x27;ENOTFOUND&#x27;) &#123; console.log(&#x27;Unable to connect to API servers.&#x27;); &#125; else &#123; console.log(e.message); &#125;&#125;); Weather App 額外的功能 (思路) 除了 Current Temperature 之外，可以從 Weather API 讀取更多資訊 如果讀不到位置，可以使用預設的地點 搜尋完的結果用 filesystem 寫入檔案 網頁伺服器及應用程式部署 Hello Express Express 官方網站 安裝 express npm install express@4.14.0 --save 在根目錄新增 server.js 123456789101112131415161718192021222324252627const express = require(&#x27;express&#x27;);var app = express();app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; // res.send(&#x27;&lt;h1&gt;Hello Express!&lt;/h1&gt;&#x27;); res.send(&#123; name: &#x27;Andrew&#x27;, likes: [ &#x27;Biking&#x27;, &#x27;Cities&#x27; ] &#125;);&#125;);app.get(&#x27;/about&#x27;, (req, res) =&gt; &#123; res.send(&#x27;About Page&#x27;);&#125;);// /bad - send back json with errorMessageapp.get(&#x27;/bad&#x27;, (req, res) =&gt; &#123; res.send(&#123; errorMessage: &#x27;Unable to handle request&#x27; &#125;);&#125;);app.listen(3000); 創建網頁伺服器 新增 public/help.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Help Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Help Page&lt;/h1&gt; &lt;p&gt;Some text here&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 使用 app.use 指定 public 目錄 app.use(express.static(__dirname + '/public')); 當伺服器啟動，傳送訊息 123app.listen(3000, () =&gt; &#123; console.log(&#x27;Server is up on port 3000&#x27;);&#125;); 呈現 template 和 data handlebars.js 安裝 handlebars.js npm install hbs@4.0.0 --save 設定 view engine app.set('view engine', 'hbs'); 新增 views/about.hbs 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Help Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;About Page&lt;/h1&gt; &lt;p&gt;Some text here&lt;/p&gt; &lt;footer&gt; &lt;p&gt;Copyright 2017&lt;/p&gt; &lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 使用 render 取得頁面 123app.get(&#x27;/about&#x27;, (req, res) =&gt; &#123; res.render(&#x27;about.hbs&#x27;);&#125;); 動態存取資料，傳送值到 view 123456app.get(&#x27;/about&#x27;, (req, res) =&gt; &#123; res.render(&#x27;about.hbs&#x27;, &#123; pageTitle: &#x27;About Page&#x27;, currentYear: new Date().getFullYear() &#125;);&#125;); 在 view 取得值 123456&lt;h1&gt;&#123;&#123;pageTitle&#125;&#125;&lt;/h1&gt;&lt;p&gt;Some text here&lt;/p&gt;&lt;footer&gt; &lt;p&gt;Copyright &#123;&#123;currentYear&#125;&#125;&lt;/p&gt;&lt;/footer&gt;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://vincent.fishboneapps.com/tags/Nodejs/"}]},{"title":"Nodejs 快速學習自我挑戰 Day3","slug":"Nodejs-快速學習自我挑戰-Day3","date":"2017-06-11T21:25:35.000Z","updated":"2020-06-22T17:15:24.880Z","comments":true,"path":"2017/06/11/Nodejs-快速學習自我挑戰-Day3/","link":"","permalink":"https://vincent.fishboneapps.com/2017/06/11/Nodejs-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day3/","excerpt":"","text":"Weather App 美化 Printing Objects 將 Printing Object 用 stringify 處理 console.log(JSON.stringify(body, undefined, 2)); Http Request 觀看 response 資訊，成功的話 Http status 會是 200 console.log(JSON.stringify(response, undefined, 2)); 觀看是否有錯誤 console.log(JSON.stringify(error, undefined, 2)); User Input 編碼 安裝 Yargs npm install yargs@4.8.1 --save 使用 yargs 新增 command 以及其他設定 123456789101112const argv = yargs .options(&#123; a: &#123; demand: true, alias: &#x27;address&#x27;, describe: &#x27;Address to fetch weather for&#x27;, string: true &#125; &#125;) .help() .alias(&#x27;help&#x27;, &#x27;h&#x27;) .argv; 將輸入編碼 var encodedAddress = encodeURIComponent(argv.address); 將編碼好的地址傳進 request 1url: `https://maps.googleapis.com/maps/api/geocode/json?address=$&#123;encodedAddress&#125;` Callback Errors 處理 處理錯誤 1234567891011121314request (&#123; url: `https://maps.googleapis.com/maps/api/geocode/json?address=$&#123;encodedAddress&#125;`, json: true&#125;, (error, response, body) =&gt; &#123; if (error) &#123; console.log(&#x27;Unable to connect to Google servers&#x27;); &#125; else if (body.status === &#x27;ZERO_RESULTS&#x27;) &#123; console.log(&#x27;Unable to find that address&#x27;); &#125; else if (body.status === &#x27;OK&#x27;) &#123; console.log(`Address: $&#123;body.results[0].formatted_address&#125;`); console.log(`Latitude: $&#123;body.results[0].geometry.location.lat&#125;`); console.log(`Longitude: $&#123;body.results[0].geometry.location.lng&#125;`); &#125;&#125;); 將 Callback 放到其他地方 新增 geocode/geocode.js 12345678910111213141516171819202122const request = require(&#x27;request&#x27;);var geocodeAddress = (address) =&gt; &#123; var encodedAddress = encodeURIComponent(address); request (&#123; url: `https://maps.googleapis.com/maps/api/geocode/json?address=$&#123;encodedAddress&#125;`, json: true &#125;, (error, response, body) =&gt; &#123; if (error) &#123; console.log(&#x27;Unable to connect to Google servers&#x27;); &#125; else if (body.status === &#x27;ZERO_RESULTS&#x27;) &#123; console.log(&#x27;Unable to find that address&#x27;); &#125; else if (body.status === &#x27;OK&#x27;) &#123; console.log(`Address: $&#123;body.results[0].formatted_address&#125;`); console.log(`Latitude: $&#123;body.results[0].geometry.location.lat&#125;`); console.log(`Longitude: $&#123;body.results[0].geometry.location.lng&#125;`); &#125; &#125;);&#125;;module.exports.geocodeAddress = geocodeAddress; 在 app.js 引入 geocode const geocode = require('./geocode/geocode'); 在 app.js 使用 geocode geocode.geocodeAddress(argv.address); 使用 callback 來得到結果 1234567geocode.geocodeAddress(argv.address, (errorMessage, results) =&gt; &#123; if (errorMessage) &#123; console.log(errorMessage); &#125; else &#123; console.log(JSON.stringify(results, undefined, 2)) &#125;&#125;); 在 geocode 使用 callback 1234567891011121314151617181920var geocodeAddress = (address, callback) =&gt; &#123; var encodedAddress = encodeURIComponent(address); request (&#123; url: `https://maps.googleapis.com/maps/api/geocode/json?address=$&#123;encodedAddress&#125;`, json: true &#125;, (error, response, body) =&gt; &#123; if (error) &#123; callback(&#x27;Unable to connect to Google servers&#x27;); &#125; else if (body.status === &#x27;ZERO_RESULTS&#x27;) &#123; callback(&#x27;Unable to find that address&#x27;); &#125; else if (body.status === &#x27;OK&#x27;) &#123; callback(undefined, &#123; address: body.results[0].formatted_address, Latitude: body.results[0].geometry.location.lat, Longitude: body.results[0].geometry.location.lng, &#125;); &#125; &#125;);&#125;; 跟天氣搜索的 API 串接 forecast.io 開發者區 Forecast Request api 格式 https://api.darksky.net/forecast/[key]/[latitude],[longitude] request weather API 123456789101112const request = require(&#x27;request&#x27;);request(&#123; url: &#x27;https://api.darksky.net/forecast/[key]/[latitude],[longitude]&#x27;, json: true&#125;, (error, response, body) =&gt; &#123; if (!error) &#123; console.log(body.currently.temperature); &#125; else &#123; console.log(&#x27;Unable to fetch weather.&#x27;); &#125;&#125;); 把 callback 串連在一起 新增 weather/weather.js 12345678910111213141516171819const request = require(&#x27;request&#x27;);var getWeather = (lat, lng, callback) =&gt; &#123; request(&#123; url: `https://api.darksky.net/forecast/5c410165ac4d6fd40bb36232d16d7c8e/$&#123;lat&#125;, $&#123;lng&#125;`, json: true &#125;, (error, response, body) =&gt; &#123; if (!error) &#123; callback(undefined, &#123; temperature: body.currently.temperature, apparentTemperature: body.currently.apparentTemperature &#125;); &#125; else &#123; callback(&#x27;Unable to fetch weather.&#x27;); &#125; &#125;);&#125;;module.exports.getWeather = getWeather; 將兩個 function 合在一起 1234567891011121314geocode.geocodeAddress(argv.address, (errorMessage, results) =&gt; &#123; if (errorMessage) &#123; console.log(errorMessage); &#125; else &#123; console.log(results.address); weather.getWeather(results.latitude, results.longitude, (errorMessage, weatherResults) =&gt; &#123; if (errorMessage) &#123; console.log(errorMessage); &#125; else &#123; console.log(`It&#x27;s currently $&#123;weatherResults.temperature&#125;. it feels like $&#123;weatherResults.apparentTemperature&#125;.`); &#125; &#125;); &#125;&#125;); ES6 Promises Promise 提供兩種 function 可以使用：resolve 和 reject 123var somePromise = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;Hey. It worked!&#x27;);&#125;); .then 對 成功或錯誤的 cases 提供 callback function 12345somePromise.then((message) =&gt; &#123; console.log(&#x27;Success: &#x27;, message);&#125;, (errorMessage) =&gt; &#123; console.log(&#x27;Error: &#x27;, errorMessage);&#125;); 在 Promise 的處理，不可以同時出現 reject 和 resolve，若兩項同時出現，會執行第一項 reject('Unable to fulfill promise');","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://vincent.fishboneapps.com/tags/Nodejs/"}]},{"title":"Nodejs 快速學習自我挑戰 Day2","slug":"Nodejs-快速學習自我挑戰-Day2","date":"2017-06-11T14:07:05.000Z","updated":"2020-06-22T17:15:24.880Z","comments":true,"path":"2017/06/11/Nodejs-快速學習自我挑戰-Day2/","link":"","permalink":"https://vincent.fishboneapps.com/2017/06/11/Nodejs-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day2/","excerpt":"","text":"Note App 刪除 Note 修改 removeNote function，先取得所有 notes，然後把跟標題不一樣的 title 取出來，然後存起來，所以選定的 title 就被刪除了 12345var removeNote = (title) =&gt; &#123; var notes = fetchNotes(); var filteredNotes = notes.filter((note) =&gt; note.title !== title); saveNotes(filteredNotes);&#125;; 在 removeNote function 傳回 true 或 false，如果長度不一樣為 true，代表資料刪除，反之亦然。 return notes.length !== filteredNotes.length; 在 app.js 用 noteRemoved 這個變數取得剛剛傳回來的值，如果 true，就顯示「 Note was removed」，false 的話，顯示「 Note not found 」 12345else if (command === &#x27;remove&#x27;) &#123; var noteRemoved = notes.removeNote(argv.title); var message = noteRemoved ? &#x27;Note was removed&#x27; : &#x27;Note not found&#x27;; console.log(message);&#125; 閱讀 Note 修改 getNote function，先取得所有的 notes，然後把標題一樣的取出來，最後 return 陣列 0 (就是取出來的資料) 12345var getNote = (title) =&gt; &#123; var notes = fetchNotes(); var filteredNotes = notes.filter((note) =&gt; note.title === title); return filteredNotes[0];&#125;; 將傳來回的物件用 note 取得，如果存在，顯示資料 123456789var note = notes.getNote(argv.title); if (note) &#123; console.log(&#x27;Note found&#x27;); console.log(&#x27;--&#x27;); console.log(`Title: $&#123;note.title&#125;`); console.log(`Body: $&#123;note.body&#125;`); &#125; else &#123; console.log(&#x27;Note not found&#x27;); &#125; 為了簡化重複的部分，將重複的部分移到 notes.js，並用 function 包裝，還要記得把 logNote export 出去 12345678910var logNote = (note) =&gt; &#123; console.log(&#x27;--&#x27;); console.log(`Title: $&#123;note.title&#125;`); console.log(`Body: $&#123;note.body&#125;`);&#125;;module.exports = &#123; /* 其它 note function */ logNote&#125;; 剛剛重複的部分，用 function 取代 notes.logNote(note); Note.js 應用除錯 使用 node debug 除錯，n 跳到下一個錯誤，c 直接跳到結果或是 debugger 處，repl 可以輸入指令看相關變數 list Notes 直接 return 取得的所有資料 123var getAll = () =&gt; &#123; return fetchNotes();&#125;; 用 forEach 列出取得的所有 notes 12345else if (command === &#x27;list&#x27;) &#123; var allNotes = notes.getAll(); console.log(`Printing $&#123;allNotes.length&#125; note(s).`); allNotes.forEach((note) =&gt; notes.logNote(note));&#125; 進階 Yargs 用 yargs .command 來編寫 help 命令的內容 1234567891011121314151617181920212223242526const titleOptions = &#123; describe: &#x27;Title of note&#x27;, demand: true, alias: &#x27;t&#x27;&#125;;const bodyOptions = &#123; describe: &#x27;Body of note&#x27;, demand: true, alias: &#x27;b&#x27;&#125;const argv = yargs .command(&#x27;add&#x27;, &#x27;Add a new note&#x27;, &#123; title: titleOptions, body: bodyOptions &#125;) .command(&#x27;list&#x27;, &#x27;List all notes&#x27;) .command(&#x27;read&#x27;, &#x27;Read a note&#x27;, &#123; title: titleOptions &#125;) .command(&#x27;remove&#x27;, &#x27;Remove a note&#x27;, &#123; title: titleOptions &#125;) .help() .argv; Arrow function 如果只有一個變數，()可以省略，另外，var square = x =&gt; x * x; 等於 1234var square = (x) =&gt; &#123; var result = x * x; return result;&#125;; 使用 Arrow function 的時候，argument 和 this.name 不能使用 (所以這邊的 sayHi 是讀不出來的) 12345678910111213var user = &#123; name: &#x27;Vincent&#x27;, sayHi: () =&gt; &#123; console.log(arguments); console.log(`Hi. I&#x27;m $&#123;this.name&#125;`); &#125;, sayHiAlt () &#123; console.log(arguments); console.log(`Hi. I&#x27;m $&#123;this.name&#125;`); &#125;&#125;;user.sayHiAlt(1, 2, 3); Weather App Async 下列的程式，會依照下列順序執行 Starting app =&gt; Finishing up =&gt; Second setTimeout =&gt; Inside of callback 123456789101112console.log(&#x27;Starting app&#x27;);setTimeout(() =&gt; &#123; console.log(&#x27;Inside of callback&#x27;);&#125;, 2000);setTimeout(() =&gt; &#123; console.log(&#x27;Second setTimeout&#x27;);&#125;, 0);console.log(&#x27;Finishing up&#x27;); callback Function &amp; APIs Callback 範例，最後會輸出 &#123; id: 31, name: 'Vikram' &#125; 1234567891011121314var getUser = (id, callback) =&gt; &#123; var user = &#123; id: id, name: &#x27;Vikram&#x27; &#125;; setTimeout(() =&gt; &#123; callback(user); &#125;, 3000);&#125;;getUser(31, (userObject) =&gt; &#123; console.log(userObject);&#125;); 第三方 request 插件 啟動 npm 專案 npm init 安裝 request 套件 npm install request@2.73.0 --save 在根目錄新增 app.js 開始專案 先 require request 套件，然後從 google api 擷取 json 資訊 12345678const request = require(&#x27;request&#x27;);request (&#123; url: &#x27;https://maps.googleapis.com/maps/api/geocode/json?address=1301%20lombard%20street%20philadelphia&#x27;, json: true&#125;, (error, response, body) =&gt; &#123; console.log(body);&#125;);","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://vincent.fishboneapps.com/tags/Nodejs/"}]},{"title":"Nodejs 快速學習自我挑戰 Day1","slug":"Nodejs-快速學習自我挑戰-Day1","date":"2017-06-10T15:32:55.000Z","updated":"2020-06-22T17:15:24.880Z","comments":true,"path":"2017/06/10/Nodejs-快速學習自我挑戰-Day1/","link":"","permalink":"https://vincent.fishboneapps.com/2017/06/10/Nodejs-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day1/","excerpt":"","text":"環境設定 安裝 安裝 node 什麼是 Node JavaScript 本來是用於瀏覽器的，現在可以用在 Server 端，node 是一套用 JavaScript Syntax 且可以用來建立程式、檔案系統，還可以直接跟資料庫溝通，甚至可以直接用 node 來建立伺服器。 Node 和 JavaScript 在瀏覽器裡執行都是使用同個引擎，叫做 JavaScript V8 runtime engine，這是一個開源軟體，將 JavaScript 的程式編譯成較快的機器語言，機器語言是低階語言，電腦可以直接執行不需經過轉譯，少了必須轉譯的動作，電腦只能執行特定程式碼，舉例來說，機器可以執行 JavaScript 程式碼、PHP 程式碼不需要轉譯成機器本來就知道的東西，因為 V8 引擎做得很好，Node 非常的快，使用 V8 引擎，我們可以將 JavaScript 程式碼編譯成較快速的機器語言，然後執行它，V8 引擎是用 C++ 寫的，所以如果想拓展 Node 語言，就要學用 C++。 Node 有檔案系統的功能，瀏覽器則控制什麼出現在視窗裡面。瀏覽器使用 window 呼叫指令，Node 用 global。 瀏覽器使用 document 顯示 DOM，Node 使用 process 顯示進程。process.exit(0); 離開執行狀態(或用兩次 ctrl+C 也可以)。 為什麼使用 Nodejs Nodejs 使用事件驅動、非阻塞式 I/O 模型讓它非常輕量而且高效。I/O 是電腦非常常做的事情，當資料讀取或是寫入資料庫，就是 I/O，也稱為輸入和輸出，這是一個用來溝通物聯網和應用程式的東西，包含資料庫讀取或寫入 request，或是改變檔案系統裡的檔案，或者是傳送 http request 到伺服器，例如：Google API 取得用戶的位置。至於非阻塞式 (non-blocking) 是當有用戶從Google request URL，另外一個用戶可以讀取資料庫的資料而不需等待其他用戶的 request 完成。 Nodejs 套件的生態系系統 npm ，是世界上最大的開源資料庫生態系統。 Note App Using Require Module 是單元功能，Require 是用來取用單元功能的 Node 函式。 Modules 新增根目錄檔案 app.js 先 console.log console.log('Starting app.'); 引入 filesystem const fs = require('fs'); 使用函式庫新增檔案 fs.appendFile('greeting.txt', 'Hello world!'); 如果使用函式庫新增檔案出現錯誤，有其他兩種解法 123456789Option1fs.appendFile(&#x27;greeting.txt&#x27;, &#x27;Hello world!&#x27;, function (err) &#123; if (err) &#123; console.log(&#x27;Unable to write to file&#x27;); &#125;&#125;);Option2fs.appendFileSync(&#x27;greeting.txt&#x27;, &#x27;Hello world!&#x27;); 引入 os const os = require('os'); 使用函式庫調出 user 資料 var user = os.userInfo(); ES5 輸出資料 fs.appendFile('greeting.txt', 'Hello ' + user.username + '!'); ES6 輸出資料 1fs.appendFile(&#x27;greeting.txt&#x27;, `Hello $&#123;user.username&#125;!`); Require 自己的檔案 新增根目錄檔案 notes.js 加入一行 console.log('Starting notes.js') 在 app.js require 檔案 const notes = require('./notes.js'); 在 notes.js 新增 addNote function 1234module.exports.addNote = () =&gt; &#123; console.log(&#x27;addNote&#x27;); return &#x27;New note&#x27;;&#125;; 在 app.js 使用 function 12var res = notes.addNote();console.log(res); 在 notes.js 新增 add function 123module.exports.add = (a, b) =&gt; &#123; return a + b;&#125;; 在 app.js 使用 function console.log('Result:', notes.add(9, -2)); 使用第三方套件 啟動 npm 專案 npm init 安裝 lodash npm install lodash --save Require module 到 app.js const _ = requrie('lodash'); 使用 lodash function 去除陣列中一樣的內容 12var filteredArray = _.uniq([&#x27;Vincent&#x27;, 1, &#x27;Vincent&#x27;, 1, 2, 3, 4]);console.log(filteredArray); 使用 Nodemon 開始專案 安裝 Nodemon npm install nodemon -g 啟動 Nodemon 來監控專案 nodemon app.js 從使用者取得 input 在 app.js 新增 process.argv 監控 command 123var command = process.argv[2];console.log(&#x27;Command:&#x27;, command);console.log(process.argv); 在 app.js 新增 if else function 給不同的 command 不同 output 1234567891011if (command === &#x27;add&#x27;) &#123; console.log(&#x27;Adding new note&#x27;);&#125; else if (command === &#x27;list&#x27;) &#123; console.log(&#x27;Listing all notes&#x27;);&#125; else if (command === &#x27;read&#x27;) &#123; console.log(&#x27;Reading note&#x27;);&#125; else if (command === &#x27;remove&#x27;) &#123; console.log(&#x27;Removing note&#x27;);&#125; else &#123; console.log(&#x27;Command not recognized&#x27;);&#125; 檢查 command node app.js remove 使用 Yargs 簡化 input 安裝 Yargs npm install yargs@4.7.1 --save Require Yargs const yargs = require('yargs'); 修改 app.js 的 if function 1234567891011if (command === &#x27;add&#x27;) &#123; notes.addNote(argv.title, argv.body);&#125; else if (command === &#x27;list&#x27;) &#123; notes.getAll();&#125; else if (command === &#x27;read&#x27;) &#123; notes.getNote(argv.title);&#125; else if (command === &#x27;remove&#x27;) &#123; notes.removeNote(argv.title);&#125; else &#123; console.log(&#x27;Command not recognized&#x27;);&#125; 在 notes.js 新增 addNote, getAll, getNote, removeNote function 123456789101112131415var addNote = (title, body) =&gt; &#123; console.log(&#x27;Adding note&#x27;, title, body);&#125;;var getAll = () =&gt; &#123; console.log(&#x27;Getting all notes&#x27;);&#125;;var getNote = (title) =&gt; &#123; console.log(&#x27;Getting note&#x27;, title);&#125;;var removeNote = (title) =&gt; &#123; console.log(&#x27;Removing note&#x27;, title);&#125;; 在 notes.js 輸出 function (ES6) 123456module.exports = &#123; addNote, getAll, getNote, removeNote&#125;; 使用 JSON 先引入 fileSystem，然後用 originalNote 新增 JSON 物件，新增一個變數 originalNoteString 用 stringify 將 originalNote 轉為 String，然後再新增一個變數 note 將 originalNoteString parse 回 JSON 物件。 12345678910111213const fs = require(&#x27;fs&#x27;);var originalNote = &#123; title: &#x27;Some title&#x27;, body: &#x27;Some body&#x27;&#125;;var originalNoteString = JSON.stringify(originalNote);fs.writeFileSync(&#x27;notes.json&#x27;, originalNoteString);var noteString = fs.readFileSync(&#x27;notes.json&#x27;);var note = JSON.parse(originalNoteString);console.log(typeof note);console.log(note.title); 新增和儲存 Note 首先在 addNote 傳入 title 和 body 兩個變數，然後用 notes.push 把得到的兩個變數傳進去 notes 陣列裡面，最後用 String 的方式寫入 notes-data.json。過程中，為了避免資料重複，用 notesString 取得檔案內的所有 note，然後用 notes.filter 檢查 title 是不是一樣，最後，如果不一樣，再將檔案寫入 notes-data.json。 123456789101112131415161718192021var addNote = (title, body) =&gt; &#123; var notes = []; var note = &#123; title, body &#125;; try &#123; var notesString = fs.readFileSync(&#x27;notes-data.json&#x27;); notes = JSON.parse(notesString); &#125; catch (e) &#123; &#125; var duplicateNotes = notes.filter((note) =&gt; note.title === title); if (duplicateNotes.length === 0) &#123; notes.push(note); fs.writeFileSync(&#x27;notes-data.json&#x27;, JSON.stringify(notes)); &#125;&#125;; 重複使用 function 將本來在 addNote 的 fucntion 移出來 123456789101112var fetchNotes = () =&gt; &#123; try &#123; var notesString = fs.readFileSync(&#x27;notes-data.json&#x27;); return JSON.parse(notesString); &#125; catch (e) &#123; return []; &#125;&#125;;var saveNotes = (notes) =&gt; &#123; fs.writeFileSync(&#x27;notes-data.json&#x27;, JSON.stringify(notes));&#125;; addNote function 移出來的 function 用 fetchNotes 和 saveNotes 取代 1234567891011121314var addNote = (title, body) =&gt; &#123; var notes = fetchNotes(); var note = &#123; title, body &#125;; var duplicateNotes = notes.filter((note) =&gt; note.title === title); if (duplicateNotes.length === 0) &#123; notes.push(note); saveNotes(notes); return note; &#125;&#125;; 將從 notes.js return 出來的 note 用 if else function 來顯示是否完成新增 notes 的動作 1234567891011if (command === &#x27;add&#x27;) &#123; var note = notes.addNote(argv.title, argv.body); if (note) &#123; console.log(&#x27;Note created&#x27;); console.log(&#x27;--&#x27;); console.log(`Title: $&#123;note.title&#125;`); console.log(`Body: $&#123;note.body&#125;`); &#125; else &#123; console.log(&#x27;Note title taken&#x27;); &#125;&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://vincent.fishboneapps.com/tags/Nodejs/"}]},{"title":"Lavarel 快速學習自我挑戰 Day22","slug":"Lavarel-快速學習自我挑戰-Day22","date":"2017-06-01T07:04:36.000Z","updated":"2020-06-22T17:14:53.700Z","comments":true,"path":"2017/06/01/Lavarel-快速學習自我挑戰-Day22/","link":"","permalink":"https://vincent.fishboneapps.com/2017/06/01/Lavarel-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day22/","excerpt":"","text":"部署 app 與共享主機 主機相關 申請 godaddy 主機(一元主機) 啟用 ssh 連線並匯入金鑰 ssh -i ~/.ssh/id_rsa 帳號@ip Select PHP verion =&gt; 選擇 5.6 =&gt; 啟用 zip =&gt; 儲存 Composer install 預設就裝好了。 如果沒有，使用 wget 或是 curl 取得 composer wget https://getcomposer.org/installer curl -sS https://getcomposer.org/installer | php 檢查 composer 是否可用 php installer --check 安裝 composer php installer 執行 composer php composer.phar laravel install 用 composer 下載 laravel installer composer global require &quot;laravel/installer&quot; 新增 path 到 ~/.bash_profile export PATH=&quot;$PATH:$HOME/.composer/vendor/bin&quot; 更新檔案 source .bash_profile 執行 laravel 語法 上傳專案 直接到 cpanel 上傳檔案 設定環境檔案 下載相依檔案 composer update 複製 env 範例檔 cp .env.example .env 設定 .env 新增 APP_KEY php artisan key:generate 發佈 修改 documentroot 到 public folder 如果主目錄路徑不同，可修改 public 目錄下的 index.php 修改 config/app.php 的 URL 網址、時區(Asia/Taipei) 將 adimin/media/index view 的 form path 改為 delete/media 將 routes/web.php 的 delete media route 改為 Route::get('admin/delete/media', 'AdminMediasController@deleteMedia'); 修改 .env 將 debug 關閉且將環境改為 production 升級到 5.4 刪除 bootstrap/cache/compiled.php 修改 composer.json &quot;phpunit/phpunit&quot;: &quot;~5.7&quot;, &quot;laravel/framework&quot;: &quot;5.4.*&quot;, &quot;laravelcollective/html&quot;: &quot;5.4.*&quot;, &quot;cviebrock/eloquent-sluggable&quot;: &quot;4.2.1&quot;, 更新套件 composer update 清除快取 php artisan view:clear 清除路由快取 php artisan route:clear 刪除 gulpfile.js 新增 webpack.mix.js 12345678910111213141516171819202122232425const &#123; mix &#125; = require (&#x27;laravel-mix&#x27;);mix.js(&#x27;resources/assets/js/app.js&#x27;, &#x27;public/js&#x27;) .sass(&#x27;resources/assets/sass/app.css&#x27;, &#x27;public/css&#x27;);mix.styles([ &#x27;resources/assets/css/libs/blog-post.css&#x27;, &#x27;resources/assets/css/libs/bootstrap.css&#x27;, &#x27;resources/assets/css/libs/font-awesome.css&#x27;, &#x27;resources/assets/css/libs/metisMenu.css&#x27;, &#x27;resources/assets/css/libs/sb-admin-2.css&#x27;], &#x27;public/css/libs.css&#x27;);mix.scripts([ &#x27;resources/assets/js/libs/jquery.js&#x27;, &#x27;resources/assets/js/libs/bootstrap.js&#x27;, &#x27;resources/assets/js/libs/metisMenu.js&#x27;, &#x27;resources/assets/js/libs/sb-admin-2.js&#x27;, &#x27;resources/assets/js/libs/scripts.js&#x27;], &#x27;./public/js/libs.js&#x27;); 將 package.json 取代為 123456789101112131415161718&#123; &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;node node_modules/cross-env/dist/bin/cross-env.js NODE_ENV=development node_modules/webpack/bin/webpack.js --progress --hide-modules --config=node_modules/laravel-mix/setup/webpack.config.js&quot;, &quot;watch&quot;: &quot;node node_modules/cross-env/dist/bin/cross-env.js NODE_ENV=development node_modules/webpack/bin/webpack.js --watch --progress --hide-modules --config=node_modules/laravel-mix/setup/webpack.config.js&quot;, &quot;watch-poll&quot;: &quot;node node_modules/cross-env/dist/bin/cross-env.js NODE_ENV=development node_modules/webpack/bin/webpack.js --watch --watch-poll --progress --hide-modules --config=node_modules/laravel-mix/setup/webpack.config.js&quot;, &quot;hot&quot;: &quot;node node_modules/cross-env/dist/bin/cross-env.js NODE_ENV=development node_modules/webpack-dev-server/bin/webpack-dev-server.js --inline --hot --config=node_modules/laravel-mix/setup/webpack.config.js&quot;, &quot;production&quot;: &quot;node node_modules/cross-env/dist/bin/cross-env.js NODE_ENV=production node_modules/webpack/bin/webpack.js --progress --hide-modules --config=node_modules/laravel-mix/setup/webpack.config.js&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;axios&quot;: &quot;^0.15.3&quot;, &quot;bootstrap-sass&quot;: &quot;^3.3.7&quot;, &quot;jquery&quot;: &quot;^3.1.1&quot;, &quot;laravel-mix&quot;: &quot;^0.8.1&quot;, &quot;lodash&quot;: &quot;^4.17.4&quot;, &quot;vue&quot;: &quot;^2.2.2&quot; &#125;&#125; 安裝相依套件 npm install 執行 webpack npm run dev 監控 webpack 任何變化 npm run watch 完成課程結業證書","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://vincent.fishboneapps.com/tags/Laravel/"}]},{"title":"Lavarel 快速學習自我挑戰 Day21","slug":"Lavarel-快速學習自我挑戰-Day21","date":"2017-05-31T08:58:07.000Z","updated":"2020-06-22T17:14:53.700Z","comments":true,"path":"2017/05/31/Lavarel-快速學習自我挑戰-Day21/","link":"","permalink":"https://vincent.fishboneapps.com/2017/05/31/Lavarel-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day21/","excerpt":"","text":"升級到 Laravel 5.3 Part II 升級 users 把 AdminUsersController 的 lists 全部改為 pluck 升級 posts 新增到 routes/web.php Route::get('/post/&#123;id&#125;', ['as'=&gt;'home.post', 'uses'=&gt;'AdminPostsController@post']); 新增 comment routes 'show'=&gt;'admin.comments.show' 把 AdminPostsController 的 lists 全部改為 pluck 在 composer.json 升級套件 &quot;laravelcollective/html&quot;: &quot;5.3.*&quot;,，並使用 composer update 升級 middleware 修改 kernel.php 的 $routeMiddleware 'can' =&gt; \\Illuminate\\Auth\\Middleware\\Authorize::class, 新增 kernel.php 的 $middlewareGroups \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, 新增 kernel.php 的 $routeMiddleware 'bindings' =&gt; \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, 新增 kernel.php 的 api 'bindings', WYSIWYG and file installing editor 下載套件 &amp; 安裝編輯器 TinyMCE 官方網站 新增 includes/tinyeditor.blade.php view 12&lt;script src=&quot;https://cloud.tinymce.com/stable/tinymce.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;tinymce.init(&#123; selector:&#x27;textarea&#x27; &#125;);&lt;/script&gt; 在 admin/posts/create view 新增 @include('includes.tinyeditor') FileManager Github 安裝套件 composer require unisharp/laravel-filemanager laravel intervention 官方網站 安裝 intervention composer require intervention/image 將 class 加到 config/app.php provider Unisharp\\Laravelfilemanager\\LaravelFilemanagerServiceProvider::class, Intervention\\Image\\ImageServiceProvider::class, 將 class 加到 config/app.php alias 'Image' =&gt; Intervention\\Image\\Facades\\Image::class, Publish the package’s config and assets php artisan vendor:publish --tag=lfm_config php artisan vendor:publish --tag=lfm_public 創建資料夾和上傳檔案 修改 includes/tinyeditor.blade.php view 12345678910111213141516171819202122232425262728293031323334353637&lt;script src=&quot;https://cloud.tinymce.com/stable/tinymce.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var editor_config = &#123; path_absolute : &quot;/&quot;, selector: &quot;textarea.my-editor&quot;, plugins: [ &quot;advlist autolink lists link image charmap print preview hr anchor pagebreak&quot;, &quot;searchreplace wordcount visualblocks visualchars code fullscreen&quot;, &quot;insertdatetime media nonbreaking save table contextmenu directionality&quot;, &quot;emoticons template paste textcolor colorpicker textpattern&quot; ], toolbar: &quot;insertfile undo redo | styleselect | bold italic | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | link image media&quot;, relative_urls: false, file_browser_callback : function(field_name, url, type, win) &#123; var x = window.innerWidth || document.documentElement.clientWidth || document.getElementsByTagName(&#x27;body&#x27;)[0].clientWidth; var y = window.innerHeight|| document.documentElement.clientHeight|| document.getElementsByTagName(&#x27;body&#x27;)[0].clientHeight; var cmsURL = editor_config.path_absolute + &#x27;laravel-filemanager?field_name=&#x27; + field_name; if (type == &#x27;image&#x27;) &#123; cmsURL = cmsURL + &quot;&amp;type=Images&quot;; &#125; else &#123; cmsURL = cmsURL + &quot;&amp;type=Files&quot;; &#125; tinyMCE.activeEditor.windowManager.open(&#123; file : cmsURL, title : &#x27;Filemanager&#x27;, width : x * 0.8, height : y * 0.8, resizable : &quot;yes&quot;, close_previous : &quot;no&quot; &#125;); &#125; &#125;; tinymce.init(editor_config);&lt;/script&gt; 在 admin/posts/create view 的 textarea 加上 my-editor 的 class 修改 post view，強制顯示圖片 &lt;p&gt;&#123;!! $post-&gt;body !!&#125;&lt;/p&gt; 將編輯器也引入 admin/posts/edit view @include('includes.tinyeditor') Disqus system 進入網站首頁，選擇安裝程式碼到我的網站上面。 新增新的網站，按照步驟做即可。 大量刪除媒體 新增 form 到 admin/media/index view 12345678910111213&lt;form action=&quot;/delete/media/&quot; method=&quot;get&quot; class=&quot;form-inline&quot;&gt; &#123;&#123;csrf_field()&#125;&#125; &#123;&#123;method_field(&#x27;delete&#x27;)&#125;&#125; &lt;div class=&quot;form-group&quot;&gt; &lt;select name=&quot;checkBoxArray&quot; id=&quot;&quot; class=&quot;form-control&quot;&gt; &lt;option value=&quot;delete&quot;&gt;Delete&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;submit&quot; class=&quot;btn-primary&quot;&gt; &lt;/div&gt; /*table code*/&lt;/form&gt; 新增 routes Route::get('/delete/media', 'AdminMediasController@deleteMedia'); 將 Delete button 的 form 修改為 12345&lt;input type=&quot;hidden&quot; name=&quot;photo&quot; value=&quot;&#123;&#123;$photo-&gt;id&#125;&#125;&quot;&gt;&lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;delete_single&quot; value=&quot;Delete&quot; class=&quot;btn btn-danger&quot;&gt;&lt;/div&gt; 在 AdminMediasController 新增 deleteMedia function 1234567891011121314151617181920212223242526272829public function deleteMedia(Request $request)&#123; if(isset($request-&gt;delete_single))&#123; $this-&gt;destroy($request-&gt;photo); return redirect()-&gt;back(); &#125; if(isset($request-&gt;delete_all) &amp;&amp; !empty($request-&gt;checkBoxArray))&#123; $photos = Photo::findOrFail($request-&gt;checkBoxArray); foreach ($photos as $photo) &#123; $photo-&gt;delete(); &#125; return redirect()-&gt;back(); &#125; else &#123; return redirect()-&gt;back(); &#125;&#125; 新增 script section 到 media/index view，讓全選功能完成。 123456789101112131415161718192021222324252627282930313233@section(&#x27;scripts&#x27;) &lt;script&gt; $(document).ready(function()&#123; $(&#x27;#options&#x27;).click(function()&#123; if(this.checked)&#123; $(&#x27;.checkBoxes&#x27;).each(function()&#123; this.checked = true; &#125;); &#125; else &#123; $(&#x27;.checkBoxes&#x27;).each(function()&#123; this.checked = false; &#125;); &#125; &#125;) &#125;); &lt;/script&gt;@stop","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://vincent.fishboneapps.com/tags/Laravel/"}]},{"title":"Lavarel 快速學習自我挑戰 Day20","slug":"Lavarel-快速學習自我挑戰-Day20","date":"2017-05-30T07:46:47.000Z","updated":"2020-06-22T17:14:53.700Z","comments":true,"path":"2017/05/30/Lavarel-快速學習自我挑戰-Day20/","link":"","permalink":"https://vincent.fishboneapps.com/2017/05/30/Lavarel-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day20/","excerpt":"","text":"Pretty URL eloquent-sluggable 套件說明書 require 套件 composer require cviebrock/eloquent-sluggable 4.1 在 config/app.php 新增 provider Cviebrock\\EloquentSluggable\\ServiceProvider::class, 在 Post model 新增 123456789101112131415161718192021use Cviebrock\\EloquentSluggable\\Sluggable;class Post extends Model&#123; use Sluggable; /** * Return the sluggable configuration array for this model. * * @return array */ public function sluggable() &#123; return [ &#x27;slug&#x27; =&gt; [ &#x27;source&#x27; =&gt; &#x27;title&#x27; ] ]; &#125;&#125; 新增 migration php artisan make:migration add_slug_to_posts_table --create=posts 修改 add_slug_to_posts_table 1234567891011121314151617181920212223242526class AddSlugToPostsTable extends Migration&#123; /** * Run the migrations. * * @return void */ public function up() &#123; Schema::table(&#x27;posts&#x27;, function (Blueprint $table) &#123; $table-&gt;string(&#x27;slug&#x27;)-&gt;nullable(); &#125;); &#125; /** * Reverse the migrations. * * @return void */ public function down() &#123; Schema::table(&#x27;posts&#x27;, function (Blueprint $table) &#123; $table-&gt;dropColumn(&#x27;slug&#x27;); &#125;); &#125;&#125; 將資料匯入資料庫 php artisan migrate 修改 admin/posts/index view 的檢視貼文欄位 &lt;td&gt;&lt;a href=&quot;&#123;&#123;\" &#123;&#123;route('home.post', $post->slug)\" &#125;&#125;&#125;&#125;&quot;&gt;View post&lt;/a&gt;&lt;/td&gt; 修改 AdminPostsController 的 post function 123456789public function post($slug)&#123; $post = Post::where(&#x27;slug&#x27;, $slug)-&gt;first() ?: Post::findOrFail((int)$slug); $comments = $post-&gt;comments()-&gt;whereIsActive(1)-&gt;get(); return view(&#x27;post&#x27;, compact(&#x27;post&#x27;, &#x27;comments&#x27;));&#125; Pagination (Pagination 官方文件) 修改 AdminPostsController 的 index function $posts = Post::all();=&gt;$posts = Post::paginate(2); 在 admin/posts/index view 新增 1234567&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-6 col-sm-offset-5&quot;&gt; &#123;&#123;$posts-&gt;render()&#125;&#125; &lt;/div&gt;&lt;/div&gt; 從 gravatar 拿大頭貼 在 User model 新增 getGravatarAttribute function 1234567public function getGravatarAttribute()&#123; $hash = md5(strtolower(trim($this-&gt;attributes[&#x27;email&#x27;]))); return &quot;http://www.gravatar.com/avatar/$hash&quot;;&#125; 取得大頭貼 src=&quot;&#123;&#123;\" &#123;&#123;Auth::user()->gravatar\" &#125;&#125;&#125;&#125;&quot; 升級到 Laravel 5.3 Part I 升級 更新內容 檢查版本 php artisan --version 修改 composer.json &quot;laravel/framework&quot;: &quot;5.3.*&quot;,=&gt;&quot;laravel/framework&quot;: &quot;5.3.*&quot;, 更新資料 composer update 把 app/Providers/EventServiceProvider 的 boot function 的變數拿掉 1234public function boot()&#123; parent::boot();&#125; 把 app/Providers/RouteServiceProvider 的 boot, map, mapWebRoutes function 的變數拿掉 1234public function boot()&#123; parent::boot();&#125; 1234public function map()&#123; $this-&gt;mapWebRoutes();&#125; 12345678protected function mapWebRoutes()&#123; Route::group([ &#x27;namespace&#x27; =&gt; $this-&gt;namespace, &#x27;middleware&#x27; =&gt; &#x27;web&#x27;, ], function ($router) &#123; require app_path(&#x27;Http/routes.php&#x27;); &#125;);&#125; 接上面的步驟，將 use Illuminate\\Routing\\Router;移除 修改 mapWebRoutes function 的 path 12345678protected function mapWebRoutes()&#123; Route::group([ &#x27;namespace&#x27; =&gt; $this-&gt;namespace, &#x27;middleware&#x27; =&gt; &#x27;web&#x27;, ], function ($router) &#123; require base_path(&#x27;routes/web.php&#x27;); &#125;);&#125; 更新 routes 在 app/Http/Controllers/Controller.php 刪除 AuthorizesResources, 更新 routes 檔案 將更新檔案複製到 app/Http/Controllers/Auth 目錄底下 新增以下兩行到 routes/web.php 12Auth::routes();Route::get(&#x27;/logout&#x27;, &#x27;Auth\\LoginController@logout&#x27;); 修改 LoginController 將目錄導向 admin protected $redirectTo = '/admin'; 客製化 routes 來符合舊的路由設定 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Route::group([&#x27;middleware&#x27;=&gt;&#x27;admin&#x27;], function()&#123; Route::get(&#x27;/admin&#x27;, function()&#123; return view(&#x27;admin.index&#x27;); &#125;); Route::resource(&#x27;admin/users&#x27;, &#x27;AdminUsersController&#x27;, [&#x27;names&#x27;=&gt;[ &#x27;index&#x27;=&gt;&#x27;admin.users.index&#x27;, &#x27;create&#x27;=&gt;&#x27;admin.users.create&#x27;, &#x27;store&#x27;=&gt;&#x27;admin.users.store&#x27;, &#x27;edit&#x27;=&gt;&#x27;admin.users.edit&#x27; ]]); Route::resource(&#x27;admin/posts&#x27;, &#x27;AdminPostsController&#x27;, [&#x27;names&#x27;=&gt;[ &#x27;index&#x27;=&gt;&#x27;admin.posts.index&#x27;, &#x27;create&#x27;=&gt;&#x27;admin.posts.create&#x27;, &#x27;store&#x27;=&gt;&#x27;admin.posts.store&#x27;, &#x27;edit&#x27;=&gt;&#x27;admin.posts.edit&#x27; ]]); Route::resource(&#x27;admin/categories&#x27;, &#x27;AdminCategoriesController&#x27;, [&#x27;names&#x27;=&gt;[ &#x27;index&#x27;=&gt;&#x27;admin.categories.index&#x27;, &#x27;create&#x27;=&gt;&#x27;admin.categories.create&#x27;, &#x27;store&#x27;=&gt;&#x27;admin.categories.store&#x27;, &#x27;edit&#x27;=&gt;&#x27;admin.categories.edit&#x27; ]]); Route::resource(&#x27;admin/comments&#x27;, &#x27;PostCommentsController&#x27;, [&#x27;names&#x27;=&gt;[ &#x27;index&#x27;=&gt;&#x27;admin.comments.index&#x27;, &#x27;create&#x27;=&gt;&#x27;admin.comments.create&#x27;, &#x27;store&#x27;=&gt;&#x27;admin.comments.store&#x27;, &#x27;edit&#x27;=&gt;&#x27;admin.comments.edit&#x27; ]]); Route::resource(&#x27;admin/comments/replies&#x27;, &#x27;CommentRepliesController&#x27;, [&#x27;names&#x27;=&gt;[ &#x27;index&#x27;=&gt;&#x27;admin.comments.replies.index&#x27;, &#x27;create&#x27;=&gt;&#x27;admin.comments.replies.create&#x27;, &#x27;store&#x27;=&gt;&#x27;admin.comments.replies.store&#x27;, &#x27;edit&#x27;=&gt;&#x27;admin.comments.replies.edit&#x27; ]]);&#125;);","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://vincent.fishboneapps.com/tags/Laravel/"}]},{"title":"Lavarel 快速學習自我挑戰 Day19","slug":"Lavarel-快速學習自我挑戰-Day19","date":"2017-05-28T16:58:12.000Z","updated":"2020-06-22T17:14:53.699Z","comments":true,"path":"2017/05/28/Lavarel-快速學習自我挑戰-Day19/","link":"","permalink":"https://vincent.fishboneapps.com/2017/05/28/Lavarel-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day19/","excerpt":"","text":"Application 留言功能 Part II 顯示留言 在 admin/posts/index view 新增文章連結 &lt;td&gt;&lt;a href=&quot;&#123;&#123;\" &#123;&#123;route('home.post', $post->id)\" &#125;&#125;&#125;&#125;&quot;&gt;view post&lt;/a&gt;&lt;/td&gt; 在 admin/posts/index view 新增評論連結 &lt;td&gt;&lt;a href=&quot;&#123;&#123;\" &#123;&#123;route('admin.comments.show', $post->id)\" &#125;&#125;&#125;&#125;&quot;&gt;View Comments&lt;/a&gt;&lt;/td&gt; 新增 admin/comments/show view 在 PostCommentsController 新增 show function 12345678public function show($id)&#123; $post = POST::findOrfail($id); $comments = $post-&gt;comments; return view(&#x27;admin.comments.show&#x27;, compact(&#x27;comments&#x27;)); &#125; 修改 Post model 12345public function comments()&#123; return $this-&gt;hasMany(&#x27;App\\Comment&#x27;);&#125; 在文章中顯示留言 新增 Auth 到留言區塊，讓登入的使用者才可以留言 12@if(Auth::check())@endif 修改 AdminPostsController 的 post function 123456789public function post($id)&#123; $post = Post::findOrFail($id); $comments = $post-&gt;comments()-&gt;whereIsActive(1)-&gt;get(); return view(&#x27;post&#x27;, compact(&#x27;post&#x27;, &#x27;comments&#x27;));&#125; 新增 posted comments 到 post view 123456789101112131415@if(count($comments) &gt; 0) @foreach($comments as $comment) &lt;div class=&quot;media&quot;&gt; &lt;a class=&quot;pull-left&quot; href=&quot;#&quot;&gt; &lt;img height=&quot;64&quot; class=&quot;media-object&quot; src=&quot;&#123;&#123;$comment-&gt;photo&#125;&#125;&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;&#123;&#123;$comment-&gt;author&#125;&#125; &lt;small&gt;&#123;&#123;$comment-&gt;created_at-&gt;diffForHumans()&#125;&#125;&lt;/small&gt; &lt;/h4&gt; &#123;&#123;$comment-&gt;body&#125;&#125; &lt;/div&gt; &lt;/div&gt; @endforeach@endif 回覆留言功能 新增 routes 12345Route::group([&#x27;middleware&#x27;=&gt;&#x27;auth&#x27;], function() &#123; Route::post(&#x27;comment/reply&#x27;, &#x27;CommentRepliesController@createdReply&#x27;);&#125;); 在 CommentRepliesController 新增 CreateReply function 1234567891011121314151617181920212223public function createReply(Request $request)&#123; $user = Auth::user(); $data = [ &#x27;post_id&#x27; =&gt; $request-&gt;post_id, &#x27;author&#x27; =&gt; $user-&gt;name, &#x27;email&#x27; =&gt; $user-&gt;email, &#x27;photo&#x27; =&gt; $user-&gt;photo-&gt;file, &#x27;body&#x27; =&gt; $request-&gt;body ]; CommentReply::create($data); $request-&gt;session()-&gt;flash(&#x27;reply_message&#x27;, &#x27;Your reply has been submitted and is waiting moderation&#x27;); return redirect()-&gt;back();&#125; 在 CommentReply model 新增 'photo' 讓欄位可寫入 新增 reply comment 到 post view 123456789101112131415161718192021222324252627282930313233343536373839@if(count($comment-&gt;replies) &gt; 0) @foreach($comment-&gt;replies as $reply) &lt;!-- Nested Comment --&gt; &lt;div class=&quot;media&quot;&gt; &lt;a class=&quot;pull-left&quot; href=&quot;#&quot;&gt; &lt;img height=&quot;64&quot; class=&quot;media-object&quot; src=&quot;&#123;&#123;$reply-&gt;photo&#125;&#125;&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;div class=&quot;media-body&quot;&gt; &lt;h4 class=&quot;media-heading&quot;&gt;&#123;&#123;$reply-&gt;author&#125;&#125; &lt;small&gt;&#123;&#123;$reply-&gt;created_at-&gt;diffForHumans()&#125;&#125;&lt;/small&gt; &lt;/h4&gt; &lt;p&gt;&#123;&#123;$reply-&gt;body&#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123;!! Form::open([&#x27;method&#x27;=&gt;&#x27;POST&#x27;, &#x27;action&#x27;=&gt;&#x27;CommentRepliesController@createReply&#x27;]) !!&#125; &lt;input type=&quot;hidden&quot; name=&quot;comment_id&quot; value=&quot;&#123;&#123;$comment-&gt;id&#125;&#125;&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::label(&#x27;body&#x27;, &#x27;Body:&#x27;) !!&#125; &#123;!! Form::text(&#x27;body&#x27;, null, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;, &#x27;rows&#x27;=&gt;1]) !!&#125; &lt;/div&gt; &#123;&#123;csrf_field()&#125;&#125; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::submit(&#x27;submit&#x27;, [&#x27;class&#x27;=&gt;&#x27;btn btn-primary&#x27;]) !!&#125; &lt;/div&gt; &#123;!! Form::close() !!&#125; &lt;/div&gt; &lt;!-- End Nested Comment --&gt; @endforeach@endif 在 layouts.blog-post view 生成 script 區塊 @yield('scripts') 新增 div 123456789&lt;div class=&quot;comment-reply-container&quot;&gt; &lt;button class=&quot;toggle-reply btn btn-primary pull-right&quot;&gt;Reply&lt;/button&gt; &lt;div class=&quot;comment-reply&quot;&gt; /* Nested Comment*/ &lt;/div&gt;&lt;/div&gt; 在 resources/assets/scss/app.css 修改樣式，新增 .comment-reply &#123;display: none;&#125;，並用gulp編譯。 新增 scripts 區塊 12345678910111213@section(&#x27;scripts&#x27;) &lt;script&gt; $(&quot;.comment-reply-container .toggle-reply&quot;).click(function()&#123; $(this).next().slideToggle(&quot;slow&quot;); &#125;); &lt;/script&gt;@stop 在主管理介面顯示回覆 複製 comments/show view 到 comments/replies/show view，將 comment 改為 reply。 在 admin/comments/index view 新增 &lt;td&gt;&lt;a href=&quot;&#123;&#123;\" &#123;&#123;route('admin.comments.replies.show', $comment->id)\" &#125;&#125;&#125;&#125;&quot;&gt;View Replies&lt;/a&gt;&lt;/td&gt; 在 CommentRepliesController 新增 show function 12345678public function show($id)&#123; $comment = Comment::findOrFail($id); $replies = $comment-&gt;replies; return view(&#x27;admin.comments.replies.show&#x27;, compact(&#x27;replies&#x27;));&#125; 在 CommentRepliesController 新增 update function 123456public function update(Request $request, $id)&#123; CommentReply::findOrFail($id)-&gt;update($request-&gt;all()); return redirect()-&gt;back();&#125; 修改 post view 12345@if($reply-&gt;is_active == 1) /*nested comment*/ @else &lt;h1 class=&quot;text-center&quot;&gt;No Relies&lt;/h1&gt;@endif 在 CommentRepliesController 新增 destroy function 123456public function destroy($id)&#123; CommentReply::findOrFail($id)-&gt;delete(); redirect()-&gt;back();&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://vincent.fishboneapps.com/tags/Laravel/"}]},{"title":"Lavarel 快速學習自我挑戰 Day18","slug":"Lavarel-快速學習自我挑戰-Day18","date":"2017-05-28T08:02:04.000Z","updated":"2020-06-22T17:14:53.699Z","comments":true,"path":"2017/05/28/Lavarel-快速學習自我挑戰-Day18/","link":"","permalink":"https://vincent.fishboneapps.com/2017/05/28/Lavarel-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day18/","excerpt":"","text":"Application 留言功能 Part I 設定環境 新增 views/admin/comments/index.blade.php 和 views/admin/comments/replies/index.blade.php 新增 routes 12Route::resource(&#x27;admin/comments&#x27;, &#x27;PostCommentsController&#x27;);Route::resource(&#x27;admin/comments/replies&#x27;, &#x27;CommentRepliesController&#x27;); 新增 model php artisan make:model Comment -m php artisan make:model CommentReply -m 新增欄位到 create_comments_table 1234567891011121314Schema::create(&#x27;comments&#x27;, function (Blueprint $table) &#123; $table-&gt;increments(&#x27;id&#x27;); $table-&gt;integer(&#x27;post_id&#x27;)-&gt;unsigned()-&gt;index(); $table-&gt;integer(&#x27;is_active&#x27;)-&gt;default(0); $table-&gt;string(&#x27;author&#x27;); $table-&gt;string(&#x27;photo&#x27;); $table-&gt;string(&#x27;email&#x27;); $table-&gt;text(&#x27;body&#x27;); $table-&gt;timestamps(); $table-&gt;foreign(&#x27;post_id&#x27;)-&gt;references(&#x27;id&#x27;)-&gt;on(&#x27;posts&#x27;)-&gt;onDelete(&#x27;cascade&#x27;);&#125;); 新增欄位到 create_comment_replies_table 12345678910111213Schema::create(&#x27;comment_replies&#x27;, function (Blueprint $table) &#123; $table-&gt;increments(&#x27;id&#x27;); $table-&gt;integer(&#x27;comment_id&#x27;)-&gt;unsigned()-&gt;index(); $table-&gt;integer(&#x27;is_active&#x27;)-&gt;default(0); $table-&gt;string(&#x27;author&#x27;); $table-&gt;string(&#x27;photo&#x27;); $table-&gt;string(&#x27;email&#x27;); $table-&gt;text(&#x27;body&#x27;); $table-&gt;timestamps(); $table-&gt;foreign(&#x27;comment_id&#x27;)-&gt;references(&#x27;id&#x27;)-&gt;on(&#x27;comments&#x27;)-&gt;onDelete(&#x27;cascade&#x27;);&#125;); 匯入資料庫 php artisan migrate Relationship &amp; Mass Assignment 在 Post model 新增 12345public function comments()&#123; return $this-&gt;hasMany(&#x27;App\\Post&#x27;); &#125; 在 Comment model 新增 123456789101112131415protected $fillable = [ &#x27;post_id&#x27;, &#x27;author&#x27;, &#x27;email&#x27;, &#x27;body&#x27;, &#x27;is_active&#x27;];public function replies()&#123; return $this-&gt;hasMany(&#x27;App\\CommentReply&#x27;);&#125; 在 CommentReply 新增 123456789101112131415protected $fillable = [ &#x27;comment_id&#x27;, &#x27;author&#x27;, &#x27;email&#x27;, &#x27;body&#x27;, &#x27;is_active&#x27;];public function comment()&#123; return $this-&gt;belongsTo(&#x27;App\\Comment&#x27;);&#125; 新增 Controller php artisan make:controller --resource PostCommentsController php artisan make:controller --resource CommentRepliesController 設定 views 新增 layouts/blog-home.blade.php 和 layouts/blog-post.blade.php view 新增 layouts/blog.blade.php 創建貼文 將 admin route 移到 group 裡面 新增 routes Route::get('/post/&#123;id&#125;', ['as'=&gt;'home.post', 'uses'=&gt;'AdminPostsController@post']); 新增 post function 到 AdminPostsController 1234567public function post($id)&#123; $post = Post::findOrFail($id); return view(&#x27;post&#x27;, compact(&#x27;post&#x27;));&#125; 將 view 的 tilte 改為動態產生 &#123;&#123;\" &#123;&#123;$post->title\" &#125;&#125;&#125;&#125; 修改作者、時間、圖片、內文 &#123;&#123;\" &#123;&#123;$post->user->name\" &#125;&#125;&#125;&#125; &#123;&#123;\" &#123;&#123;$post->created_at->diffForHumans()\" &#125;&#125;&#125;&#125; &#123;&#123;\" &#123;&#123;$post->photo->file\" &#125;&#125;&#125;&#125; &#123;&#123;\" &#123;&#123;$post->body\" &#125;&#125;&#125;&#125; 創建留言 把 post view 的留言區改為 open form 123456789101112131415161718192021&lt;div class=&quot;well&quot;&gt; &lt;h4&gt;Leave a Comment:&lt;/h4&gt; &#123;!! Form::open([&#x27;method&#x27;=&gt;&#x27;POST&#x27;, &#x27;action&#x27;=&gt;&#x27;PostCommentsController@store&#x27;]) !!&#125; &lt;input type=&quot;hidden&quot; name=&quot;post_id&quot; value=&quot;&#123;&#123;$post-&gt;id&#125;&#125;&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::label(&#x27;body&#x27;, &#x27;Body:&#x27;) !!&#125; &#123;!! Form::textarea(&#x27;body&#x27;, null, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;, &#x27;rows&#x27;=&gt;3]) !!&#125; &lt;/div&gt; &#123;&#123;csrf_field()&#125;&#125; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::submit(&#x27;Submit comment&#x27;, [&#x27;class&#x27;=&gt;&#x27;btn btn-primary&#x27;]) !!&#125; &lt;/div&gt; &#123;!! Form::close() !!&#125;&lt;/div&gt; 修改 PostCommentsController 的 store function 123456789101112131415161718192021public function store(Request $request) &#123; $user = Auth::user(); $data = [ &#x27;post_id&#x27; =&gt; $request-&gt;post_id, &#x27;author&#x27; =&gt; $user-&gt;name, &#x27;email&#x27; =&gt; $user-&gt;email, &#x27;photo&#x27; =&gt; $user-&gt;photo-&gt;file, &#x27;body&#x27; =&gt; $request-&gt;body ]; Comment::create($data); $request-&gt;session()-&gt;flash(&#x27;comment message&#x27;, &#x27;Your message has been submitted and is waiting moderation&#x27;); return redirect()-&gt;back();&#125; 顯示訊息，修改 post view 12345@if(Session::has(&#x27;comment message&#x27;)) &#123;&#123;session(&#x27;comment message&#x27;)&#125;&#125;@endif 顯示貼文 修改 PostCommentsController 的 index function 12$comments = Comment::all();return view(&#x27;admin.comments.index&#x27;, compact(&#x27;comments&#x27;)); 修改 Comment model 12345public function post()&#123; return $this-&gt;belongsTo(&#x27;App\\Post&#x27;);&#125; 修改 comments/index view 1234567891011121314151617181920212223242526272829303132333435@if(count($comments) &gt; 0)&lt;h1&gt;Comments&lt;/h1&gt;&lt;table class=&quot;table&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;Author&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;th&gt;Body&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; @foreach($comments as $comment) &lt;tr&gt; &lt;td&gt;&#123;&#123;$comment-&gt;id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$comment-&gt;author&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$comment-&gt;email&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$comment-&gt;body&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;&#123;&#123;route(&#x27;home.post&#x27;, $comment-&gt;post-&gt;id)&#125;&#125;&quot;&gt;View Post&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; @endforeach &lt;/tbody&gt;&lt;/table&gt; @else &lt;h1 class=&quot;text-center&quot;&gt;No Comments&lt;/h1&gt;@endif 審核和刪除貼文 在 comments/index view 新增審核按鈕 12345678910111213141516171819202122232425262728293031323334&lt;td&gt; @if($comment-&gt;is_active == 1) &#123;!! Form::open([&#x27;method&#x27;=&gt;&#x27;PATCH&#x27;, &#x27;action&#x27;=&gt; [&#x27;PostCommentsController@update&#x27;, $comment-&gt;id]]) !!&#125; &lt;input type=&quot;hidden&quot; name=&quot;is_active&quot; value=&quot;0&quot;&gt; &#123;&#123;csrf_field()&#125;&#125; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::submit(&#x27;Un-approve&#x27;, [&#x27;class&#x27;=&gt;&#x27;btn btn-success&#x27;]) !!&#125; &lt;/div&gt; &#123;!! Form::close() !!&#125; @else &#123;!! Form::open([&#x27;method&#x27;=&gt;&#x27;PATCH&#x27;, &#x27;action&#x27;=&gt; [&#x27;PostCommentsController@update&#x27;, $comment-&gt;id]]) !!&#125; &lt;input type=&quot;hidden&quot; name=&quot;is_active&quot; value=&quot;1&quot;&gt; &#123;&#123;csrf_field()&#125;&#125; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::submit(&#x27;Approve&#x27;, [&#x27;class&#x27;=&gt;&#x27;btn btn-info&#x27;]) !!&#125; &lt;/div&gt; &#123;!! Form::close() !!&#125; @endif&lt;/td&gt; 在 comments/index view 新增刪除按鈕 12345678910111213&lt;td&gt; &#123;!! Form::open([&#x27;method&#x27;=&gt;&#x27;DELETE&#x27;, &#x27;action&#x27;=&gt; [&#x27;PostCommentsController@destroy&#x27;, $comment-&gt;id]]) !!&#125; &#123;&#123;csrf_field()&#125;&#125; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::submit(&#x27;Delete&#x27;, [&#x27;class&#x27;=&gt;&#x27;btn btn-danger&#x27;]) !!&#125; &lt;/div&gt; &#123;!! Form::close() !!&#125;&lt;/td&gt; 修改 PostCommentsController 的 update function 123Comment::findOrFail($id)-&gt;update($request-&gt;all());return redirect(&#x27;/admin/comments&#x27;); 修改 PostCommentsController 的 delete function 123Comment::findOrFail($id)-&gt;delete();return redirect()-&gt;back();","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://vincent.fishboneapps.com/tags/Laravel/"}]},{"title":"Lavarel 快速學習自我挑戰 Day17","slug":"Lavarel-快速學習自我挑戰-Day17","date":"2017-05-26T17:21:27.000Z","updated":"2020-06-22T17:14:53.700Z","comments":true,"path":"2017/05/26/Lavarel-快速學習自我挑戰-Day17/","link":"","permalink":"https://vincent.fishboneapps.com/2017/05/26/Lavarel-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day17/","excerpt":"","text":"Application Media 設定和顯示 新增 view views/media/index.blade.php 設定 media index view 12345678910111213141516171819202122232425262728293031323334@extends(&#x27;layouts.admin&#x27;)@section(&#x27;content&#x27;) &lt;h1&gt;Media&lt;/h1&gt; @if($photos) &lt;table class=&quot;table&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Created&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; @foreach($photos as $photo) &lt;tr&gt; &lt;td&gt;&#123;&#123;$photo-&gt;id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$photo-&gt;file&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$photo-&gt;created_at ? $photo-&gt;created_at : &#x27;no date&#x27;&#125;&#125;&lt;/td&gt; &lt;/tr&gt; @endforeach &lt;/tbody&gt; &lt;/table&gt; @endif@stop 新增 media controller php artisan make:control AdminMediasController 新增 routes Route::resource('admin/media', 'AdminMediasController'); 修改 layout admin 1234567&lt;li&gt; &lt;a href=&quot;&#123;&#123;route(&#x27;admin.media.index&#x27;)&#125;&#125;&quot;&gt;All Media&lt;/a&gt;&lt;/li&gt;&lt;li&gt; &lt;a href=&quot;&#123;&#123;route(&#x27;admin.media.upload&#x27;)&#125;&#125;&quot;&gt;Upload Media&lt;/a&gt;&lt;/li&gt; 在 AdminMediasController 新增 index function 1234567public function index()&#123; $photos = Photo::all(); return view(&#x27;admin.media.index&#x27;, compact(&#x27;photos&#x27;)); &#125; 修改 routes Route::get('admin/media/upload', ['as'=&gt;'admin.media.upload', 'uses'=&gt;'AdminMediasController@store']); 設定 view 刪除 routes (因為這個是為了不讓錯誤顯示) Route::get('admin/media/upload', ['as'=&gt;'admin.media.upload', 'uses'=&gt;'AdminMediasController@store']); 修改 layouts admin view &lt;a href=&quot;&#123;&#123;\" &#123;&#123;route('admin.media.create')\" &#125;&#125;&#125;&#125;&quot;&gt;Upload Media&lt;/a&gt; 在 AdminMediasController 新增 create function 12345public function create()&#123; return view(&#x27;admin.media.create&#x27;);&#125; 新增 media create view 12345678@extends(&#x27;layouts.admin&#x27;)@section(&#x27;content&#x27;) &lt;h1&gt;Upload Media&lt;/h1&gt;@stop 新增上傳外掛 Dropzone 上傳外掛 在 media create view 新增 script section 12345@section(&#x27;scripts&#x27;) &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/dropzone/4.3.0/min/dropzone.min.js&quot;&gt;&lt;/script&gt;@stop 在 media create view 新增 style section 12345@section(&#x27;styles&#x27;) &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/dropzone/4.3.0/min/dropzone.min.css&quot;&gt; @stop 在 layouts admin view 新增 yield 才能使用 section @yield('styles') @yield('scripts') 新增上傳區塊 12345&#123;!! Form::open([&#x27;method&#x27;=&gt;&#x27;POST&#x27;, &#x27;action&#x27;=&gt;&#x27;AdminMediasController@store&#x27;, &#x27;class&#x27;=&gt;&#x27;dropzone&#x27;]) !!&#125; &#123;&#123;csrf_field()&#125;&#125;&#123;!! Form::close() !!&#125; 上傳檔案 在 AdminMediasController 新增 store function 12345678910111213public function store(Request $request)&#123; $file = $request-&gt;file(&#x27;file&#x27;); $name = time() . $file-&gt;getClientOriginalName(); $file-&gt;move(&#x27;images&#x27;, $name); Photo::create([&#x27;file&#x27;=&gt;$name]); return $name;&#125; 刪除圖片 在 media index view 新增 delete button 12345678910&lt;td&gt; &#123;!! Form::open([&#x27;method&#x27;=&gt;&#x27;DELETE&#x27;, &#x27;action&#x27;=&gt;[&#x27;AdminMediasController@destroy&#x27;, $photo-&gt;id]]) !!&#125; &#123;&#123;csrf_field()&#125;&#125; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::submit(&#x27;Delete Post&#x27;, [&#x27;class&#x27;=&gt;&#x27;btn btn-danger&#x27;]) !!&#125; &lt;/div&gt; &#123;!! Form::close() !!&#125;&lt;/td&gt; 在 AdminMediaController 新增 destroy function 1234567891011public function destroy($id)&#123; $photo = Photo::findOrFail($id); unlink(public_path() . $photo-&gt;file); $photo-&gt;delete(); return redirect(&#x27;/admin/media&#x27;);&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://vincent.fishboneapps.com/tags/Laravel/"}]},{"title":"Lavarel 快速學習自我挑戰 Day16","slug":"Lavarel-快速學習自我挑戰-Day16","date":"2017-05-26T04:23:31.000Z","updated":"2020-06-22T17:14:53.699Z","comments":true,"path":"2017/05/26/Lavarel-快速學習自我挑戰-Day16/","link":"","permalink":"https://vincent.fishboneapps.com/2017/05/26/Lavarel-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day16/","excerpt":"","text":"Application Post Part II 對貼文分類新增 model 和 migration 新增 model php artisan make:model Category -m 在 category 的 model 處理 mass assignment protected $fillable = ['name']; 在 create_categories_table 新增欄位 $table-&gt;string('name'); 將欄位寫入資料庫 php artisan migrate 與貼文分類顯示或創建貼文 修改 posts 的 index view &lt;td&gt;&#123;&#123;\" &#123;&#123;$post->category ? $post->category->name : 'Uncategorized'\" &#125;&#125;&#125;&#125;&lt;/td&gt; 修改 AdminPostsController 的 create function 12$categories = Category::lists(&#x27;name&#x27;,&#x27;id&#x27;)-&gt;all();return view(&#x27;admin.posts.create&#x27;, compact(&#x27;categories&#x27;)); 修改 Post create view 1234&lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::label(&#x27;category_id&#x27;, &#x27;Category:&#x27;) !!&#125; &#123;!! Form::select(&#x27;category_id&#x27;, [&#x27;&#x27;=&gt;&#x27;Choose Categories&#x27;] + $categories, null, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;]) !!&#125;&lt;/div&gt; 編輯貼文 修改 AdminPostsController 的 edit function 123$post = Post::findOrFail($id);$categories = Category::lists(&#x27;name&#x27;, &#x27;id&#x27;)-&gt;all();return view(&#x27;admin.posts.edit&#x27;, compact(&#x27;post&#x27;, &#x27;categories&#x27;)); 複製 create view 到 edit view 並修改 form &#123;!! Form::model($post, ['method'=&gt;'PATCH', 'action'=&gt;['AdminPostsController@update', $post-&gt;id], 'files'=&gt;true]) !!&#125; 在 posts index view 的名字新增超連結 &lt;td&gt;&lt;a href=&quot;&#123;&#123;\" &#123;&#123;route('admin.posts.edit', $post->id)\" &#125;&#125;&#125;&#125;&quot;&gt;&#123;&#123;\" &#123;&#123;$post->user->name\" &#125;&#125;&#125;&#125;&lt;/a&gt;&lt;/td&gt; 修改 post edit view 的 category &#123;!! Form::select('category_id', $categories, null, ['class'=&gt;'form-control']) !!&#125; 修改 AdminPostsController 的 update function 1234567891011121314151617$input = $request-&gt;all();if($file = $request-&gt;file(&#x27;photo_id&#x27;))&#123; $name = time() . $file-&gt;getClientOriginalName(); $file-&gt;move(&#x27;images&#x27;, $name); $photo = Photo::create([&#x27;file&#x27;=&gt;$name]); $input[&#x27;photo_id&#x27;] = $photo-&gt;id;&#125;Auth::user()-&gt;posts()-&gt;whereId($id)-&gt;first()-&gt;update($input);return redirect(&#x27;/admin/posts&#x27;); 在 post index view 縮短字的長度 &#123;&#123;\" &#123;&#123;str_limit($post->body, 30)\" &#125;&#125;&#125;&#125; 刪除貼文 在 post edit view 新增 delete button 123456789&#123;!! Form::open([&#x27;method&#x27;=&gt;&#x27;DELETE&#x27;, &#x27;action&#x27;=&gt;[&#x27;AdminPostsController@destroy&#x27;, $post-&gt;id]]) !!&#125; &#123;&#123;csrf_field()&#125;&#125; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::submit(&#x27;Delete Post&#x27;, [&#x27;class&#x27;=&gt;&#x27;btn btn-danger col-sm-6&#x27;]) !!&#125; &lt;/div&gt;&#123;!! Form::close() !!&#125; 修改 AdminPostsController 的 destroy function 1234567$post = Post::findOrfail($id);unlink(public_path() . $post-&gt;photo-&gt;file);$post-&gt;delete();return redirect(&#x27;/admin/posts&#x27;); 刪除使用者時也刪除貼文 修改 create_posts_table $table-&gt;foreign('user_id')-&gt;references('id')-&gt;on('users')-&gt;onDelete('cascade'); 更新資料庫 php artisan migrate:refresh 在編輯貼文時顯示圖片 修改 post edit view 12345&lt;div class=&quot;col-sm-3&quot;&gt; &lt;img src=&quot;&#123;&#123;$post-&gt;photo-&gt;file&#125;&#125;&quot; alt=&quot;&quot; class=&quot;img-responsive&quot;&gt;&lt;/div&gt; 設定分類 新增 Controller php artisan make:controller --resource AdminCategoriesController 新增 routes Route::resource('admin/categories', 'AdminCategoriesController'); 新增 categories index view 1234567@extends(&#x27;layouts.admin&#x27;);@section(&#x27;content&#x27;) &lt;h1&gt;Categories&lt;/h1&gt;@stop 修改 layout.admin 的 routes 1234567&lt;li&gt; &lt;a href=&quot;&#123;&#123;route(&#x27;admin.categories.index&#x27;)&#125;&#125;&quot;&gt;All Categories&lt;/a&gt;&lt;/li&gt;&lt;li&gt; &lt;a href=&quot;&#123;&#123;route(&#x27;admin.categories.create&#x27;)&#125;&#125;&quot;&gt;Create Category&lt;/a&gt;&lt;/li&gt; 創建分類 修改 AdminCategoriesController 的 index 123$categories = Category::all();return view(&#x27;admin.categories.index&#x27;, compact(&#x27;categories&#x27;)); 修改 categories index view 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@extends(&#x27;layouts.admin&#x27;);@section(&#x27;content&#x27;) &lt;h1&gt;Categories&lt;/h1&gt; &lt;div class=&quot;col-sm-6&quot;&gt; &#123;!! Form::open([&#x27;method&#x27;=&gt;&#x27;POST&#x27;, &#x27;action&#x27;=&gt;&#x27;AdminCategoriesController@store&#x27;]) !!&#125; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::label(&#x27;name&#x27;, &#x27;Name:&#x27;) !!&#125; &#123;!! Form::text(&#x27;name&#x27;, null, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;]) !!&#125; &lt;/div&gt; &#123;&#123;csrf_field()&#125;&#125; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::submit(&#x27;Create Category&#x27;, [&#x27;class&#x27;=&gt;&#x27;btn btn-primary&#x27;]) !!&#125; &lt;/div&gt; &#123;!! Form::close() !!&#125; &lt;/div&gt; &lt;div class=&quot;col-sm-6&quot;&gt; @if($categories) &lt;table class=&quot;table&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Created date&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; @foreach($categories as $category) &lt;tr&gt; &lt;td&gt;&#123;&#123;$category-&gt;id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$category-&gt;name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$category-&gt;created_at ? $category-&gt;created_at-&gt;diffForHumans() : &#x27;No date&#x27;&#125;&#125;&lt;/td&gt; &lt;/tr&gt; @endforeach &lt;/table&gt; @endif &lt;/div&gt;@stop 在 AdminCategoriesController store function 12Category::create($request-&gt;all());return redirect(&#x27;admin/categories&#x27;); 更新和刪除分類 修改 category edit view 1234567891011121314151617181920212223242526272829@extends(&#x27;layouts.admin&#x27;);@section(&#x27;content&#x27;) &lt;h1&gt;Categories&lt;/h1&gt; &lt;div class=&quot;col-sm-6&quot;&gt; &#123;!! Form::model($category, [&#x27;method&#x27;=&gt;&#x27;PATCH&#x27;, &#x27;action&#x27;=&gt;[&#x27;AdminCategoriesController@update&#x27;, $category-&gt;id]]) !!&#125; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::label(&#x27;name&#x27;, &#x27;Name:&#x27;) !!&#125; &#123;!! Form::text(&#x27;name&#x27;, null, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;]) !!&#125; &lt;/div&gt; &#123;&#123;csrf_field()&#125;&#125; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::submit(&#x27;Update Category&#x27;, [&#x27;class&#x27;=&gt;&#x27;btn btn-primary&#x27;]) !!&#125; &lt;/div&gt; &#123;!! Form::close() !!&#125; &lt;/div&gt; &lt;div class=&quot;col-sm-6&quot;&gt; &lt;/div&gt;@stop 修改 AdminCategoriesController 的 edit function 12$category = Category::findOrFail($id);return view(&#x27;admin.categories&#x27;, compact(&#x27;category&#x27;)); 在 category edit view 新增 delete button 123456789&#123;!! Form::open([&#x27;method&#x27;=&gt;&#x27;DELETE&#x27;, &#x27;action&#x27;=&gt;[&#x27;AdminCategoriesController@destroy&#x27;, $category-&gt;id]]) !!&#125;&#123;&#123;csrf_field()&#125;&#125;&lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::submit(&#x27;Delete Category&#x27;, [&#x27;class&#x27;=&gt;&#x27;btn btn-danger col-sm-6&#x27;]) !!&#125;&lt;/div&gt;&#123;!! Form::close() !!&#125; 修改 AdminCategoriesController 的 destroy function 12Category::findOrFail($id)-&gt;delete();return redirect(&#x27;/admin/categories&#x27;); 修改 AdminCategoriesController 的 update function 123$category = Category::findOrFail($id);$category-&gt;update($request-&gt;all());return redirect(&#x27;/admin/categories&#x27;);","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://vincent.fishboneapps.com/tags/Laravel/"}]},{"title":"Lavarel 快速學習自我挑戰 Day15","slug":"Lavarel-快速學習自我挑戰-Day15","date":"2017-05-25T12:10:35.000Z","updated":"2020-06-22T17:14:53.700Z","comments":true,"path":"2017/05/25/Lavarel-快速學習自我挑戰-Day15/","link":"","permalink":"https://vincent.fishboneapps.com/2017/05/25/Lavarel-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day15/","excerpt":"","text":"Application Post Part I 設定 routes 設定 404 page view 1234567@extends(&#x27;layouts.app&#x27;)@section(&#x27;content&#x27;) &lt;h1 class=&quot;text-center&quot;&gt;Opps no page available&lt;/h1&gt;@stop 新增 routes 在 admin group 裡面 Route::resource('admin/posts', 'AdminPostsController'); 新增 Controller php artisan make:controller --resource AdminPostsController 在 Controller 的 index return view('admin.posts.index'); 新增 /views/admin/posts/index.blade.php 1234567@extends(&#x27;layouts.admin&#x27;)@section(&#x27;content&#x27;) &lt;h1&gt;Posts&lt;/h1&gt;@stop 修改 layouts 的連結 All Posts -&gt; &#123;&#123;\" &#123;&#123;route('admin.posts.index')\" &#125;&#125;&#125;&#125; Create Post -&gt; &#123;&#123;\" &#123;&#123;route('admin.posts.create')\" &#125;&#125;&#125;&#125; 修改 Create 和 Edit 的 view 1234567@extends(&#x27;layouts.admin&#x27;)@section(&#x27;content&#x27;) &lt;h1&gt;Create Post&lt;/h1&gt;@stop 1234567@extends(&#x27;layouts.admin&#x27;)@section(&#x27;content&#x27;) &lt;h1&gt;Edit Post&lt;/h1&gt;@stop 修改 Controller 的 create return view('admin.posts.create'); Migration 新增 model php artisan make:model Post -m 在 create_posts_table 新增欄位 12345$table-&gt;integer(&#x27;user_id&#x27;)-&gt;unsigned()-&gt;index();$table-&gt;integer(&#x27;category_id&#x27;)-&gt;unsigned()-&gt;index();$table-&gt;integer(&#x27;photo_id&#x27;)-&gt;unsigned()-&gt;inex();$table-&gt;string(&#x27;title&#x27;);$table-&gt;text(&#x27;body&#x27;); 寫入資料庫 php artisan migrate 顯示貼文 在 Post model 處理 mass assignment 12345678protected $fillable = [ &#x27;category_id&#x27;, &#x27;photo_id&#x27;, &#x27;title&#x27;, &#x27;body&#x27;]; 進入 tinker 模式新增資料庫內容 php artisan tinker 新增一行資料 $post = App\\Post::create(['title'=&gt;'my first post', 'body'=&gt;'I love laravel with Edwin Diaz']); 修改 Controller 的 Index function 12$posts = Post::all();return view(&#x27;admin.posts.index&#x27;, compact(&#x27;posts&#x27;)); 在 Post index view 新增一個 table 讀取資料庫資料 1234567891011121314151617181920212223242526272829303132333435&lt;table class=&quot;table&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;User&lt;/th&gt; &lt;th&gt;Category&lt;/th&gt; &lt;th&gt;Photo&lt;/th&gt; &lt;th&gt;Title&lt;/th&gt; &lt;th&gt;body&lt;/th&gt; &lt;th&gt;Created&lt;/th&gt; &lt;th&gt;Updated&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; @if($posts) @foreach($posts as $post) &lt;tr&gt; &lt;td&gt;&#123;&#123;$post-&gt;id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$post-&gt;user_id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$post-&gt;category_id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$post-&gt;photo_id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$post-&gt;title&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$post-&gt;body&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$post-&gt;created_at-&gt;diffForHumans()&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$post-&gt;updated_at-&gt;diffForHumans()&#125;&#125;&lt;/td&gt; &lt;/tr&gt; @endforeach @endif &lt;/tbody&gt;&lt;/table&gt; Relationship 設定 在 User model 新增 posts function 12345public function posts()&#123; return $this-&gt;hasMany(&#x27;App\\Post&#x27;);&#125; 在 Post model 新增 user function 12345public function user()&#123; return $this-&gt;belongsTo(&#x27;App\\User&#x27;);&#125; 修改 index view 的 user 欄位 &#123;&#123; \"&#123;&#123;$post->user->name\" &#125;&#125;&#125;&#125; 在 Post model 新增 photo 和 category function 12345678910public function photo()&#123; return $this-&gt;belongsTo(&#x27;App\\Photo&#x27;); &#125;public function category()&#123; return $this-&gt;belongsTo(&#x27;App\\Category&#x27;);&#125; 在 Role model 讓 name 可寫入 12345protected $fillable = [ &#x27;name&#x27;]; 創建表單 新增 create view 表單 1234567891011121314151617181920212223242526272829&#123;!! Form::open([&#x27;method&#x27;=&gt;&#x27;POST&#x27;, &#x27;action&#x27;=&gt;&#x27;AdminPostsController@store&#x27;, &#x27;files&#x27;=&gt;true]) !!&#125; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::label(&#x27;title&#x27;, &#x27;Title:&#x27;) !!&#125; &#123;!! Form::text(&#x27;title&#x27;, null, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;]) !!&#125; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::label(&#x27;category_id&#x27;, &#x27;Category:&#x27;) !!&#125; &#123;!! Form::select(&#x27;category_id&#x27;, array(&#x27;&#x27;=&gt;&#x27;options&#x27;), null, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;]) !!&#125; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::label(&#x27;photo_id&#x27;, &#x27;Photo:&#x27;) !!&#125; &#123;!! Form::file(&#x27;photo_id&#x27;, null, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;]) !!&#125; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::label(&#x27;body&#x27;, &#x27;Description:&#x27;) !!&#125; &#123;!! Form::textarea(&#x27;body&#x27;, null, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;, &#x27;rows&#x27;=&gt;3]) !!&#125; &lt;/div&gt; &#123;&#123;csrf_field()&#125;&#125; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::submit(&#x27;Create Post&#x27;, [&#x27;class&#x27;=&gt;&#x27;btn btn-primary&#x27;]) !!&#125; &lt;/div&gt;&#123;!! Form::close() !!&#125; 新增 Request php artisan make:request PostsCreateRequest 修改 PostscreateRequest 12345678910111213141516public function authorize() &#123; return true; &#125;public function rules() &#123; return [ &#x27;title&#x27; =&gt;&#x27;required&#x27;, &#x27;category_id&#x27; =&gt;&#x27;required&#x27;, &#x27;photo_id&#x27; =&gt;&#x27;required&#x27;, &#x27;body&#x27; =&gt;&#x27;required&#x27; ]; &#125; 在 create post view include error message @include('includes.form_error') 創建貼文 更新 Controller 的 store function 12345678910111213141516171819$input = $request-&gt;all();$user = Auth::user();if($file = $request-&gt;file(&#x27;photo_id&#x27;))&#123; $name = time() . $file-&gt;getClientOriginalName(); $file-&gt;move(&#x27;images&#x27;, $name); $photo = Photo::create([&#x27;file&#x27;=&gt;$name]); $input[&#x27;photo_id&#x27;] = $photo-&gt;id;&#125;$user-&gt;posts()-&gt;create($input);return redirect(&#x27;/admin/posts&#x27;); 修改 Post index view 來顯示圖片 &lt;img height=&quot;100&quot; src=&quot;&#123;&#123; \"&#123;&#123;$post->photo ? $post->photo->file : 'http://placehold.it/400x400'\" &#125;&#125;&#125;&#125;&quot; alt=&quot;&quot;&gt;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://vincent.fishboneapps.com/tags/Laravel/"}]},{"title":"Lavarel 快速學習自我挑戰 Day14","slug":"Lavarel-快速學習自我挑戰-Day14","date":"2017-05-04T16:06:02.000Z","updated":"2020-06-22T17:14:53.699Z","comments":true,"path":"2017/05/04/Lavarel-快速學習自我挑戰-Day14/","link":"","permalink":"https://vincent.fishboneapps.com/2017/05/04/Lavarel-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day14/","excerpt":"","text":"Application 2 上傳功能 新增 enctype ('type'=&gt;true) &#123;!! Form::open(['method'=&gt;'POST', 'action'=&gt;'AdminUsersController@store', 'files'=&gt;true]) !!&#125; 新增 migration php artisan make:migration add_photo_id_to_users --table=users 修改 add_photo_id_to_users_table 1234567891011121314public function up()&#123; Schema::table(&#x27;users&#x27;, function (Blueprint $table) &#123; $table-&gt;string(&#x27;photo_id&#x27;); &#125;);&#125;public function down()&#123; Schema::table(&#x27;users&#x27;, function (Blueprint $table) &#123; $table-&gt;dropColumn(&#x27;photo_id&#x27;); &#125;);&#125; 在 Create Page 新增 upload 欄位 1234&lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::label(&#x27;file&#x27;, &#x27;Title:&#x27;) !!&#125; &#123;!! Form::file(&#x27;file&#x27;, null, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;]) !!&#125;&lt;/div&gt; 在 User model 讓欄位可寫入 protected $fillable = ['name', 'email', 'password', 'role_id', 'is_active', 'photo_id'] 修改 AdminUsersController 的 store function 123456public function store(UsersRequest $request)&#123; User::create($request-&gt;all()); return redirect(&#x27;/admin/users&#x27;);&#125; 新增 Model 和 migration php artisan make:model Photo -m 在 create_photos_table 新增欄位 $table-&gt;string('file'); 在 Photo model 讓 file 可寫入 protected $fillable = ['file']; 在 User model 新增 relationship public function photo()&#123;return $this-&gt;belongsTo('App\\Photo');&#125; 新增連結 在 layouts/admin.blade.php 新增 route link 1234567&lt;li&gt; &lt;a href=&quot;&#123;&#123;route(&#x27;admin.users.index&#x27;)&#125;&#125;&quot;&gt;All Users&lt;/a&gt;&lt;/li&gt;&lt;li&gt; &lt;a href=&quot;&#123;&#123;route(&#x27;admin.users.create&#x27;)&#125;&#125;&quot;&gt;Create User&lt;/a&gt;&lt;/li&gt; 修改 create page 1234&lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::label(&#x27;photo_id&#x27;, &#x27;Photo:&#x27;) !!&#125; &#123;!! Form::file(&#x27;photo_id&#x27;, null, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;]) !!&#125;&lt;/div&gt; 在 AdminUsersController 的 store function 新增 1234567891011if($file = $request-&gt;file(&#x27;photo_id&#x27;)) &#123; $name = time() . $file-&gt;getClientOriginalName(); $file-&gt;move(&#x27;images&#x27;, $name); $photo = Photo::create([&#x27;file&#x27;=&gt;$name]); $input[&#x27;photo_id&#x27;] = $photo-&gt;id;&#125; 繼續在 store function 將密碼加密後儲存所有檔案 123$input[&#x27;password&#x27;] = bcrypt($request-&gt;password);User::create($input); 新增路徑資訊到 Photo model 1234567protected $uploads = &#x27;/images/&#x27;;public function getFileAttribute($photo)&#123; return $this-&gt;uploads . $photo;&#125; 新增 photo 到 User index page &lt;td&gt;&lt;img height=&quot;50&quot; src=&quot;&#123;&#123; \"&#123;&#123;$user->photo ? $user->photo->file : 'no user photo'\" &#125;&#125;&#125;&#125;&quot; alt=&quot;&quot;&gt;&lt;/td&gt; Edit page 修改 AdminUsersController 的 edit function (傳送 role 的資訊) 12345678public function edit($id) &#123; $user = User::findOrFail($id); $roles = Role::lists(&#x27;name&#x27;, &#x27;id&#x27;)-&gt;all(); return view(&#x27;admin.users.edit&#x27;, compact(&#x27;user&#x27;, &#x27;roles&#x27;)); &#125; 修改 edit page (先從 create page 複製頁面，將 form 連結 model) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@extends(&#x27;layouts.admin&#x27;)@section(&#x27;content&#x27;) &lt;h1&gt;Edit User&lt;/h1&gt; &#123;!! Form::model($user, [&#x27;method&#x27;=&gt;&#x27;PATCH&#x27;, &#x27;action&#x27;=&gt;[&#x27;AdminUsersController@update&#x27;, $user-&gt;id], &#x27;files&#x27;=&gt;true]) !!&#125; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::label(&#x27;name&#x27;, &#x27;Name:&#x27;) !!&#125; &#123;!! Form::text(&#x27;name&#x27;, null, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;]) !!&#125; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::label(&#x27;email&#x27;, &#x27;Email:&#x27;) !!&#125; &#123;!! Form::email(&#x27;email&#x27;, null, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;]) !!&#125; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::label(&#x27;role_id&#x27;, &#x27;Role:&#x27;) !!&#125; &#123;!! Form::select(&#x27;role_id&#x27;, $roles , null, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;]) !!&#125; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::label(&#x27;is_active&#x27;, &#x27;Status:&#x27;) !!&#125; &#123;!! Form::select(&#x27;is_active&#x27;, array(1 =&gt; &#x27;Active&#x27;, 0 =&gt; &#x27;No Active&#x27;), 0, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;]) !!&#125; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::label(&#x27;photo_id&#x27;, &#x27;Photo:&#x27;) !!&#125; &#123;!! Form::file(&#x27;photo_id&#x27;, null, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;]) !!&#125; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::label(&#x27;password&#x27;, &#x27;Password:&#x27;) !!&#125; &#123;!! Form::password(&#x27;password&#x27;, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;]) !!&#125; &lt;/div&gt; &#123;&#123;csrf_field()&#125;&#125; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::submit(&#x27;Create User&#x27;, [&#x27;class&#x27;=&gt;&#x27;btn btn-primary&#x27;]) !!&#125; &lt;/div&gt; &#123;!! Form::close() !!&#125; @include(&#x27;includes.form_error&#x27;)@stop 在 edit page 新增圖片 123456789&lt;div class=&quot;col-sm-3&quot;&gt; &lt;img src=&quot;&#123;&#123;$user-&gt;photo ? $user-&gt;photo-&gt;file : &#x27;http://placehold.it/400x400&#x27;&#125;&#125;&quot; alt=&quot;&quot; class=&quot;img-responsive img-rounded&quot;&gt; &lt;/div&gt;&lt;div class=&quot;col-sm-9&quot;&gt;&lt;/div&gt; 將 users/index view 的圖片改成若無圖片，顯示 sample 圖片 &lt;td&gt;&lt;img height=&quot;50&quot; src=&quot;&#123;&#123; \"&#123;&#123;$user->photo ? $user->photo->file : 'http://placehold.it/400x400'\" &#125;&#125;&#125;&#125;&quot; alt=&quot;&quot;&gt;&lt;/td&gt; 將 AdminUsersController 的 update function 改用 UsersRequest 來做 validation public function update(UsersRequest $request, $id)&#123;&#125; 修改 AdminUsersController 的 update function 12345678910111213141516171819202122public function update(UsersRequest $request, $id)&#123; $user = User::findOrFail($id); $input = $request-&gt;all(); if($file = $request-&gt;file(&#x27;photo_id&#x27;)) &#123; $name = time() . $file-&gt;getClientOriginalName(); $file-&gt;move(&#x27;images&#x27;, $name); $photo = Photo::create([&#x27;file&#x27; =&gt; $name]); $input[&#x27;photo_id&#x27;] = $photo-&gt;id; &#125; $user-&gt;update($input); return redirect(&#x27;/admin/users&#x27;)&#125; 新增新的 Request php artisan make:request UsersEditRequest 修改 Request public function authorize()&#123;return true;&#125; 123456789public function rules() &#123; return [ &#x27;name&#x27; =&gt; &#x27;required&#x27;, &#x27;email&#x27; =&gt; &#x27;required&#x27;, &#x27;role_id&#x27; =&gt; &#x27;required&#x27;, &#x27;is_active&#x27; =&gt; &#x27;required&#x27;, ]; &#125; 修改 AdminUsersController 的 create 和 update function 1234567891011if(trim($request-&gt;password) == &#x27;&#x27;)&#123; $input = $request-&gt;except(&#x27;password&#x27;);&#125; else &#123; $input = $request-&gt;all(); $input[&#x27;password&#x27;] = bcrypt($request-&gt;password);&#125; Mutator 123456789public function setPasswordAttribute($password)&#123; if(!empty($password))&#123; $this-&gt;attributes[&#x27;password&#x27;] = bcrypt($password); &#125;&#125; Middleware 新增一個 middleware php artisan make:middleware Admin 在 app\\kernel.php 註冊 middleware (routemiddleware) 'admin' =&gt; \\App\\Http\\Middleware\\Admin::class, 新增 404 頁面 resources\\views\\errors\\404.blade.php 在 User model 新增一個 function 1234567891011public function isAdmin()&#123; if($this-&gt;role-&gt;name == &quot;administrator&quot;)&#123; return true; &#125; return false;&#125; 修改 Admin middleware 123456789101112131415public function handle($request, Closure $next)&#123; if(Auth::check())&#123; if(Auth::user()-&gt;isAdmin())&#123; return $next($request); &#125; &#125; return redirect(&#x27;/&#x27;);&#125; Delete User 新增 form 到 Users/edit view 1234567&#123;!! Form::open([&#x27;method&#x27;=&gt;&#x27;DELETE&#x27;, &#x27;action&#x27;=&gt;[&#x27;AdminUsersController@destroy&#x27;, $user-&gt;id]]) !!&#125; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::submit(&#x27;Delete User&#x27;, [&#x27;class&#x27;=&gt;&#x27;btn btn-danger&#x27;]) !!&#125; &lt;/div&gt;&#123;!! Form::close() !!&#125; 在 AdminUsersController 新增 destroy function 12345678public function destroy($id)&#123; User::findOrfail($id)-&gt;delete(); Session::flash(&#x27;deleted_user&#x27;, &quot;The user has been deleted&quot;); return redirect(&#x27;/admin/users&#x27;);&#125; 將讀取到的 session 顯示在 Users/index view 12345@if(Session::has(&#x27;deleted_user&#x27;)) &lt;p class=&quot;bg-danger&quot;&gt;&#123;&#123;session(&#x27;deleted_user&#x27;)&#125;&#125;&lt;/p&gt;@endif 在目錄刪除圖片 修改 destroy function 123456789101112public function destroy($id)&#123; $user = User::findOrfail($id); unlink(public_path() . $user-&gt;photo-&gt;file); $user-&gt;delete(); Session::flash(&#x27;deleted_user&#x27;, &quot;The user has been deleted&quot;); return redirect(&#x27;/admin/users&#x27;);&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://vincent.fishboneapps.com/tags/Laravel/"}]},{"title":"Lavarel 快速學習自我挑戰 Day13","slug":"Lavarel-快速學習自我挑戰-Day13","date":"2017-05-03T19:07:21.000Z","updated":"2020-06-22T17:14:53.699Z","comments":true,"path":"2017/05/03/Lavarel-快速學習自我挑戰-Day13/","link":"","permalink":"https://vincent.fishboneapps.com/2017/05/03/Lavarel-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day13/","excerpt":"","text":"Application 基礎設定 開新的專案 composer create-project --prefer-dist laravel/laravel codehacking 5.2.29 新增資料庫、設定環境變數、進行 migration php artisan migrate 設定 views 新增登入介面 php artisan make:auth 在 view 將目錄權限分開 新增 admin/index admin/users/index admin/users/create admin/users/edit admin/posts/index admin/posts/create admin/posts/edit admin/categories/index admin/categories/edit User table migration 加入 git 專案：git init、git add .、git commit -m &quot;my first commit - admin view created&quot; 新增資料欄位到 create_users_table.php $table-&gt;integer('role_id')-&gt;index()-&gt;unsigned()-&gt;nullable(); $table-&gt;integer('is_active')-&gt;default(0); 新增 model php artisan make:model Role -m 新增資料欄位到 create_roles_table.php $table-&gt;string('name'); Relation setup and data entry 新增 Relation 到 User model 12345public function role()&#123; return $this-&gt;belongsTo(&#x27;App\\Role&#x27;);&#125; 將資料重新 migrate 到資料庫 php artisan migrate:refresh 用 Tinker 測試 Relation 進入 tinder 模式 php aritsan tinker 找到第一個 User $user = App\\User::find(1) 檢查該 user 的 role $user-&gt;role 新增 User App\\User::create(['name'=&gt;'Edwin Diaz', 'email'=&gt;'edwin@codingfaculty.com']); Admin Controller and Routes 新增 routes Route::resource('admin/users', 'AdminUsersController'); 新增 controller php artisan make:controller --resource AdminUsersController 在 AdminUsersController 的 index function 加入 return view('admin.users.index'); 在 AdminUsersController 的 create function 加入 return view('admin.users.create'); 在 AdminUsersController 的 show function 加入 return view('admin.users.show'); 在 AdminUsersController 的 edit function 加入 return view('admin.users.edit'); 安裝 nodejs &amp; 下載檔案 安裝 gulp npm install --global gulp Gulp &amp; assets 安裝套件 npm install 將 css、js 檔案放置到 resources\\assets 將 font 檔案放置到 public 設定 gulpfile.js 12345678910111213141516171819.styles([ &#x27;libs/blog-post.css&#x27;, &#x27;libs/bootstrap.css&#x27;, &#x27;libs/font-awesome.css&#x27;, &#x27;libs/metisMenu.css&#x27;, &#x27;libs/sb-admin-2.css&#x27; ], &#x27;./public/css/libs.css&#x27;).scripts([ &#x27;libs/jquery.js&#x27;, &#x27;libs/bootstrap.js&#x27;, &#x27;libs/metisMenu.js&#x27;, &#x27;libs/sb-admin-2.js&#x27;, &#x27;libs/scripts.js&#x27; ], &#x27;./public/js/libs.js&#x27;) 編譯檔案 gulp 新增 view /layouts/admin.blade.php 修正頁面 修改 resources/assets/sass/app.scss #admin-page &#123;padding-top: 0px;&#125; 重新編譯檔案 gulp 新增 routes 12345Route::get(&#x27;/admin&#x27;, function()&#123; return view(&#x27;admin.index&#x27;);&#125;); 修改 admin/index view 1234567@extends(&#x27;layouts.admin&#x27;)@section(&#x27;content&#x27;) &lt;h1&gt;Admin&lt;/h1&gt;@stop 顯示 Users 修改 admin/users/index view 1234567@extends(&#x27;layouts.admin&#x27;)@section(&#x27;content&#x27;) &lt;h1&gt;Users&lt;/h1&gt;@stop 修改 AdminUsersController 123456public function index() &#123; $users = User::all(); return view(&#x27;admin.users.index&#x27;, compact(&#x27;users&#x27;)); &#125; 在 admin/users/index view 新增 table 1234567891011121314151617181920212223242526272829303132&lt;table class=&quot;table&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Email&lt;/th&gt; &lt;th&gt;Role&lt;/th&gt; &lt;th&gt;Active&lt;/th&gt; &lt;th&gt;Created&lt;/th&gt; &lt;th&gt;Updated&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; @if($users) @foreach($users as $user) &lt;tr&gt; &lt;td&gt;&#123;&#123;$user-&gt;id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$user-&gt;name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$user-&gt;email&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$user-&gt;role-&gt;name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$user-&gt;is_active == 1 ? &#x27;Active&#x27; : &#x27;No Active&#x27;&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$user-&gt;created_at-&gt;diffForHumans()&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;$user-&gt;updated_at-&gt;diffForHumans()&#125;&#125;&lt;/td&gt; &lt;/tr&gt; @endforeach @endif &lt;/tbody&gt;&lt;/table&gt; 新增 Create Page 1234567@extends(&#x27;layouts.admin&#x27;)@section(&#x27;content&#x27;) &lt;h1&gt;Create User&lt;/h1&gt;@stop 安裝 laravel collective html package composer require &quot;laravelcollective/html&quot;:&quot;^5.2.0&quot; 在 config/app.php 新增 provider Collective\\Html\\HtmlServiceProvider::class, 在 config/app.php 新增 aliases 'Form' =&gt; Collective\\Html\\FormFacade::class, 'Html' =&gt; Collective\\Html\\HtmlFacade::class, Create Page Form 表單 在 admin/users/create view 新增表單 1234567891011121314151617181920212223242526272829303132&#123;!! Form::open([&#x27;method&#x27;=&gt;&#x27;POST&#x27;, &#x27;action&#x27;=&gt;&#x27;AdminUsersController@store&#x27;]) !!&#125; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::label(&#x27;name&#x27;, &#x27;Name:&#x27;) !!&#125; &#123;!! Form::text(&#x27;name&#x27;, null, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;]) !!&#125; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::label(&#x27;email&#x27;, &#x27;Email:&#x27;) !!&#125; &#123;!! Form::email(&#x27;email&#x27;, null, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;]) !!&#125; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::label(&#x27;role_id&#x27;, &#x27;Role:&#x27;) !!&#125; &#123;!! Form::select(&#x27;role_id&#x27;, [&#x27;&#x27;=&gt;&#x27;Choose Options&#x27;] + $roles , null, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;]) !!&#125; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::label(&#x27;status&#x27;, &#x27;Status:&#x27;) !!&#125; &#123;!! Form::select(&#x27;status&#x27;, array(1 =&gt; &#x27;Active&#x27;, 0 =&gt; &#x27;No Active&#x27;), 0, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;]) !!&#125; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::label(&#x27;password&#x27;, &#x27;Password:&#x27;) !!&#125; &#123;!! Form::password(&#x27;password&#x27;, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;]) !!&#125; &lt;/div&gt; &#123;&#123;csrf_field()&#125;&#125; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::submit(&#x27;Create User&#x27;, [&#x27;class&#x27;=&gt;&#x27;btn btn-primary&#x27;]) !!&#125; &lt;/div&gt; &#123;!! Form::close() !!&#125; Role 的資料引入 (用 controller 抓取資料) - 修改 AdminUsersController 123456public function create() &#123; $roles = Role::lists(&#x27;name&#x27;, &#x27;id&#x27;)-&gt;all(); return view(&#x27;admin.users.create&#x27;, compact(&#x27;roles&#x27;)); &#125; 新增 Request php artisan make:request UsersRequest 新增 rules function validation 12345678910public function rules() &#123; return [ &#x27;name&#x27; =&gt; &#x27;required&#x27;, &#x27;email&#x27; =&gt; &#x27;required&#x27;, &#x27;role_id&#x27; =&gt; &#x27;required&#x27;, &#x27;is_active&#x27; =&gt; &#x27;required&#x27;, &#x27;password&#x27; =&gt; &#x27;required&#x27; ]; &#125; 將 AdminUsersController 的 store function 的 Request 換成 UsersRequest (要 import) public function store(UsersRequest $request) 新增 views/includes/form_error.blade.php 1234567891011121314151617@if(count($errors) &gt; 0) &lt;div class=&quot;alert alert-danger&quot;&gt; &lt;ul&gt; @foreach($errors-&gt;all() as $error) &lt;li&gt;&#123;&#123;$error&#125;&#125;&lt;/li&gt; @endforeach &lt;/ul&gt; &lt;/div&gt;@endif 在 create page view include form error @include('includes.form_error')","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://vincent.fishboneapps.com/tags/Laravel/"}]},{"title":"Lavarel 快速學習自我挑戰 Day12","slug":"Lavarel-快速學習自我挑戰-Day12","date":"2017-05-02T21:44:13.000Z","updated":"2020-06-22T17:14:53.699Z","comments":true,"path":"2017/05/02/Lavarel-快速學習自我挑戰-Day12/","link":"","permalink":"https://vincent.fishboneapps.com/2017/05/02/Lavarel-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day12/","excerpt":"","text":"Sessions - Sessions 設定官方文件 Setting and Reading Sessions 加到 HomeController 1234$request-&gt;session()-&gt;put([&#x27;edwin&#x27;=&gt;&#x27;master instructor&#x27;]);// session([&#x27;peter&#x27;=&gt;&#x27;student&#x27;]); //最常用 $request-&gt;session()-&gt;get(&#x27;edwin&#x27;); Global Session Function Deleting 新增 session 123session([&#x27;edwin2&#x27;=&gt;&#x27;your teacher&#x27;]);return session(&#x27;edwin2&#x27;); 刪除 session：$request-&gt;session()-&gt;forget('edwin2'); 刪除所有 session：$request-&gt;session()-&gt;flush(); 顯示 session 狀態：return $request-&gt;session()-&gt;all(); Flashing Data 建立 flash data (只顯示一次的資料) 123$request-&gt;session()-&gt;flash(&#x27;message&#x27;, &#x27;Post has been created&#x27;);return $request-&gt;session()-&gt;get(&#x27;message&#x27;); data 保存久一點 123$request-&gt;session()-&gt;reflash(); $request-&gt;session()-&gt;keep(&#x27;message&#x27;); Sending Email / API - Mail 設定官方文件 mailgun Mailgun 官方網站 mailgun 設定 設定 config/mail.php 的寄件人名稱與 mail 'from' =&gt; ['address' =&gt; 'admin@pcelab.info', 'name' =&gt; 'Vincent Adler'], 設定 .env 123MAIL_DRIVER=mailgunMAILGUN_DOMAIN=XXXXXMAILGUN_SECRET=XXXXX 新增 mail 的 view (resources/views/mails/test.blade.php) 新增 routes 12345678910111213141516Route::get(&#x27;/&#x27;, function () &#123; $data = [ &#x27;title&#x27;=&gt; &#x27;Hi student I hope you like the course&#x27;, &#x27;content&#x27;=&gt; &#x27;This laravel course was created with a lot of love and dedication for you&#x27; ]; Mail::send(&#x27;emails.test&#x27;, $data, function($message)&#123; $message-&gt;to(&#x27;dtvgood202@gmail.com&#x27;, &#x27;Vincent&#x27;)-&gt;subject(&#x27;Hello student how are you&#x27;); &#125;);&#125;); 新增套件：composer require guzzlehttp/guzzle SSL certification error - 修改 vendor/guzzlehttp/guzzle/src/Client.php：configureDefaults function 的 verify 改為 false Git and Github (Version Control) 新增 branch 分支 git checkout -b newBranch 合併到主分支 git merge newBranch 刪除已合併到 master 的分支 git branch -d newBranch","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://vincent.fishboneapps.com/tags/Laravel/"}]},{"title":"Lavarel 快速學習自我挑戰 Day11","slug":"Lavarel-快速學習自我挑戰-Day11","date":"2017-05-01T19:43:56.000Z","updated":"2020-06-22T17:14:53.700Z","comments":true,"path":"2017/05/01/Lavarel-快速學習自我挑戰-Day11/","link":"","permalink":"https://vincent.fishboneapps.com/2017/05/01/Lavarel-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day11/","excerpt":"","text":"Form Login - Authentication 設定官方文件 安裝新的 Laravel composer create-project --prefer-dist laravel/laravel login 5.2.29 設定 vhost Database 連線和 migration 建立資料庫、設定 .env 直接 migrate php artisan migrate 建立登入系統 php artisan make:auth 取得登入的使用者資料 修改 HomeController 123456public function index() &#123; $user = Auth::user(); return view(&#x27;home&#x27;, compact(&#x27;user&#x27;)); &#125; 在 view 取得資料 &#123;&#123; \"&#123;&#123;$user->name\" &#125;&#125;&#125;&#125; Auth::check：檢查登入資料、Auth::attempt：檢查是否有權限。 Middleware - Middleware 設定官方文件 建立 Middleware 建立一個新的 middleware：php artisan make:middleware RoleMiddleware 進入維護模式：php artisan down 關閉維護模式：php artisan up 在 kernal.php 新增 alias：'role' =&gt; \\App\\Http\\Middleware\\RoleMiddleware::class, 新增 routes Route::get('/admin/user/roles', ['middleware'=&gt;'role', function()&#123;return &quot;Middleware role&quot;;&#125;]); 修改 RoleMiddleware 導向至首頁 return redirect('/'); Middleware 應用 - roles, migration and relations 新增 Role Model：php artisan make:model Role -m 新增 role_id 到 User table：$table-&gt;integer('role_id'); 新增 name 到 Role table：$table-&gt;string('name'); 更新資料庫：php artisan migrate:refresh 在 User Model 新增 relation 12345public function role()&#123; return $this-&gt;belongsTo(&#x27;App\\Role&#x27;); &#125; Middleware 應用 1 新增一個新的 middleware：php aritsan make:middleware IsAdmin 在 kernal.php 新增 alias：'IsAdmin' =&gt; \\App\\Http\\Middleware\\IsAdmin::class, 在 User Model 新增 function 1234567891011public function isAdmin()&#123; if($this-&gt;role-&gt;name == &#x27;administrator&#x27;)&#123; return true; &#125; return false;&#125; 在 routes 測試 function 12345if($user-&gt;isAdmin())&#123; echo &quot;this user is a administrator&quot;;&#125; Middleware 應用 2 將 function 從 routes 移動到 IsAdmin middle ware 的 handle function 1234567$user = Auth::user();if($user-&gt;isAdmin())&#123; return redirect()-&gt;intended(&#x27;/admin&#x27;);&#125; 新增 routes 連到 controller：Route::get('/admin', 'AdminController@index'); 新增 controller：php artisan make:controller AdminController 新增 function 到 controller 12345678910public function __construct() &#123; $this-&gt;middleware(&#x27;IsAdmin&#x27;); &#125; public function index()&#123; return &quot;you are and administrator because you are seeing this page&quot;; &#125; 如果不是 administrator 就導向首頁 1234567$user = Auth::user();if(!$user-&gt;isAdmin())&#123; return redirect(&#x27;/&#x27;);&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://vincent.fishboneapps.com/tags/Laravel/"}]},{"title":"Lavarel 快速學習自我挑戰 Day10","slug":"Lavarel-快速學習自我挑戰-Day10","date":"2017-05-01T15:21:35.000Z","updated":"2020-06-22T17:14:53.700Z","comments":true,"path":"2017/05/01/Lavarel-快速學習自我挑戰-Day10/","link":"","permalink":"https://vincent.fishboneapps.com/2017/05/01/Lavarel-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day10/","excerpt":"","text":"Model Manipulation Dates 搜尋套件 composer search carbon 引用套件 use Carbon\\Carbon; 新增 routes 12345678910111213141516171819Route::get(&#x27;/dates&#x27;, function()&#123; $date = new DateTime(&#x27;+1 week&#x27;); echo $date-&gt;format(&#x27;m-d-Y&#x27;); echo &#x27;&lt;br&gt;&#x27;; echo Carbon::now()-&gt;addDays(10)-&gt;diffForHumans(); echo &#x27;&lt;br&gt;&#x27;; echo Carbon::now()-&gt;subMonth(5)-&gt;diffForHumans(); echo &#x27;&lt;br&gt;&#x27;; echo Carbon::now()-&gt;yesterday()-&gt;diffForHumans();&#125;); Accessors (pull data out of database) 修改 model 123456public function getNameAttribute($value)&#123;// return ucfirst($value); //第一個字大寫 return strtoupper($value); //全部變成大寫 &#125; 修改 routes 1234567Route::get(&#x27;/getname&#x27;, function()&#123; $user = User::find(1); echo $user-&gt;name;&#125;); Mutators - Mutators 設定官方文件 修改 model 12345public function setNameAttribute($value)&#123; $this-&gt;attributes[&#x27;name&#x27;] = strtoupper($value); &#125; 修改 routes 123456789Route::get(&#x27;/setname&#x27;, function()&#123; $user = User::find(1); $user-&gt;name= &quot;william&quot;; $user-&gt;save();&#125;); Query Scopes - Query Scopes 設定官方文件 修改 PostsController 1234567public function index() &#123; $posts = Post::latest(); return view(&#x27;posts.index&#x27;, compact(&#x27;posts&#x27;)); &#125; 修改 Post model 12345public static function scopeLatest($query)&#123; return $query-&gt;orderBy(&#x27;id&#x27;, &#x27;asc&#x27;)-&gt;get(); &#125; 上傳檔案 新增 Views 修改第三個參數 'files'=&gt;true 來新增 enctype ，並加入上傳的 input 12345678910111213141516171819&#123;!! Form::open([&#x27;method&#x27;=&gt;&#x27;POST&#x27;, &#x27;action&#x27;=&gt;&#x27;PostsController@store&#x27;, &#x27;files&#x27;=&gt;true]) !!&#125; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::label(&#x27;title&#x27;, &#x27;Title:&#x27;) !!&#125; &#123;!! Form::text(&#x27;title&#x27;, null, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;]) !!&#125; &lt;/div&gt; &#123;&#123;csrf_field()&#125;&#125; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::file(&#x27;file&#x27;, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;]) !!&#125; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::submit(&#x27;Create Post&#x27;, [&#x27;class&#x27;=&gt;&#x27;btn btn-primary&#x27;]) !!&#125; &lt;/div&gt; &#123;!! Form::close() !!&#125; 取得上傳檔案資訊 修改 PostsController 123456789101112public function store(CreatePostRequest $request) &#123; $file = $request-&gt;file(&#x27;file&#x27;); //取得檔案，會以暫存檔(temp)呈現 echo &quot;&lt;br&gt;&quot;; echo $file-&gt;getClientOriginalName(); //取得原始名稱 echo &quot;&lt;br&gt;&quot;; echo $file-&gt;getClientSize(); //取得檔案大小 &#125; 將上傳的檔案寫入資料庫 (persist file data into database) 新增一個 migration 並關聯到 posts php artisan make:migration add_path_column_to_posts --table=posts 新增 migration 到資料庫 php artisan migrate 讓 path 欄位可寫入 protected $fillable = ['path']; 設定 PostsController 讓檔案可以寫入資料庫 12345678910111213141516public function store(CreatePostRequest $request) &#123; $input = $request-&gt;all(); if($file = $request-&gt;file(&#x27;file&#x27;))&#123; $name = $file-&gt;getClientOriginalName(); $file-&gt;move(&#x27;images&#x27;, $name); $input[&#x27;path&#x27;] = $name; &#125; Post::create($input); &#125; 顯示上傳的圖片 新增 image-container 到 index.blade.php 12345&lt;div class=&quot;image-container&quot;&gt; &lt;img height=&quot;100&quot; src=&quot;&#123;&#123;$post-&gt;path&#125;&#125;&quot; alt=&quot;&quot;&gt; &lt;/div&gt; 新增目錄到 Post model public $directory = '/images/'; 用 Accessors 新增圖片路徑 12345public function getPathAttribute($value)&#123; return $this-&gt;directory . $value; &#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://vincent.fishboneapps.com/tags/Laravel/"}]},{"title":"Lavarel 快速學習自我挑戰 Day9","slug":"Lavarel-快速學習自我挑戰-Day9","date":"2017-04-30T15:21:35.000Z","updated":"2020-06-22T17:14:53.700Z","comments":true,"path":"2017/04/30/Lavarel-快速學習自我挑戰-Day9/","link":"","permalink":"https://vincent.fishboneapps.com/2017/04/30/Lavarel-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day9/","excerpt":"","text":"Form and Validation 設定 Migration &amp; Relations 在 create_posts_table.php 新增 user_id $table-&gt;integer('user_id')-&gt;unsigned(); 重新將資料匯入資料庫 php artisan migrate:refresh 設定 Views &amp; Routes 設定 Controller Route Route::resource('/posts', 'PostsController'); 在 resources/views 底下新增 posts，新增 index、edit、create、show 的 blade.php View 模板 設定 create 的 markup 123456789101112131415161718@extends(&#x27;layouts.app&#x27;)@section(&#x27;content&#x27;) &lt;form method=&quot;post&quot; action=&quot;/posts&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;title&quot; placeholder=&quot;Enter title&quot;&gt; // 避免 TokenMismatchException Error &#123;&#123;csrf_field()&#125;&#125; &lt;input type=&quot;submit&quot; name=&quot;submit&quot;&gt; &lt;/form&gt;@stop@yield(&#x27;footer&#x27;) 設定 Controller &amp; View 在 PostsController 的 create 新增 View public function create()&#123;return view('posts.create');&#125; 在 PostsController 的 store 回傳資料 public function store(Request $request)&#123;return $request-&gt;all();&#125; 將資料傳送到資料庫 修改 PostsController 的 store function 1234567891011121314151617181920212223242526 public function store(Request $request) &#123;// return $request-&gt;all(); // First method Post::create($request-&gt;all()); // second method// $input = $request-&gt;all();//// $input[&#x27;title&#x27;] = $request-&gt;title;//// Post::create($request-&gt;all()); // third method// $post = new Post;//// $post-&gt;title = $request-&gt;title;//// $post-&gt;save(); &#125; 讀取資料 在 PostsController 的 store 新增導向函式 return redirect('/posts') 在 PostsController 的 index 讀取所有的 post 並傳送給 index 的 View 去呈現 $posts = Post::all(); return view('posts.index', compact('posts')); 修改 index.blade.php 12345678910111213@extends(&#x27;layouts.app&#x27;)@section(&#x27;content&#x27;) &lt;ul&gt; @foreach($posts as $post) &lt;li&gt;&#123;&#123;$post-&gt;title&#125;&#125;&lt;/li&gt; @endforeach &lt;/ul&gt;@endsection@yield(&#x27;footer&#x27;) 顯示單一貼文並修改 在 PostsController 的 show 讀取特定 id 的 post 並傳送給 show 的 View 去呈現 $post = Post::findOrFail($id); return view('posts.show', compact('post')); 修改 show.blade.php &lt;h1&gt;&#123;&#123; \"&#123;&#123;$post->title\" &#125;&#125;&#125;&#125;&lt;/h1&gt; 讓 index.blade.php 可以超連結 &lt;li&gt;&lt;a href=&quot;&#123;&#123; \"&#123;&#123;route('posts.show', $post->id)\" &#125;&#125;&#125;&#125;&quot;&gt; &#123;&#123; \"&#123;&#123;$post->title&#125;\" &#125;&#125;&#125;&#125;&lt;/a&gt;&lt;/li&gt; edit 頁面製作 在 PostsController 的 edit 讀取特定 id 的 post 並傳送給 edit 的 View 使用 $post = Post::findOrFail($id); return view('posts.edit', compact('post')); 修改 edit.blade.php 12345678910111213141516171819202122@extends(&#x27;layouts.app&#x27;)@section(&#x27;content&#x27;) &lt;h1&gt;Edit Post&lt;/h1&gt; &lt;form method=&quot;post&quot; action=&quot;/posts/&#123;&#123;$post-&gt;id&#125;&#125;&#125;&quot;&gt; //取得 Token &#123;&#123;csrf_field()&#125;&#125; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;title&quot; placeholder=&quot;Enter title&quot; value=&quot;&#123;&#123;$post-&gt;title&#125;&#125;&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot;&gt; &lt;/form&gt;@endsection@yield(&#x27;footer&#x27;) 編輯紀錄並重新導向 修改 PostsController 的 update function $post = Post::findOrFail($id); $post-&gt;update($request-&gt;all()); return redirect('/posts'); 在 show.blade.php 新增超連結到編輯 &lt;h1&gt;&lt;a href=&quot;&#123;&#123; \"&#123;&#123;route('posts.edit', $post->id)\" &#125;&#125;&#125;&#125;&quot;&gt;&#123;&#123; \"&#123;&#123;$post->title\" &#125;&#125;&#125;&#125;&lt;/a&gt;&lt;/h1&gt; 刪除貼文 修改 PostsController 的 delete function $post = Post::whereId($id)-&gt;delete(); return redirect('/posts'); 新增 delete button edit.blade.php 123456789&lt;form method=&quot;post&quot; action=&quot;/posts/&#123;&#123;$post-&gt;id&#125;&#125;&quot;&gt; &#123;&#123;csrf_field()&#125;&#125; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;DELETE&quot;&gt; &lt;/form&gt; Forms - Package and Validation - Forms &amp; HTML 設定官方文件 Validation 設定官方文件 安裝套件 &amp; 測試 在 composer.json 的 require 新增套件 &quot;laravelcollective/html&quot;:&quot;^5.2.0&quot; 更新套件 composer update 在 config/app.php 的 provider 新增 Collective\\Html\\HtmlServiceProvider::class, 在 config/app.php 的 aliases 新增 'Form' =&gt; Collective\\Html\\FormFacade::class, 'Html' =&gt; Collective\\Html\\HtmlFacade::class, 在 create.blade.php 將 &lt;form method=&quot;post&quot; action=&quot;/posts&quot;&gt; 取代來測試套件 &#123;!! Form::open() !!&#125; 修改 form 套件的內容 修改 form package 的傳遞方式 &#123;!! Form::open(['method'=&gt;'POST', 'action'=&gt;'PostsController@store']) !!&#125; &#123;!! Form::close() !!&#125; 將表單改為 form package 的形式，並使用 Bootstrap 的 class 1234567891011121314&lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::label(&#x27;title&#x27;, &#x27;Title:&#x27;) !!&#125; &#123;!! Form::text(&#x27;title&#x27;, null, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;]) !!&#125; &lt;/div&gt; &#123;&#123;csrf_field()&#125;&#125; &lt;div class=&quot;form-group&quot;&gt; &#123;!! Form::submit(&#x27;Create Post&#x27;, [&#x27;class&#x27;=&gt;&#x27;btn btn-primary&#x27;]) !!&#125; &lt;/div&gt; Update &amp; Delete 修改 edit.blade.php 123456789101112131415161718&#123;!! Form::model($post, [&#x27;method&#x27;=&gt;&#x27;PATCH&#x27;, &#x27;action&#x27;=&gt;[&#x27;PostsController@update&#x27;, $post-&gt;id]]) !!&#125; &#123;&#123;csrf_field()&#125;&#125; &#123;!! Form::label(&#x27;title&#x27;, &#x27;Title:&#x27;) !!&#125; &#123;!! Form::text(&#x27;title&#x27;, null, [&#x27;class&#x27;=&gt;&#x27;form-control&#x27;]) !!&#125; &#123;!! Form::submit(&#x27;Update Post&#x27;, [&#x27;class&#x27;=&gt;&#x27;btn btn-info&#x27;]) !!&#125; &#123;!! Form::close() !!&#125; &#123;!! Form::open([&#x27;method&#x27;=&gt;&#x27;DELETE&#x27;, &#x27;action&#x27;=&gt;[&#x27;PostsController@destroy&#x27;, $post-&gt;id]]) !!&#125; &#123;&#123;csrf_field()&#125;&#125; &#123;!! Form::submit(&#x27;Delete Post&#x27;, [&#x27;class&#x27;=&gt;&#x27;btn btn-danger&#x27;]) !!&#125; &#123;!! Form::close() !!&#125; Validation 將 validate function 新增到 PostsController 的 store function 123456$this-&gt;validate($request, [ &#x27;title&#x27;=&gt; &#x27;required&#x27;, &#x27;content&#x27;=&gt; &#x27;required&#x27; ]); 顯示錯誤 修改 validation $this-&gt;validate($request, [ 'title'=&gt; 'required|max:4' ]); 在 create.blade.php 新增 error display 1234567891011121314151617@if(count($errors) &gt; 0) &lt;div class=&quot;alert alert-danger&quot;&gt; &lt;ul&gt; @foreach($errors-&gt;all() as $error) &lt;li&gt;&#123;&#123;$error&#125;&#125;&lt;/li&gt; @endforeach &lt;/ul&gt; &lt;/div&gt;@endif advanced validation 新增一個 request php artisan make:request CreatePostRequest 修改 PostsController 的 store function，並 import Request public function store(Requests\\CreatePostRequest $request) 修改 CreatePostRequest.php 的 authorize 為 true 修改 CreatePostRequest.php 的 rules 為 required (validation的效果) 'title' =&gt; 'required' 將 validation 註解掉 $this-&gt;validate($request, [ 'title'=&gt; 'required|max:4' ]); PhpStorm snippet PhpStorm-&gt;Preferences-&gt;Editor-&gt;Live template","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://vincent.fishboneapps.com/tags/Laravel/"}]},{"title":"Lavarel 快速學習自我挑戰 Day8","slug":"Lavarel-快速學習自我挑戰-Day8","date":"2017-04-29T15:21:35.000Z","updated":"2020-06-22T17:14:53.699Z","comments":true,"path":"2017/04/29/Lavarel-快速學習自我挑戰-Day8/","link":"","permalink":"https://vincent.fishboneapps.com/2017/04/29/Lavarel-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day8/","excerpt":"","text":"Polymorphic Relationship (CRUD) - Eloquent Relationship 設定官方文件 安裝＋設定 新增一個專案 composer create-project --prefer-dist laravel/laravel polymorphic 5.2.29 建立資料庫 &amp; 設定 .env 資料庫設定和 migration 新增 三個model php artisan make:model Staff -m php artisan make:model Product -m php artisan make:model Photo -m 新增 Staff 和 Product migration 欄位 $table-&gt;string('name'); 新增 Photo migration 欄位 $table-&gt;string('path'); $table-&gt;integer('imageable_id'); $table-&gt;string('imageable_type'); 進行 migrate php artisan migrate 設定 Relation 和 mass assignment 在 Photo.php 設定 Relation public function imageable()&#123;return $this-&gt;morphTo();&#125; 在 Photo.php 新增 protected，讓資料可填入 protected $fillable = ['path']; 在 Staff.php 和 Product.php 設定 Relation public function photos()&#123;return $this-&gt;morphMany('App\\Photo', 'imageable');&#125; 在 Staff.php 新增 protected，讓資料可填入 protected $fillable = ['name']; 新增資料 新增 routes 12345678910use App\\Staff;Route::get(&#x27;/create&#x27;, function()&#123; $staff = Staff::find(1); $staff-&gt;photos()-&gt;create([&#x27;path&#x27;=&gt;&#x27;example.jpg&#x27;]);&#125;); 讀取資料 新增 routes 1234567891011Route::get(&#x27;/read&#x27;, function()&#123; $staff = Staff::findOrFail(1); foreach($staff-&gt;photos as $photo)&#123; return $photo-&gt;path; &#125;&#125;); 更新資料 新增 routes 1234567891011Route::get(&#x27;/update&#x27;, function()&#123; $staff = Staff::findOrFail(1); $photo = $staff-&gt;photos()-&gt;whereId(1)-&gt;first(); $photo-&gt;path = &quot;Update example.jpg&quot;; $photo-&gt;save();&#125;); 刪除資料 新增 routes 1234567Route::get(&#x27;/delete&#x27;, function()&#123; $staff = Staff::findOrFail(1); $staff-&gt;photos()-&gt;whereId(1)-&gt;delete();&#125;); Assign &amp; Unassign assign Route::get('/assign', function()&#123; $staff = Staff::findOrFail(1); $photo = Photo::findOrFail(4); $staff-&gt;photos()-&gt;save($photo); &#125;); unassign Route::get('/un-assign', function()&#123; $staff = Staff::findOrFail(1); $staff-&gt;photos()-&gt;whereId(4)-&gt;update(['imageable_id'=&gt;'', 'imageable_type'=&gt;'']); &#125;); Polymorphic Many to Many Relationship (CRUD) - Eloquent Relationship 設定官方文件 安裝＋設定 新增一個專案 composer create-project --prefer-dist laravel/laravel polymorphicmanytomany 5.2.29 建立資料庫 &amp; 設定 .env 資料庫設定和 migration 新增 三個model php artisan make:model Post -m php artisan make:model Video -m php artisan make:model Tag -m php artisan make:model Taggable -m 新增 Post、Video 和 Tag migration 欄位 $table-&gt;string('name'); 新增 Taggable migration 欄位 $table-&gt;integer('tag_id'); $table-&gt;integer('taggable_id'); $table-&gt;string('taggable_type'); 進行 migrate php artisan migrate 設定 Relation 和 mass assignment 在 Post.php 和 Video.php 設定 Relation public function tags()&#123;return $this-&gt;morphToMany('App\\Tag', 'taggable');&#125; 在 Post.php、Video.php 和 Tag.php 新增 protected，讓資料可填入 protected $fillable = ['name'];; 新增資料 新增 routes 123456789101112131415Route::get(&#x27;/create&#x27;, function()&#123; $post = Post::create([&#x27;name&#x27;=&gt;&#x27;My first post 1&#x27;]); $tag1 = Tag::find(1); $post-&gt;tags()-&gt;save($tag1); $video = Video::create([&#x27;name&#x27;=&gt;&#x27;Video.mov&#x27;]); $tag2 = Tag::find(2); $video-&gt;tags()-&gt;save($tag2);&#125;); 讀取資料 新增 routes 1234567891011Route::get(&#x27;/read&#x27;, function()&#123; $post = Post::findOrFail(1); foreach ($post-&gt;tags as $tag)&#123; echo $tag; &#125;&#125;); 更新資料 新增 routes 123456789101112131415161718192021Route::get(&#x27;/update&#x27;, function()&#123;// $post = Post::findOrFail(1);//// foreach ($post-&gt;tags as $tag)&#123;//// return $tag-&gt;whereName(&#x27;PHP&#x27;)-&gt;update([&#x27;name&#x27;=&gt;&#x27;Updated PHP&#x27;]);//// &#125; $post = Post::findOrFail(1); $tag = Tag::find(2); $post-&gt;tags()-&gt;save($tag);// $post-&gt;tags()-&gt;attach($tag);//// $post-&gt;tags()-&gt;sync([1,2]);&#125;); 刪除資料 新增 routes 123456789101112Route::get(&#x27;/delete&#x27;, function()&#123; $post = Post::find(2); foreach ($post-&gt;tags as $tag)&#123; $tag-&gt;whereId(4)-&gt;delete(); &#125;&#125;);","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://vincent.fishboneapps.com/tags/Laravel/"}]},{"title":"Lavarel 快速學習自我挑戰 Day7","slug":"Lavarel-快速學習自我挑戰-Day7","date":"2017-04-28T15:21:35.000Z","updated":"2020-06-22T17:14:53.699Z","comments":true,"path":"2017/04/28/Lavarel-快速學習自我挑戰-Day7/","link":"","permalink":"https://vincent.fishboneapps.com/2017/04/28/Lavarel-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day7/","excerpt":"","text":"One to Many Relationship (CRUD) - Eloquent Relationship 設定官方文件 安裝＋設定 新增一個專案 composer create-project --prefer-dist laravel/laravel onetomany 5.2.29 建立資料庫 &amp; 設定 .env 資料庫設定和 migration 新增 model php artisan make:model Post -m 新增欄位 $table-&gt;integer('user_id')-&gt;unsigned()-&gt;nullable()-&gt;index(); $table-&gt;string('title'); $table-&gt;text('body'); 進行 migrate php artisan migrate 設定 Relation 和 mass assignment 在 User.php 設定 Relation public function posts() &#123;return $this-&gt;hasMany('App\\Post');&#125; 在 Post.php 新增 protected，讓資料可填入 protected $fillable = ['title','body']; 用 tinker 和 routes 新增資料 進入 tinker 模式 php artisan tinker 新增一筆 User App\\User::create(['name'=&gt;'Edwin Diaz', 'email'=&gt;'edwin@codingfaculty.com', 'password'=&gt;bcrypt(&quot;123&quot;)]) 離開 tinker 模式 exit 用 routes 的方式 123456789Route::get(&#x27;/insert&#x27;, function()&#123; $user = User::findOrFail(1); $post = new Post([&#x27;title&#x27;=&gt;&#x27;My first post with Edwin Diaz&#x27;, &#x27;body&#x27;=&gt;&#x27;I love Laravel, with Edwin Diaz&#x27;]); $user-&gt;posts()-&gt;save($post); &#125;); 讀取資料 新增 routes 12345678910111213Route::get(&#x27;/read&#x27;, function()&#123; $user = User::findOrFail(1);// dd($user); //一種 collection object foreach($user-&gt;posts as $post)&#123; echo $post-&gt;title . &quot;&lt;br&gt;&quot;; &#125;&#125;); 更新資料 新增 routes 12345678Route::get(&#x27;/update&#x27;, function()&#123; $user = User::find(1); $user-&gt;posts()-&gt;where(&#x27;id&#x27;, &#x27;=&#x27;, &#x27;2&#x27;)-&gt;update([&#x27;title&#x27;=&gt;&#x27;I love laravel2&#x27;, &#x27;body&#x27;=&gt;&#x27;This is awesome, thank you Edwin2&#x27;]);&#125;); 刪除資料 新增 routes 123456789Route::get(&#x27;/delete&#x27;, function()&#123; $user = User::find(1); $user-&gt;posts()-&gt;whereId(1)-&gt;delete();// $user-&gt;posts()-&gt;delete(); // 刪除全部&#125;); Many to Many Relationship (CRUD) - Eloquent Relationship 設定官方文件 安裝＋設定 新增一個專案 composer create-project --prefer-dist laravel/laravel manytomany 5.2.29 建立資料庫 &amp; 設定 .env 資料庫設定和 migration 新增 model php artisan make:model Role -m 新增 migration php artisan make:migration create_role_user_table --create=role_user 在 create_role_user_table 新增欄位 $table-&gt;integer('user_id')-&gt;unsigned()-&gt;nullable()-&gt;index(); $table-&gt;integer('role_id')-&gt;unsigned()-&gt;nullable()-&gt;index(); 在 create_roles_table 新增欄位 $table-&gt;string('name'); 進行 migrate php artisan migrate 設定 Relation 和 mass assignment 在 User.php 設定 Relation public function roles() &#123;return $this-&gt;belongsToMany('App\\Role');&#125; 在 Post.php 新增 protected，讓資料可填入 protected $fillable = ['name']; 新增資料 新增 routes 123456789Route::get(&#x27;/create&#x27;, function()&#123; $user = User::find(1); $role = new Role([&#x27;name&#x27;=&gt;&#x27;Administrator&#x27;]); $user-&gt;roles()-&gt;save($role);&#125;); 讀取資料 新增 routes 1234567891011Route::get(&#x27;/read&#x27;, function()&#123; $user = User::findOrFail(1); foreach($user-&gt;roles as $role)&#123; echo $role-&gt;name; &#125;&#125;); 更新資料 新增 routes 123456789101112131415161718192021Route::get(&#x27;/update&#x27;, function()&#123; $user = User::findOrFail(1); if($user-&gt;has(&#x27;roles&#x27;))&#123; foreach($user-&gt;roles as $role)&#123; if($role-&gt;name == &#x27;Administrator&#x27;)&#123; $role-&gt;name = &quot;subscriber&quot;; $role-&gt;save(); &#125; &#125; &#125;&#125;); 刪除資料 新增 routes 1234567891011Route::get(&#x27;/delete&#x27;, function()&#123; $user = User::findOrFail(1); foreach($user-&gt;roles as $role)&#123; $role-&gt;whereId(5)-&gt;delete(); &#125;&#125;); Attaching, Detaching and Syncing attach：新增 user 的 role Route::get('/attach', function()&#123; $user = User::findOrFail(1); $user-&gt;roles()-&gt;attach(4); &#125;); detach：把 user 的 role 移除 Route::get('/detach', function()&#123; $user = User::findOrFail(1); $user-&gt;roles()-&gt;detach(); &#125;); sync：把 user_id 和多個 role_id 做連結 Route::get('/sync', function()&#123; $user = User::findOrFail(1); $user-&gt;roles()-&gt;sync([6,7]); &#125;);","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://vincent.fishboneapps.com/tags/Laravel/"}]},{"title":"Lavarel 快速學習自我挑戰 Day6","slug":"Lavarel-快速學習自我挑戰-Day6","date":"2017-04-27T02:19:30.000Z","updated":"2020-06-22T17:14:53.699Z","comments":true,"path":"2017/04/26/Lavarel-快速學習自我挑戰-Day6/","link":"","permalink":"https://vincent.fishboneapps.com/2017/04/26/Lavarel-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day6/","excerpt":"","text":"Tinker 使用 Tinker 建立資料 進入 Tinker 模式 php artisan tinker 建立資料 $post = App\\Post::create(['title'=&gt;'PHP post from tinker','content'=&gt;'PHP content from tinker']); 再看一次資料 $post 創建物件 $post = new App\\Post 新增 title 到物件 $post-&gt;title = &quot;New Title from this object&quot; 新增 content 到物件 $post-&gt;content = &quot;yeah baby I\\'m coding and doing awesome&quot; 寫入資料庫 $post-&gt;save() 離開 Tinker 模式 exit 使用 Tinker 讀取資料庫 讀取資料 $post = App\\Post::find(5); 用 constraint 的方式讀取 $post = App\\Post::where('id', 5)-&gt;first(); $post = App\\Post::whereId(5)-&gt;first(); 更新和刪除資料庫 更新 title $post-&gt;title = &quot;update record with id 4&quot; 更新 content $post-&gt;content = &quot;updated record content with id 4&quot; 寫入資料庫 $post-&gt;save() 從資料庫刪除(丟入垃圾桶) $post-&gt;delete() 從資料庫強迫刪除 $post = App\\Post::onlyTrashed() $post-&gt;forceDelete() Relations in Tinker 搜尋 User $user = App\\User::find(1) 搜尋 User 相關的 role $user-&gt;roles One to One Relationship (CRUD) - Eloquent Relationship 設定官方文件 安裝＋設定 新增一個專案 composer create-project --prefer-dist laravel/laravel onetoone 5.2.29 建立資料庫 &amp; 設定 .env 資料庫設定和 migration 新增 model php artisan make:model Address -m 新增欄位 $table-&gt;string('name'); 進行 migrate php artisan migrate 設定 Relation 新增欄位 $table-&gt;integer('user_id')-&gt;nullable(); 重新 migrate php artisan migrate:refresh 在 User.php 設定 Relation public function address()&#123;return $this-&gt;hasOne('App\\Address');&#125; 在資料庫 insert User 在 Address.php 新增 protected，讓資料可填入 protected $fillable = ['name']; 用 routes 新增資料 123456789101112use App\\User;use App\\Address;Route::get(&#x27;/insert&#x27;, function()&#123; $user = User::findOrFail(1); $address = new Address([&#x27;name&#x27;=&gt;&#x27;1234 Houston av NY NY 11218&#x27;]); $user-&gt;address()-&gt;save($address);&#125;); 更新資料 新增 routes 123456789Route::get(&#x27;/update&#x27;, function()&#123; $address = Address::whereUserId(1)-&gt;first(); $address-&gt;name = &quot;4353 Update Av, alaska&quot;; $address-&gt;save();&#125;); 讀取資料 新增 routes 1234567Route::get(&#x27;/read&#x27;, function()&#123; $user = User::findOrFail(1); echo $user-&gt;address-&gt;name;&#125;); 刪除資料 新增 routes 123456789Route::get(&#x27;/delete&#x27;, function()&#123; $user = User::findOrFail(1); $user-&gt;address()-&gt;delete(); return &quot;done&quot;;&#125;);","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://vincent.fishboneapps.com/tags/Laravel/"}]},{"title":"Lavarel 快速學習自我挑戰 Day5","slug":"Lavarel-快速學習自我挑戰-Day5","date":"2017-04-26T02:19:30.000Z","updated":"2020-06-22T17:14:53.700Z","comments":true,"path":"2017/04/25/Lavarel-快速學習自我挑戰-Day5/","link":"","permalink":"https://vincent.fishboneapps.com/2017/04/25/Lavarel-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day5/","excerpt":"","text":"Eloquent Relationship - Eloquent Relationship 設定官方文件 One to One Relationship 新增 user_id 到 migration $table-&gt;integer('user_id')-&gt;unsigned(); 新增一個 function 到 User.php public function post()&#123;return $this-&gt;hasOne('App\\Post');&#125; 新增 routes Route::get('/user/&#123;id&#125;/post', function($id)&#123;return User::find($id)-&gt;post-&gt;title;&#125;); Reverse One to One Relationship (Inverse Relationship) 新增一個 function 到 Post.php public function user()&#123;return $this-&gt;belongsTo('App\\User');&#125; 新增 routes Route::get('/user/&#123;id&#125;/post', function($id)&#123;return User::find($id)-&gt;post-&gt;content;&#125;); One to Many Relationship 新增一個 function 到 User.php public function posts()&#123;return $this-&gt;hasMany('App\\Post');&#125; 新增 routes 1234567891011 Route::get(&#x27;/posts&#x27;, function()&#123; $user = User::find(1); foreach ($user-&gt;posts as $post) &#123; echo $post-&gt;title .&quot;&lt;br&gt;&quot;; (不要使用 return，return 只能傳回一個內容) &#125;&#125;); Many to Many Relationship 新增一個 model php artisan make:model Role -m 新增一個 migration php artisan make:migration create_users_roles_table --create=role_user 在 create_roles_table 新增姓名 $table-&gt;string('name'); 在 create_users_roles_table 新增 user_id 和 role_id $table-&gt;integer('user_id'); $table-&gt;integer('role_id'); 在 User.php 新增一個 function public function roles()&#123;return $this-&gt;belongsToMany('App\\Role');&#125; 新增 routes (1) Route::get('/user/&#123;id&#125;/role', function($id)&#123; $user = User::find($id); foreach ($user-&gt;roles as $role) &#123;return $role-&gt;name;&#125;&#125;); 新增 routes (2) Route::get('/user/&#123;id&#125;/role', function($id)&#123; $user = User::find($id)-&gt;roles()-&gt;orderBy('id', 'desc')-&gt;get(); return $user; &#125;); 取得 Intermediate table 在 Role.php 新增 belongsToMany public function users()&#123;return $this-&gt;belongsToMany('App\\User');&#125; 在 User.php 的 roles function 新增 withPivot return $this-&gt;belongsToMany('App\\Role')-&gt;withPivot('created_at'); 新增 routes 1234567891011Route::get(&#x27;/user/pivot&#x27;, function()&#123; $user = User::find(1); foreach($user-&gt;roles as $role)&#123; return $role-&gt;pivot-&gt;created_at; &#125;&#125;); Has Many Through Relation 新增一個 model php artisan make:model Country -m 新增一個 migration php artisan make:migration add_country_id_column_to_users --table=users 到 add_country_id_column_to_users.php 的 up function 新增 $table-&gt;integer('country_id'); 到 add_country_id_column_to_users.php 的 down function 新增 $table-&gt;dropColumn('country_id'); 到 create_countries_table 新增 $table-&gt;string('name'); 匯入資料庫 php artisan migrate 在 Country Model 新增 function public function posts()&#123;return $this-&gt;hasManyThrough('App\\Post', 'App\\User');&#125; 在 routes 引入 Model use App\\Country 新增 routes 1234567891011Route::get(&#x27;/user/country&#x27;, function()&#123;$country = Country::find(4);foreach ($country-&gt;posts as $post)&#123; return $post-&gt;title;;&#125;&#125;); Polymorphic Relation 新增 photo 的 Model php artisan make:model Photo -m 在 create_photos_table 新增以下欄位 $table-&gt;string('path'); $table-&gt;integer('imageable_id'); $table-&gt;string('imageable_type'); 匯入資料庫 php artisan migrate 不需要 user_id，在 create_post_talbe 移除並更新 $table-&gt;integer('user_id')-&gt;unsigned(); php artisan migrate:refresh 在 Photo.php 新增一個 function public function imageable() &#123;return $this-&gt;morphTo();&#125; 在 Post.php 和 User.php 各新增一個 function public function photos()&#123;return $this-&gt;morphMany('App\\Photo', 'imageable');&#125; 新增 routes 1234567891011Route::get(&#x27;post/&#123;id&#125;/photos&#x27;, function($id)&#123; $post = Post::find($id); foreach($post-&gt;photos as $photo)&#123; echo $photo-&gt;path . &quot;&lt;br&gt;&quot;; &#125;&#125;); Reverse Polymorphic Relation 在 routes 引入 Model use App\\Photo; 新增 routes 1234567Route::get(&#x27;photo/&#123;id&#125;/post&#x27;, function($id)&#123; $photo = Photo::findOrFail($id); return $photo-&gt;imageable;&#125;); Many to Many Polymorphic Relation 新增三個 model php artisan make:model Video -m php artisan make:model Tag -m php artisan make:model Taggable -m 在 create_videos_table 和 create_tags_table 建立 name 的 table $table-&gt;string('name'); 在 create_taggables_table 建立以下 table $table-&gt;integer('tag_id'); $table-&gt;integer('taggable_id'); $table-&gt;string('taggable_type'); 在 Post.php 新增 morphToMany function public function tags()&#123;return $this-&gt;morphToMany('App\\Tag', 'taggable');&#125; 在 Tag.php 新增 morphedByMany function public function posts()&#123; return $this-&gt;morphedByMany('App\\Post', 'taggable');&#125; public function videos()&#123;return $this-&gt;morphedByMany('App\\Video', 'taggable');&#125; 匯入 migrate php artisan migrate 新增 routes Route::get('/post/tag', function()&#123; $post = Post::find(1); foreach ($post-&gt;tags as $tag)&#123; echo $tag-&gt;name; &#125; &#125;); import Tag model use App\\Tag; 新增 routes Route::get('/tag/post', function()&#123; $tag = Tag::find(2); foreach($tag-&gt;posts as $post)&#123; return $post-&gt;title; &#125; &#125;);","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://vincent.fishboneapps.com/tags/Laravel/"}]},{"title":"Lavarel 快速學習自我挑戰 Day4","slug":"Lavarel-快速學習自我挑戰-Day4","date":"2017-04-25T05:12:19.000Z","updated":"2020-06-22T17:14:53.700Z","comments":true,"path":"2017/04/25/Lavarel-快速學習自我挑戰-Day4/","link":"","permalink":"https://vincent.fishboneapps.com/2017/04/25/Lavarel-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day4/","excerpt":"","text":"Raw SQL Queries - Database 設定官方文件 insert data (直接在 Routes.php 設定) 123Route::get(&#x27;/insert&#x27;, function()&#123; DB::insert(&#x27;insert into posts(title, content) values(?, ?)&#x27;, [&#x27;PHP with Laravel&#x27;, &#x27;Laravel is the best thing that has happened to PHP&#x27;]);&#125;); read data 123456789101112Route::get(&#x27;/read&#x27;, function() &#123; $results = DB::select(&#x27;select * from posts where id = ?&#x27;, [1]); return $results; (傳回陣列)// return var_dump($results); (傳回值的詳細資料)// foreach($results as $post)&#123;//// return $post-&gt;title;//// &#125;(傳回單一項目)&#125;); update data 1234Route::get(&#x27;/update&#x27;, function()&#123; $updated = DB::update(&#x27;update posts set title = &quot;update title&quot; where id = ?&#x27;, [1]); return $updated;&#125;); delete data 1234Route::get(&#x27;/delete&#x27;, function()&#123; $deleted = DB::delete(&#x27;delete from posts where id = ?&#x27;, [1]); return $deleted;&#125;); Eloquent / ORM - Eloquent 設定官方文件 創建一個 model：php artisan make:model 在 model 的 class 宣告 table 名稱：protected $table = 'posts'; 在 Routes 引入 class：use App\\Post; 用 model 的方式讀取所有資料 123456789Route::get(&#x27;/find&#x27;, function()&#123; $posts = Post::all(); // 加入 Post 的所有紀錄 foreach($posts as $post) &#123; return $post-&gt;title; &#125;&#125;); 用 model 的方式讀取單一資料 123456Route::get(&#x27;/find&#x27;, function()&#123; $post = Post::find(1); return $post-&gt;title;&#125;); 用 eloquent 的方式取得資料：$posts = Post::where('id', 1)-&gt;orderBy('id', 'desc')-&gt;take(1)-&gt;get(); eloquent -&gt; 取得或失敗：$posts = Post::findOrFail(2); save data 12345678910Route::get(&#x27;/basicinsert&#x27;, function()&#123; $post = new Post; $post-&gt;title = &#x27;new Eloquent title insert&#x27;; $post-&gt;content = &#x27;Wow eloquent is really cool, look at this content&#x27;; $post-&gt;save();&#125;); 修改 data 12345678910Route::get(&#x27;/basicinsert1&#x27;, function()&#123; $post = Post::find(1); $post-&gt;title = &#x27;new Eloquent title insert 1&#x27;; $post-&gt;content = &#x27;Wow eloquent is really cool, look at this content 1&#x27;; $post-&gt;save();&#125;); Mass Assignment 在路由用 create 來新增 model Post::create(['title'=&gt;'the create method', 'content'=&gt; 'WOW I\\'m learning a lot with Edwin Diaz']); 在 model 裡面設定 protected protected $fillable = ['title', 'content']; update data Post::where('id', 2)-&gt;where('is_admin', 0)-&gt;update(['title'=&gt;'NEW PHP TITLE', 'content'=&gt;'I love my instructor Edwin']); delete data 方法 1 1234567Route::get(&#x27;/delete&#x27;, function()&#123; $post = Post::find(1); $post-&gt;delete();&#125;); 方法 2 1234567Route::get(&#x27;/delete2&#x27;, function()&#123; Post::destroy(2); // Post::destroy([4,5]); //刪除多筆資料 // Post::where(&#x27;is_admin&#x27;, 0)-&gt;delete(); //加上條件的刪除法&#125;); Soft delete / trashing 在 model 引入 softdelete use Illuminate\\Database\\Eloquent\\SoftDeletes; 在 model 使用 protected protected $dates = ['deleted_at']; 建立新的 model php artisan make:migration add_deleted_at_column_to_posts_tables --table=posts 設定新的 model up 的部分：$table-&gt;softDeletes(); down 的部分：$table-&gt;dropColumn('deleted_at'); 提醒：在刪除 model 之前要先 reset 才不會造成資料庫錯誤 直接在 Routes 進行刪除：Post::find(3)-&gt;delete(); 取得 deleted / trashed 紀錄 123456789101112131415Route::get(&#x27;resoftdelete&#x27;, function()&#123;// 取得單一紀錄// $post = Post::find(3);// return $post;// 取得包含丟到回收桶的紀錄// $post = Post::withTrashed()-&gt;where(&#x27;is_admin&#x27;, 0)-&gt;get();// return $post;// 只取得丟到回收桶的紀錄// $post = Post::onlyTrashed()-&gt;where(&#x27;is_admin&#x27;, 0)-&gt;get();// return $post;&#125;); 恢復 deleted / trashed 紀錄 12345Route::get(&#x27;/restore&#x27;, function()&#123; Post::withTrashed()-&gt;where(&#x27;is_admin&#x27;, 0)-&gt;restore();&#125;); 永久移除紀錄 12345Route::get(&#x27;/forcedelete&#x27;, function()&#123; Post::onlyTrashed()-&gt;where(&#x27;is_admin&#x27;, 0)-&gt;forceDelete();&#125;);","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://vincent.fishboneapps.com/tags/Laravel/"}]},{"title":"Lavarel 快速學習自我挑戰 Day3","slug":"Lavarel-快速學習自我挑戰-Day3","date":"2017-04-24T07:12:12.000Z","updated":"2020-06-22T17:14:53.699Z","comments":true,"path":"2017/04/24/Lavarel-快速學習自我挑戰-Day3/","link":"","permalink":"https://vincent.fishboneapps.com/2017/04/24/Lavarel-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day3/","excerpt":"","text":"Views - Views 設定官方文件 路徑：/resources/views 在 Controller 新增一個 function public function contact()&#123;return view('contact');&#125; 新增一個 view (檔名為xxx.blade.php) 可以將 view 的檔案設定在子目錄下。例：新增一個 pages/contact.php，路由部分則要設定為 view(page/contact(或是page.contact)') Routes 設定 Route::get('/contact', 'PostsController@contact'); 傳送 data 到 Views 設定 Routes Route::get('post/&#123;id&#125;', 'PostsController@show_post'); 在 Controller 新增一個 function public function show_post($id)&#123;return view('post')-&gt;with('id',$id);&#125; 在 View 裡面使用 data &#123;&#123; \"&#123;&#123;$id\" &#125;&#125;&#125;&#125; 傳送多 data 到 Views 設定 Routes Route::get('post/&#123;id&#125;/&#123;name&#125;/&#123;password&#125;', 'PostsController@show_post'); 在 Controller 使用 compact function public function show_post($id, $name, $password)&#123;return view('post', compact('id','name','password'));&#125; 在 View 裡面使用 data blade (PHP模板引擎) - blade 設定官方文件 ! + tab =&gt; html 模板 div.container + tab =&gt; class 為 container 的 div 容器 @yield('content') =&gt; 產生一個內容的區塊 @extends('layouts.app') =&gt; 使用 layouts.app 裡面的內容 @section('content') =&gt; 產生自定義內容 blade 使用範例： 在 PostsController 裡的 Contact 新增人名 array，並傳送 data $people = ['Edwin', 'Jose', 'James', 'Peter', 'Maria']; return view('contact', compact('people')); 在 contact.blade.php 裡面列出人名 (blade 的函式皆以 @ 開頭) 1234567@if (count($people)) &lt;ul&gt; @foreach($people as $person) &lt;li&gt;&#123;&#123;$person&#125;&#125;&lt;/li&gt; @endforeach &lt;/ul&gt;@endif Database Migration - Migration 設定官方文件 sqlite：file based database，資料庫內容儲存於檔案裡，應用於小專案。 先設定 .env php artisan migrate (將資料庫設定檔自動移入資料庫) 自定義 migration 自行創建一個 migration 檔案：php artisan make:migration (migration_NAME) (FLAG) 範例：php artisan make:migration create_posts_table --create=&quot;posts&quot; 在 migration 裡面新增 table 項目。($table-&gt;string('title');) 撤回上一步完成的 migration：php artisan migrate:rollback。 新增 column 到存在的 table 新增一個 migration：php artisan make:migration add_is_admin_column_to_posts_tables --table=&quot;posts&quot;(定義相關table) 在新增的 migration 檔案的 up 新增 $table-&gt;integer('is_admin')-&gt;unsigned(); 在新增的 migration 檔案的 down 新增 $table-&gt;dropColumn('is_admin'); Migration 命令 刪除所有資料庫內容：php artisan migrate:reset 更新資料庫內容(刪除資料庫再重新新增):php artisan migrate:refresh 確認 migration 狀態：php artisan migrate:status","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://vincent.fishboneapps.com/tags/Laravel/"}]},{"title":"Lavarel 快速學習自我挑戰 Day2","slug":"Lavarel-快速學習自我挑戰-Day2","date":"2017-04-23T08:15:17.000Z","updated":"2020-06-22T17:14:53.699Z","comments":true,"path":"2017/04/23/Lavarel-快速學習自我挑戰-Day2/","link":"","permalink":"https://vincent.fishboneapps.com/2017/04/23/Lavarel-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day2/","excerpt":"","text":"Laravel 目錄結構 /app/Http/Controllers：make request、routes 設定。 /config： 註冊外掛進入 packages、database 連線 (但是連線資訊都設定在根目錄的 .env)、mail 連線。 /database/migration：透過檔案建立資料，會非常常用。 /public：css folder、javascript folder、image folder。 /resources/views：存放畫面的位置，跟 controller 保持連線。 /vendor：存放套件的地方。 Route 設定 - 路由設定官方文件 修改 /app/Http/routes.php 傳 id, name 兩個變數到頁面的範例。 123Route::get(&#x27;/post/&#123;id&#125;/&#123;name&#125;&#x27;, function($id, $name)&#123; return &quot;This is post number &quot;. $id . &quot; &quot; .$name;&#125;); 路由命名法 查詢路由狀態。 php artisan route:list 將路由用簡短的方式命名，以下用admin.home來取得路由。 12345Route::get(&#x27;admin/posts/example&#x27;, array(&#x27;as&#x27;=&gt;&#x27;admin.home&#x27; ,function()&#123; $url = route(&#x27;admin.home&#x27;); return &quot;this url is &quot;. $url;&#125;)); Controller - Controller 設定官方文件 Controller 是用來處理來自 database 資訊的 class，然後將資料丟到 view (反之亦然)。 Controller 路徑 - /app/Http/Controllers/Controller.php。 用 terminal 創建一個 Controller。 php artisan make:controller PostsController(Name) php artisan make:controller --resource PostsController(Name) 在路由設定 Controller 設定 routes.php Route::get('/post', 'PostsController@index'); (讀取 Controller 的 index) 修改 PostsController.php public function index() &#123;return 'its working';&#125; 在 Controller 傳送 data 設定 routes.php Route::get('/post/&#123;id&#125;', 'PostsController@index'); (讀取 Controller 的 index) 修改 PostsController.php public function index($id) &#123;return 'its working the number' . $id;&#125; Resources &amp; Controller 設定 routes.php - 用 resource 的做法會產生 GET、DELETE、PUT…等不同 Method。 Route::resource('posts', 'PostsController'); 檢查路由狀態 php artisan route:list 測試 show method public function show($id) &#123;return &quot;This is the show method yaaa&quot; . $id;&#125; 測試 create method public function create() &#123;return &quot;I am the method that creates stuff:)&quot;;&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://vincent.fishboneapps.com/tags/Laravel/"}]},{"title":"Lavarel 快速學習自我挑戰 Day1","slug":"Lavarel-快速學習自我挑戰-Day1","date":"2017-04-21T19:00:35.000Z","updated":"2020-06-22T17:14:53.699Z","comments":true,"path":"2017/04/21/Lavarel-快速學習自我挑戰-Day1/","link":"","permalink":"https://vincent.fishboneapps.com/2017/04/21/Lavarel-%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day1/","excerpt":"","text":"安裝 PHP 環境 安裝 XAMPP，選 PHP 最新版本。 啟動 XAMPP，網址列輸入 localhost，可以看到 XAMPP 的最新畫面。 安裝 IDE (PhpStorm) 官方網站。 學生免費。 下載 IDE。 Install Composer (相依套件管理器) Composer官方網站。 找套件的網站：packagist。 Download Composer。 按照程式碼安裝之後，會產生一個 composer.phar，為了要在全域使用，在 .zshrc 裡面加上export PATH=&quot;~/.composer/vendor/bin:$PATH&quot;，在指令列用source .zshrc更新檔案。 啟動 laravel 專案 composer create-project --prefer-dist laravel/laravel cms 5.2.29 更改讀取權限 chmod -R o+w cms/storage，就可以直接預覽了。 如果不想修改權限，可以在修改 httpd 設定檔。 vim /Applications/XAMPP/xamppfiles/etc/httpd.conf 將 User daemon 改成 User 你的Username。 Virtual hosts 修改 httpd 設定檔 vim /Applications/XAMPP/xamppfiles/etc/httpd.conf 把 Virtaul hosts include 進去 (將 # 移除) Include etc/extra/httpd-vhosts.conf 修改 hosts 檔案 vim /etc/hosts 加上 127.0.0.1 cms.dev 修改 vhosts 設定檔 vim /Applications/XAMPP/etc/extra/httpd-vhosts.conf 將檔案修改為以下格式 12345678910111213141516171819202122232425262728# &lt;URL:http://httpd.apache.org/docs/2.4/vhosts/&gt;# for further details before you try to setup virtual hosts.## You may use the command line option &#x27;-S&#x27; to verify your virtual host# configuration.NameVirtualHost *:80## VirtualHost example:# Almost any Apache directive may go into a VirtualHost container.# The first VirtualHost section is used for all requests that do not# match a ServerName or ServerAlias in any &lt;VirtualHost&gt; block.#&lt;VirtualHost *:80&gt; ServerAdmin webmaster@dummy-host.example.com DocumentRoot &quot;/Applications/XAMPP/xamppfiles/htdocs&quot; ServerName localhost ServerAlias www.localhost&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; ServerAdmin webmaster@dummy-host2.example.com DocumentRoot &quot;/Applications/XAMPP/xamppfiles/htdocs/cms/public&quot; ServerName cms.dev# ErrorLog &quot;logs/dummy-host2.example.com-error_log&quot;# CustomLog &quot;logs/dummy-host2.example.com-access_log&quot; common&lt;/VirtualHost&gt; 用 PhpStorm 打開專案 點選 open，選擇 laravel 專案目錄。 觀念摘錄 MVC 架構 Model (Deals with Databse), View (Deals with the HTML), Controller (The middle-man)。 快捷鍵設定 — 加入 .zshrc 輸入 desk 直接跳到桌面 alias desk=&quot;cd /Users/**USERNAME**/Desktop&quot; 輸入 refzsh 更新 .zshrc alias refzsh=&quot;source ~/.zshrc&quot; 輸入 zsh 編輯 .zshrc alias zsh=&quot;vim ~/.zshrc&quot; 輸入 htdocs 跳轉到 htdocs 目錄 alias htdocs=&quot;cd /Applications/XAMPP/htdocs&quot;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"https://vincent.fishboneapps.com/tags/Laravel/"}]},{"title":"React快速學習自我挑戰 Day12","slug":"React快速學習自我挑戰-Day12","date":"2017-04-03T06:41:19.000Z","updated":"2020-06-22T17:16:10.831Z","comments":true,"path":"2017/04/03/React快速學習自我挑戰-Day12/","link":"","permalink":"https://vincent.fishboneapps.com/2017/04/03/React%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day12/","excerpt":"","text":"&#123;title.touched ? title.error : ''&#125;，如果 title.touched 是 true，顯示 title.error，如果不是，什麼都不要顯示。 &#123;`form-group $&#123;title.touched &amp;&amp; title.invalid ? 'has-danger' : ''&#125;`&#125;，如果 title 被 touched，而且 title 是 invalid，顯示 className “has-danger”，否則顯示空白 string。 盡量避免使用 context。只有在我們使用 react-router 的時候再使用 context。 Create Post 是一個 action creator，action creator 可以創造一個 promise 當作他自己的 payload。當我們呼叫 action creator，就會產生一個當作 payload 的 promise，所以當 promise 解決以後，就等同於我們順利創建一個 post 了。 要存取 react-router，我們必須定義 contextTypes。這告訴 react 我想要從 parent component 存取這個 property。 Lorem Ipsum 產生器。 redux thunk 是用來處理非同步的 action creator。 dispatch method 是 redux store 的一部份，包含了 application state。 Firebase react library。","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"React","slug":"React","permalink":"https://vincent.fishboneapps.com/tags/React/"}]},{"title":"React快速學習自我挑戰 Day11","slug":"React快速學習自我挑戰-Day11","date":"2017-03-30T06:35:46.000Z","updated":"2020-06-22T17:16:10.831Z","comments":true,"path":"2017/03/30/React快速學習自我挑戰-Day11/","link":"","permalink":"https://vincent.fishboneapps.com/2017/03/30/React%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day11/","excerpt":"","text":"React Lifecycle method 是一個 React Component class 的 function，用來被 React 自動呼叫。 componentWillMount 是一個 Lifecycle method，他會在第一次 component 將要被 DOM render 的時候自動呼叫 componentWillMount，但是當下一次執行 component 的時候，就不會再執行 componentWillMount。 componentWillMount 用在不知道什麼情況下要 fetch data。 如果要讓 react component 可以呼叫 action creator，我們必須要把 component 提升為 container。 製作 container 的方法。 import connect import action creator 定義 mapDispatchToProps function，然後連接到 component。 Redux Form。 import &#123; reducer as formReducer &#125; from 'redux-form';，import redux-form，拿取 reducer 這個 property，然後建立一個名為 formReducer 的變數。(此用法為了避免命名上的衝突) const &#123; handleSubmit &#125; = this.props; === const handleSubmit = this.props.handleSubmit; const &#123; fields: &#123; title, categories, content&#125;, handleSubmit &#125; = this.props; === const title = this.props.fields.title;。 reduxform 可以被用來注入 action creators 到 component 裡面，然後創建一個在 component 外的 container。 reduxform 和 connect 的不同就是 reduxform 有一個額外的參數傳遞給他。 connect：第一個參數是 mapStateToProps，第二個是 mapDispatchToProps。 reduxform：第一個是 form config，第二個是 mapStateToProps，第三個是 mapDispatchToProps。","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"React","slug":"React","permalink":"https://vincent.fishboneapps.com/tags/React/"}]},{"title":"React快速學習自我挑戰 Day10","slug":"React快速學習自我挑戰-Day10","date":"2017-03-22T02:16:50.000Z","updated":"2020-06-22T17:16:10.831Z","comments":true,"path":"2017/03/21/React快速學習自我挑戰-Day10/","link":"","permalink":"https://vincent.fishboneapps.com/2017/03/21/React%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day10/","excerpt":"","text":"Redux Blog Post API Reference。 Postman 是一個 HTTP client 的 API。 npm install --save react-router@2.0.0-rc5，安裝 react router。 React-Router 套件有 History 的子套件，用來管理網頁的 URL，監控改變並隨著時間更新。 History 對 URL 互動，並將更新傳送給 React-Router，React-Router 拿到 URL 之後並根據 URL 決定哪個 React Component 需要更新。 Router 是一個當 URL 改變時，我們需要決定哪個 React Component 需要重新 render 的物件。 browserHistory 是一個告訴 React-Router 如何 interpret URL changes 物件。 History 有 browserHistory、hashHistory、memoryHistory 可以使用。 IndexRoute 是一個做起來像是 Route，但是當 URL 符合我們所定義的 parent path 才會出現的 helper。","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"React","slug":"React","permalink":"https://vincent.fishboneapps.com/tags/React/"}]},{"title":"React快速學習自我挑戰 Day9","slug":"React快速學習自我挑戰-Day9","date":"2017-03-14T12:17:57.000Z","updated":"2020-06-22T17:16:10.831Z","comments":true,"path":"2017/03/14/React快速學習自我挑戰-Day9/","link":"","permalink":"https://vincent.fishboneapps.com/2017/03/14/React%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day9/","excerpt":"","text":"React Sparkline(畫圖工具)。 class based component：有變數傳遞。 function based component：無變數傳遞。 action type 用 const 定義，這樣才能在 action 和 reducer 裡面指定 action type。 在本專案中用的 middleware 就是 redux promise，我們用 redux promise 來處理收到的 promise，然後使用 axios 來產生 AJAX request，這個 middleware 會自動偵測我們提供的 promise 的 payload，middleware 會停止 action 並等到問題解決、promise 才會解決，middleware 就會從 request 把回傳的 data 拿來塞在 payload 這個 property，然後把 action 送到本專案的所有 reducer 中。 雖然 Ajax request 本質上涉及非同步式語言，但我們完全不需要思考到非同步語言的部分。我們只要寫創造 action、然後流向 reducer，我們並不需要擔心任何 promise 或是 callback。 我們從不做 state.weather.push 這樣的動作，不要直接修改 state，取而代之的是，我們 return 一個新物件來代替已經存在的 state。","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"React","slug":"React","permalink":"https://vincent.fishboneapps.com/tags/React/"}]},{"title":"React快速學習自我挑戰 Day8","slug":"React快速學習自我挑戰-Day8","date":"2017-03-13T14:56:31.000Z","updated":"2020-06-22T17:16:10.831Z","comments":true,"path":"2017/03/13/React快速學習自我挑戰-Day8/","link":"","permalink":"https://vincent.fishboneapps.com/2017/03/13/React%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day8/","excerpt":"","text":"Middleware 是一個 function，Middleware 可以選擇讓 action 通過，還可以操縱 action。 在到達 reducer 之前，我們可以在 action 上的所有不同型態的小任務做 console.log 或 stop。 application state 擁有 application 全部的 data。 新增 data 需要 dispatch 一個 action 來呼叫(action creactor)，然後他要 AJAX request 負責。 在處理 action type 的時候，不可將不同型態的值傳遞到 reducer，需要先做 export const FETCH_WEATHER = 'FETCH_WEATHER';。 axios 是一個從瀏覽器製作 Ajax request 的 Library。 Promise 不包含任何 data。 Redux Promis 是一個 Middleware，在點擊任何 reducer 之前，Middleware 都可以選擇讓 action 通過，還可以操縱 action。 state.push 的用法會回傳一整個新的 array；用 state.concat 則是將新東西加上 array。 ES5 return state.concat([action.payload.data]); = ES6 return [ action.payload.data, ...state ];。 &#123; weather &#125; === &#123; weather: weather &#125;。","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"React","slug":"React","permalink":"https://vincent.fishboneapps.com/tags/React/"}]},{"title":"React快速學習自我挑戰 Day7","slug":"React快速學習自我挑戰-Day7","date":"2017-03-11T12:15:40.000Z","updated":"2020-06-22T17:16:10.831Z","comments":true,"path":"2017/03/11/React快速學習自我挑戰-Day7/","link":"","permalink":"https://vincent.fishboneapps.com/2017/03/11/React%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day7/","excerpt":"","text":"React Component 只負責顯示 data，而 Redux 則負責提取 data。 設計一個元件的時候，記得要先問自己該元件是 Container 還是 Component。 基本上需要跟 Redux 溝通的就是 Container。 下面範例中，this (就是 SearchBar) 有一個 function 叫做 onInputChange，然後把這個 function bind 到 this，然後把得到值放到下方的 onInputChange 裡面。 1234567891011constructor(props) &#123; super(props); this.state = &#123; term: &#x27;&#x27; &#125;; this.onInputChange = this.onInputChange.bind(this); &#125; onInputChange(event) &#123; this.setState(&#123; term: event.target.value &#125;) &#125; 如果不希望 User 一直重新整理頁面，我們可以加 event handler。 open weather API。 sign up 之後，進入 API Key 的頁面，就可以拿到 API key 囉！ JSON Formatter (chrome 外掛)。","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"React","slug":"React","permalink":"https://vincent.fishboneapps.com/tags/React/"}]},{"title":"React快速學習自我挑戰 Day6","slug":"React快速學習自我挑戰-Day6","date":"2017-03-10T05:02:52.000Z","updated":"2020-06-22T17:16:10.831Z","comments":true,"path":"2017/03/10/React快速學習自我挑戰-Day6/","link":"","permalink":"https://vincent.fishboneapps.com/2017/03/10/React%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day6/","excerpt":"","text":"當知道 action creactor 將要呼叫(但不知道什麼時候)，當被呼叫的時候，我想要確定 flow 的結果能夠經過 dispatch function，然後這個 dispatch function 會像是漏斗般的接收這些 actions，最後再把 actions 分別送回不同的 reducers。 action 通常有兩種值：type 和 payload。 不管 action 有沒有 dispatch，reducer 都會被呼叫，所以 function 隨時會頻繁的被呼叫，因為 action 不在乎任何時間、任何特定的 reducer。 用來 combine reducer 的 object 的任何 key 都會以 global state key 的方式結尾。 當想要做一個可以直接接觸 redux state 的 component，就要用 container。 定義一個 function 呼叫 Map state 來 process ，然後我們 connect book detail 的 props。 Redux 控制整個 application 的 state，state 是 single plain javascript object。 Component state 跟 application state 是完全分離的。 用 combineReducer 的方法可以將 reducer 全部連結在一起。 function 內每一個 key 都會指定一個 reducer，然後 reducer 必須對創造 state 負責。 reducer 負責隨著時間改變 application state，這個是透過 action 來使用。 當有一個 action dispatch，action 會流過 application 內不同的 reducer；所以每一個 reducer 有選擇的根據收到不同的 action type 來 return state。 action creator 是一個 simple function 來 return 一個 action，action 是 single plain javascript object。","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"React","slug":"React","permalink":"https://vincent.fishboneapps.com/tags/React/"}]},{"title":"React快速學習自我挑戰 Day5","slug":"React快速學習自我挑戰-Day5","date":"2017-03-09T03:01:39.000Z","updated":"2020-06-22T17:16:10.831Z","comments":true,"path":"2017/03/08/React快速學習自我挑戰-Day5/","link":"","permalink":"https://vincent.fishboneapps.com/2017/03/08/React%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day5/","excerpt":"","text":"Reducer 是一個 function 用來 return piece of the application state。 Reducer 產出 state 的值。 在檔名的命名中，應該在前面加前綴，例如：reducer_books.js。(不是一定要，作者提供的方法) Container 是 react component，對 Redux 所管理的 state 有直接的連結。 有一個 Library 叫做 React-Redux，負責 React 和 Redux 的溝通橋樑。(本身 React 和 Redux 是完全分開的 Library) Container 在 Redux 的官方文件中叫做 Smart Component。 以整體來說，整個 App 並不在乎任何 state，而是由各個元件去在乎個別需要在乎的 state(所以 App 被稱為 dumb component)。 mapStateToProps 以陣列的形式得到 application state。 Redux 建構 application state，React 提供 View 來顯示 State，這兩個是不同的 Library，唯有透過 React-Redux 才能將這兩個連結。 如果 application state 改變，Container 也會跟著 rerender。 按按鈕 =&gt; 呼叫 action creator =&gt; action automatically sent to all reducers =&gt; reducer 可以選擇根據 action 來 return 不同的 state，然後將 state pipe into application =&gt; application state 會 pump back into React application，然後所有的 components 就會 rerender。 action creator 會 return 物件。 在所有不同的 reducer 裡面，我們會設置一個 switch statement。","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"React","slug":"React","permalink":"https://vincent.fishboneapps.com/tags/React/"}]},{"title":"React快速學習自我挑戰 Day4","slug":"React快速學習自我挑戰-Day4","date":"2017-03-08T14:10:00.000Z","updated":"2020-06-22T17:16:10.831Z","comments":true,"path":"2017/03/08/React快速學習自我挑戰-Day4/","link":"","permalink":"https://vincent.fishboneapps.com/2017/03/08/React%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day4/","excerpt":"","text":"Redux 參考資料。 學習完 Redux 之後，還要學 webpack、Redux Router、Redux Promise、Redux Thunk、Hot Reloading。 Redux 是一個針對 JS application 的可預測 state container。 Redux 處理 data 的部分，React 處理 View 的部分。 React 和其他框架不同的地方就是將所有 data 放到 central single object，這個 object 可被用來查詢 state。","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"React","slug":"React","permalink":"https://vincent.fishboneapps.com/tags/React/"}]},{"title":"React快速學習自我挑戰 Day3","slug":"React快速學習自我挑戰-Day3","date":"2017-03-07T14:13:59.000Z","updated":"2020-06-22T17:16:10.831Z","comments":true,"path":"2017/03/07/React快速學習自我挑戰-Day3/","link":"","permalink":"https://vincent.fishboneapps.com/2017/03/07/React%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day3/","excerpt":"","text":"在 React 中，只有最上層的元件需要從 API 或 flux 取得資料。 用 className 來當作平常在 html 看到的 class，以跟 class based function 做區別。 function()可以簡化為() =&gt;。 React 處理 List 的時候，不要使用 for 迴圈，用 map 來取代。 React 會辨識變數是否為 List 或是 Array of Component。 在處理 List 的時候，React會要求給每個 element 一個 ID。 以下兩行一樣，下面為 ES6 語法。 const VideoListItem = (props) =&gt; &#123; const video = props.video; const VideoListItem = (&#123;video&#125;) =&gt; &#123; 以下兩行一樣，下面為 ES6 語法。(string interpolation) const url = 'https://www.youtube.com/embed/' + videoId; const url = `https://www.youtube.com/embed/$&#123;videoId&#125;`; 降低 callback function 執行速度的套件 lodash 。 在 class based component，我們將 state 設定在 constructor 裡面。 範例中，四個元件用了兩個 callback function，我們要用 redux 來讓 callback 更乾淨。 在 react 中用的 state 屬於 Component level，而在 redux 上面使用的則是 application level。","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"React","slug":"React","permalink":"https://vincent.fishboneapps.com/tags/React/"}]},{"title":"React快速學習自我挑戰 Day2","slug":"React快速學習自我挑戰-Day2","date":"2017-03-06T02:13:59.000Z","updated":"2020-06-22T17:16:10.830Z","comments":true,"path":"2017/03/05/React快速學習自我挑戰-Day2/","link":"","permalink":"https://vincent.fishboneapps.com/2017/03/05/React%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day2/","excerpt":"","text":"從 node modules 呼叫 react：import React from 'react';。 從 node modules 呼叫 react-dom：import ReactDOM from 'react-dom';。 React Render 要用元件方式包裝：&lt;App /&gt;。 指定 Render 的地方：document.querySelector('.container')。 每個檔案都只能有一個元件。 Youtube API 的使用。 註冊 Youtube API Key。 前往Goolge開發者界面。 點選左方選單的 Library。 搜尋 Youtube，並選擇「YouTube Data API v3」。 Enable 該套件。 選擇左方選單的 Credentials。 Create Credentials =&gt; API key =&gt; Restrict Key。 設定名稱，設定類別為「HTTP referrers (web sites) 」 Save =&gt; 拿到 API Key 安裝 Youtube API 套件。 Youtube API Search npm install --save youtube-api-search 輸出值：export default SearchBar;。 得到輸出值：import SearchBar from './components/search_bar';(需要包含路徑)。 Class Base Method: class SearchBar extends React.Component。 語法糖：import React, &#123; Component &#125; from 'react'; 等於 import React from 'react'; const Component = React.Component; React 處理事件有兩個步驟。 Declare “Event handler” =&gt; 當事件發生時啟動 handler Pass “Event handler” =&gt; 直接跳到我們想對事件顯示的某元素 State 是 React 最令人困惑的部分。 定義：State 是 JS 純物件，且用來記錄和對使用者事件做反應。不論元件的 State 是否改變、元件是否立刻 Render或是子原件也重新 Rerender，每一個 Class based 元件都有自己的 State Object。 所有的 JS classes 都有一個名為 constructor 的特別函式。 class 的元件用來追蹤 State 的狀態或是值需要持續改變；functional 的元件用來取得某些資訊。 建立搜尋欄位 123const SearchBar = () =&gt; &#123; return &lt;input /&gt;&#125;; 即時顯示值 this.state =&gt; 創建一個 term 的空值。 this.setState =&gt; 得到現在 input 裡面的值(並非直接改變)。 value={this.state.term} =&gt; 取得 this.state 的值。 123456789101112131415161718class SearchBar extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; term: &#x27;&#x27; &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;input value=&#123;this.state.term&#125; onChange=&#123;event =&gt; this.setState(&#123; term: event.target.value &#125;)&#125; /&gt; Value of the input: &#123;this.state.term&#125; &lt;/div&gt; ); &#125;&#125;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"React","slug":"React","permalink":"https://vincent.fishboneapps.com/tags/React/"}]},{"title":"React快速學習自我挑戰 Day1","slug":"React快速學習自我挑戰-Day1","date":"2017-03-05T13:00:59.000Z","updated":"2020-06-22T17:16:10.830Z","comments":true,"path":"2017/03/05/React快速學習自我挑戰-Day1/","link":"","permalink":"https://vincent.fishboneapps.com/2017/03/05/React%E5%BF%AB%E9%80%9F%E5%AD%B8%E7%BF%92%E8%87%AA%E6%88%91%E6%8C%91%E6%88%B0-Day1/","excerpt":"","text":"Reactjs 和 Redux 有 Library 可以使用。 瀏覽器尚未支援 ES6。 完成的檔案用 webpack + babel 來 transpile 變成網頁。 index.html application.js style.css 起手專案(boilerplate)：React + Youtube API 直接在 Command line 開 atom： atom . Component 是 JS 的 Function 的組合，用來生成 HTML。 使用 const 取變數，代表不改變的值；用 var 取變數，代表會改變的值。 JSX 是一種 JavaScript 的類別，允許我們可以寫 HTML 在 JavaScript 裡面。 寫 index.js 的邏輯 創建一個元件，元件應該可以產生 HTML。 把創建好的元件產生 HTML，然後放到頁面上(這個動作叫做 Render)。 JSX 轉換範例(使用babel轉換工具) 轉換前(1) 123const App = function() &#123; return &lt;div&gt;Hi!&lt;/div&gt;;&#125; 轉換後(1) 1234567var App = function App() &#123; return React.createElement( &quot;div&quot;, null, &quot;Hi!&quot; );&#125;; 轉換前(2) 1234567const App = function() &#123; return &lt;ol&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ol&gt;;&#125; 轉換後(2) 123456789101112131415161718192021var App = function App() &#123; return React.createElement( &quot;ol&quot;, null, React.createElement( &quot;li&quot;, null, &quot;1&quot; ), React.createElement( &quot;li&quot;, null, &quot;2&quot; ), React.createElement( &quot;li&quot;, null, &quot;3&quot; ) );&#125;;","categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"}],"tags":[{"name":"React","slug":"React","permalink":"https://vincent.fishboneapps.com/tags/React/"}]},{"title":"Wordpress 處理中文檔名上傳","slug":"Wordpress-處理中文檔名上傳","date":"2017-03-04T08:29:52.000Z","updated":"2020-06-22T17:16:35.828Z","comments":true,"path":"2017/03/04/Wordpress-處理中文檔名上傳/","link":"","permalink":"https://vincent.fishboneapps.com/2017/03/04/Wordpress-%E8%99%95%E7%90%86%E4%B8%AD%E6%96%87%E6%AA%94%E5%90%8D%E4%B8%8A%E5%82%B3/","excerpt":"","text":"修改 wp-admin\\includes\\file.php 找： 1$filename = wp_unique_filename( $uploads[&#x27;path&#x27;], $file[&#x27;name&#x27;], $unique_filename_callback ); 在其後加上： 1234$fileTypeNameArr =explode(&quot;.&quot; , $filename);$countNum=count($fileTypeNameArr)-1;$fileExt = $fileTypeNameArr[$countNum]; //取得所上傳文件後綴名$filename = time().&#x27;-&#x27;.rand(0,999999999).&#x27;.&#x27;.$fileExt;//將文件由原名改為時間戳 這樣上傳的文件會以時間戳為名稱儲存。 上傳中文名的文件後，依然能夠將原中文文件名作為文件的標題。 在後台管理界面顯示的是中文標題，因此對於使用沒有影響。","categories":[{"name":"Skill Share","slug":"Skill-Share","permalink":"https://vincent.fishboneapps.com/categories/Skill-Share/"}],"tags":[{"name":"WordPress","slug":"WordPress","permalink":"https://vincent.fishboneapps.com/tags/WordPress/"}]},{"title":"筆記規則 重點摘要","slug":"筆記規則-重點摘要","date":"2017-01-13T02:22:47.000Z","updated":"2020-06-22T17:17:00.485Z","comments":true,"path":"2017/01/12/筆記規則-重點摘要/","link":"","permalink":"https://vincent.fishboneapps.com/2017/01/12/%E7%AD%86%E8%A8%98%E8%A6%8F%E5%89%87-%E9%87%8D%E9%BB%9E%E6%91%98%E8%A6%81/","excerpt":"","text":"為每一天重要的事情，下一個大標題。 把實際開始和結束的時間用螢光筆框起來，紀錄行程是否太滿。 用一些自己專屬的記號。 多色規則：我喜歡五色原則(加上自己的顏色)。 紅色：重要事項。 藍色：工作相關。 黑色：日常私事、每日固定工作(包含記帳)。 綠色：非日常私事。 粉紅色：朝夢想前進的行動。 專案管理的方法。 設定專案目標，寫下要做的事情。 用便利貼，為目標訂出細部的具體任務。 用甘特圖將進度圖像化。 把已經約好的事情寫入待辦事項，還沒約好的事情另外用清單管理。 利用多色便條紙來書寫，藍色代表 工作、黃色代表 外出、綠色代表 私事、粉紅色代表 朝夢想前進的行動。 重要的靈感用另外一本筆記本紀錄。 所有的事情加上人，可以輕鬆回憶起事情。 每天寫三行日記，第一行主題、第二行感想、第三行對未來的展望。 用漫畫的對白框寫下自己為什麼快樂和傷心。 對自己有用的資訊額外也用一本筆記本。 重要的通訊錄。 紀錄上司推薦的事情。 寫下想看的書籍。 寫下別人送禮清單。 寫下自己可以送別人的禮物清單(包含別人提過他想要的)。 標記重要的紀念日。 寫下死前想完成的事情。 將自己想做的目標加以分類，分類別：工作、證照、金錢、健康、興趣、旅行、家人、朋友。 計畫凌亂時，寫出理想時間表，找回自己的節奏。 把成功者的名言佳句寫在書的一角，化為動力。 幾點睡覺、幾點起床要寫下來。 也可以記錄天氣，喚起那一天的所有回憶。","categories":[{"name":"Reading Note","slug":"Reading-Note","permalink":"https://vincent.fishboneapps.com/categories/Reading-Note/"}],"tags":[]},{"title":"PHP multiple select 寫入資料庫的方法","slug":"PHP-multiple-select-寫入資料庫的方法","date":"2016-12-01T05:48:23.000Z","updated":"2020-06-22T17:15:47.688Z","comments":true,"path":"2016/12/01/PHP-multiple-select-寫入資料庫的方法/","link":"","permalink":"https://vincent.fishboneapps.com/2016/12/01/PHP-multiple-select-%E5%AF%AB%E5%85%A5%E8%B3%87%E6%96%99%E5%BA%AB%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"填入文字的頁面需要用陣列的方式傳遞資料 name=&quot;item[]&quot; 123456&lt;label for=&quot;item[]&quot; class=&quot;formTitle&quot;&gt;選擇項目&lt;/label&gt;&lt;select name=&quot;item[]&quot; class=&quot;form-control selectpicker&quot; multiple&gt; &lt;option&gt;項目一&lt;/option&gt; &lt;option&gt;項目二&lt;/option&gt; &lt;option&gt;項目三&lt;/option&gt;&lt;/select&gt; 在取得值之前，要先將取得的陣列用文字的方式顯示。 1234// 得到 item 的值$item= $_POST[&quot;item&quot;];// 將取得的陣列用「、」分開$itemArray= implode(&quot;、&quot;, $item); 將得到的值寫入 DataTable 資料表內的 DataColumn 欄位，值為剛剛取得的陣列值 $itemarray 1$sql_query = INSERT INTO DataTable (`DataColumn`) VALUES (&#x27;$itemarray&#x27;);","categories":[{"name":"Skill Share","slug":"Skill-Share","permalink":"https://vincent.fishboneapps.com/categories/Skill-Share/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://vincent.fishboneapps.com/tags/PHP/"}]},{"title":"Github Pushed Commit Delete (Redraw)","slug":"Github-Pushed-Commit-Delete-Redraw","date":"2016-11-17T06:47:14.000Z","updated":"2020-06-22T17:12:50.526Z","comments":true,"path":"2016/11/17/Github-Pushed-Commit-Delete-Redraw/","link":"","permalink":"https://vincent.fishboneapps.com/2016/11/17/Github-Pushed-Commit-Delete-Redraw/","excerpt":"","text":"如果 Commit 之後並 Push 到遠端，想要在本地端用 CI 去 Delete/Redraw，就可以用以下方法。 如果要刪除倒數第一個 Commit，用以下方法。 12git reset --hard HEAD^git push -f 如果要刪除倒數二個 Commit，用以下方法。 12git reset --hard HEAD^^git push -f","categories":[{"name":"Skill Share","slug":"Skill-Share","permalink":"https://vincent.fishboneapps.com/categories/Skill-Share/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://vincent.fishboneapps.com/tags/Git/"}]},{"title":"JavaScript用AJAX的方式獲得時間","slug":"JavaScript用AJAX的方式獲得時間","date":"2016-11-05T15:22:31.000Z","updated":"2020-06-22T17:14:13.387Z","comments":true,"path":"2016/11/05/JavaScript用AJAX的方式獲得時間/","link":"","permalink":"https://vincent.fishboneapps.com/2016/11/05/JavaScript%E7%94%A8AJAX%E7%9A%84%E6%96%B9%E5%BC%8F%E7%8D%B2%E5%BE%97%E6%99%82%E9%96%93/","excerpt":"","text":"新增一個js的檔案，將以下程式碼複製貼上 1234567891011121314151617181920212223242526272829var xmlHttp;function srvTime()&#123;try &#123; //FF, Opera, Safari, Chrome xmlHttp = new XMLHttpRequest();&#125;catch (err1) &#123; //IE try &#123; xmlHttp = new ActiveXObject(&#x27;Msxml2.XMLHTTP&#x27;); &#125; catch (err2) &#123; try &#123; xmlHttp = new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;); &#125; catch (eerr3) &#123; //AJAX not supported, use CPU time. alert(&quot;AJAX not supported&quot;); &#125; &#125;&#125;xmlHttp.open(&#x27;HEAD&#x27;,window.location.href.toString(),false);xmlHttp.setRequestHeader(&quot;Content-Type&quot;, &quot;text/html&quot;);xmlHttp.send(&#x27;&#x27;);return xmlHttp.getResponseHeader(&quot;Date&quot;);&#125;var st = srvTime();var date = new Date(st); 新增時間 1var localTime = new Date();","categories":[{"name":"Skill Share","slug":"Skill-Share","permalink":"https://vincent.fishboneapps.com/categories/Skill-Share/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://vincent.fishboneapps.com/tags/JavaScript/"}]},{"title":"In fact, life is a kind of strong","slug":"In-fact-life-is-a-kind-of-strong","date":"2016-09-17T05:45:46.000Z","updated":"2020-06-22T17:13:41.435Z","comments":true,"path":"2016/09/17/In-fact-life-is-a-kind-of-strong/","link":"","permalink":"https://vincent.fishboneapps.com/2016/09/17/In-fact-life-is-a-kind-of-strong/","excerpt":"","text":"Because of the rainy days, I didn’t go to visit the potted plants on the balcony for several days. Today, I went out to look and I feel surprised. One of them had been in critical conditions and leaves covered the ground. However, an unknown plant grow lush at it side and swayed proudly in the wind. One kind of sadness instantly came up from my mind. I blamed my carelessness, but also lamented the fragile of potted plants. I urgently watered the potted plants, but I don’t know why I couldn’t eradicate that unknown alien plant. What kind of conditions could make this life? Due to the lack of attention from me, my potted plants are gradually lost luster. However, it seized this gap and thrived itself. Yes, if I concerned in place, it might be removed when it was inconspicuous. After all, that is my potted plants world, this life didn’t belong to here will be eventually destroy the crafted beauty. But just a few days effort, it was no fear of lack of water and hold the opportunity to put itself look as tall as potted plants. I looked on the potted plants in the verge of death, but also looked at that unknown plant. I was suddenly enlightened in the sadness and moved emotion: In fact, life is a kind of strong. Isn’t it? Plant did it, life is also much better than this! Life can be born, because the mother and baby are all strong. Life comes from the strong. Life is inseparable from the strong. Every day we are dependent with the strong. I think, if you can choose, no one wants to have pain, willing to be sad, even to be toil. But from the birth, we are inevitably deal with some ailment or even illness. Everyone wants to expose under the sun when woke up every day, listen to songs and see the sights every day. However, we haven’t be willing to get up by parent’s call since we were in small age. Then do the things we need to do, reading or working. These all rely on the strong. There are no pure land on earth which can make us arbitrary. There is always a distance between dreams and realities. If the environment is unsatisfactory; if we are in sick and forsaken by lover; if life is too gloomy. Strong, it is the support of life. We must be use the strong to face the tedious every day and stimulate the neglected and injured soul. The strong is necessary in life. It is the pillar of the spirit and the faith to across obstacles. The unknown plant of the potted plants use the strong to touch me. I would leave it and have no regrets, because it let me understand thoroughly: in fact, life is a kind of strong.","categories":[{"name":"English Learning","slug":"English-Learning","permalink":"https://vincent.fishboneapps.com/categories/English-Learning/"}],"tags":[{"name":"English Writing","slug":"English-Writing","permalink":"https://vincent.fishboneapps.com/tags/English-Writing/"}]},{"title":"在hexo使用emoji","slug":"在hexo使用emoji","date":"2016-09-11T02:15:30.000Z","updated":"2020-06-22T17:16:40.708Z","comments":true,"path":"2016/09/10/在hexo使用emoji/","link":"","permalink":"https://vincent.fishboneapps.com/2016/09/10/%E5%9C%A8hexo%E4%BD%BF%E7%94%A8emoji/","excerpt":"","text":"修改渲染器 123cd /workspace/blogs/ //跳轉到hexo的目錄npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --save 下載markdown-it-emoji插件： 1npm install markdown-it-emoji --save 編輯Hexo的最上層的配置文件_config.yml來配置markdown渲染器 1234567891011121314markdown: render: html: true xhtmlOut: false breaks: true //這邊我改成true直接在.md裡面enter就換行 linkify: true typographer: true quotes: &#x27;“”‘’&#x27; plugins: - markdown-it-footnote - markdown-it-sup - markdown-it-sub - markdown-it-abbr - markdown-it-emoji","categories":[{"name":"Skill Share","slug":"Skill-Share","permalink":"https://vincent.fishboneapps.com/categories/Skill-Share/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://vincent.fishboneapps.com/tags/Hexo/"}]},{"title":"Train to Busan (屍速列車) - 劇透","slug":"Train-to-Busan-屍速列車-劇透","date":"2016-09-10T02:59:31.000Z","updated":"2020-06-22T17:16:29.163Z","comments":true,"path":"2016/09/09/Train-to-Busan-屍速列車-劇透/","link":"","permalink":"https://vincent.fishboneapps.com/2016/09/09/Train-to-Busan-%E5%B1%8D%E9%80%9F%E5%88%97%E8%BB%8A-%E5%8A%87%E9%80%8F/","excerpt":"","text":"評價分數（滿分十分）：⭐⭐⭐⭐⭐⭐⭐⭐⭐ 地點：台中新時代威秀影城 陪看：豪豪、毛董、柏勳 劇情簡介： 劇情一開始，有位不知名的大叔開著車回家(應該是回家？)，前方有安檢人員消毒說前方洩漏了一點東西，不知名大叔抱怨說不知道這是第幾次了，進入之後，他為了接電話不小心撞死一隻小鹿，不知名大叔下車看了一下，覺得運氣很背的把車開走，結果，小鹿竟然站起來變成喪屍，病毒就這樣開始了… 男主角是一間證券公司的經理，他在電腦上看到某地區魚全部死光，就自私地賣掉所有相關股票，也不管是不是會造成市場動盪，只在乎有沒有賺錢。 男主角回家看到小孩秀安在跟媽媽講電話，今天是秀安的生日，爸爸特地買禮物回去給他，結果沒想到去年生日已經送過同樣的禮物了，秀安想要去釜山找媽媽，男主角擔心秀安的安全，決定一同前往，隔天要出發的時候，遠遠看到火燒的大樓，只是推斷那邊有事情發生，也沒有想太多。 大家上車之後，出現一個臨時衝上車的女生，她已經快要病變成殭屍，列車就這樣關上門了，火車離開之前，車站外已經有人開始大打出手，秀安看到外面有人咬人，想要叫醒男主角，可是男主角卻睡得正甜。秀安跑去上廁所發現一個流浪漢說著：「都死掉了…(碎碎念)」。 這個時候，病變的那個女生咬了要急救她的列車服務員，開始了一連串的有人被咬，男配角尹相華和他的老婆盛景在最後要逃到活人車廂的時候，被男主角關上門，後來秀安大叫是剛剛在廁所看到的大叔，男主角才開門讓他進來。男主角發現，殭屍不會開門，然後看到人才追擊，所以盛景把玻璃門用報紙貼起來，順利的讓殭屍安靜下來。男主角的媽媽剛好打電話來，詢問男主角是否平安，還有抱怨媳婦的不好之後，電話的另一頭就突然聽不到聲音了。 新聞訊息開始大量曝光，網路影片都開始看到殭屍的蹤影，車站到達下一站的時候因為不停使繼續開，外面卻是一陣混亂的殭屍追擊，車站經由管控室通知，決定在大田停車，男主角打電話給認識的人，請他幫忙確認大田的情況，友人指示讓他出站之後右轉會有人接應，一旁的流浪漢也聽到了。 抵達大田要出站之前，所有的軍人全部變成殭屍，追擊上來，只有一些人順利逃走，卻把男主角、尹相華、閔英國分在同個車廂，秀安、盛景、流浪漢、還有一對姐妹的姊姊在同個車廂，後來列車長決定繼續把列車開往釜山，男主角、尹相華、閔英國在和秀安、盛景、金珍熙分別通話之後，決定全副武裝通過數個車廂去找對方，在穿越車廂的時候，男主角又意外發現，如果列車進山洞的話，殭屍會停止追擊，只朝有聲音的地方移動，後來順利的找到秀安、盛景、流浪漢、還有一對姐妹的姊姊。閔英國打電話給金珍熙說要去同個車廂找他們，結果被金珍熙同車廂的自私客運營運長煽動不要讓其他人過來，結果讓尹相華被殭屍咬到，還有那對姐妹的姊姊也因為沒有順利抵達在妹妹面前被殭屍咬死了。男主角一群人雖然順利的到達活人的車廂，卻又被營運長說他們都被感染了煽動群眾，結果被所有人把男主角一群人趕到更前面的車廂。營運長的那個車廂開始吵架，在大家都不注意的時候，剛剛那對姐妹花的妹妹抱怨完姊姊為什麼那麼傻之後，就跑去把殭屍的門打開，營運長那個車廂的人就被咬了。 男主角一行人抵達東大區時，因為前面的列車東倒西歪而停住了，列車長廣播要大家下車跑向其他列車，繼續開往釜山。而營運長的那個車廂，服務員和營運長因為趁混亂中逃進了廁所逃過一劫，卻沒想到營運長為了到下一個列車，推了服務員一把，自己順利逃出。有一台不知道從哪裡來的冒火列車，突然撞上了男主角一群人附近的列車，把男主角一行人分開，棒球隊的閔英國和金珍熙為了破壞一個打不開的門拖了很久，營運長從剛剛的列車跑出之後，剛好也到了他們那個車廂，營運長又拉著金珍熙去撞殭屍，讓金珍熙被殭屍咬到，閔英國傷心地抱著她大哭，金珍熙變成殭屍之後也咬了閔英國一口。營運長繼續往要開往釜山的列車奔跑，結果列車長看到營運長要上來，過去幫他一把，沒想到列車長也被營運長推了一把之後被殭屍咬到，營運長自己順利逃到列車上。 男主角、秀安、盛景、流浪漢因為冒火的列車撞上其他列車，把他們困在列車之間，流浪漢也為了救他們自己犧牲而死，最後男主角帶著秀安、盛景順利地跑上開往釜山的列車，卻發現營運長已經被咬了，男主角為了救秀安和盛景，把營運長推下列車之後，因為自己也被咬，所以也跳下列車自殺。 最後剩下秀安和盛景抵達釜山，山洞的另一頭軍人看到兩個模糊的人走向他們，準備把他們射殺，這時候秀安卻唱起了歌，讓他們順利地被拯救了。 評論： 整部影片劇情緊湊，殭屍也演得很到位，在電影院被很多畫面嚇到，內容除了殭屍，也帶出了一些引人深思的議題，大部分的人都很自私，也正因為這種自私把大家帶入死亡，如果能更信賴彼此，其實很快就能把殭屍控制住了。除了這部電影，其實很多殭屍類別的影集也同樣帶出這樣的議題，人，其實比殭屍還要可怕。聽說要出前傳啦！會解釋到那個上車的女生怎麼來的，為什麼一直說對不起？非常期待十月的前傳。 要去看的時候也是臨時約的，我完全沒有看預告片，還以為是美劇之類的，沒想到韓國的電影已經有這樣的成熟度，也相當令我驚訝。 圖片來源：WellGoUSA","categories":[{"name":"Reading Note","slug":"Reading-Note","permalink":"https://vincent.fishboneapps.com/categories/Reading-Note/"}],"tags":[]},{"title":"Mechanic: Resurrection (極速秒殺2) - 劇透","slug":"Mechanic: Resurrection (極速秒殺2) - 劇透","date":"2016-09-09T02:27:45.000Z","updated":"2020-06-22T17:15:12.491Z","comments":true,"path":"2016/09/08/Mechanic: Resurrection (極速秒殺2) - 劇透/","link":"","permalink":"https://vincent.fishboneapps.com/2016/09/08/Mechanic:%20Resurrection%20(%E6%A5%B5%E9%80%9F%E7%A7%92%E6%AE%BA2)%20-%20%E5%8A%87%E9%80%8F/","excerpt":"","text":"評價分數（滿分十分）：⭐⭐⭐⭐⭐⭐ 地點：台中新時代威秀影城 陪看：豪豪 劇情簡介： 男主角Bishop在一場假死之後住在里約熱內盧，過著愉快的隱居生活，突然有一位女性出現，表示他的老闆要他去殺死三個人，而且這三個人得死得像是意外，結果當然男主角不領情，拍一張她的照片之後逃走。後來，男主角為了躲避追擊逃到泰國的秘密基地，而他的朋友Mae正是男主角守護這個地方的人，男主角在秘密基地調查出襲擊他的人的老闆原來是Crain。 隔天，女主角Gina出現，並向Mae索要急救物品，Mae注意到他裂開的嘴唇和瘀傷的手臂，而那天下午，Mae看到Gina在船上被毆打，所以說服Bishop去拯救女主角，男主角衝到船上警告毆打女主角的男子，結果那名男子完全不理會，所以當然被男主角殺了（看起來像是意外），這時，Mae來到船上把Gina接走，男主角在船上調查發現女主角原來叫做Gina，而且他還為Crain工作，最後，為了隱匿蹤跡，男主角放火把船燒了。 男主角當面質問女主角，發現女主角在柬埔寨的兒童庇護所工作，Crain威脅她的那些小孩，強迫他到男主角所在的位置執行任務。男主角推斷Crain的計畫就是讓女主角在被Crain綁架之前，男主角會深深愛上她，最後男主角就不得不接受任務。男主角注意到Crain的特務正盯緊他，所以就故意牽起Gina的手，而且親密的互動，他告訴Gina其實他和Crain都是被賣到某個黑幫的孤兒，直到他逃離之前，他們都被當作戰士來訓練。最後，男主角順著Crain的計畫，就和女主角發生親密關係，等待明天被綁架。被綁架之後，男主角被帶去Crain面前，告訴他要殺哪三個人。 男主角第一個要殺的是非洲的軍閥Krill，他被關在馬來西亞的監獄裡，男主角把自己弄得跟某個通緝犯很像，順利地進去監獄，男主角在裡面殺死了一位試圖殺死Krill的囚犯取得Krill的信任，最後在他們兩個獨處的時候把他殺死，然後在Crain特工們的幫忙下順利躲過鯊魚的追擊逃出監獄。 男主角第二個要殺的是在澳洲做未成年人口販賣的Cook，男主角在Cook的露天游泳池下面鑽洞，導致游泳池漏水，然後Cook直接就從高樓墜下死亡。 這個時候，Bishop找到女主角想要救他出來，可是失敗了。他只好去殺他的第三個目標保加利亞的軍火商Adams，結果男主角和Adams合作要殺死Crain，男主角讓Adams假死，然後讓Crain以為他已經死掉了，並告訴Crain任務已經完成，結果Crain本來就準備要把男主角殺死，就讓傭兵們衝到Adams的要賽裡面，結果被男主角佈局殺了精光。 男主角回到船上找Crain，結果Crain已經設定了倒數計時的船隻引爆器，男主角把女主角放到水中的逃生艙裡面，自己去找Crain徒手單挑，最後男主角把Crain用鎖鏈鎖在甲板上面，在船爆炸之前往船裡面跑，爆炸之後，女主角被告知已經沒有任何生還者了。 女主角回到柬埔寨繼續工作，當男主角出現的時候，她非常驚訝。最後一幕則是Adams看了監視器，發現男主角從船裡面的另外一個逃生艙走出來，Adams直接把影片刪除，再次偽造男主角的死亡。 評論： 評分給六分，因為劇情完全沒有可看性，可以像你思考的一樣去走，本來還期待會有一些意想不到的情節，不過深深地讓我失望了。不過以畫面和特效來說都非常到位，如果喜歡打鬥的視覺效果，這部電影可以大大的滿足你的需求。 圖片來源：官方預告片","categories":[{"name":"Reading Note","slug":"Reading-Note","permalink":"https://vincent.fishboneapps.com/categories/Reading-Note/"}],"tags":[]},{"title":"華碩Win8電腦USB開機","slug":"華碩Win8電腦USB開機","date":"2016-09-03T19:30:18.000Z","updated":"2020-06-22T17:17:18.732Z","comments":true,"path":"2016/09/03/華碩Win8電腦USB開機/","link":"","permalink":"https://vincent.fishboneapps.com/2016/09/03/%E8%8F%AF%E7%A2%A9Win8%E9%9B%BB%E8%85%A6USB%E9%96%8B%E6%A9%9F/","excerpt":"","text":"(1) 開機連按Del進入BIOS之後，切換到「Security」選單，將「Secure Boot Control」設定成「Disabled」，重新開機。 (2) 重新開機後繼續連按Del進入BIOS，切換到「Boot」選單，將「Lunch CSM」設定成「Enabled」，重新開機。 (3) 重新開機後繼續連按Del進入BIOS，切換到「Exit」選單，就可以找到USB進行重灌囉！","categories":[{"name":"Skill Share","slug":"Skill-Share","permalink":"https://vincent.fishboneapps.com/categories/Skill-Share/"}],"tags":[]},{"title":"The connection of people in the age of information","slug":"The-connection-of-people-in-the-age-of-information","date":"2016-09-03T08:40:08.000Z","updated":"2020-06-22T17:13:41.435Z","comments":true,"path":"2016/09/03/The-connection-of-people-in-the-age-of-information/","link":"","permalink":"https://vincent.fishboneapps.com/2016/09/03/The-connection-of-people-in-the-age-of-information/","excerpt":"","text":"In the past, people were separated by the distant ocean, they got each others’ message need a long time through letters. Nowadays, we just need to sign in the account through internet, we can chat with each other. Not only that, we can use video to see each other as truly communication. It’s much more convenient than before, but this feature doesn’t make the interpersonal networks closely than before. We increased our quality of life, but also decreased our humanity. I’m so curious what happened in nowadays world? Surfing on internet and open Facebook, a piece of photos and so many short words which are expressing someone’s feelings. You can see all of current situations of your friends and relatives. Even you have had a friend which lost contact for ten years, you still can use the various search method and “catch the line” with that friend. If you are lucky, you can contact with overseas people through these convenient networks and become the friends. Furthermore, you will be the member of internationalization. All steps sound like just need one finger. It seems like you caught a mouse and you caught the corner of interpersonal network. All of connections naturally become the “object of hand”, you can play it as you want between the hands. However, rapid transmission of information also caused rapid interpersonal conversion. I think perhaps it’s the attitude of “the most beautiful star is that one you can’t pick it.”. Something was hard-earned in the past, but now you can easily get it. That star which already holds on your hand is not shiny anymore and it will be discarded in the end. Moreover, people who had bad idea use internet to cheat some good people. In the ginormous networks, someone is pretending as your friends and family. You can’t recognize and verify, how to protect yourself? More and more frauds and criminal events make people stopping use internet to communicate with others because they don’t want to be the next victims. And some people talk very happy on internet, but they are speechless in the reality. Comparing the warm and lively talk in virtual with the silent in reality, this phenomenon make me unable to stop sighing and sobbing. People addicted with online unreal world and ignored people and things they should concern about in reality. In addition, people are growing further apart in reality and try to seek the new warm from internet, the vicious cycles trigger again and again and difficult to save. In conclusion, although convenient networks shorten the distance between people, but the distance of heart is far away than before. We don’t have truly personal experience in many things, many things are hard to understand if you just rely on touching the cold screen. For me, instead of waiting people in front of computer all day, I would rather to turn around to talk someone who was waiting for my reply. Internet is convenient and just for moderate using. After all, something can tighten interpersonal networks is your hand but not the little mouse you hold on.","categories":[{"name":"English Learning","slug":"English-Learning","permalink":"https://vincent.fishboneapps.com/categories/English-Learning/"}],"tags":[{"name":"English Writing","slug":"English-Writing","permalink":"https://vincent.fishboneapps.com/tags/English-Writing/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-09-02T08:36:32.000Z","updated":"2020-06-22T17:13:01.638Z","comments":true,"path":"2016/09/02/hello-world/","link":"","permalink":"https://vincent.fishboneapps.com/2016/09/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[{"name":"Skill Share","slug":"Skill-Share","permalink":"https://vincent.fishboneapps.com/categories/Skill-Share/"}],"tags":[]}],"categories":[{"name":"Study Note","slug":"Study-Note","permalink":"https://vincent.fishboneapps.com/categories/Study-Note/"},{"name":"English Learning","slug":"English-Learning","permalink":"https://vincent.fishboneapps.com/categories/English-Learning/"},{"name":"Skill Share","slug":"Skill-Share","permalink":"https://vincent.fishboneapps.com/categories/Skill-Share/"},{"name":"Reading Note","slug":"Reading-Note","permalink":"https://vincent.fishboneapps.com/categories/Reading-Note/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://vincent.fishboneapps.com/tags/Golang/"},{"name":"C++","slug":"C","permalink":"https://vincent.fishboneapps.com/tags/C/"},{"name":"Java","slug":"Java","permalink":"https://vincent.fishboneapps.com/tags/Java/"},{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://vincent.fishboneapps.com/tags/Kubernetes/"},{"name":"Docker","slug":"Docker","permalink":"https://vincent.fishboneapps.com/tags/Docker/"},{"name":"English Grammer","slug":"English-Grammer","permalink":"https://vincent.fishboneapps.com/tags/English-Grammer/"},{"name":"React-Native","slug":"React-Native","permalink":"https://vincent.fishboneapps.com/tags/React-Native/"},{"name":"Weight Loss","slug":"Weight-Loss","permalink":"https://vincent.fishboneapps.com/tags/Weight-Loss/"},{"name":"Nutrition","slug":"Nutrition","permalink":"https://vincent.fishboneapps.com/tags/Nutrition/"},{"name":"Git","slug":"Git","permalink":"https://vincent.fishboneapps.com/tags/Git/"},{"name":"HTML","slug":"HTML","permalink":"https://vincent.fishboneapps.com/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://vincent.fishboneapps.com/tags/CSS/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://vincent.fishboneapps.com/tags/Nodejs/"},{"name":"UI","slug":"UI","permalink":"https://vincent.fishboneapps.com/tags/UI/"},{"name":"Illustrator","slug":"Illustrator","permalink":"https://vincent.fishboneapps.com/tags/Illustrator/"},{"name":"Mac","slug":"Mac","permalink":"https://vincent.fishboneapps.com/tags/Mac/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://vincent.fishboneapps.com/tags/Jenkins/"},{"name":"Productivity","slug":"Productivity","permalink":"https://vincent.fishboneapps.com/tags/Productivity/"},{"name":"React","slug":"React","permalink":"https://vincent.fishboneapps.com/tags/React/"},{"name":"Laravel","slug":"Laravel","permalink":"https://vincent.fishboneapps.com/tags/Laravel/"},{"name":"WordPress","slug":"WordPress","permalink":"https://vincent.fishboneapps.com/tags/WordPress/"},{"name":"PHP","slug":"PHP","permalink":"https://vincent.fishboneapps.com/tags/PHP/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://vincent.fishboneapps.com/tags/JavaScript/"},{"name":"English Writing","slug":"English-Writing","permalink":"https://vincent.fishboneapps.com/tags/English-Writing/"},{"name":"Hexo","slug":"Hexo","permalink":"https://vincent.fishboneapps.com/tags/Hexo/"}]}